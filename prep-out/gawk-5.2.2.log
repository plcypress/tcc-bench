Command: /itch/common/crepos/tcc-scripts/tidy-braces.sh
Directory: /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2
----------------------------------------

Enabled checks:
    clang-analyzer-apiModeling.Errno
    clang-analyzer-apiModeling.TrustNonnull
    clang-analyzer-apiModeling.TrustReturnsNonnull
    clang-analyzer-apiModeling.google.GTest
    clang-analyzer-apiModeling.llvm.CastValue
    clang-analyzer-apiModeling.llvm.ReturnValue
    clang-analyzer-core.BitwiseShift
    clang-analyzer-core.CallAndMessage
    clang-analyzer-core.CallAndMessageModeling
    clang-analyzer-core.DereferenceModeling
    clang-analyzer-core.DivideZero
    clang-analyzer-core.DynamicTypePropagation
    clang-analyzer-core.NonNullParamChecker
    clang-analyzer-core.NonnilStringConstants
    clang-analyzer-core.NullDereference
    clang-analyzer-core.StackAddrEscapeBase
    clang-analyzer-core.StackAddressEscape
    clang-analyzer-core.UndefinedBinaryOperatorResult
    clang-analyzer-core.VLASize
    clang-analyzer-core.builtin.BuiltinFunctions
    clang-analyzer-core.builtin.NoReturnFunctions
    clang-analyzer-core.uninitialized.ArraySubscript
    clang-analyzer-core.uninitialized.Assign
    clang-analyzer-core.uninitialized.Branch
    clang-analyzer-core.uninitialized.CapturedBlockVariable
    clang-analyzer-core.uninitialized.NewArraySize
    clang-analyzer-core.uninitialized.UndefReturn
    clang-analyzer-cplusplus.ArrayDelete
    clang-analyzer-cplusplus.InnerPointer
    clang-analyzer-cplusplus.Move
    clang-analyzer-cplusplus.NewDelete
    clang-analyzer-cplusplus.NewDeleteLeaks
    clang-analyzer-cplusplus.PlacementNew
    clang-analyzer-cplusplus.PureVirtualCall
    clang-analyzer-cplusplus.SelfAssignment
    clang-analyzer-cplusplus.SmartPtrModeling
    clang-analyzer-cplusplus.StringChecker
    clang-analyzer-cplusplus.VirtualCallModeling
    clang-analyzer-deadcode.DeadStores
    clang-analyzer-fuchsia.HandleChecker
    clang-analyzer-nullability.NullPassedToNonnull
    clang-analyzer-nullability.NullReturnedFromNonnull
    clang-analyzer-nullability.NullabilityBase
    clang-analyzer-nullability.NullableDereferenced
    clang-analyzer-nullability.NullablePassedToNonnull
    clang-analyzer-nullability.NullableReturnedFromNonnull
    clang-analyzer-optin.core.EnumCastOutOfRange
    clang-analyzer-optin.cplusplus.UninitializedObject
    clang-analyzer-optin.cplusplus.VirtualCall
    clang-analyzer-optin.mpi.MPI-Checker
    clang-analyzer-optin.osx.OSObjectCStyleCast
    clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker
    clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker
    clang-analyzer-optin.performance.GCDAntipattern
    clang-analyzer-optin.performance.Padding
    clang-analyzer-optin.portability.UnixAPI
    clang-analyzer-optin.taint.GenericTaint
    clang-analyzer-optin.taint.TaintPropagation
    clang-analyzer-optin.taint.TaintedAlloc
    clang-analyzer-optin.taint.TaintedDiv
    clang-analyzer-osx.API
    clang-analyzer-osx.MIG
    clang-analyzer-osx.NSOrCFErrorDerefChecker
    clang-analyzer-osx.NumberObjectConversion
    clang-analyzer-osx.OSObjectRetainCount
    clang-analyzer-osx.ObjCProperty
    clang-analyzer-osx.SecKeychainAPI
    clang-analyzer-osx.cocoa.AtSync
    clang-analyzer-osx.cocoa.AutoreleaseWrite
    clang-analyzer-osx.cocoa.ClassRelease
    clang-analyzer-osx.cocoa.Dealloc
    clang-analyzer-osx.cocoa.IncompatibleMethodTypes
    clang-analyzer-osx.cocoa.Loops
    clang-analyzer-osx.cocoa.MissingSuperCall
    clang-analyzer-osx.cocoa.NSAutoreleasePool
    clang-analyzer-osx.cocoa.NSError
    clang-analyzer-osx.cocoa.NilArg
    clang-analyzer-osx.cocoa.NonNilReturnValue
    clang-analyzer-osx.cocoa.ObjCGenerics
    clang-analyzer-osx.cocoa.RetainCount
    clang-analyzer-osx.cocoa.RetainCountBase
    clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak
    clang-analyzer-osx.cocoa.SelfInit
    clang-analyzer-osx.cocoa.SuperDealloc
    clang-analyzer-osx.cocoa.UnusedIvars
    clang-analyzer-osx.cocoa.VariadicMethodTypes
    clang-analyzer-osx.coreFoundation.CFError
    clang-analyzer-osx.coreFoundation.CFNumber
    clang-analyzer-osx.coreFoundation.CFRetainRelease
    clang-analyzer-osx.coreFoundation.containers.OutOfBounds
    clang-analyzer-osx.coreFoundation.containers.PointerSizedValues
    clang-analyzer-security.ArrayBound
    clang-analyzer-security.FloatLoopCounter
    clang-analyzer-security.MmapWriteExec
    clang-analyzer-security.PointerSub
    clang-analyzer-security.PutenvStackArray
    clang-analyzer-security.SetgidSetuidOrder
    clang-analyzer-security.cert.env.InvalidPtr
    clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling
    clang-analyzer-security.insecureAPI.SecuritySyntaxChecker
    clang-analyzer-security.insecureAPI.UncheckedReturn
    clang-analyzer-security.insecureAPI.bcmp
    clang-analyzer-security.insecureAPI.bcopy
    clang-analyzer-security.insecureAPI.bzero
    clang-analyzer-security.insecureAPI.decodeValueOfObjCType
    clang-analyzer-security.insecureAPI.getpw
    clang-analyzer-security.insecureAPI.gets
    clang-analyzer-security.insecureAPI.mkstemp
    clang-analyzer-security.insecureAPI.mktemp
    clang-analyzer-security.insecureAPI.rand
    clang-analyzer-security.insecureAPI.strcpy
    clang-analyzer-security.insecureAPI.vfork
    clang-analyzer-unix.API
    clang-analyzer-unix.BlockInCriticalSection
    clang-analyzer-unix.Chroot
    clang-analyzer-unix.DynamicMemoryModeling
    clang-analyzer-unix.Errno
    clang-analyzer-unix.Malloc
    clang-analyzer-unix.MallocSizeof
    clang-analyzer-unix.MismatchedDeallocator
    clang-analyzer-unix.StdCLibraryFunctions
    clang-analyzer-unix.Stream
    clang-analyzer-unix.Vfork
    clang-analyzer-unix.cstring.BadSizeArg
    clang-analyzer-unix.cstring.CStringModeling
    clang-analyzer-unix.cstring.NotNullTerminated
    clang-analyzer-unix.cstring.NullArg
    clang-analyzer-valist.CopyToSelf
    clang-analyzer-valist.Uninitialized
    clang-analyzer-valist.Unterminated
    clang-analyzer-valist.ValistBase
    clang-analyzer-webkit.NoUncountedMemberChecker
    clang-analyzer-webkit.RefCntblBaseVirtualDtor
    clang-analyzer-webkit.UncountedLambdaCapturesChecker
    readability-braces-around-statements

Running clang-tidy for 54 files out of 54 in compilation database ...
[ 1/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpvwp8ge_j.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/malloc/dynarray_at_failure.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 2/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpypguz0oa.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/time.c
[1mtime.c:179:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  179 |                 if ((rc = nanosleep(&req,NULL)) < 0)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  180 |                         /* probably interrupted */[0m
  181 |                         update_ERRNO_int(errno);[0m
      | [0;1;32m                                                
[0m[1mtime.c:233:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  233 |                 fprintf(stderr, _("do_strptime: argument 1 is not a string\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtime.c:233:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  233 |                 fprintf(stderr, _("do_strptime: argument 1 is not a string\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtime.c:238:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  238 |                 fprintf(stderr, _("do_strptime: argument 2 is not a string\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtime.c:238:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  238 |                 fprintf(stderr, _("do_strptime: argument 2 is not a string\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtime.c:244:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  244 |         memset(& broken_time, 0, sizeof(broken_time));[0m
      | [0;1;32m        ^~~~~~
[0m[1mtime.c:244:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  244 |         memset(& broken_time, 0, sizeof(broken_time));[0m
      | [0;1;32m        ^~~~~~
[0m[1mtime.c:270:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  270 | dl_load_func(func_table, time, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtime.c:270:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  270 | dl_load_func(func_table, time, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m21 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 3/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpc06ydk6g.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/readdir_test.c
[1mreaddir_test.c:105:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  105 |         case DT_BLK:    return "b";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:106:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  106 |         case DT_CHR:    return "c";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:107:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  107 |         case DT_DIR:    return "d";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:108:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  108 |         case DT_FIFO:   return "p";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:109:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  109 |         case DT_LNK:    return "l";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:110:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  110 |         case DT_REG:    return "f";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:111:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  111 |         case DT_SOCK:   return "s";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir_test.c:119:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  119 |         strcpy(fname, dirname);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir_test.c:119:2: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  119 |         strcpy(fname, dirname);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir_test.c:120:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  120 |         strcat(fname, "/");[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir_test.c:120:2: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
  120 |         strcat(fname, "/");[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir_test.c:121:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  121 |         strcat(fname, entry->d_name);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir_test.c:121:2: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
  121 |         strcat(fname, entry->d_name);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir_test.c:123:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  123 |                 if (S_ISBLK(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  124 |                         return "b";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:125:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  125 |                 if (S_ISCHR(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  126 |                         return "c";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:127:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  127 |                 if (S_ISDIR(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  128 |                         return "d";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:129:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  129 |                 if (S_ISFIFO(sbuf.st_mode))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  130 |                         return "p";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:131:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  131 |                 if (S_ISREG(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  132 |                         return "f";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:134:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  134 |                 if (S_ISLNK(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  135 |                         return "l";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:138:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  138 |                 if (S_ISSOCK(sbuf.st_mode))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  139 |                         return "s";[0m
      | [0;1;32m                                   
[0m[1mreaddir_test.c:193:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  193 |         if (out == NULL || iobuf == NULL || iobuf->opaque == NULL)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  194 |                 return EOF;[0m
      | [0;1;32m                           
[0m[1mreaddir_test.c:214:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  214 |         len = sprintf(the_dir->buf, "%llu", ino);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mreaddir_test.c:214:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  214 |         len = sprintf(the_dir->buf, "%llu", ino);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mreaddir_test.c:217:17: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  217 |         len += (flen = sprintf(the_dir->buf + len, "/%s", dirent->d_name));[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mreaddir_test.c:217:17: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  217 |         len += (flen = sprintf(the_dir->buf + len, "/%s", dirent->d_name));[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mreaddir_test.c:221:17: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  221 |         len += (flen = sprintf(the_dir->buf + len, "/%s", ftstr));[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mreaddir_test.c:221:17: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  221 |         len += (flen = sprintf(the_dir->buf + len, "/%s", ftstr));[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mreaddir_test.c:228:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  228 |         if (field_width)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  229 |                 *field_width = & the_dir->fw;[0m
      | [0;1;32m                                             
[0m[1mreaddir_test.c:240:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  240 |         if (iobuf == NULL || iobuf->opaque == NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  241 |                 return;[0m
      | [0;1;32m                       
[0m[1mreaddir_test.c:257:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  257 |         if (iobuf == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  258 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mreaddir_test.c:344:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  344 | dl_load_func(func_table, readdir, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mreaddir_test.c:344:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  344 | dl_load_func(func_table, readdir, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m41 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 4/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpjln6j7hw.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/malloc/dynarray_resize.c
[1mmalloc/dynarray_resize.c:56:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   56 |       if (new_array != NULL && list->array != NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m   57 |         memcpy (new_array, list->array, list->used * element_size);[0m
      | [0;1;32m                                                                   
[0m[1mmalloc/dynarray_resize.c:57:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   57 |         memcpy (new_array, list->array, list->used * element_size);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmalloc/dynarray_resize.c:57:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
   57 |         memcpy (new_array, list->array, list->used * element_size);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmalloc/dynarray_resize.c:59:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   59 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   60 |     new_array = realloc (list->array, new_size_bytes);[0m
      | [0;1;32m                                                      
[0m[1mmalloc/dynarray_resize.c:61:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   61 |   if (new_array == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m   62 |     return false;[0m
      | [0;1;32m                 
[0m6 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 5/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpjshzx9rr.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/malloc/dynarray_finalize.c
[1mmalloc/dynarray_finalize.c:32:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   32 |   if (__dynarray_error (list))[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m   33 |     /* The caller will reported the deferred error.  */[0m
   34 |     return false;[0m
      | [0;1;32m                 
[0m[1mmalloc/dynarray_finalize.c:43:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   43 |       if (list->array != scratch)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m   44 |         free (list->array);[0m
      | [0;1;32m                           
[0m[1mmalloc/dynarray_finalize.c:54:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   54 |       if (list->array != NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m   55 |         memcpy (heap_array, list->array, allocation_size);[0m
      | [0;1;32m                                                          
[0m[1mmalloc/dynarray_finalize.c:55:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   55 |         memcpy (heap_array, list->array, allocation_size);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmalloc/dynarray_finalize.c:55:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
   55 |         memcpy (heap_array, list->array, allocation_size);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmalloc/dynarray_finalize.c:56:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   56 |       if (list->array != scratch)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m   57 |         free (list->array);[0m
      | [0;1;32m                           
[0m[1mmalloc/dynarray_finalize.c:62:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   62 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   63 |     /* The caller will perform the freeing operation.  */[0m
   64 |     return false;[0m
      | [0;1;32m                 
[0m8 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 6/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp0yi2ijsi.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/malloc/dynarray_emplace_enlarge.c
[1mmalloc/dynarray_emplace_enlarge.c:38:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   38 |       if (element_size < 4)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m   39 |         new_allocated = 16;[0m
   40 |       else if (element_size < 8)[0m
      | [0;32m      } 
[0m[1mmalloc/dynarray_emplace_enlarge.c:40:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   40 |       else if (element_size < 8)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m   41 |         new_allocated = 8;[0m
   42 |       else[0m
      | [0;32m      } 
[0m[1mmalloc/dynarray_emplace_enlarge.c:42:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   42 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m   43 |         new_allocated = 4;[0m
      | [0;1;32m                          
[0m[1mmalloc/dynarray_emplace_enlarge.c:59:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   59 |   if (INT_MULTIPLY_WRAPV (new_allocated, element_size, &new_size))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m   60 |     return false;[0m
      | [0;1;32m                 
[0m[1mmalloc/dynarray_emplace_enlarge.c:66:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   66 |       if (new_array != NULL && list->array != NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m   67 |         memcpy (new_array, list->array, list->used * element_size);[0m
      | [0;1;32m                                                                   
[0m[1mmalloc/dynarray_emplace_enlarge.c:67:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   67 |         memcpy (new_array, list->array, list->used * element_size);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmalloc/dynarray_emplace_enlarge.c:67:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
   67 |         memcpy (new_array, list->array, list->used * element_size);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmalloc/dynarray_emplace_enlarge.c:69:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   69 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   70 |     new_array = realloc (list->array, new_size);[0m
      | [0;1;32m                                                
[0m[1mmalloc/dynarray_emplace_enlarge.c:71:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   71 |   if (new_array == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m   72 |     return false;[0m
      | [0;1;32m                 
[0m10 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 7/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp_vrtjpnz.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/stack.c
[1mstack.c:49:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   49 |         if (stack_empty() || stack == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m   50 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mstack.c:60:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   60 |         if (stack_empty() || stack == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m   61 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mstack.c:75:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   75 |                 if (stack == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m   76 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mstack.c:79:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   79 |                 if (new_size < size)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m   80 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mstack.c:82:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   82 |                 if (new_stack == NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m   83 |                         return 0;[0m
      | [0;1;32m                                 
[0m7 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 8/54][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpftijzfbi.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/version.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 9/54][0.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpeeos0d89.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/fork.c
[1mfork.c:83:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   83 |         if (ret < 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m   84 |                 update_ERRNO_int(errno);[0m
   85 |         else if (ret == 0) {[0m
      | [0;32m        } 
[0m[1mfork.c:91:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   91 |                                 if (do_lint)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m   92 |                                         lintwarn(ext_id, _("fork: PROCINFO is not an array!"));[0m
      | [0;1;32m                                                                                               
[0m[1mfork.c:118:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  118 |                 if (ret < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  119 |                         update_ERRNO_int(errno);[0m
      | [0;1;32m                                                
[0m[1mfork.c:137:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  137 |         if (ret < 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  138 |                 update_ERRNO_int(errno);[0m
      | [0;1;32m                                        
[0m[1mfork.c:152:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  152 | dl_load_func(func_table, fork, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mfork.c:152:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  152 | dl_load_func(func_table, fork, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m21 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[10/54][1.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpkuh7tnfx.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/revoutput.c
[1mrevoutput.c:67:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   67 |         for (; nbytes >= 1; nbytes--)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m   68 |                 putc(cp[nbytes-1], fp);[0m
      | [0;1;32m                                       
[0m[1mrevoutput.c:81:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   81 |         if (outbuf == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m   82 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrevoutput.c:84:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   84 |         if (! sym_lookup("REVOUT", AWK_NUMBER, & value))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m   85 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrevoutput.c:99:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   99 |         if (outbuf == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  100 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrevoutput.c:142:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  142 | dl_load_func(func_table, revoutput, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mrevoutput.c:142:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  142 | dl_load_func(func_table, revoutput, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m21 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[11/54][1.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpd7c4iax0.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/awklib/grcat.c
[1mgrcat.c:41:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   41 |             if (g->gr_mem[i+1] != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m   42 |                 putchar(',');[0m
      | [0;1;32m                             
[0m3 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[12/54][0.8s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpn5hu44zr.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/malloc/dynarray_resize_clear.c
[1mmalloc/dynarray_resize_clear.c:31:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   31 |   if (!__libc_dynarray_resize (list, size, scratch, element_size))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m   32 |     return false;[0m
      | [0;1;32m                 
[0m[1mmalloc/dynarray_resize_clear.c:35:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   35 |   memset (array + (old_size * element_size), 0,[0m
      | [0;1;32m  ^~~~~~
[0m[1mmalloc/dynarray_resize_clear.c:35:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
   35 |   memset (array + (old_size * element_size), 0,[0m
      | [0;1;32m  ^~~~~~
[0m4 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[13/54][1.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpdbjkgwqk.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/awklib/pwcat.c
[1mpwcat.c:28:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   28 |     while ((p = getpwent()) != NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m   29 | #ifdef HAVE_STRUCT_PASSWD_PW_PASSWD[0m
   30 |         printf("%s:%s:%ld:%ld:%s:%s:%s\n",[0m
   31 |             p->pw_name, p->pw_passwd, (long) p->pw_uid,[0m
   32 |             (long) p->pw_gid, p->pw_gecos, p->pw_dir, p->pw_shell);[0m
      | [0;1;32m                                                                   
[0m3 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[14/54][2.2s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp84m1u6of.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/gawkmisc.c
41 warnings generated.
Suppressed 41 warnings (41 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[15/54][2.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpdockvswv.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/readfile.c
[1mreadfile.c:132:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  132 |         } else if (do_lint)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  133 |                 lintwarn(ext_id, _("readfile: called with wrong kind of argument"));[0m
      | [0;1;32m                                                                                    
[0m[1mreadfile.c:154:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  154 |         if (out == NULL || iobuf == NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  155 |                 return EOF;[0m
      | [0;1;32m                           
[0m[1mreadfile.c:169:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  169 |         if (text == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  170 |                 return EOF;[0m
      | [0;1;32m                           
[0m[1mreadfile.c:191:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  191 |         if (iobuf == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  192 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mreadfile.c:216:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  216 |         if (iobuf == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  217 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mreadfile.c:246:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  246 | dl_load_func(func_table, readfile, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mreadfile.c:246:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  246 | dl_load_func(func_table, readfile, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m22 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[16/54][3.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmphajpe4e4.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/floatcomp.c
30 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[17/54][3.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpwszebp2s.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/fnmatch.c
[1mfnmatch.c:209:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  209 | dl_load_func(func_table, fnmatch, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mfnmatch.c:209:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  209 | dl_load_func(func_table, fnmatch, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m17 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[18/54][1.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpkyfnkkta.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/getopt1.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[19/54][3.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpw2xbsa6b.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/revtwoway.c
[1mrevtwoway.c:148:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  148 |         if (out == NULL || iobuf == NULL || iobuf->opaque == NULL)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  149 |                 return EOF;[0m
      | [0;1;32m                           
[0m[1mrevtwoway.c:152:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  152 |         if (proc_data->len == 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  153 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mrevtwoway.c:179:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  179 |         if (iobuf == NULL || iobuf->opaque == NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  180 |                 return;[0m
      | [0;1;32m                       
[0m[1mrevtwoway.c:203:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  203 |         if (opaque == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  204 |                 return 0;       /* error */[0m
      | [0;1;32m                                           
[0m[1mrevtwoway.c:211:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  211 |                 if (proc_data->data == NULL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  212 |                         emalloc(proc_data->data, char *,  amount, "rev2way_fwrite");[0m
  213 |                 else[0m
      | [0;32m                } 
[0m[1mrevtwoway.c:213:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  213 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  214 |                         erealloc(proc_data->data, char *, proc_data->size + amount, "rev2way_fwrite");[0m
      | [0;1;32m                                                                                                      
[0m[1mrevtwoway.c:222:11: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  222 |                 *dest++ = *src--;[0m
      | [0;1;32m                ~~~~~~~~^~~~~~~~
[0m[1mrevtwoway.c:203:6: [0m[0;1;36mnote: [0mAssuming 'opaque' is not equal to NULL[0m
  203 |         if (opaque == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~
[0m[1mrevtwoway.c:203:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  203 |         if (opaque == NULL)[0m
      | [0;1;32m        ^
[0m[1mrevtwoway.c:210:6: [0m[0;1;36mnote: [0mAssuming 'amount' is > field 'size'[0m
  210 |         if (amount > proc_data->size || proc_data->len > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mrevtwoway.c:210:31: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  210 |         if (amount > proc_data->size || proc_data->len > 0) {[0m
      | [0;1;32m                                     ^
[0m[1mrevtwoway.c:211:7: [0m[0;1;36mnote: [0mAssuming field 'data' is equal to NULL[0m
  211 |                 if (proc_data->data == NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mrevtwoway.c:211:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  211 |                 if (proc_data->data == NULL)[0m
      | [0;1;32m                ^
[0m[1mrevtwoway.c:212:4: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  212 |                         emalloc(proc_data->data, char *,  amount, "rev2way_fwrite");[0m
      | [0;1;32m                        ^
[0m[1m./../gawkapi.h:964:7: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  964 |                 if ((pointer = (type) gawk_malloc(size)) == 0) \[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mrevtwoway.c:212:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  212 |                         emalloc(proc_data->data, char *,  amount, "rev2way_fwrite");[0m
      | [0;1;32m                        ^
[0m[1m./../gawkapi.h:964:3: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  964 |                 if ((pointer = (type) gawk_malloc(size)) == 0) \[0m
      | [0;1;32m                ^
[0m[1mrevtwoway.c:212:4: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  212 |                         emalloc(proc_data->data, char *,  amount, "rev2way_fwrite");[0m
      | [0;1;32m                        ^
[0m[1m./../gawkapi.h:963:2: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  963 |         do { \[0m
      | [0;1;32m        ^
[0m[1mrevtwoway.c:220:28: [0m[0;1;36mnote: [0mAssuming 'char_count' is > 0[0m
  220 |         for (char_count = amount; char_count > 0; char_count--) {[0m
      | [0;1;32m                                  ^~~~~~~~~~~~~~
[0m[1mrevtwoway.c:220:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  220 |         for (char_count = amount; char_count > 0; char_count--) {[0m
      | [0;1;32m        ^
[0m[1mrevtwoway.c:222:4: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  222 |                 *dest++ = *src--;[0m
      | [0;1;32m                 ^~~~~~
[0m[1mrevtwoway.c:222:11: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  222 |                 *dest++ = *src--;[0m
      | [0;1;32m                ~~~~~~~~^~~~~~~~
[0m[1mrevtwoway.c:258:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  258 |         if (opaque == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  259 |                 return EOF;     /* error */[0m
      | [0;1;32m                                           
[0m[1mrevtwoway.c:290:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  290 |         if (inbuf == NULL || outbuf == NULL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  291 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrevtwoway.c:299:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  299 |         if (max_fds + 1 == 0)   /* wrapped. ha! */[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  300 |                 max_fds = getdtablesize();[0m
      | [0;1;32m                                          
[0m[1mrevtwoway.c:345:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  345 | dl_load_func(func_table, revtwoway, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mrevtwoway.c:345:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  345 | dl_load_func(func_table, revtwoway, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m27 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[20/54][5.3s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmptosrr4ft.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/command.c
[1mcommand.c:1272:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1272 |   if (!yymsg)[0m
      | [0;1;32m             ^
[0m      | [0;32m              {
[0m 1273 |     yymsg = "Deleting";[0m
      | [0;1;32m                       
[0m[1mcommand.c:1393:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1393 |       if (YYMAXDEPTH <= yystacksize)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1394 |         YYNOMEM;[0m
      | [0;1;32m                
[0m[1mcommand.c:1396:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1396 |       if (YYMAXDEPTH < yystacksize)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1397 |         yystacksize = YYMAXDEPTH;[0m
      | [0;1;32m                                 
[0m[1mcommand.c:1404:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1404 |         if (! yyptr)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1405 |           YYNOMEM;[0m
      | [0;1;32m                  
[0m[1mcommand.c:1409:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1409 |         if (yyss1 != yyssa)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1410 |           YYSTACK_FREE (yyss1);[0m
      | [0;1;32m                               
[0m[1mcommand.c:1422:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1422 |       if (yyss + yystacksize - 1 <= yyssp)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1423 |         YYABORT;[0m
      | [0;1;32m                
[0m[1mcommand.c:1428:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1428 |   if (yystate == YYFINAL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1429 |     YYACCEPT;[0m
      | [0;1;32m             
[0m[1mcommand.c:1443:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1443 |   if (yypact_value_is_default (yyn))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1444 |     goto yydefault;[0m
      | [0;1;32m                   
[0m[1mcommand.c:1480:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1480 |   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1481 |     goto yydefault;[0m
      | [0;1;32m                   
[0m[1mcommand.c:1485:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1485 |       if (yytable_value_is_error (yyn))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1486 |         goto yyerrlab;[0m
      | [0;1;32m                      
[0m[1mcommand.c:1493:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1493 |   if (yyerrstatus)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1494 |     yyerrstatus--;[0m
      | [0;1;32m                  
[0m[1mcommand.c:1513:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1513 |   if (yyn == 0)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m 1514 |     goto yyerrlab;[0m
      | [0;1;32m                  
[0m[1mcommand.c:1541:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1541 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1542 |                 cmd_idx = -1;[0m
 1543 |                 want_nodeval = false;[0m
 1544 |                 if (lexptr_begin != NULL) {[0m
 1545 |                         if (input_from_tty && lexptr_begin[0] != '\0')[0m
 1546 |                                 add_history(lexptr_begin);[0m
 1547 |                         efree(lexptr_begin);[0m
 1548 |                         lexptr_begin = NULL;[0m
 1549 |                 }[0m
 1550 |                 if (arg_list != NULL) {[0m
 1551 |                         free_cmdarg(arg_list);[0m
 1552 |                         arg_list = NULL;[0m
 1553 |                 }[0m
 1554 |           }[0m
 1555 | #line 1556 "command.c"[0m
 1556 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1545:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1545 |                         if (input_from_tty && lexptr_begin[0] != '\0')[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1546 |                                 add_history(lexptr_begin);[0m
      | [0;1;32m                                                          
[0m[1mcommand.c:1560:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1560 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mcommand.c:1582:5: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1582 |                         )[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1583 |                                 repeat_idx = cmd_idx;[0m
 1584 |                         else[0m
      | [0;32m                        } 
[0m[1mcommand.c:1584:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1584 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1585 |                                 repeat_idx = -1;[0m
      | [0;1;32m                                                
[0m[1mcommand.c:1594:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1594 |                         if (in_commands)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1595 |                                 cmdfunc = do_commands;[0m
      | [0;1;32m                                                      
[0m[1mcommand.c:1603:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1603 |                         if (! in_commands || ctype == D_commands)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 1604 |                                 free_cmdarg(args);[0m
      | [0;1;32m                                                  
[0m[1mcommand.c:1605:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1605 |                         if (terminate)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1606 |                                 YYACCEPT;[0m
      | [0;1;32m                                         
[0m[1mcommand.c:1614:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1614 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1615 |                 yyerrok;[0m
 1616 |           }[0m
 1617 | #line 1618 "command.c"[0m
 1618 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1622:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1622 |           { want_nodeval = true; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1623 | #line 1624 "command.c"[0m
 1624 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1628:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1628 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mcommand.c:1648:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1648 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1649 |                 yyval = append_statement(arg_list, (char *) start_EVAL);[0m
 1650 |                 if (read_a_line == read_commands_string)        /* unserializing 'eval' in 'commands' */[0m
 1651 |                         yyval->a_string[0] = '\0';[0m
 1652 |                 free_cmdarg(arg_list);[0m
 1653 |                 arg_list = NULL;[0m
 1654 |           }[0m
 1655 | #line 1656 "command.c"[0m
 1656 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1650:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1650 |                 if (read_a_line == read_commands_string)        /* unserializing 'eval' in 'commands' */[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1651 |                         yyval->a_string[0] = '\0';[0m
      | [0;1;32m                                                  
[0m[1mcommand.c:1660:38: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1660 |                                      { yyval = append_statement(yyvsp[-1], lexptr_begin); }[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                     {
[0m 1661 | #line 1662 "command.c"[0m
 1662 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1666:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1666 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1667 |                 yyval = yyvsp[-1];[0m
 1668 |           }[0m
 1669 | #line 1670 "command.c"[0m
 1670 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1674:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1674 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mcommand.c:1694:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1694 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1695 |                 NODE *n;[0m
 1696 |                 CMDARG *arg;[0m
 1697 |                 n = yyvsp[0]->a_node;[0m
 1698 |                 arg = append_statement(NULL, (char *) start_EVAL);[0m
 1699 |                 (void) append_statement(arg, n->stptr);[0m
 1700 |                 (void) append_statement(arg, (char *) end_EVAL);[0m
 1701 |                 free_cmdarg(arg_list);[0m
 1702 |                 arg_list = arg;[0m
 1703 |           }[0m
 1704 | #line 1705 "command.c"[0m
 1705 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1709:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1709 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1710 |                 if (cmdtab[cmd_idx].lex_class == D_FRAME[0m
 1711 |                                 && yyvsp[0] != NULL && yyvsp[0]->a_int < 0)[0m
 1712 |                         yyerror(_("invalid frame number: %d"), yyvsp[0]->a_int);[0m
 1713 |           }[0m
 1714 | #line 1715 "command.c"[0m
 1715 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1711:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1711 |                                 && yyvsp[0] != NULL && yyvsp[0]->a_int < 0)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 1712 |                         yyerror(_("invalid frame number: %d"), yyvsp[0]->a_int);[0m
      | [0;1;32m                                                                                
[0m[1mcommand.c:1719:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1719 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1720 |                 int idx = find_argument(yyvsp[0]);[0m
 1721 |                 if (idx < 0)[0m
 1722 |                         yyerror(_("info: invalid option - `%s'"), yyvsp[0]->a_string);[0m
 1723 |                 else {[0m
 1724 |                         efree(yyvsp[0]->a_string);[0m
 1725 |                         yyvsp[0]->a_string = NULL;[0m
 1726 |                         yyvsp[0]->type = D_argument;[0m
 1727 |                         yyvsp[0]->a_argument = argtab[idx].value;[0m
 1728 |                 }[0m
 1729 |           }[0m
 1730 | #line 1731 "command.c"[0m
 1731 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1721:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1721 |                 if (idx < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1722 |                         yyerror(_("info: invalid option - `%s'"), yyvsp[0]->a_string);[0m
 1723 |                 else {[0m
      | [0;32m                } 
[0m[1mcommand.c:1735:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1735 |                   { want_nodeval = true; }[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1736 | #line 1737 "command.c"[0m
 1737 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1741:20: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1741 |                    { want_nodeval = true; }[0m
      | [0;1;32m                   ^
[0m      | [0;32m                   {
[0m 1742 | #line 1743 "command.c"[0m
 1743 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1747:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1747 |                 { want_nodeval = true; }[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1748 | #line 1749 "command.c"[0m
 1749 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1753:20: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1753 |                    { want_nodeval = true; }[0m
      | [0;1;32m                   ^
[0m      | [0;32m                   {
[0m 1754 | #line 1755 "command.c"[0m
 1755 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1759:21: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1759 |                     { want_nodeval = true; }[0m
      | [0;1;32m                    ^
[0m      | [0;32m                    {
[0m 1760 | #line 1761 "command.c"[0m
 1761 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1765:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1765 |                   { want_nodeval = true; }[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1766 | #line 1767 "command.c"[0m
 1767 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1771:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1771 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1772 |                 if (in_cmd_src(yyvsp[0]->a_string))[0m
 1773 |                         yyerror(_("source: `%s': already sourced"), yyvsp[0]->a_string);[0m
 1774 |           }[0m
 1775 | #line 1776 "command.c"[0m
 1776 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1772:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1772 |                 if (in_cmd_src(yyvsp[0]->a_string))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1773 |                         yyerror(_("source: `%s': already sourced"), yyvsp[0]->a_string);[0m
      | [0;1;32m                                                                                        
[0m[1mcommand.c:1780:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1780 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1781 |                 if (! input_from_tty)[0m
 1782 |                         yyerror(_("save: `%s': command not permitted"), yyvsp[0]->a_string);[0m
 1783 |           }[0m
 1784 | #line 1785 "command.c"[0m
 1785 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1781:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1781 |                 if (! input_from_tty)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1782 |                         yyerror(_("save: `%s': command not permitted"), yyvsp[0]->a_string);[0m
      | [0;1;32m                                                                                            
[0m[1mcommand.c:1789:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1789 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mcommand.c:1793:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1793 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1794 |                         num = yyvsp[0]->a_int;[0m
      | [0;1;32m                                              
[0m[1mcommand.c:1796:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1796 |                 if (dbg_errcount != 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1797 |                         ;[0m
 1798 |                 else if (in_commands)[0m
      | [0;32m                } 
[0m[1mcommand.c:1798:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1798 |                 else if (in_commands)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1799 |                         yyerror(_("cannot use command `commands' for breakpoint/watchpoint commands"));[0m
 1800 |                 else if (yyvsp[0] == NULL &&  ! (type = has_break_or_watch_point(&num, true)))[0m
      | [0;32m                } 
[0m[1mcommand.c:1800:81: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1800 |                 else if (yyvsp[0] == NULL &&  ! (type = has_break_or_watch_point(&num, true)))[0m
      | [0;1;32m                                                                                              ^
[0m      | [0;32m                                                                                               {
[0m 1801 |                         yyerror(_("no breakpoint/watchpoint has been set yet"));[0m
 1802 |                 else if (yyvsp[0] != NULL && ! (type = has_break_or_watch_point(&num, false)))[0m
      | [0;32m                } 
[0m[1mcommand.c:1802:81: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1802 |                 else if (yyvsp[0] != NULL && ! (type = has_break_or_watch_point(&num, false)))[0m
      | [0;1;32m                                                                                              ^
[0m      | [0;32m                                                                                               {
[0m 1803 |                         yyerror(_("invalid breakpoint/watchpoint number"));[0m
      | [0;1;32m                                                                           
[0m[1mcommand.c:1819:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1819 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1820 |                 if (! in_commands)[0m
 1821 |                         yyerror(_("`end' valid only in command `commands' or `eval'"));[0m
 1822 |                 else {[0m
 1823 |                         if (input_from_tty)[0m
 1824 |                                 dbg_prompt = dgawk_prompt;[0m
 1825 |                         in_commands = false;[0m
 1826 |                 }[0m
 1827 |           }[0m
 1828 | #line 1829 "command.c"[0m
 1829 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1820:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1820 |                 if (! in_commands)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1821 |                         yyerror(_("`end' valid only in command `commands' or `eval'"));[0m
 1822 |                 else {[0m
      | [0;32m                } 
[0m[1mcommand.c:1823:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1823 |                         if (input_from_tty)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1824 |                                 dbg_prompt = dgawk_prompt;[0m
      | [0;1;32m                                                          
[0m[1mcommand.c:1833:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1833 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1834 |                 if (! in_commands)[0m
 1835 |                         yyerror(_("`silent' valid only in command `commands'"));[0m
 1836 |           }[0m
 1837 | #line 1838 "command.c"[0m
 1838 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1834:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1834 |                 if (! in_commands)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1835 |                         yyerror(_("`silent' valid only in command `commands'"));[0m
      | [0;1;32m                                                                                
[0m[1mcommand.c:1842:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1842 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1843 |                 int idx = find_argument(yyvsp[0]);[0m
 1844 |                 if (idx < 0)[0m
 1845 |                         yyerror(_("trace: invalid option - `%s'"), yyvsp[0]->a_string);[0m
 1846 |                 else {[0m
 1847 |                         efree(yyvsp[0]->a_string);[0m
 1848 |                         yyvsp[0]->a_string = NULL;[0m
 1849 |                         yyvsp[0]->type = D_argument;[0m
 1850 |                         yyvsp[0]->a_argument = argtab[idx].value;[0m
 1851 |                 }[0m
 1852 |           }[0m
 1853 | #line 1854 "command.c"[0m
 1854 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1844:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1844 |                 if (idx < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1845 |                         yyerror(_("trace: invalid option - `%s'"), yyvsp[0]->a_string);[0m
 1846 |                 else {[0m
      | [0;32m                } 
[0m[1mcommand.c:1858:36: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1858 |                                    { want_nodeval = true; }[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                   {
[0m 1859 | #line 1860 "command.c"[0m
 1860 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1864:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1864 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1865 |                 int type;[0m
 1866 |                 int num = yyvsp[-2]->a_int;[0m
 1867 |                 type = has_break_or_watch_point(&num, false);[0m
 1868 |                 if (! type)[0m
 1869 |                         yyerror(_("condition: invalid breakpoint/watchpoint number"));[0m
 1870 |           }[0m
 1871 | #line 1872 "command.c"[0m
 1872 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1868:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1868 |                 if (! type)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1869 |                         yyerror(_("condition: invalid breakpoint/watchpoint number"));[0m
      | [0;1;32m                                                                                      
[0m[1mcommand.c:1876:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1876 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1877 |                 if (in_commands) {[0m
 1878 |                         /* Prepend command 'eval' to argument list */[0m
 1879 |                         CMDARG *arg;[0m
 1880 |                         arg = mk_cmdarg(D_string);[0m
 1881 |                         arg->a_string = estrdup("eval", 4);[0m
 1882 |                         arg->next = arg_list;[0m
 1883 |                         arg_list = arg;[0m
 1884 |                 }[0m
 1885 |           }[0m
 1886 | #line 1887 "command.c"[0m
 1887 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1891:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1891 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1892 |                 if (yyvsp[0] != NULL) {[0m
 1893 |                         NODE *n = yyvsp[0]->a_node;[0m
 1894 |                         yyvsp[0]->type = D_string;[0m
 1895 |                         yyvsp[0]->a_string = n->stptr;[0m
 1896 |                         freenode(n);[0m
 1897 |                 }[0m
 1898 |                 yyval = yyvsp[0];[0m
 1899 |           }[0m
 1900 | #line 1901 "command.c"[0m
 1901 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1905:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1905 |           {     yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1906 | #line 1907 "command.c"[0m
 1907 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1911:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1911 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1912 | #line 1913 "command.c"[0m
 1913 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1917:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1917 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1918 | #line 1919 "command.c"[0m
 1919 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1923:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1923 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1924 | #line 1925 "command.c"[0m
 1925 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1929:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1929 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1930 | #line 1931 "command.c"[0m
 1931 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1935:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1935 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1936 |                 NODE *n;[0m
 1937 |                 n = yyvsp[0]->a_node;[0m
 1938 |                 if ((n->flags & STRING) == 0)[0m
 1939 |                         yyerror(_("argument not a string"));[0m
 1940 |           }[0m
 1941 | #line 1942 "command.c"[0m
 1942 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1938:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1938 |                 if ((n->flags & STRING) == 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1939 |                         yyerror(_("argument not a string"));[0m
      | [0;1;32m                                                            
[0m[1mcommand.c:1946:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1946 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1947 | #line 1948 "command.c"[0m
 1948 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1952:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1952 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1953 |                 if (find_option(yyvsp[0]->a_string) < 0)[0m
 1954 |                         yyerror(_("option: invalid parameter - `%s'"), yyvsp[0]->a_string);[0m
 1955 |           }[0m
 1956 | #line 1957 "command.c"[0m
 1957 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1953:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1953 |                 if (find_option(yyvsp[0]->a_string) < 0)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1954 |                         yyerror(_("option: invalid parameter - `%s'"), yyvsp[0]->a_string);[0m
      | [0;1;32m                                                                                           
[0m[1mcommand.c:1961:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1961 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1962 |                 if (find_option(yyvsp[-2]->a_string) < 0)[0m
 1963 |                         yyerror(_("option: invalid parameter - `%s'"), yyvsp[-2]->a_string);[0m
 1964 |           }[0m
 1965 | #line 1966 "command.c"[0m
 1966 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1962:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1962 |                 if (find_option(yyvsp[-2]->a_string) < 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1963 |                         yyerror(_("option: invalid parameter - `%s'"), yyvsp[-2]->a_string);[0m
      | [0;1;32m                                                                                            
[0m[1mcommand.c:1970:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1970 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1971 |                 NODE *n;[0m
 1972 |                 n = lookup(yyvsp[0]->a_string);[0m
 1973 |                 if (n == NULL || n->type != Node_func)[0m
 1974 |                         yyerror(_("no such function - `%s'"), yyvsp[0]->a_string);[0m
 1975 |                 else {[0m
 1976 |                         yyvsp[0]->type = D_func;[0m
 1977 |                         efree(yyvsp[0]->a_string);[0m
 1978 |                         yyvsp[0]->a_string = NULL;[0m
 1979 |                         yyvsp[0]->a_node = n;[0m
 1980 |                 }[0m
 1981 |           }[0m
 1982 | #line 1983 "command.c"[0m
 1983 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1973:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1973 |                 if (n == NULL || n->type != Node_func)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1974 |                         yyerror(_("no such function - `%s'"), yyvsp[0]->a_string);[0m
 1975 |                 else {[0m
      | [0;32m                } 
[0m[1mcommand.c:1987:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1987 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1988 | #line 1989 "command.c"[0m
 1989 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1993:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1993 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1994 | #line 1995 "command.c"[0m
 1995 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:1999:24: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1999 |                        { want_nodeval = true; }[0m
      | [0;1;32m                       ^
[0m      | [0;32m                       {
[0m 2000 | #line 2001 "command.c"[0m
 2001 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2005:37: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2005 |                                     { want_nodeval = true; }[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                    {
[0m 2006 | #line 2007 "command.c"[0m
 2007 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2011:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2011 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2012 | #line 2013 "command.c"[0m
 2013 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2017:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2017 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2018 | #line 2019 "command.c"[0m
 2019 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2023:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2023 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2024 | #line 2025 "command.c"[0m
 2025 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2029:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2029 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2030 |                 int idx = find_argument(yyvsp[-1]);[0m
 2031 |                 if (idx < 0)[0m
 2032 |                         yyerror(_("enable: invalid option - `%s'"), yyvsp[-1]->a_string);[0m
 2033 |                 else {[0m
 2034 |                         efree(yyvsp[-1]->a_string);[0m
 2035 |                         yyvsp[-1]->a_string = NULL;[0m
 2036 |                         yyvsp[-1]->type = D_argument;[0m
 2037 |                         yyvsp[-1]->a_argument = argtab[idx].value;[0m
 2038 |                 }[0m
 2039 |           }[0m
 2040 | #line 2041 "command.c"[0m
 2041 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2031:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2031 |                 if (idx < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2032 |                         yyerror(_("enable: invalid option - `%s'"), yyvsp[-1]->a_string);[0m
 2033 |                 else {[0m
      | [0;32m                } 
[0m[1mcommand.c:2045:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2045 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2046 |                 yyvsp[0]->type = D_array;       /* dump all items */[0m
 2047 |                 yyvsp[0]->a_count = 0;[0m
 2048 |           }[0m
 2049 | #line 2050 "command.c"[0m
 2050 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2054:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2054 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2055 |                 yyvsp[-1]->type = D_array;[0m
 2056 |                 yyvsp[-1]->a_count = num_dim;[0m
 2057 |           }[0m
 2058 | #line 2059 "command.c"[0m
 2059 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2063:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2063 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2064 | #line 2065 "command.c"[0m
 2065 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2069:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2069 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2070 | #line 2071 "command.c"[0m
 2071 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2075:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2075 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2076 |                 CMDARG *a;[0m
 2077 |                 a = mk_cmdarg(D_int);[0m
 2078 |                 a->a_int = -1;[0m
 2079 |                 append_cmdarg(a);[0m
 2080 |           }[0m
 2081 | #line 2082 "command.c"[0m
 2082 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2086:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2086 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2087 |                 if (yyvsp[-2]->a_int > yyvsp[0]->a_int)[0m
 2088 |                         yyerror(_("invalid range specification: %d - %d"),[0m
 2089 |                                 yyvsp[-2]->a_int, yyvsp[0]->a_int);[0m
 2090 |                 else[0m
 2091 |                         yyvsp[-2]->type = D_range;[0m
 2092 |                 yyval = yyvsp[-2];[0m
 2093 |           }[0m
 2094 | #line 2095 "command.c"[0m
 2095 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2087:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2087 |                 if (yyvsp[-2]->a_int > yyvsp[0]->a_int)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2088 |                         yyerror(_("invalid range specification: %d - %d"),[0m
 2089 |                                 yyvsp[-2]->a_int, yyvsp[0]->a_int);[0m
 2090 |                 else[0m
      | [0;32m                } 
[0m[1mcommand.c:2090:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2090 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2091 |                         yyvsp[-2]->type = D_range;[0m
      | [0;1;32m                                                  
[0m[1mcommand.c:2099:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2099 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2100 | #line 2101 "command.c"[0m
 2101 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2105:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2105 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2106 | #line 2107 "command.c"[0m
 2107 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2111:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2111 |           { yyval = yyvsp[-2]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2112 | #line 2113 "command.c"[0m
 2113 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2117:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2117 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2118 |                 CMDARG *a;[0m
 2119 |                 NODE *subs;[0m
 2120 |                 int count = 0;[0m
 2121 | [0m
 2122 |                 for (a = yyvsp[-1]; a != NULL; a = a->next)[0m
 2123 |                         count++;[0m
 2124 |                 subs = concat_args(yyvsp[-1], count);[0m
 2125 |                 free_cmdarg(yyvsp[-1]->next);[0m
 2126 |                 yyvsp[-1]->next = NULL;[0m
 2127 |                 yyvsp[-1]->type = D_node;[0m
 2128 |                 yyvsp[-1]->a_node = subs;[0m
 2129 |                 yyval = yyvsp[-1];[0m
 2130 |           }[0m
 2131 | #line 2132 "command.c"[0m
 2132 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2122:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2122 |                 for (a = yyvsp[-1]; a != NULL; a = a->next)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2123 |                         count++;[0m
      | [0;1;32m                                
[0m[1mcommand.c:2136:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2136 |           { yyval = yyvsp[0]; num_dim = 1; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2137 | #line 2138 "command.c"[0m
 2138 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2142:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2142 |           {     yyval = yyvsp[-1]; num_dim++; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2143 | #line 2144 "command.c"[0m
 2144 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2148:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2148 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2149 |                 NODE *n = yyvsp[0]->a_node;[0m
 2150 |                 if ((n->flags & NUMBER) == 0)[0m
 2151 |                         yyerror(_("non-numeric value for field number"));[0m
 2152 |                 else[0m
 2153 |                         yyvsp[0]->type = D_field;[0m
 2154 |                 yyval = yyvsp[0];[0m
 2155 |           }[0m
 2156 | #line 2157 "command.c"[0m
 2157 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2150:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2150 |                 if ((n->flags & NUMBER) == 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2151 |                         yyerror(_("non-numeric value for field number"));[0m
 2152 |                 else[0m
      | [0;32m                } 
[0m[1mcommand.c:2152:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2152 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2153 |                         yyvsp[0]->type = D_field;[0m
      | [0;1;32m                                                 
[0m[1mcommand.c:2161:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2161 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2162 |                 /* a_string is array name, a_count is dimension count */[0m
 2163 |                 yyvsp[-1]->type = D_subscript;[0m
 2164 |                 yyvsp[-1]->a_count = num_dim;[0m
 2165 |                 yyval = yyvsp[-1];[0m
 2166 |           }[0m
 2167 | #line 2168 "command.c"[0m
 2168 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2172:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2172 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2173 | #line 2174 "command.c"[0m
 2174 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2178:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2178 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2179 |                 NODE *n = yyvsp[0]->a_node;[0m
 2180 |                 if ((n->flags & NUMBER) == 0)[0m
 2181 |                         yyerror(_("non-numeric value found, numeric expected"));[0m
 2182 |                 yyval = yyvsp[0];[0m
 2183 |           }[0m
 2184 | #line 2185 "command.c"[0m
 2185 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2180:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2180 |                 if ((n->flags & NUMBER) == 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2181 |                         yyerror(_("non-numeric value found, numeric expected"));[0m
      | [0;1;32m                                                                                
[0m[1mcommand.c:2189:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2189 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2190 |                 NODE *n = yyvsp[0]->a_node;[0m
 2191 |                 if ((n->flags & NUMBER) == 0)[0m
 2192 |                         yyerror(_("non-numeric value found, numeric expected"));[0m
 2193 |                 else[0m
 2194 |                         negate_num(n);[0m
 2195 |                 yyval = yyvsp[0];[0m
 2196 |           }[0m
 2197 | #line 2198 "command.c"[0m
 2198 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2191:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2191 |                 if ((n->flags & NUMBER) == 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2192 |                         yyerror(_("non-numeric value found, numeric expected"));[0m
 2193 |                 else[0m
      | [0;32m                } 
[0m[1mcommand.c:2193:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2193 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2194 |                         negate_num(n);[0m
      | [0;1;32m                                      
[0m[1mcommand.c:2202:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2202 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2203 | #line 2204 "command.c"[0m
 2204 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2208:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2208 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2209 | #line 2210 "command.c"[0m
 2210 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2214:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2214 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2215 | #line 2216 "command.c"[0m
 2216 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2220:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2220 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2221 | #line 2222 "command.c"[0m
 2222 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2226:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2226 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2227 |                 if (yyvsp[0]->a_int == 0)[0m
 2228 |                         yyerror(_("non-zero integer value"));[0m
 2229 |                 yyval = yyvsp[0];[0m
 2230 |           }[0m
 2231 | #line 2232 "command.c"[0m
 2232 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2227:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2227 |                 if (yyvsp[0]->a_int == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2228 |                         yyerror(_("non-zero integer value"));[0m
      | [0;1;32m                                                             
[0m[1mcommand.c:2236:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2236 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2237 |                 if (yyvsp[0]->a_int == 0)[0m
 2238 |                         yyerror(_("non-zero integer value"));[0m
 2239 |                 yyval = yyvsp[0];[0m
 2240 |           }[0m
 2241 | #line 2242 "command.c"[0m
 2242 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2237:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2237 |                 if (yyvsp[0]->a_int == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2238 |                         yyerror(_("non-zero integer value"));[0m
      | [0;1;32m                                                             
[0m[1mcommand.c:2246:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2246 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2247 | #line 2248 "command.c"[0m
 2248 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2252:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2252 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2253 | #line 2254 "command.c"[0m
 2254 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2258:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2258 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2259 |                 yyvsp[0]->a_int = - yyvsp[0]->a_int;[0m
 2260 |                 yyval = yyvsp[0];[0m
 2261 |           }[0m
 2262 | #line 2263 "command.c"[0m
 2263 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2267:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2267 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2268 |                 if (lexptr_begin != NULL) {[0m
 2269 |                         if (input_from_tty && lexptr_begin[0] != '\0')[0m
 2270 |                                 add_history(lexptr_begin);[0m
 2271 |                         efree(lexptr_begin);[0m
 2272 |                         lexptr_begin = NULL;[0m
 2273 |                 }[0m
 2274 |           }[0m
 2275 | #line 2276 "command.c"[0m
 2276 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mcommand.c:2269:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2269 |                         if (input_from_tty && lexptr_begin[0] != '\0')[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2270 |                                 add_history(lexptr_begin);[0m
      | [0;1;32m                                                          
[0m[1mcommand.c:2281:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2281 |       default: break;[0m
      | [0;1;32m               ^    
[0m      | [0;32m               {    ;} 
[0m[1mcommand.c:2337:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2337 |           if (yychar == YYEOF)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2338 |             YYABORT;[0m
      | [0;1;32m                    
[0m[1mcommand.c:2359:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2359 |   if (0)[0m
      | [0;1;32m        ^
[0m      | [0;32m         {
[0m 2360 |     YYERROR;[0m
      | [0;1;32m            
[0m[1mcommand.c:2388:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2388 |               if (0 < yyn)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2389 |                 break;[0m
      | [0;1;32m                      
[0m[1mcommand.c:2394:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2394 |       if (yyssp == yyss)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2395 |         YYABORT;[0m
      | [0;1;32m                
[0m[1mcommand.c:2465:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2465 |   if (yyss != yyssa)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2466 |     YYSTACK_FREE (yyss);[0m
      | [0;1;32m                        
[0m[1mcommand.c:2489:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2489 |                 for (a = stmt_list; a != NULL; a = a->next)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2490 |                         len += strlen(a->a_string) + 1; /* 1 for ',' */[0m
      | [0;1;32m                                                                       
[0m[1mcommand.c:2505:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2505 |                         if (a->next != NULL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2506 |                                 s[slen++] = ',';[0m
      | [0;1;32m                                                
[0m[1mcommand.c:2531:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2531 |         if (stmt == end_EVAL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2532 |                 erealloc(stmt_list->a_string, char *, slen + 1, "append_statement");[0m
      | [0;1;32m                                                                                    
[0m[1mcommand.c:2660:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2660 |                 if (cmdtab[i].type == ctype)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2661 |                         return cmdtab[i].cf_ptr;[0m
      | [0;1;32m                                                
[0m[1mcommand.c:2673:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2673 |                 if (cmdtab[i].type == ctype)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2674 |                         return cmdtab[i].name;[0m
      | [0;1;32m                                              
[0m[1mcommand.c:2697:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2697 |         if (arg_list == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2698 |                 arg_list = arg;[0m
 2699 |         else[0m
      | [0;32m        } 
[0m[1mcommand.c:2699:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2699 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2700 |                 savetail->next = arg;[0m
      | [0;1;32m                                     
[0m[1mcommand.c:2719:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2719 |                         if (arg->a_string != NULL)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 2720 |                                 efree(arg->a_string);[0m
      | [0;1;32m                                                     
[0m[1mcommand.c:2721:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2721 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mcommand.c:2725:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2725 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mcommand.c:2727:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2727 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mcommand.c:2776:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2776 |                         if (get_eof_status() == EXIT_FATAL)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2777 |                                 exit(EXIT_FATAL);[0m
      | [0;1;32m                                                 
[0m[1mcommand.c:2794:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2794 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2795 |                                         return '\n';    /* end command 'quit' */[0m
      | [0;1;32m                                                                                
[0m[1mcommand.c:2797:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2797 |                         if (errno != 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2798 |                                 d_error(_("cannot read command: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                       
[0m[1mcommand.c:2799:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2799 |                         if (pop_cmd_src() == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 2800 |                                 goto again;[0m
      | [0;1;32m                                           
[0m[1mcommand.c:2806:4: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2806 |                 )[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 2807 |                         history_expand_line(&lexptr_begin);[0m
      | [0;1;32m                                                           
[0m[1mcommand.c:2819:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2819 |                         if (h != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2820 |                                 add_history(h->line);[0m
      | [0;1;32m                                                     
[0m[1mcommand.c:2830:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2830 |         while (c == ' ' || c == '\t')[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2831 |                 c = *++lexptr;[0m
      | [0;1;32m                              
[0m[1mcommand.c:2833:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2833 |         if (! input_from_tty && c == '#')[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2834 |                 return '\n';[0m
      | [0;1;32m                            
[0m[1mcommand.c:2837:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2837 |         if (lexptr >= lexend)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2838 |                 return '\n';[0m
      | [0;1;32m                            
[0m[1mcommand.c:2893:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2893 |                 if (c == '=')[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2894 |                         return *lexptr++;[0m
      | [0;1;32m                                         
[0m[1mcommand.c:2895:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2895 |         } else if (c == '-' || c == '+' || c == ':' || c == '|')[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 2896 |                 return *lexptr++;[0m
      | [0;1;32m                                 
[0m[1mcommand.c:2917:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2917 |                                 if (want_nodeval || c != '"')[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 2918 |                                         *p++ = '\\';[0m
      | [0;1;32m                                                    
[0m[1mcommand.c:2920:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2920 |                         if (lexptr == lexend)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2921 |                                 goto err;[0m
      | [0;1;32m                                         
[0m[1mcommand.c:2933:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2933 |                         if (esc_seen)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2934 |                                 flags |= SCAN;[0m
      | [0;1;32m                                              
[0m[1mcommand.c:2944:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2944 |                                         && c != ' ' && c != '\t' && c != '=')[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m 2945 |                         ;[0m
      | [0;1;32m                         
[0m[1mcommand.c:3013:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3013 |                         || c == ',' || c == '=')[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3014 |                 return *lexptr++;[0m
      | [0;1;32m                                 
[0m[1mcommand.c:3021:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3021 |         while (is_identchar(c))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3022 |                 c = *++lexptr;[0m
      | [0;1;32m                              
[0m[1mcommand.c:3082:4: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3082 |                 )[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 3083 |                         return idx;[0m
      | [0;1;32m                                   
[0m[1mcommand.c:3121:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3121 |                 if (subseplen == 1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3122 |                         *p++ = *subsep;[0m
 3123 |                 else if (subseplen > 0) {[0m
      | [0;32m                } 
[0m[1mcommand.c:3166:4: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3166 |                 )[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 3167 |                         return i;[0m
      | [0;1;32m                                 
[0m[1mcommand.c:3169:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3169 |                 if (*name > *token || i == (k - 1))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3170 |                         try_exact = false;[0m
      | [0;1;32m                                          
[0m[1mcommand.c:3175:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3175 |                                 if (toklen == 1 && ! abrv[1])[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3176 |                                         abrv_match = i;[0m
 3177 |                                 else if (toklen == 2 && abrv[1] == token[1])[0m
      | [0;32m                                } 
[0m[1mcommand.c:3177:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3177 |                                 else if (toklen == 2 && abrv[1] == token[1])[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 3178 |                                         abrv_match = i;[0m
      | [0;1;32m                                                       
[0m[1mcommand.c:3181:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3181 |                 if (! try_exact && abrv_match >= 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3182 |                         return abrv_match;[0m
      | [0;1;32m                                          
[0m[1mcommand.c:3190:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3190 |                                 )[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3191 |                                         partial_match = i;[0m
      | [0;1;32m                                                          
[0m[1mcommand.c:3218:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3218 |                         if (strcmp(cmdtab[i].name, "option") == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3219 |                                 option_help();[0m
      | [0;1;32m                                              
[0m[1mcommand.c:3220:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3220 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3221 |                         fprintf(out_fp, _("undefined command: %s\n"), name);[0m
      | [0;1;32m                                                                            
[0m[1mcommand.c:3240:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3240 |         if (p == NULL || len <= 0)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3241 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcommand.c:3242:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3242 |         for (i = 0; i < len; i++, p++)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3243 |                 if (*p != ' ' && *p != '\t')[0m
 3244 |                         break;[0m
      | [0;1;32m                              
[0m[1mcommand.c:3243:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3243 |                 if (*p != ' ' && *p != '\t')[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 3244 |                         break;[0m
      | [0;1;32m                              
[0m[1mcommand.c:3245:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3245 |         if (i == len)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 3246 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcommand.c:3248:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3248 |                 for (i++, q = p + 1; i < len; i++, q++)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 3249 |                         if (*q == ' ' || *q == '\t')[0m
 3250 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mcommand.c:3249:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3249 |                         if (*q == ' ' || *q == '\t')[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 3250 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mcommand.c:3277:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3277 |         if ((cmdtok = next_word(rl_line_buffer, len, &e)) == NULL)      /* no first word yet */[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3278 |                 return  rl_completion_matches(text, command_generator);[0m
      | [0;1;32m                                                                       
[0m[1mcommand.c:3282:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3282 |         if (idx < 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3283 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcommand.c:3300:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3300 |                         return rl_completion_matches(text, option_generator);[0m
      | [0;1;32m                        ^                                                   
[0m      | [0;32m                        {                                                   ;} 
[0m[1mcommand.c:3308:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3308 |                         return NULL;[0m
      | [0;1;32m                        ^          
[0m      | [0;32m                        {          ;} 
[0m[1mcommand.c:3312:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3312 |         if (this_cmd == D_print || this_cmd == D_printf)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 3313 |                 return rl_completion_matches(text, variable_generator);[0m
      | [0;1;32m                                                                       
[0m[1mcommand.c:3332:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3332 |                 if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3333 |                         return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                           
[0m[1mcommand.c:3359:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3359 |                 if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3360 |                         return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                           
[0m[1mcommand.c:3381:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3381 |                         if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 3382 |                                 return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                                   
[0m[1mcommand.c:3386:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3386 |                         if (this_cmd != argtab[idx++].cmd)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3387 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mcommand.c:3388:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3388 |                         if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 3389 |                                 return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                                   
[0m[1mcommand.c:3409:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3409 |                 if (vars != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3410 |                         efree(vars);[0m
      | [0;1;32m                                    
[0m[1mcommand.c:3424:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3424 |                 if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3425 |                         return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                           
[0m[1mcommand.c:3431:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3431 |                 if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3432 |                         return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                           
[0m[1mcommand.c:3446:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3446 |         if (! *line || input_fd != 0 || ! input_from_tty)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3447 |                 return;[0m
      | [0;1;32m                       
[0m[1mcommand.c:3450:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3450 |         if (ret < 0 || ret == 2)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3451 |                 efree(expansion);[0m
 3452 |         else {[0m
      | [0;32m        } 
[0m212 warnings generated.
Suppressed 25 warnings (25 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[21/54][3.2s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpd50cfjl6.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/readdir.c
[1mreaddir.c:100:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  100 |         case DT_BLK:    return "b";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:101:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  101 |         case DT_CHR:    return "c";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:102:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  102 |         case DT_DIR:    return "d";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:103:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  103 |         case DT_FIFO:   return "p";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:104:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  104 |         case DT_LNK:    return "l";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:105:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  105 |         case DT_REG:    return "f";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:106:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  106 |         case DT_SOCK:   return "s";[0m
      | [0;1;32m                        ^         
[0m      | [0;32m                        {         ;} 
[0m[1mreaddir.c:114:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  114 |         strcpy(fname, dirname);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir.c:114:2: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  114 |         strcpy(fname, dirname);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir.c:115:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  115 |         strcat(fname, "/");[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir.c:115:2: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
  115 |         strcat(fname, "/");[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir.c:116:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  116 |         strcat(fname, entry->d_name);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir.c:116:2: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
  116 |         strcat(fname, entry->d_name);[0m
      | [0;1;32m        ^~~~~~
[0m[1mreaddir.c:118:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  118 |                 if (S_ISBLK(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  119 |                         return "b";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:120:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  120 |                 if (S_ISCHR(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  121 |                         return "c";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:122:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  122 |                 if (S_ISDIR(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  123 |                         return "d";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:124:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  124 |                 if (S_ISFIFO(sbuf.st_mode))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  125 |                         return "p";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:126:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  126 |                 if (S_ISREG(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  127 |                         return "f";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:129:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  129 |                 if (S_ISLNK(sbuf.st_mode))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  130 |                         return "l";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:133:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  133 |                 if (S_ISSOCK(sbuf.st_mode))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  134 |                         return "s";[0m
      | [0;1;32m                                   
[0m[1mreaddir.c:191:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  191 |         if (out == NULL || iobuf == NULL || iobuf->opaque == NULL)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  192 |                 return EOF;[0m
      | [0;1;32m                           
[0m[1mreaddir.c:212:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  212 |         len = sprintf(the_dir->buf, "%llu/%s", ino, dirent->d_name);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mreaddir.c:212:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  212 |         len = sprintf(the_dir->buf, "%llu/%s", ino, dirent->d_name);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mreaddir.c:216:9: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  216 |         len += sprintf(the_dir->buf + len, "/%s", ftstr);[0m
      | [0;1;32m               ^~~~~~~
[0m[1mreaddir.c:216:9: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  216 |         len += sprintf(the_dir->buf + len, "/%s", ftstr);[0m
      | [0;1;32m               ^~~~~~~
[0m[1mreaddir.c:232:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  232 |         if (iobuf == NULL || iobuf->opaque == NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  233 |                 return;[0m
      | [0;1;32m                       
[0m[1mreaddir.c:249:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  249 |         if (iobuf == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  250 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mreaddir.c:333:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  333 | dl_load_func(func_table, readdir, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mreaddir.c:333:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  333 | dl_load_func(func_table, readdir, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m39 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[22/54][5.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmptvsbwl19.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/mpfr.c
30 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[23/54][5.2s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp5320_isf.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/intdiv.c
[1mintdiv.c:67:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   67 |         if (d >= 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m   68 |                 d = floor(d);[0m
   69 |         else[0m
      | [0;32m        } 
[0m[1mintdiv.c:69:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   69 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m   70 |                 d = ceil(d);[0m
      | [0;1;32m                            
[0m[1mintdiv.c:242:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  242 | dl_load_func(func_table, intdiv, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mintdiv.c:242:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  242 | dl_load_func(func_table, intdiv, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m19 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[24/54][2.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpny1hb_cf.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/ordchr.c
[1mordchr.c:71:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   71 |         } else if (do_lint)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m   72 |                 lintwarn(ext_id, _("ord: first argument is not a string"));[0m
      | [0;1;32m                                                                           
[0m[1mordchr.c:98:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   98 |         } else if (do_lint)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m   99 |                 lintwarn(ext_id, _("chr: first argument is not a number"));[0m
      | [0;1;32m                                                                           
[0m[1mordchr.c:112:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  112 | dl_load_func(func_table, ord_chr, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mordchr.c:112:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  112 | dl_load_func(func_table, ord_chr, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m19 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[25/54][4.8s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpyp2snngk.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/replace.c
30 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[26/54][13.7s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpjy950f7g.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/regex.c
858 warnings generated.
Suppressed 858 warnings (858 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[27/54][10.7s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpkydwt909.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/awkgram.c
[1mawkgram.c:1687:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1687 |   if (!yymsg)[0m
      | [0;1;32m             ^
[0m      | [0;32m              {
[0m 1688 |     yymsg = "Deleting";[0m
      | [0;1;32m                       
[0m[1mawkgram.c:1808:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1808 |       if (YYMAXDEPTH <= yystacksize)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1809 |         YYNOMEM;[0m
      | [0;1;32m                
[0m[1mawkgram.c:1811:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1811 |       if (YYMAXDEPTH < yystacksize)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1812 |         yystacksize = YYMAXDEPTH;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:1819:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1819 |         if (! yyptr)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1820 |           YYNOMEM;[0m
      | [0;1;32m                  
[0m[1mawkgram.c:1824:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1824 |         if (yyss1 != yyssa)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1825 |           YYSTACK_FREE (yyss1);[0m
      | [0;1;32m                               
[0m[1mawkgram.c:1837:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1837 |       if (yyss + yystacksize - 1 <= yyssp)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1838 |         YYABORT;[0m
      | [0;1;32m                
[0m[1mawkgram.c:1843:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1843 |   if (yystate == YYFINAL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1844 |     YYACCEPT;[0m
      | [0;1;32m             
[0m[1mawkgram.c:1858:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1858 |   if (yypact_value_is_default (yyn))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1859 |     goto yydefault;[0m
      | [0;1;32m                   
[0m[1mawkgram.c:1895:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1895 |   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1896 |     goto yydefault;[0m
      | [0;1;32m                   
[0m[1mawkgram.c:1900:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1900 |       if (yytable_value_is_error (yyn))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1901 |         goto yyerrlab;[0m
      | [0;1;32m                      
[0m[1mawkgram.c:1908:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1908 |   if (yyerrstatus)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1909 |     yyerrstatus--;[0m
      | [0;1;32m                  
[0m[1mawkgram.c:1928:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1928 |   if (yyn == 0)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m 1929 |     goto yyerrlab;[0m
      | [0;1;32m                  
[0m[1mawkgram.c:1956:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1956 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1957 | #line 1958 "awkgram.c"[0m
 1958 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:1962:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1962 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1963 |                 rule = 0;[0m
 1964 |                 yyerrok;[0m
 1965 |           }[0m
 1966 | #line 1967 "awkgram.c"[0m
 1967 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:1971:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1971 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1972 |                 if (yyvsp[0] != NULL) {[0m
 1973 |                         if (yyvsp[-1] == NULL)[0m
 1974 |                                 outer_comment = yyvsp[0];[0m
 1975 |                         else[0m
 1976 |                                 interblock_comment = yyvsp[0];[0m
 1977 |                 }[0m
 1978 |                 yyval = yyvsp[-1];[0m
 1979 |           }[0m
 1980 | #line 1981 "awkgram.c"[0m
 1981 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:1973:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1973 |                         if (yyvsp[-1] == NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1974 |                                 outer_comment = yyvsp[0];[0m
 1975 |                         else[0m
      | [0;32m                        } 
[0m[1mawkgram.c:1975:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1975 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1976 |                                 interblock_comment = yyvsp[0];[0m
      | [0;1;32m                                                              
[0m[1mawkgram.c:1985:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1985 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1986 |                 next_sourcefile();[0m
 1987 |           }[0m
 1988 | #line 1989 "awkgram.c"[0m
 1989 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:1993:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1993 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1994 |                 rule = 0;[0m
 1995 |                 /*[0m
 1996 |                  * If errors, give up, don't produce an infinite[0m
 1997 |                  * stream of syntax error messages.[0m
 1998 |                  */[0m
 1999 |                 /* yyerrok; */[0m
 2000 |           }[0m
 2001 | #line 2002 "awkgram.c"[0m
 2002 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2006:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2006 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2007 |                 (void) append_rule(yyvsp[-1], yyvsp[0]);[0m
 2008 |                 if (pending_comment != NULL) {[0m
 2009 |                         interblock_comment = pending_comment;[0m
 2010 |                         pending_comment = NULL;[0m
 2011 |                 }[0m
 2012 |           }[0m
 2013 | #line 2014 "awkgram.c"[0m
 2014 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2018:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2018 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2019 |                 if (rule != Rule) {[0m
 2020 |                         msg(_("%s blocks must have an action part"), ruletab[rule]);[0m
 2021 |                         errcount++;[0m
 2022 |                 } else if (yyvsp[-1] == NULL) {[0m
 2023 |                         msg(_("each rule must have a pattern or an action part"));[0m
 2024 |                         errcount++;[0m
 2025 |                 } else {        /* pattern rule with non-empty pattern */[0m
 2026 |                         if (yyvsp[0] != NULL)[0m
 2027 |                                 list_append(yyvsp[-1], yyvsp[0]);[0m
 2028 |                         (void) append_rule(yyvsp[-1], NULL);[0m
 2029 |                 }[0m
 2030 |           }[0m
 2031 | #line 2032 "awkgram.c"[0m
 2032 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2026:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2026 |                         if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2027 |                                 list_append(yyvsp[-1], yyvsp[0]);[0m
      | [0;1;32m                                                                 
[0m[1mawkgram.c:2036:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2036 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2037 |                 in_function = false;[0m
 2038 |                 (void) mk_function(yyvsp[-1], yyvsp[0]);[0m
 2039 |                 want_param_names = DONT_CHECK;[0m
 2040 |                 if (pending_comment != NULL) {[0m
 2041 |                         interblock_comment = pending_comment;[0m
 2042 |                         pending_comment = NULL;[0m
 2043 |                 }[0m
 2044 |                 yyerrok;[0m
 2045 |           }[0m
 2046 | #line 2047 "awkgram.c"[0m
 2047 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2051:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2051 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2052 |                 want_source = false;[0m
 2053 |                 at_seen--;[0m
 2054 |                 if (yyvsp[-1] != NULL && yyvsp[0] != NULL) {[0m
 2055 |                         SRCFILE *s = (SRCFILE *) yyvsp[-1];[0m
 2056 |                         s->comment = yyvsp[0];[0m
 2057 |                 }[0m
 2058 |                 yyerrok;[0m
 2059 |           }[0m
 2060 | #line 2061 "awkgram.c"[0m
 2061 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2065:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2065 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2066 |                 want_source = false;[0m
 2067 |                 at_seen--;[0m
 2068 |                 if (yyvsp[-1] != NULL && yyvsp[0] != NULL) {[0m
 2069 |                         SRCFILE *s = (SRCFILE *) yyvsp[-1];[0m
 2070 |                         s->comment = yyvsp[0];[0m
 2071 |                 }[0m
 2072 |                 yyerrok;[0m
 2073 |           }[0m
 2074 | #line 2075 "awkgram.c"[0m
 2075 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2079:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2079 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2106:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2106 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2107 |                 void *srcfile = NULL;[0m
 2108 | [0m
 2109 |                 if (! include_source(yyvsp[0], & srcfile))[0m
 2110 |                         YYABORT;[0m
 2111 |                 efree(yyvsp[0]->lextok);[0m
 2112 |                 bcfree(yyvsp[0]);[0m
 2113 |                 yyval = (INSTRUCTION *) srcfile;[0m
 2114 |           }[0m
 2115 | #line 2116 "awkgram.c"[0m
 2116 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2109:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2109 |                 if (! include_source(yyvsp[0], & srcfile))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2110 |                         YYABORT;[0m
      | [0;1;32m                                
[0m[1mawkgram.c:2120:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2120 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2121 | #line 2122 "awkgram.c"[0m
 2122 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2126:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2126 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2127 | #line 2128 "awkgram.c"[0m
 2128 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2132:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2132 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2133 |                 void *srcfile;[0m
 2134 | [0m
 2135 |                 if (! load_library(yyvsp[0], & srcfile))[0m
 2136 |                         YYABORT;[0m
 2137 |                 efree(yyvsp[0]->lextok);[0m
 2138 |                 bcfree(yyvsp[0]);[0m
 2139 |                 yyval = (INSTRUCTION *) srcfile;[0m
 2140 |           }[0m
 2141 | #line 2142 "awkgram.c"[0m
 2142 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2135:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2135 |                 if (! load_library(yyvsp[0], & srcfile))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2136 |                         YYABORT;[0m
      | [0;1;32m                                
[0m[1mawkgram.c:2146:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2146 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2147 | #line 2148 "awkgram.c"[0m
 2148 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2152:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2152 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2153 | #line 2154 "awkgram.c"[0m
 2154 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2158:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2158 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2159 | #line 2160 "awkgram.c"[0m
 2160 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2164:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2164 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2165 | #line 2166 "awkgram.c"[0m
 2166 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2170:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2170 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2171 | #line 2172 "awkgram.c"[0m
 2172 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2176:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2176 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2177 |                 rule = Rule;[0m
 2178 |                 yyval = NULL;[0m
 2179 |           }[0m
 2180 | #line 2181 "awkgram.c"[0m
 2181 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2185:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2185 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2186 |                 rule = Rule;[0m
 2187 |           }[0m
 2188 | #line 2189 "awkgram.c"[0m
 2189 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2193:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2193 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2216:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2216 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2217 |                         yyval = list_append(list_merge(list_prepend(yyvsp[-2], yyvsp[-1]), yyvsp[0]), tp);[0m
 2218 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:2218:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2218 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2219 |                         yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), tp);[0m
      | [0;1;32m                                                                                 
[0m[1mawkgram.c:2227:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2227 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2228 |                 static int begin_seen = 0;[0m
 2229 | [0m
 2230 |                 if (do_lint_old && ++begin_seen == 2)[0m
 2231 |                         lintwarn_ln(yyvsp[0]->source_line,[0m
 2232 |                                 _("old awk does not support multiple `BEGIN' or `END' rules"));[0m
 2233 | [0m
 2234 |                 yyvsp[0]->in_rule = rule = BEGIN;[0m
 2235 |                 yyvsp[0]->source_file = source;[0m
 2236 |                 yyval = yyvsp[0];[0m
 2237 |           }[0m
 2238 | #line 2239 "awkgram.c"[0m
 2239 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2230:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2230 |                 if (do_lint_old && ++begin_seen == 2)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2231 |                         lintwarn_ln(yyvsp[0]->source_line,[0m
 2232 |                                 _("old awk does not support multiple `BEGIN' or `END' rules"));[0m
      | [0;1;32m                                                                                               
[0m[1mawkgram.c:2243:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2243 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2244 |                 static int end_seen = 0;[0m
 2245 | [0m
 2246 |                 if (do_lint_old && ++end_seen == 2)[0m
 2247 |                         lintwarn_ln(yyvsp[0]->source_line,[0m
 2248 |                                 _("old awk does not support multiple `BEGIN' or `END' rules"));[0m
 2249 | [0m
 2250 |                 yyvsp[0]->in_rule = rule = END;[0m
 2251 |                 yyvsp[0]->source_file = source;[0m
 2252 |                 yyval = yyvsp[0];[0m
 2253 |           }[0m
 2254 | #line 2255 "awkgram.c"[0m
 2255 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2246:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2246 |                 if (do_lint_old && ++end_seen == 2)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2247 |                         lintwarn_ln(yyvsp[0]->source_line,[0m
 2248 |                                 _("old awk does not support multiple `BEGIN' or `END' rules"));[0m
      | [0;1;32m                                                                                               
[0m[1mawkgram.c:2259:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2259 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2260 |                 yyvsp[0]->in_rule = rule = BEGINFILE;[0m
 2261 |                 yyvsp[0]->source_file = source;[0m
 2262 |                 yyval = yyvsp[0];[0m
 2263 |           }[0m
 2264 | #line 2265 "awkgram.c"[0m
 2265 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2269:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2269 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2270 |                 yyvsp[0]->in_rule = rule = ENDFILE;[0m
 2271 |                 yyvsp[0]->source_file = source;[0m
 2272 |                 yyval = yyvsp[0];[0m
 2273 |           }[0m
 2274 | #line 2275 "awkgram.c"[0m
 2275 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2279:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2279 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2280 |                 INSTRUCTION *ip = make_braced_statements(yyvsp[-4], yyvsp[-3], yyvsp[-2]);[0m
 2281 | [0m
 2282 |                 if (yyvsp[-2] != NULL && yyvsp[0] != NULL) {[0m
 2283 |                         merge_comments(yyvsp[-2], yyvsp[0]);[0m
 2284 |                         pending_comment = yyvsp[-2];[0m
 2285 |                 } else if (yyvsp[-2] != NULL) {[0m
 2286 |                         pending_comment = yyvsp[-2];[0m
 2287 |                 } else if (yyvsp[0] != NULL) {[0m
 2288 |                         pending_comment = yyvsp[0];[0m
 2289 |                 }[0m
 2290 | [0m
 2291 |                 yyval = ip;[0m
 2292 |           }[0m
 2293 | #line 2294 "awkgram.c"[0m
 2294 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2298:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2298 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2299 |                 const char *name = yyvsp[0]->lextok;[0m
 2300 |                 char *qname = qualify_name(name, strlen(name));[0m
 2301 | [0m
 2302 |                 if (qname != name) {[0m
 2303 |                         efree((void *)name);[0m
 2304 |                         yyvsp[0]->lextok = qname;[0m
 2305 |                 }[0m
 2306 |                 yyval = yyvsp[0];[0m
 2307 |           }[0m
 2308 | #line 2309 "awkgram.c"[0m
 2309 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2313:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2313 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2314 |                 yyerror(_("`%s' is a built-in function, it cannot be redefined"),[0m
 2315 |                                         tokstart);[0m
 2316 |                 YYABORT;[0m
 2317 |           }[0m
 2318 | #line 2319 "awkgram.c"[0m
 2319 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2323:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2323 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2324 |                 yyval = yyvsp[0];[0m
 2325 |                 at_seen--;[0m
 2326 |           }[0m
 2327 | #line 2328 "awkgram.c"[0m
 2328 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2332:38: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2332 |                                      { want_param_names = FUNC_HEADER; }[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                     {
[0m 2333 | #line 2334 "awkgram.c"[0m
 2334 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2338:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2338 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2354:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2354 |                 if (install_function(yyvsp[-5]->lextok, yyvsp[-6], yyvsp[-2]) < 0)[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 2355 |                         YYABORT;[0m
      | [0;1;32m                                
[0m[1mawkgram.c:2368:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2368 |                 { want_regexp = true; }[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 2369 | #line 2370 "awkgram.c"[0m
 2370 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2374:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2374 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mawkgram.c:2383:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2383 |                         if (len == 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2384 |                                 lintwarn_ln(yyvsp[0]->source_line,[0m
 2385 |                                         _("regexp constant `//' looks like a C++ comment, but is not"));[0m
 2386 |                         else if (re[0] == '*' && re[len-1] == '*')[0m
      | [0;32m                        } 
[0m[1mawkgram.c:2386:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2386 |                         else if (re[0] == '*' && re[len-1] == '*')[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 2387 |                                 /* possible C comment */[0m
 2388 |                                 lintwarn_ln(yyvsp[0]->source_line,[0m
 2389 |                                         _("regexp constant `/%s/' looks like a C comment, but is not"), re);[0m
      | [0;1;32m                                                                                                            
[0m[1mawkgram.c:2407:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2407 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 2408 |                   char *re;[0m
 2409 |                   size_t len;[0m
 2410 | [0m
 2411 |                   re = yyvsp[0]->lextok;[0m
 2412 |                   yyvsp[0]->lextok = NULL;[0m
 2413 |                   len = strlen(re);[0m
 2414 | [0m
 2415 |                   yyval = yyvsp[0];[0m
 2416 |                   yyval->opcode = Op_push_re;[0m
 2417 |                   yyval->memory = make_typed_regex(re, len);[0m
 2418 |                 }[0m
 2419 | #line 2420 "awkgram.c"[0m
 2420 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2424:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2424 |           { bcfree(yyvsp[0]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2425 | #line 2426 "awkgram.c"[0m
 2426 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2430:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2430 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2431 | #line 2432 "awkgram.c"[0m
 2432 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2436:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2436 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2460:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2460 |           {     yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2461 | #line 2462 "awkgram.c"[0m
 2462 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2466:25: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2466 |                         { yyval = yyvsp[0]; }[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 2467 | #line 2468 "awkgram.c"[0m
 2468 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2472:25: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2472 |                         { yyval = yyvsp[0]; }[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 2473 | #line 2474 "awkgram.c"[0m
 2474 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2478:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2478 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2479 |                 if (yyvsp[0] != NULL) {[0m
 2480 |                         INSTRUCTION *ip;[0m
 2481 | [0m
 2482 |                         merge_comments(yyvsp[0], NULL);[0m
 2483 |                         ip = list_create(instruction(Op_no_op));[0m
 2484 |                         yyval = list_append(ip, yyvsp[0]);[0m
 2485 |                 } else[0m
 2486 |                         yyval = NULL;[0m
 2487 |           }[0m
 2488 | #line 2489 "awkgram.c"[0m
 2489 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2485:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2485 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2486 |                         yyval = NULL;[0m
      | [0;1;32m                                     
[0m[1mawkgram.c:2493:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2493 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2494 |                 trailing_comment = yyvsp[0];    // NULL or comment[0m
 2495 |                 yyval = make_braced_statements(yyvsp[-2], yyvsp[-1], yyvsp[0]);[0m
 2496 |           }[0m
 2497 | #line 2498 "awkgram.c"[0m
 2498 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2502:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2502 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2503 |                 if (do_pretty_print)[0m
 2504 |                         yyval = list_prepend(yyvsp[0], instruction(Op_exec_count));[0m
 2505 |                 else[0m
 2506 |                         yyval = yyvsp[0];[0m
 2507 |           }[0m
 2508 | #line 2509 "awkgram.c"[0m
 2509 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2503:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2503 |                 if (do_pretty_print)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2504 |                         yyval = list_prepend(yyvsp[0], instruction(Op_exec_count));[0m
 2505 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:2505:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2505 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2506 |                         yyval = yyvsp[0];[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:2513:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2513 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2545:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2545 |                                                 if (strcmp(caseval, case_values[i]) == 0)[0m
      | [0;1;32m                                                                                         ^
[0m      | [0;32m                                                                                          {
[0m 2546 |                                                         error_ln(curr->source_line,[0m
 2547 |                                                                 _("duplicate case values in switch body: %s"), caseval);[0m
      | [0;1;32m                                                                                                                        
[0m[1mawkgram.c:2550:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2550 |                                         if (case_values == NULL)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 2551 |                                                 emalloc(case_values, const char **, sizeof(char *) * maxcount, "statement");[0m
 2552 |                                         else if (case_count >= maxcount) {[0m
      | [0;32m                                        } 
[0m[1mawkgram.c:2566:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2566 |                                 if (dflt->target_jmp != tbreak)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 2567 |                                         error_ln(curr->source_line,[0m
 2568 |                                                 _("duplicate `default' detected in switch body"));[0m
 2569 |                                 else[0m
      | [0;32m                                } 
[0m[1mawkgram.c:2569:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2569 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2570 |                                         dflt->target_jmp = casestmt->nexti;[0m
      | [0;1;32m                                                                           
[0m[1mawkgram.c:2576:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2576 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2577 |                                         bcfree(curr);[0m
      | [0;1;32m                                                     
[0m[1mawkgram.c:2583:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2583 |                 if (case_values != NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2584 |                         efree(case_values);[0m
      | [0;1;32m                                           
[0m[1mawkgram.c:2594:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2594 |                         } else if (yyvsp[-4] != NULL)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2595 |                                 head_comment = yyvsp[-4];[0m
 2596 |                         else[0m
      | [0;32m                        } 
[0m[1mawkgram.c:2596:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2596 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2597 |                                 head_comment = yyvsp[-3];[0m
      | [0;1;32m                                                         
[0m[1mawkgram.c:2613:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2613 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2614 |                         (void) list_append(cstmt, yyvsp[-1]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:2625:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2625 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2658:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2658 |                         if (yyvsp[0] == NULL)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2659 |                                 yyvsp[0] = list_create(instruction(Op_no_op));[0m
      | [0;1;32m                                                                              
[0m[1mawkgram.c:2665:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2665 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2666 |                         (void) list_merge(ip, yyvsp[0]);[0m
      | [0;1;32m                                                        
[0m[1mawkgram.c:2680:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2680 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2698:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2698 |                 if (yyvsp[-5] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2699 |                         ip = list_merge(yyvsp[-5], yyvsp[-2]);[0m
 2700 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:2700:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2700 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2701 |                         ip = list_prepend(yyvsp[-2], instruction(Op_no_op));[0m
      | [0;1;32m                                                                            
[0m[1mawkgram.c:2703:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2703 |                 if (yyvsp[-6] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2704 |                         (void) list_prepend(ip, yyvsp[-6]);[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:2706:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2706 |                 if (do_pretty_print)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2707 |                         (void) list_prepend(ip, instruction(Op_exec_count));[0m
      | [0;1;32m                                                                            
[0m[1mawkgram.c:2723:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2723 |                         if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2724 |                                 yyvsp[-7]->comment = yyvsp[0];[0m
      | [0;1;32m                                                              
[0m[1mawkgram.c:2734:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2734 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2762:84: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2762 |                         if (yyvsp[-3]->nexti->opcode == Op_push && yyvsp[-3]->lasti == yyvsp[-3]->nexti)[0m
      | [0;1;32m                                                                                                        ^
[0m      | [0;32m                                                                                                         {
[0m 2763 |                                 arr = yyvsp[-3]->nexti->memory;[0m
      | [0;1;32m                                                               
[0m[1mawkgram.c:2773:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2773 |                                 if (yyvsp[-7] != NULL)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 2774 |                                         bcfree(yyvsp[-7]);[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:2784:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2784 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2785 |                                 goto regular_loop;[0m
      | [0;1;32m                                                  
[0m[1mawkgram.c:2840:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2840 |                         if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 2841 |                                 merge_comments(yyvsp[-1], NULL);[0m
      | [0;1;32m                                                                
[0m[1mawkgram.c:2844:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2844 |                                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 2845 |                                         yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);[0m
      | [0;1;32m                                                                                     
[0m[1mawkgram.c:2847:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2847 |                         } else if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2848 |                                 (void) list_append(ip, yyvsp[-1]);[0m
      | [0;1;32m                                                                  
[0m[1mawkgram.c:2864:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2864 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2874:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2874 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2875 |                                 yyvsp[-11]->comment->comment = yyvsp[-4];[0m
      | [0;1;32m                                                                         
[0m[1mawkgram.c:2877:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2877 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2878 |                         yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);[0m
      | [0;1;32m                                                                     
[0m[1mawkgram.c:2890:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2890 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2900:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2900 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2901 |                                 yyvsp[-10]->comment->comment = yyvsp[-4];[0m
      | [0;1;32m                                                                         
[0m[1mawkgram.c:2903:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2903 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2904 |                         yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);[0m
      | [0;1;32m                                                                     
[0m[1mawkgram.c:2915:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2915 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2916 |                 if (do_pretty_print)[0m
 2917 |                         yyval = list_prepend(yyvsp[0], instruction(Op_exec_count));[0m
 2918 |                 else[0m
 2919 |                         yyval = yyvsp[0];[0m
 2920 |           }[0m
 2921 | #line 2922 "awkgram.c"[0m
 2922 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2916:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2916 |                 if (do_pretty_print)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2917 |                         yyval = list_prepend(yyvsp[0], instruction(Op_exec_count));[0m
 2918 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:2918:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2918 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2919 |                         yyval = yyvsp[0];[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:2926:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2926 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2927 |                 if (! break_allowed)[0m
 2928 |                         error_ln(yyvsp[-1]->source_line,[0m
 2929 |                                 _("`break' is not allowed outside a loop or switch"));[0m
 2930 |                 yyvsp[-1]->target_jmp = NULL;[0m
 2931 |                 yyval = list_create(yyvsp[-1]);[0m
 2932 |                 if (yyvsp[0] != NULL)[0m
 2933 |                         yyval = list_append(yyval, yyvsp[0]);[0m
 2934 |           }[0m
 2935 | #line 2936 "awkgram.c"[0m
 2936 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2927:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2927 |                 if (! break_allowed)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2928 |                         error_ln(yyvsp[-1]->source_line,[0m
 2929 |                                 _("`break' is not allowed outside a loop or switch"));[0m
      | [0;1;32m                                                                                      
[0m[1mawkgram.c:2932:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2932 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2933 |                         yyval = list_append(yyval, yyvsp[0]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:2940:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2940 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2941 |                 if (! continue_allowed)[0m
 2942 |                         error_ln(yyvsp[-1]->source_line,[0m
 2943 |                                 _("`continue' is not allowed outside a loop"));[0m
 2944 |                 yyvsp[-1]->target_jmp = NULL;[0m
 2945 |                 yyval = list_create(yyvsp[-1]);[0m
 2946 |                 if (yyvsp[0] != NULL)[0m
 2947 |                         yyval = list_append(yyval, yyvsp[0]);[0m
 2948 |           }[0m
 2949 | #line 2950 "awkgram.c"[0m
 2950 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2941:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2941 |                 if (! continue_allowed)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2942 |                         error_ln(yyvsp[-1]->source_line,[0m
 2943 |                                 _("`continue' is not allowed outside a loop"));[0m
      | [0;1;32m                                                                               
[0m[1mawkgram.c:2946:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2946 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2947 |                         yyval = list_append(yyval, yyvsp[0]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:2954:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2954 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2955 |                 /* if inside function (rule = 0), resolve context at run-time */[0m
 2956 |                 if (rule && rule != Rule)[0m
 2957 |                         error_ln(yyvsp[-1]->source_line,[0m
 2958 |                                 _("`next' used in %s action"), ruletab[rule]);[0m
 2959 |                 yyvsp[-1]->target_jmp = ip_rec;[0m
 2960 |                 yyval = list_create(yyvsp[-1]);[0m
 2961 |                 if (yyvsp[0] != NULL)[0m
 2962 |                         yyval = list_append(yyval, yyvsp[0]);[0m
 2963 |           }[0m
 2964 | #line 2965 "awkgram.c"[0m
 2965 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2956:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2956 |                 if (rule && rule != Rule)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2957 |                         error_ln(yyvsp[-1]->source_line,[0m
 2958 |                                 _("`next' used in %s action"), ruletab[rule]);[0m
      | [0;1;32m                                                                              
[0m[1mawkgram.c:2961:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2961 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2962 |                         yyval = list_append(yyval, yyvsp[0]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:2969:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2969 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2970 |                 /* if inside function (rule = 0), resolve context at run-time */[0m
 2971 |                 if (rule == BEGIN || rule == END || rule == ENDFILE)[0m
 2972 |                         error_ln(yyvsp[-1]->source_line,[0m
 2973 |                                 _("`nextfile' used in %s action"), ruletab[rule]);[0m
 2974 | [0m
 2975 |                 yyvsp[-1]->target_newfile = ip_newfile;[0m
 2976 |                 yyvsp[-1]->target_endfile = ip_endfile;[0m
 2977 |                 yyval = list_create(yyvsp[-1]);[0m
 2978 |                 if (yyvsp[0] != NULL)[0m
 2979 |                         yyval = list_append(yyval, yyvsp[0]);[0m
 2980 |           }[0m
 2981 | #line 2982 "awkgram.c"[0m
 2982 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:2971:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2971 |                 if (rule == BEGIN || rule == END || rule == ENDFILE)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 2972 |                         error_ln(yyvsp[-1]->source_line,[0m
 2973 |                                 _("`nextfile' used in %s action"), ruletab[rule]);[0m
      | [0;1;32m                                                                                  
[0m[1mawkgram.c:2978:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2978 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2979 |                         yyval = list_append(yyval, yyvsp[0]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:2986:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2986 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:2997:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2997 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2998 |                         yyval = list_append(yyvsp[-1], yyvsp[-2]);[0m
      | [0;1;32m                                                                  
[0m[1mawkgram.c:2999:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2999 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3000 |                         yyval = list_append(yyval, yyvsp[0]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:3007:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3007 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3008 |                 if (! in_function)[0m
 3009 |                         yyerror(_("`return' used outside function context"));[0m
 3010 |           }[0m
 3011 | #line 3012 "awkgram.c"[0m
 3012 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3008:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3008 |                 if (! in_function)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3009 |                         yyerror(_("`return' used outside function context"));[0m
      | [0;1;32m                                                                             
[0m[1mawkgram.c:3016:42: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3016 |                                          {[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                         {
[0m 3017 |                 if (called_from_eval)[0m
 3018 |                         yyvsp[-3]->opcode = Op_K_return_from_eval;[0m
 3019 | [0m
 3020 |                 if (yyvsp[-1] == NULL) {[0m
 3021 |                         yyval = list_create(yyvsp[-3]);[0m
 3022 |                         (void) list_prepend(yyval, instruction(Op_push_i));[0m
 3023 |                         yyval->nexti->memory = dupnode(Nnull_string);[0m
 3024 |                 } else[0m
 3025 |                         yyval = list_append(yyvsp[-1], yyvsp[-3]);[0m
 3026 |                 if (yyvsp[0] != NULL)[0m
 3027 |                         yyval = list_append(yyval, yyvsp[0]);[0m
 3028 |           }[0m
 3029 | #line 3030 "awkgram.c"[0m
 3030 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3017:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3017 |                 if (called_from_eval)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3018 |                         yyvsp[-3]->opcode = Op_K_return_from_eval;[0m
      | [0;1;32m                                                                  
[0m[1mawkgram.c:3024:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3024 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3025 |                         yyval = list_append(yyvsp[-1], yyvsp[-3]);[0m
      | [0;1;32m                                                                  
[0m[1mawkgram.c:3026:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3026 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3027 |                         yyval = list_append(yyval, yyvsp[0]);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:3034:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3034 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3035 |                 if (yyvsp[0] != NULL)[0m
 3036 |                         yyval = list_append(yyvsp[-1], yyvsp[0]);[0m
 3037 |                 else[0m
 3038 |                         yyval = yyvsp[-1];[0m
 3039 |           }[0m
 3040 | #line 3041 "awkgram.c"[0m
 3041 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3035:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3035 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3036 |                         yyval = list_append(yyvsp[-1], yyvsp[0]);[0m
 3037 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:3037:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3037 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3038 |                         yyval = yyvsp[-1];[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:3045:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3045 |                 { in_print = true; in_parens = 0; }[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3046 | #line 3047 "awkgram.c"[0m
 3047 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3051:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3051 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3079:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3079 |                                 if ((n->flags & (STRING|STRCUR)) != 0 || ! is_zero(n))[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m 3080 |                                         goto regular_print;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:3122:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3122 |                                         if (yyvsp[-3]->opcode == Op_K_print)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 3123 |                                                 yyvsp[-3]->opcode = Op_K_print_rec;[0m
      | [0;1;32m                                                                                   
[0m[1mawkgram.c:3140:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3140 |                                         if (yyvsp[-3]->opcode == Op_K_print)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 3141 |                                                 yyvsp[-3]->opcode = Op_K_print_rec;[0m
      | [0;1;32m                                                                                   
[0m[1mawkgram.c:3156:27: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3156 |                           { sub_counter = 0; }[0m
      | [0;1;32m                          ^
[0m      | [0;32m                          {
[0m 3157 | #line 3158 "awkgram.c"[0m
 3158 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3162:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3162 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3169:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3169 |                         if (yyvsp[-2]->memory == symbol_table)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 3170 |                                 fatal(_("`delete' is not allowed with SYMTAB"));[0m
 3171 |                         else if (yyvsp[-2]->memory == func_table)[0m
      | [0;32m                        } 
[0m[1mawkgram.c:3171:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3171 |                         else if (yyvsp[-2]->memory == func_table)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 3172 |                                 fatal(_("`delete' is not allowed with FUNCTAB"));[0m
      | [0;1;32m                                                                                 
[0m[1mawkgram.c:3199:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3199 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3218:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3218 |                         if (yyvsp[-1]->memory == symbol_table)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 3219 |                                 fatal(_("`delete' is not allowed with SYMTAB"));[0m
 3220 |                         else if (yyvsp[-1]->memory == func_table)[0m
      | [0;32m                        } 
[0m[1mawkgram.c:3220:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3220 |                         else if (yyvsp[-1]->memory == func_table)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 3221 |                                 fatal(_("`delete' is not allowed with FUNCTAB"));[0m
      | [0;1;32m                                                                                 
[0m[1mawkgram.c:3229:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3229 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3230 |                 yyval = optimize_assignment(yyvsp[0]);[0m
 3231 |           }[0m
 3232 | #line 3233 "awkgram.c"[0m
 3233 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3237:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3237 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3238 | #line 3239 "awkgram.c"[0m
 3239 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3243:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3243 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3244 | #line 3245 "awkgram.c"[0m
 3245 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3249:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3249 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3250 | #line 3251 "awkgram.c"[0m
 3251 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3255:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3255 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3256 |                 if (yyvsp[-1] == NULL)[0m
 3257 |                         yyval = list_create(yyvsp[0]);[0m
 3258 |                 else[0m
 3259 |                         yyval = list_prepend(yyvsp[-1], yyvsp[0]);[0m
 3260 |           }[0m
 3261 | #line 3262 "awkgram.c"[0m
 3262 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3256:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3256 |                 if (yyvsp[-1] == NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3257 |                         yyval = list_create(yyvsp[0]);[0m
 3258 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:3258:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3258 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3259 |                         yyval = list_prepend(yyvsp[-1], yyvsp[0]);[0m
      | [0;1;32m                                                                  
[0m[1mawkgram.c:3266:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3266 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3267 | #line 3268 "awkgram.c"[0m
 3268 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3272:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3272 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3273 |                 INSTRUCTION *casestmt = yyvsp[0];[0m
 3274 |                 if (yyvsp[0] == NULL)[0m
 3275 |                         casestmt = list_create(instruction(Op_no_op));[0m
 3276 |                 if (do_pretty_print)[0m
 3277 |                         (void) list_prepend(casestmt, instruction(Op_exec_count));[0m
 3278 |                 yyvsp[-4]->case_exp = yyvsp[-3];[0m
 3279 |                 yyvsp[-4]->case_stmt = casestmt;[0m
 3280 |                 yyvsp[-4]->comment = yyvsp[-1];[0m
 3281 |                 bcfree(yyvsp[-2]);[0m
 3282 |                 yyval = yyvsp[-4];[0m
 3283 |           }[0m
 3284 | #line 3285 "awkgram.c"[0m
 3285 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3274:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3274 |                 if (yyvsp[0] == NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3275 |                         casestmt = list_create(instruction(Op_no_op));[0m
      | [0;1;32m                                                                      
[0m[1mawkgram.c:3276:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3276 |                 if (do_pretty_print)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3277 |                         (void) list_prepend(casestmt, instruction(Op_exec_count));[0m
      | [0;1;32m                                                                                  
[0m[1mawkgram.c:3289:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3289 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3290 |                 INSTRUCTION *casestmt = yyvsp[0];[0m
 3291 |                 if (yyvsp[0] == NULL)[0m
 3292 |                         casestmt = list_create(instruction(Op_no_op));[0m
 3293 |                 if (do_pretty_print)[0m
 3294 |                         (void) list_prepend(casestmt, instruction(Op_exec_count));[0m
 3295 |                 bcfree(yyvsp[-2]);[0m
 3296 |                 yyvsp[-3]->case_stmt = casestmt;[0m
 3297 |                 yyvsp[-3]->comment = yyvsp[-1];[0m
 3298 |                 yyval = yyvsp[-3];[0m
 3299 |           }[0m
 3300 | #line 3301 "awkgram.c"[0m
 3301 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3291:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3291 |                 if (yyvsp[0] == NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3292 |                         casestmt = list_create(instruction(Op_no_op));[0m
      | [0;1;32m                                                                      
[0m[1mawkgram.c:3293:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3293 |                 if (do_pretty_print)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3294 |                         (void) list_prepend(casestmt, instruction(Op_exec_count));[0m
      | [0;1;32m                                                                                  
[0m[1mawkgram.c:3305:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3305 |           {     yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3306 | #line 3307 "awkgram.c"[0m
 3307 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3311:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3311 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3312 |                 NODE *n = yyvsp[0]->memory;[0m
 3313 |                 (void) force_number(n);[0m
 3314 |                 negate_num(n);[0m
 3315 |                 bcfree(yyvsp[-1]);[0m
 3316 |                 yyval = yyvsp[0];[0m
 3317 |           }[0m
 3318 | #line 3319 "awkgram.c"[0m
 3319 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3323:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3323 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3324 |                 NODE *n = yyvsp[0]->lasti->memory;[0m
 3325 |                 bcfree(yyvsp[-1]);[0m
 3326 |                 add_sign_to_num(n, '+');[0m
 3327 |                 yyval = yyvsp[0];[0m
 3328 |           }[0m
 3329 | #line 3330 "awkgram.c"[0m
 3330 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3334:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3334 |           {     yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3335 | #line 3336 "awkgram.c"[0m
 3336 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3340:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3340 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3341 |                 if (yyvsp[0]->memory->type == Node_regex)[0m
 3342 |                         yyvsp[0]->opcode = Op_push_re;[0m
 3343 |                 else[0m
 3344 |                         yyvsp[0]->opcode = Op_push;[0m
 3345 |                 yyval = yyvsp[0];[0m
 3346 |           }[0m
 3347 | #line 3348 "awkgram.c"[0m
 3348 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3341:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3341 |                 if (yyvsp[0]->memory->type == Node_regex)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3342 |                         yyvsp[0]->opcode = Op_push_re;[0m
 3343 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:3343:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3343 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3344 |                         yyvsp[0]->opcode = Op_push;[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:3352:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3352 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3353 |                 assert((yyvsp[0]->memory->flags & REGEX) == REGEX);[0m
 3354 |                 yyvsp[0]->opcode = Op_push_re;[0m
 3355 |                 yyval = yyvsp[0];[0m
 3356 |           }[0m
 3357 | #line 3358 "awkgram.c"[0m
 3358 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3362:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3362 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3363 | #line 3364 "awkgram.c"[0m
 3364 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3368:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3368 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3369 | #line 3370 "awkgram.c"[0m
 3370 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3374:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3374 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3375 |                 yyval = yyvsp[-1];[0m
 3376 |           }[0m
 3377 | #line 3378 "awkgram.c"[0m
 3378 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3382:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3382 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3383 |                 in_print = false;[0m
 3384 |                 in_parens = 0;[0m
 3385 |                 yyval = NULL;[0m
 3386 |           }[0m
 3387 | #line 3388 "awkgram.c"[0m
 3388 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3392:18: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3392 |                  { in_print = false; in_parens = 0; }[0m
      | [0;1;32m                 ^
[0m      | [0;32m                 {
[0m 3393 | #line 3394 "awkgram.c"[0m
 3394 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3398:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3398 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3399 |                 if (yyvsp[-2]->redir_type == redirect_twoway[0m
 3400 |                         && yyvsp[0]->lasti->opcode == Op_K_getline_redir[0m
 3401 |                                 && yyvsp[0]->lasti->redir_type == redirect_twoway)[0m
 3402 |                         yyerror(_("multistage two-way pipelines don't work"));[0m
 3403 |                 if (do_lint && yyvsp[-2]->redir_type == redirect_output && yyvsp[0]->lasti->opcode == Op_concat)[0m
 3404 |                         lintwarn(_("concatenation as I/O `>' redirection target is ambiguous"));[0m
 3405 |                 yyval = list_prepend(yyvsp[0], yyvsp[-2]);[0m
 3406 |           }[0m
 3407 | #line 3408 "awkgram.c"[0m
 3408 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3401:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3401 |                                 && yyvsp[0]->lasti->redir_type == redirect_twoway)[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 3402 |                         yyerror(_("multistage two-way pipelines don't work"));[0m
      | [0;1;32m                                                                              
[0m[1mawkgram.c:3403:99: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3403 |                 if (do_lint && yyvsp[-2]->redir_type == redirect_output && yyvsp[0]->lasti->opcode == Op_concat)[0m
      | [0;1;32m                                                                                                                ^
[0m      | [0;32m                                                                                                                 {
[0m 3404 |                         lintwarn(_("concatenation as I/O `>' redirection target is ambiguous"));[0m
      | [0;1;32m                                                                                                
[0m[1mawkgram.c:3412:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3412 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3413 |                 if (yyvsp[-1] != NULL)[0m
 3414 |                         yyvsp[-5]->comment = yyvsp[-1];[0m
 3415 |                 add_lint(yyvsp[-3], LINT_assign_in_cond);[0m
 3416 |                 yyval = mk_condition(yyvsp[-3], yyvsp[-5], yyvsp[0], NULL, NULL);[0m
 3417 |           }[0m
 3418 | #line 3419 "awkgram.c"[0m
 3419 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3413:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3413 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3414 |                         yyvsp[-5]->comment = yyvsp[-1];[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:3423:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3423 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3424 |                 if (yyvsp[-4] != NULL)[0m
 3425 |                         yyvsp[-8]->comment = yyvsp[-4];[0m
 3426 |                 if (yyvsp[-1] != NULL)[0m
 3427 |                         yyvsp[-2]->comment = yyvsp[-1];[0m
 3428 |                 add_lint(yyvsp[-6], LINT_assign_in_cond);[0m
 3429 |                 yyval = mk_condition(yyvsp[-6], yyvsp[-8], yyvsp[-3], yyvsp[-2], yyvsp[0]);[0m
 3430 |           }[0m
 3431 | #line 3432 "awkgram.c"[0m
 3432 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3424:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3424 |                 if (yyvsp[-4] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3425 |                         yyvsp[-8]->comment = yyvsp[-4];[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:3426:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3426 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3427 |                         yyvsp[-2]->comment = yyvsp[-1];[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:3436:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3436 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3437 |                 yyval = yyvsp[0];[0m
 3438 |           }[0m
 3439 | #line 3440 "awkgram.c"[0m
 3440 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3444:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3444 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3458:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3458 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3459 |                         yyval = NULL;[0m
      | [0;1;32m                                     
[0m[1mawkgram.c:3466:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3466 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3467 | #line 3468 "awkgram.c"[0m
 3468 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3472:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3472 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3473 | #line 3474 "awkgram.c"[0m
 3474 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3478:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3478 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3479 | #line 3480 "awkgram.c"[0m
 3480 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3484:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3484 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3485 |                 bcfree(yyvsp[-1]);[0m
 3486 |                 yyval = yyvsp[0];[0m
 3487 |           }[0m
 3488 | #line 3489 "awkgram.c"[0m
 3489 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3493:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3493 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3494 | #line 3495 "awkgram.c"[0m
 3495 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3499:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3499 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3500 | #line 3501 "awkgram.c"[0m
 3501 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3505:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3505 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3506 |                 yyvsp[0]->param_count = 0;[0m
 3507 |                 yyval = list_create(yyvsp[0]);[0m
 3508 |           }[0m
 3509 | #line 3510 "awkgram.c"[0m
 3510 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3514:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3514 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3522:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3522 |                                 if (yyvsp[-2]->comment != NULL)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3523 |                                         merge_comments(yyvsp[-2]->comment, yyvsp[-1]);[0m
 3524 |                                 else[0m
      | [0;32m                                } 
[0m[1mawkgram.c:3524:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3524 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3525 |                                         yyvsp[-2]->comment = yyvsp[-1];[0m
      | [0;1;32m                                                                       
[0m[1mawkgram.c:3527:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3527 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3528 |                         yyval = NULL;[0m
      | [0;1;32m                                     
[0m[1mawkgram.c:3535:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3535 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3536 | #line 3537 "awkgram.c"[0m
 3537 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3541:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3541 |           { yyval = yyvsp[-1]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3542 | #line 3543 "awkgram.c"[0m
 3543 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3547:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3547 |           { yyval = yyvsp[-2]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3548 | #line 3549 "awkgram.c"[0m
 3549 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3553:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3553 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3554 | #line 3555 "awkgram.c"[0m
 3555 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3559:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3559 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3560 | #line 3561 "awkgram.c"[0m
 3561 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3565:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3565 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3566 | #line 3567 "awkgram.c"[0m
 3567 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3571:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3571 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3572 | #line 3573 "awkgram.c"[0m
 3573 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3577:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3577 |           {     yyval = mk_expression_list(NULL, yyvsp[0]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3578 | #line 3579 "awkgram.c"[0m
 3579 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3583:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3583 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3584 |                 if (yyvsp[-1] != NULL)[0m
 3585 |                         yyvsp[-2]->lasti->comment = yyvsp[-1];[0m
 3586 |                 yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);[0m
 3587 |                 yyerrok;[0m
 3588 |           }[0m
 3589 | #line 3590 "awkgram.c"[0m
 3590 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3584:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3584 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3585 |                         yyvsp[-2]->lasti->comment = yyvsp[-1];[0m
      | [0;1;32m                                                              
[0m[1mawkgram.c:3594:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3594 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3595 | #line 3596 "awkgram.c"[0m
 3596 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3600:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3600 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3601 |                 /*[0m
 3602 |                  * Returning the expression list instead of NULL lets[0m
 3603 |                  * snode get a list of arguments that it can count.[0m
 3604 |                  */[0m
 3605 |                 yyval = yyvsp[-1];[0m
 3606 |           }[0m
 3607 | #line 3608 "awkgram.c"[0m
 3608 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3612:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3612 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3613 |                 /* Ditto */[0m
 3614 |                 yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);[0m
 3615 |           }[0m
 3616 | #line 3617 "awkgram.c"[0m
 3617 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3621:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3621 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3622 |                 /* Ditto */[0m
 3623 |                 if (yyvsp[-1] != NULL)[0m
 3624 |                         yyvsp[-2]->lasti->comment = yyvsp[-1];[0m
 3625 |                 yyval = yyvsp[-2];[0m
 3626 |           }[0m
 3627 | #line 3628 "awkgram.c"[0m
 3628 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3623:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3623 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3624 |                         yyvsp[-2]->lasti->comment = yyvsp[-1];[0m
      | [0;1;32m                                                              
[0m[1mawkgram.c:3632:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3632 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3633 | #line 3634 "awkgram.c"[0m
 3634 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3638:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3638 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3639 | #line 3640 "awkgram.c"[0m
 3640 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3644:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3644 |           {     yyval = mk_expression_list(NULL, yyvsp[0]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3645 | #line 3646 "awkgram.c"[0m
 3646 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3650:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3650 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3651 |                 if (yyvsp[-1] != NULL)[0m
 3652 |                         yyvsp[-2]->lasti->comment = yyvsp[-1];[0m
 3653 |                 yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);[0m
 3654 |                 yyerrok;[0m
 3655 |           }[0m
 3656 | #line 3657 "awkgram.c"[0m
 3657 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3651:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3651 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3652 |                         yyvsp[-2]->lasti->comment = yyvsp[-1];[0m
      | [0;1;32m                                                              
[0m[1mawkgram.c:3661:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3661 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3662 | #line 3663 "awkgram.c"[0m
 3663 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3667:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3667 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3668 |                 /*[0m
 3669 |                  * Returning the expression list instead of NULL lets[0m
 3670 |                  * snode get a list of arguments that it can count.[0m
 3671 |                  */[0m
 3672 |                 yyval = yyvsp[-1];[0m
 3673 |           }[0m
 3674 | #line 3675 "awkgram.c"[0m
 3675 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3679:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3679 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3680 |                 /* Ditto */[0m
 3681 |                 yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);[0m
 3682 |           }[0m
 3683 | #line 3684 "awkgram.c"[0m
 3684 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3688:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3688 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3689 |                 /* Ditto */[0m
 3690 |                 if (yyvsp[-1] != NULL)[0m
 3691 |                         yyvsp[-2]->comment = yyvsp[-1];[0m
 3692 |                 yyval = yyvsp[-2];[0m
 3693 |           }[0m
 3694 | #line 3695 "awkgram.c"[0m
 3695 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3690:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3690 |                 if (yyvsp[-1] != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3691 |                         yyvsp[-2]->comment = yyvsp[-1];[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:3699:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3699 |               { yyval = yyvsp[0]; }[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 3700 | #line 3701 "awkgram.c"[0m
 3701 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3705:24: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3705 |                        { yyval = list_create(yyvsp[0]); }[0m
      | [0;1;32m                       ^
[0m      | [0;32m                       {
[0m 3706 | #line 3707 "awkgram.c"[0m
 3707 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3711:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3711 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3712 | #line 3713 "awkgram.c"[0m
 3713 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3717:21: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3717 |                     { yyval = yyvsp[0]; }[0m
      | [0;1;32m                    ^
[0m      | [0;32m                    {
[0m 3718 | #line 3719 "awkgram.c"[0m
 3719 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3723:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3723 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3724 |                 if (do_lint && yyvsp[0]->lasti->opcode == Op_match_rec)[0m
 3725 |                         lintwarn_ln(yyvsp[-1]->source_line,[0m
 3726 |                                 _("regular expression on right of assignment"));[0m
 3727 |                 yyval = mk_assignment(yyvsp[-2], yyvsp[0], yyvsp[-1]);[0m
 3728 |           }[0m
 3729 | #line 3730 "awkgram.c"[0m
 3730 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3724:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3724 |                 if (do_lint && yyvsp[0]->lasti->opcode == Op_match_rec)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 3725 |                         lintwarn_ln(yyvsp[-1]->source_line,[0m
 3726 |                                 _("regular expression on right of assignment"));[0m
      | [0;1;32m                                                                                
[0m[1mawkgram.c:3734:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3734 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3735 |                 yyval = mk_assignment(yyvsp[-2], list_create(yyvsp[0]), yyvsp[-1]);[0m
 3736 |           }[0m
 3737 | #line 3738 "awkgram.c"[0m
 3738 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3742:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3742 |           {     yyval = mk_boolean(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3743 | #line 3744 "awkgram.c"[0m
 3744 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3748:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3748 |           {     yyval = mk_boolean(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3749 | #line 3750 "awkgram.c"[0m
 3750 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3754:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3754 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3755 |                 if (yyvsp[-2]->lasti->opcode == Op_match_rec)[0m
 3756 |                         warning_ln(yyvsp[-1]->source_line,[0m
 3757 |                                 _("regular expression on left of `~' or `!~' operator"));[0m
 3758 | [0m
 3759 |                 assert(yyvsp[0]->opcode == Op_push_re[0m
 3760 |                         && (yyvsp[0]->memory->flags & REGEX) != 0);[0m
 3761 |                 /* RHS is @/.../ */[0m
 3762 |                 yyvsp[-1]->memory = yyvsp[0]->memory;[0m
 3763 |                 bcfree(yyvsp[0]);[0m
 3764 |                 yyval = list_append(yyvsp[-2], yyvsp[-1]);[0m
 3765 |           }[0m
 3766 | #line 3767 "awkgram.c"[0m
 3767 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3755:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3755 |                 if (yyvsp[-2]->lasti->opcode == Op_match_rec)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3756 |                         warning_ln(yyvsp[-1]->source_line,[0m
 3757 |                                 _("regular expression on left of `~' or `!~' operator"));[0m
      | [0;1;32m                                                                                         
[0m[1mawkgram.c:3771:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3771 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3772:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3772 |                 if (yyvsp[-2]->lasti->opcode == Op_match_rec)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3773 |                         warning_ln(yyvsp[-1]->source_line,[0m
 3774 |                                 _("regular expression on left of `~' or `!~' operator"));[0m
      | [0;1;32m                                                                                         
[0m[1mawkgram.c:3792:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3792 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3793 |                 if (do_lint_old)[0m
 3794 |                         lintwarn_ln(yyvsp[-1]->source_line,[0m
 3795 |                                 _("old awk does not support the keyword `in' except after `for'"));[0m
 3796 |                 yyvsp[0]->nexti->opcode = Op_push_array;[0m
 3797 |                 yyvsp[-1]->opcode = Op_in_array;[0m
 3798 |                 yyvsp[-1]->expr_count = 1;[0m
 3799 |                 yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), yyvsp[-1]);[0m
 3800 |           }[0m
 3801 | #line 3802 "awkgram.c"[0m
 3802 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3793:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3793 |                 if (do_lint_old)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3794 |                         lintwarn_ln(yyvsp[-1]->source_line,[0m
 3795 |                                 _("old awk does not support the keyword `in' except after `for'"));[0m
      | [0;1;32m                                                                                                   
[0m[1mawkgram.c:3806:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3806 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3807 |                 if (do_lint && yyvsp[0]->lasti->opcode == Op_match_rec)[0m
 3808 |                         lintwarn_ln(yyvsp[-1]->source_line,[0m
 3809 |                                 _("regular expression on right of comparison"));[0m
 3810 |                 yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), yyvsp[-1]);[0m
 3811 |           }[0m
 3812 | #line 3813 "awkgram.c"[0m
 3813 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3807:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3807 |                 if (do_lint && yyvsp[0]->lasti->opcode == Op_match_rec)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 3808 |                         lintwarn_ln(yyvsp[-1]->source_line,[0m
 3809 |                                 _("regular expression on right of comparison"));[0m
      | [0;1;32m                                                                                
[0m[1mawkgram.c:3817:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3817 |           { yyval = mk_condition(yyvsp[-4], yyvsp[-3], yyvsp[-2], yyvsp[-1], yyvsp[0]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3818 | #line 3819 "awkgram.c"[0m
 3819 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3823:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3823 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3824 | #line 3825 "awkgram.c"[0m
 3825 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3829:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3829 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3830 | #line 3831 "awkgram.c"[0m
 3831 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3835:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3835 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3836 | #line 3837 "awkgram.c"[0m
 3837 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3841:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3841 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3842 |                 yyvsp[0]->opcode = Op_assign_quotient;[0m
 3843 |                 yyval = yyvsp[0];[0m
 3844 |           }[0m
 3845 | #line 3846 "awkgram.c"[0m
 3846 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3850:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3850 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3851 | #line 3852 "awkgram.c"[0m
 3852 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3856:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3856 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3857 | #line 3858 "awkgram.c"[0m
 3858 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3862:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3862 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3863 | #line 3864 "awkgram.c"[0m
 3864 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3868:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3868 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3869 | #line 3870 "awkgram.c"[0m
 3870 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3874:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3874 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3875 | #line 3876 "awkgram.c"[0m
 3876 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3880:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3880 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3881 | #line 3882 "awkgram.c"[0m
 3882 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3886:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3886 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:3914:97: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3914 |                         if ((n1->flags & (NUMBER|NUMINT|INTLSTR)) != 0 || (n2->flags & (NUMBER|NUMINT|INTLSTR)) != 0)[0m
      | [0;1;32m                                                                                                                     ^
[0m      | [0;32m                                                                                                                      {
[0m 3915 |                                 goto plain_concat;[0m
      | [0;1;32m                                                  
[0m[1mawkgram.c:3935:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3935 |                         if (count > max_args)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3936 |                                 max_args = count;[0m
      | [0;1;32m                                                 
[0m[1mawkgram.c:3944:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3944 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3945 | #line 3946 "awkgram.c"[0m
 3946 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3950:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3950 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3951 | #line 3952 "awkgram.c"[0m
 3952 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3956:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3956 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3957 | #line 3958 "awkgram.c"[0m
 3958 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3962:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3962 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3963 | #line 3964 "awkgram.c"[0m
 3964 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3968:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3968 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3969 | #line 3970 "awkgram.c"[0m
 3970 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3974:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3974 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3975 | #line 3976 "awkgram.c"[0m
 3976 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3980:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3980 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3981 |                 /*[0m
 3982 |                  * In BEGINFILE/ENDFILE, allow `getline [var] < file'[0m
 3983 |                  */[0m
 3984 | [0m
 3985 |                 if ((rule == BEGINFILE || rule == ENDFILE) && yyvsp[0] == NULL)[0m
 3986 |                         error_ln(yyvsp[-2]->source_line,[0m
 3987 |                                  _("non-redirected `getline' invalid inside `%s' rule"), ruletab[rule]);[0m
 3988 |                 if (do_lint && rule == END && yyvsp[0] == NULL)[0m
 3989 |                         lintwarn_ln(yyvsp[-2]->source_line,[0m
 3990 |                                 _("non-redirected `getline' undefined inside END action"));[0m
 3991 |                 yyval = mk_getline(yyvsp[-2], yyvsp[-1], yyvsp[0], redirect_input);[0m
 3992 |           }[0m
 3993 | #line 3994 "awkgram.c"[0m
 3994 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:3985:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3985 |                 if ((rule == BEGINFILE || rule == ENDFILE) && yyvsp[0] == NULL)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 3986 |                         error_ln(yyvsp[-2]->source_line,[0m
 3987 |                                  _("non-redirected `getline' invalid inside `%s' rule"), ruletab[rule]);[0m
      | [0;1;32m                                                                                                        
[0m[1mawkgram.c:3988:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3988 |                 if (do_lint && rule == END && yyvsp[0] == NULL)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3989 |                         lintwarn_ln(yyvsp[-2]->source_line,[0m
 3990 |                                 _("non-redirected `getline' undefined inside END action"));[0m
      | [0;1;32m                                                                                           
[0m[1mawkgram.c:3998:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3998 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3999 |                 yyvsp[0]->opcode = Op_postincrement;[0m
 4000 |                 yyval = mk_assignment(yyvsp[-1], NULL, yyvsp[0]);[0m
 4001 |           }[0m
 4002 | #line 4003 "awkgram.c"[0m
 4003 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4007:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4007 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4008 |                 yyvsp[0]->opcode = Op_postdecrement;[0m
 4009 |                 yyval = mk_assignment(yyvsp[-1], NULL, yyvsp[0]);[0m
 4010 |           }[0m
 4011 | #line 4012 "awkgram.c"[0m
 4012 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4016:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4016 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:4041:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4041 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4042 |                   yyval = mk_getline(yyvsp[-1], yyvsp[0], yyvsp[-3], yyvsp[-2]->redir_type);[0m
 4043 |                   bcfree(yyvsp[-2]);[0m
 4044 |                 }[0m
 4045 | #line 4046 "awkgram.c"[0m
 4046 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4050:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4050 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4051 | #line 4052 "awkgram.c"[0m
 4052 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4056:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4056 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4057 | #line 4058 "awkgram.c"[0m
 4058 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4062:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4062 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4063 | #line 4064 "awkgram.c"[0m
 4064 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4068:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4068 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4069 | #line 4070 "awkgram.c"[0m
 4070 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4074:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4074 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4075 | #line 4076 "awkgram.c"[0m
 4076 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4080:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4080 |           { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4081 | #line 4082 "awkgram.c"[0m
 4082 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4086:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4086 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4087 |                 yyval = list_create(yyvsp[0]);[0m
 4088 |           }[0m
 4089 | #line 4090 "awkgram.c"[0m
 4090 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4094:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4094 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:4114:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4114 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 4115 |                                         n->numbr = (AWKNUM) (n->numbr == 0.0);[0m
      | [0;1;32m                                                                              
[0m[1mawkgram.c:4130:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4130 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4131 |                 // Always include. Allows us to lint warn on[0m
 4132 |                 // print "foo" > "bar" 1[0m
 4133 |                 // but not warn on[0m
 4134 |                 // print "foo" > ("bar" 1)[0m
 4135 |                 yyval = list_append(yyvsp[-1], bcalloc(Op_parens, 1, sourceline));[0m
 4136 |           }[0m
 4137 | #line 4138 "awkgram.c"[0m
 4138 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4142:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4142 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4143 |                 yyval = snode(yyvsp[-1], yyvsp[-3]);[0m
 4144 |                 if (yyval == NULL)[0m
 4145 |                         YYABORT;[0m
 4146 |           }[0m
 4147 | #line 4148 "awkgram.c"[0m
 4148 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4144:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4144 |                 if (yyval == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 4145 |                         YYABORT;[0m
      | [0;1;32m                                
[0m[1mawkgram.c:4152:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4152 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4153 |                 yyval = snode(yyvsp[-1], yyvsp[-3]);[0m
 4154 |                 if (yyval == NULL)[0m
 4155 |                         YYABORT;[0m
 4156 |           }[0m
 4157 | #line 4158 "awkgram.c"[0m
 4158 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4154:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4154 |                 if (yyval == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 4155 |                         YYABORT;[0m
      | [0;1;32m                                
[0m[1mawkgram.c:4162:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4162 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4163 |                 static bool warned = false;[0m
 4164 | [0m
 4165 |                 if (do_lint && ! warned) {[0m
 4166 |                         warned = true;[0m
 4167 |                         lintwarn_ln(yyvsp[0]->source_line,[0m
 4168 |                                 _("call of `length' without parentheses is not portable"));[0m
 4169 |                 }[0m
 4170 |                 yyval = snode(NULL, yyvsp[0]);[0m
 4171 |                 if (yyval == NULL)[0m
 4172 |                         YYABORT;[0m
 4173 |           }[0m
 4174 | #line 4175 "awkgram.c"[0m
 4175 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4171:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4171 |                 if (yyval == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 4172 |                         YYABORT;[0m
      | [0;1;32m                                
[0m[1mawkgram.c:4179:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4179 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4180 |                 yyvsp[-1]->opcode = Op_preincrement;[0m
 4181 |                 yyval = mk_assignment(yyvsp[0], NULL, yyvsp[-1]);[0m
 4182 |           }[0m
 4183 | #line 4184 "awkgram.c"[0m
 4184 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4188:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4188 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4189 |                 yyvsp[-1]->opcode = Op_predecrement;[0m
 4190 |                 yyval = mk_assignment(yyvsp[0], NULL, yyvsp[-1]);[0m
 4191 |           }[0m
 4192 | #line 4193 "awkgram.c"[0m
 4193 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4197:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4197 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4198 |                 yyval = list_create(yyvsp[0]);[0m
 4199 |           }[0m
 4200 | #line 4201 "awkgram.c"[0m
 4201 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4205:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4205 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4206 |                 yyval = list_create(yyvsp[0]);[0m
 4207 |           }[0m
 4208 | #line 4209 "awkgram.c"[0m
 4209 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4213:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4213 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4214 |                 if (yyvsp[0]->lasti->opcode == Op_push_i[0m
 4215 |                         && (yyvsp[0]->lasti->memory->flags & STRING) == 0[0m
 4216 |                 ) {[0m
 4217 |                         NODE *n = yyvsp[0]->lasti->memory;[0m
 4218 |                         (void) force_number(n);[0m
 4219 |                         negate_num(n);[0m
 4220 |                         yyval = yyvsp[0];[0m
 4221 |                         bcfree(yyvsp[-1]);[0m
 4222 |                 } else {[0m
 4223 |                         yyvsp[-1]->opcode = Op_unary_minus;[0m
 4224 |                         yyval = list_append(yyvsp[0], yyvsp[-1]);[0m
 4225 |                 }[0m
 4226 |           }[0m
 4227 | #line 4228 "awkgram.c"[0m
 4228 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4232:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4232 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:4254:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4254 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4255 |                 func_use(yyvsp[0]->lasti->func_name, FUNC_USE);[0m
 4256 |                 yyval = yyvsp[0];[0m
 4257 |           }[0m
 4258 | #line 4259 "awkgram.c"[0m
 4259 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4263:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4263 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:4271:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4271 |                 if (do_traditional || do_posix)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 4272 |                         yyerror("%s", msg);[0m
 4273 |                 else if (do_lint_extensions && ! warned) {[0m
      | [0;32m                } 
[0m[1mawkgram.c:4281:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4281 |                 if (is_std_var(name))[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 4282 |                         yyerror(_("cannot use special variable `%s' for indirect function call"), name);[0m
      | [0;1;32m                                                                                                        
[0m[1mawkgram.c:4301:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4301 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mawkgram.c:4338:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4338 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4339 | #line 4340 "awkgram.c"[0m
 4340 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4344:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4344 |           { yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4345 | #line 4346 "awkgram.c"[0m
 4346 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4350:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4350 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4351 | #line 4352 "awkgram.c"[0m
 4352 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4356:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4356 |           { yyval = yyvsp[-1]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4357 | #line 4358 "awkgram.c"[0m
 4358 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4362:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4362 |           {     yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4363 | #line 4364 "awkgram.c"[0m
 4364 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4368:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4368 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4369 |                 yyval = list_merge(yyvsp[-1], yyvsp[0]);[0m
 4370 |           }[0m
 4371 | #line 4372 "awkgram.c"[0m
 4372 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4376:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4376 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4377 |                 INSTRUCTION *ip = yyvsp[0]->lasti;[0m
 4378 |                 int count = ip->sub_count;      /* # of SUBSEP-seperated expressions */[0m
 4379 |                 if (count > 1) {[0m
 4380 |                         /* change Op_subscript or Op_sub_array to Op_concat */[0m
 4381 |                         ip->opcode = Op_concat;[0m
 4382 |                         ip->concat_flag = CSUBSEP;[0m
 4383 |                         ip->expr_count = count;[0m
 4384 |                 } else[0m
 4385 |                         ip->opcode = Op_no_op;[0m
 4386 |                 sub_counter++;  /* count # of dimensions */[0m
 4387 |                 yyval = yyvsp[0];[0m
 4388 |           }[0m
 4389 | #line 4390 "awkgram.c"[0m
 4390 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4384:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4384 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4385 |                         ip->opcode = Op_no_op;[0m
      | [0;1;32m                                              
[0m[1mawkgram.c:4394:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4394 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4395 |                 INSTRUCTION *t = yyvsp[-1];[0m
 4396 |                 if (yyvsp[-1] == NULL) {[0m
 4397 |                         error_ln(yyvsp[0]->source_line,[0m
 4398 |                                 _("invalid subscript expression"));[0m
 4399 |                         /* install Null string as subscript. */[0m
 4400 |                         t = list_create(instruction(Op_push_i));[0m
 4401 |                         t->nexti->memory = dupnode(Nnull_string);[0m
 4402 |                         yyvsp[0]->sub_count = 1;[0m
 4403 |                 } else[0m
 4404 |                         yyvsp[0]->sub_count = count_expressions(&t, false);[0m
 4405 |                 yyval = list_append(t, yyvsp[0]);[0m
 4406 |           }[0m
 4407 | #line 4408 "awkgram.c"[0m
 4408 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4403:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4403 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4404 |                         yyvsp[0]->sub_count = count_expressions(&t, false);[0m
      | [0;1;32m                                                                           
[0m[1mawkgram.c:4412:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4412 |           {     yyval = yyvsp[0]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4413 | #line 4414 "awkgram.c"[0m
 4414 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4418:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4418 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4419 |                 yyval = list_merge(yyvsp[-1], yyvsp[0]);[0m
 4420 |           }[0m
 4421 | #line 4422 "awkgram.c"[0m
 4422 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4426:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4426 |           { yyval = yyvsp[-1]; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4427 | #line 4428 "awkgram.c"[0m
 4428 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4432:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4432 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4433 |                 yyvsp[0]->opcode = Op_push;[0m
 4434 |                 yyvsp[0]->memory = variable(yyvsp[0]->source_line, yyvsp[0]->lextok, Node_var_new);[0m
 4435 |                 yyval = list_create(yyvsp[0]);[0m
 4436 |           }[0m
 4437 | #line 4438 "awkgram.c"[0m
 4438 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4442:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4442 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4443 |                 char *arr = yyvsp[-1]->lextok;[0m
 4444 | [0m
 4445 |                 // Don't use Node_var_array here; breaks rwarray:readall extension.[0m
 4446 |                 yyvsp[-1]->memory = variable(yyvsp[-1]->source_line, arr, Node_var_new);[0m
 4447 |                 yyvsp[-1]->opcode = Op_push_array;[0m
 4448 |                 yyval = list_prepend(yyvsp[0], yyvsp[-1]);[0m
 4449 |           }[0m
 4450 | #line 4451 "awkgram.c"[0m
 4451 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4455:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4455 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4456 |                 INSTRUCTION *ip = yyvsp[0]->nexti;[0m
 4457 |                 if (ip->opcode == Op_push[0m
 4458 |                         && ip->memory->type == Node_var[0m
 4459 |                         && ip->memory->var_update[0m
 4460 |                 ) {[0m
 4461 |                         yyval = list_prepend(yyvsp[0], instruction(Op_var_update));[0m
 4462 |                         yyval->nexti->update_var = ip->memory->var_update;[0m
 4463 |                 } else[0m
 4464 |                         yyval = yyvsp[0];[0m
 4465 |           }[0m
 4466 | #line 4467 "awkgram.c"[0m
 4467 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4463:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4463 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4464 |                         yyval = yyvsp[0];[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:4471:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4471 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4472 |                 yyval = list_append(yyvsp[-1], yyvsp[-2]);[0m
 4473 |                 if (yyvsp[0] != NULL)[0m
 4474 |                         mk_assignment(yyvsp[-1], NULL, yyvsp[0]);[0m
 4475 |           }[0m
 4476 | #line 4477 "awkgram.c"[0m
 4477 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4473:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4473 |                 if (yyvsp[0] != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 4474 |                         mk_assignment(yyvsp[-1], NULL, yyvsp[0]);[0m
      | [0;1;32m                                                                 
[0m[1mawkgram.c:4481:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4481 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4482 |                 yyvsp[0]->opcode = Op_postincrement;[0m
 4483 |           }[0m
 4484 | #line 4485 "awkgram.c"[0m
 4485 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4489:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4489 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4490 |                 yyvsp[0]->opcode = Op_postdecrement;[0m
 4491 |           }[0m
 4492 | #line 4493 "awkgram.c"[0m
 4493 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4497:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4497 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4498 | #line 4499 "awkgram.c"[0m
 4499 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4503:23: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4503 |                       { yyval = yyvsp[0]; }[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 4504 | #line 4505 "awkgram.c"[0m
 4505 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4509:25: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4509 |                         { yyval = yyvsp[0]; yyerrok; }[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4510 | #line 4511 "awkgram.c"[0m
 4511 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4515:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4515 |               { yyerrok; }[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 4516 | #line 4517 "awkgram.c"[0m
 4517 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4521:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4521 |           { yyval = NULL; }[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4522 | #line 4523 "awkgram.c"[0m
 4523 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4527:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4527 |                 { yyerrok; }[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4528 | #line 4529 "awkgram.c"[0m
 4529 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4533:17: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4533 |                 { yyval = yyvsp[0]; yyerrok; }[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4534 | #line 4535 "awkgram.c"[0m
 4535 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4539:25: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4539 |                         { yyval = yyvsp[0]; yyerrok; }[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4540 | #line 4541 "awkgram.c"[0m
 4541 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mawkgram.c:4546:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4546 |       default: break;[0m
      | [0;1;32m               ^    
[0m      | [0;32m               {    ;} 
[0m[1mawkgram.c:4602:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4602 |           if (yychar == YYEOF)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 4603 |             YYABORT;[0m
      | [0;1;32m                    
[0m[1mawkgram.c:4624:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4624 |   if (0)[0m
      | [0;1;32m        ^
[0m      | [0;32m         {
[0m 4625 |     YYERROR;[0m
      | [0;1;32m            
[0m[1mawkgram.c:4653:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4653 |               if (0 < yyn)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 4654 |                 break;[0m
      | [0;1;32m                      
[0m[1mawkgram.c:4659:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4659 |       if (yyssp == yyss)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 4660 |         YYABORT;[0m
      | [0;1;32m                
[0m[1mawkgram.c:4730:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4730 |   if (yyss != yyssa)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 4731 |     YYSTACK_FREE (yyss);[0m
      | [0;1;32m                        
[0m[1mawkgram.c:4976:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4976 |                 if (s == NULL || s->fd <= INVALID_HANDLE)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 4977 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:4981:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4981 |                 if (s->lasttok == NEWLINE)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 4982 |                         line--;[0m
      | [0;1;32m                               
[0m[1mawkgram.c:5024:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5024 |         if (lintfunc == r_fatal)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5025 |                 err(true, _("fatal: "), mesg, args);[0m
 5026 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:5026:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5026 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 5027 |                 err(false, _("warning: "), mesg, args);[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:5030:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5030 |         if (lintfunc == r_fatal)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5031 |                 gawk_exit(EXIT_FATAL);[0m
      | [0;1;32m                                      
[0m[1mawkgram.c:5076:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5076 |                                 if (cp > lexptr_begin)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 5077 |                                         cp--;[0m
      | [0;1;32m                                             
[0m[1mawkgram.c:5080:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5080 |                         for (; cp != lexptr_begin && *cp != '\n'; --cp)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 5081 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:5082:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5082 |                         if (*cp == '\n')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 5083 |                                 cp++;[0m
      | [0;1;32m                                     
[0m[1mawkgram.c:5088:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5088 |                 if (bp < thisline)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 5089 |                         bp = thisline + 1;[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:5090:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5090 |                 while (bp < lexend && *bp && *bp != '\n')[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 5091 |                         bp++;[0m
      | [0;1;32m                             
[0m[1mawkgram.c:5100:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5100 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 5101 |                 msg("%.*s", (int) (bp - thisline), thisline);[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:5104:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5104 |         if (mesg == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 5105 |                 mesg = m;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:5108:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5108 |         if (lexptr != NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 5109 |                 count += (lexeme - thisline) + 2;[0m
      | [0;1;32m                                                 
[0m[1mawkgram.c:5116:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5116 |                 while (scan < lexeme)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 5117 |                         if (*scan++ == '\t')[0m
 5118 |                                 *bp++ = '\t';[0m
 5119 |                         else[0m
 5120 |                                 *bp++ = ' ';[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:5117:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5117 |                         if (*scan++ == '\t')[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 5118 |                                 *bp++ = '\t';[0m
 5119 |                         else[0m
      | [0;32m                        } 
[0m[1mawkgram.c:5119:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5119 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5120 |                                 *bp++ = ' ';[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:5145:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5145 |         if (end_block == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5146 |                 end_block = list_create(ip_end);[0m
 5147 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:5147:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5147 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 5148 |                 (void) list_prepend(end_block, ip_end);[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:5151:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5151 |                 if (begin_block != NULL && prog_block != NULL)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 5152 |                         cp = list_merge(begin_block, prog_block);[0m
 5153 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:5153:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5153 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5154 |                         cp = (begin_block != NULL) ? begin_block : prog_block;[0m
      | [0;1;32m                                                                              
[0m[1mawkgram.c:5156:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5156 |                 if (cp != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 5157 |                         (void) list_merge(cp, end_block);[0m
 5158 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:5158:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5158 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5159 |                         cp = end_block;[0m
      | [0;1;32m                                       
[0m[1mawkgram.c:5165:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5165 |         if (endfile_block == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 5166 |                 endfile_block = list_create(ip_endfile);[0m
 5167 |         else {[0m
      | [0;32m        } 
[0m[1mawkgram.c:5172:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5172 |         if (beginfile_block == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 5173 |                 beginfile_block = list_create(ip_beginfile);[0m
 5174 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:5174:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5174 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 5175 |                 (void) list_prepend(beginfile_block, ip_beginfile);[0m
      | [0;1;32m                                                                   
[0m[1mawkgram.c:5190:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5190 |                         if (begin_block == NULL)     /* no program at all */[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 5191 |                                 cp = end_block;[0m
 5192 |                         else[0m
      | [0;32m                        } 
[0m[1mawkgram.c:5192:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5192 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5193 |                                 cp = list_merge(begin_block, end_block);[0m
      | [0;1;32m                                                                        
[0m[1mawkgram.c:5239:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5239 |         if (begin_block != NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5240 |                 cp = list_merge(begin_block, cp);[0m
      | [0;1;32m                                                 
[0m[1mawkgram.c:5283:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5283 |         if (! in_main_context())[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5284 |                 ip_newfile = ip_rec = ip_atexit = ip_beginfile = ip_endfile = NULL;[0m
 5285 |         else {[0m
      | [0;32m        } 
[0m[1mawkgram.c:5298:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5298 |                         sourcefile = sourcefile->next)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 5299 |                 ;[0m
      | [0;1;32m                 
[0m[1mawkgram.c:5314:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5314 |         if (ret == 0)   /* avoid spurious warning if parser aborted with YYABORT */[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 5315 |                 check_funcs();[0m
      | [0;1;32m                              
[0m[1mawkgram.c:5317:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5317 |         if (do_posix && ! check_param_names())[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 5318 |                 errcount++;[0m
      | [0;1;32m                           
[0m[1mawkgram.c:5320:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5320 |         if (args_array == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 5321 |                 emalloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *), "parse_program");[0m
 5322 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:5322:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5322 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 5323 |                 erealloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *), "parse_program");[0m
      | [0;1;32m                                                                                                
[0m[1mawkgram.c:5368:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5368 |         if (already_included)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 5369 |                 *already_included = false;[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:5370:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5370 |         if (errcode)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5371 |                 *errcode = 0;[0m
      | [0;1;32m                             
[0m[1mawkgram.c:5372:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5372 |         if (stype == SRC_CMDLINE || stype == SRC_STDIN)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 5373 |                 return do_add_srcfile(stype, src, NULL, thisfile);[0m
      | [0;1;32m                                                                  
[0m[1mawkgram.c:5394:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5394 |                                 if ((stype == SRC_INC) && (s->stype == SRC_FILE))[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m 5395 |                                         fatal(_("cannot include `%s' and use it as a program file"), src);[0m
      | [0;1;32m                                                                                                          
[0m[1mawkgram.c:5404:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5404 |                                         if (sourceline > 1 && lasttok == NEWLINE)[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m 5405 |                                                 line--;[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:5413:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5413 |                                 if (already_included)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 5414 |                                         *already_included = true;[0m
      | [0;1;32m                                                                 
[0m[1mawkgram.c:5418:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5418 |                                 if (s->stype == SRC_INC)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 5419 |                                         fatal(_("cannot include `%s' and use it as a program file"), src);[0m
      | [0;1;32m                                                                                                          
[0m[1mawkgram.c:5451:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5451 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5452 |                         lintwarn_ln(file->source_line, _("empty filename after @include"));[0m
      | [0;1;32m                                                                                           
[0m[1mawkgram.c:5458:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5458 |                 if (already_included)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 5459 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mawkgram.c:5507:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5507 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5508 |                         lintwarn_ln(file->source_line, _("empty filename after @load"));[0m
      | [0;1;32m                                                                                        
[0m[1mawkgram.c:5518:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5518 |                         if (already_included)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 5519 |                                 return true;[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:5544:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5544 |                 if (cp == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 5545 |                         closefunc = close;[0m
 5546 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:5546:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5546 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5547 |                         closefunc = one_line_close;[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:5563:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5563 |                 if (sourcefile->fd != fileno(stdin))  /* safety */[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 5564 |                         (*closefunc)(sourcefile->fd);[0m
      | [0;1;32m                                                     
[0m[1mawkgram.c:5574:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5574 |                 if (sourcefile == srcfiles)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 5575 |                         return;[0m
      | [0;1;32m                               
[0m[1mawkgram.c:5576:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5576 |                 if (sourcefile->stype != SRC_EXTLIB)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 5577 |                         break;[0m
      | [0;1;32m                              
[0m[1mawkgram.c:5621:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5621 |                 if (cp == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 5622 |                         /*[0m
 5623 |                          * cast is to remove warnings on systems with[0m
 5624 |                          * different return types for read.[0m
 5625 |                          */[0m
 5626 |                         readfunc = ( ssize_t(*)(int, void *, size_t) ) read;[0m
 5627 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:5627:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5627 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5628 |                         readfunc = read_one_line;[0m
      | [0;1;32m                                                 
[0m[1mawkgram.c:5632:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5632 |         if (sourcefile == srcfiles)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 5633 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mawkgram.c:5665:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5665 |                         for (scan = lexeme; scan > lexptr_begin; scan--)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 5666 |                                 if (*scan == '\n') {[0m
 5667 |                                         scan++;[0m
 5668 |                                         break;[0m
 5669 |                                 }[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:5680:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5680 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 5681 |                         lexeof = true;[0m
      | [0;1;32m                                      
[0m[1mawkgram.c:5690:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5690 |                 if (source == NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 5691 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mawkgram.c:5714:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5714 |                 if (l < A_DECENT_BUFFER_SIZE)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 5715 |                         l = A_DECENT_BUFFER_SIZE;[0m
      | [0;1;32m                                                 
[0m[1mawkgram.c:5730:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5730 |                 for (scan = lexeme; scan > lexptr_begin; scan--)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 5731 |                         if (*scan == '\n') {[0m
 5732 |                                 scan++;[0m
 5733 |                                 break;[0m
 5734 |                         }[0m
      | [0;1;32m                         
[0m[1mawkgram.c:5833:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5833 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mawkgram.c:5836:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5836 |         if (iscntrl(c) && ! isspace(c))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 5837 |                 // This is a PEBKAC error, but we'll be nice and not say so.[0m
 5838 |                 fatal(_("error: invalid character '\\%03o' in source code"), c & 0xFF);[0m
      | [0;1;32m                                                                                       
[0m[1mawkgram.c:5852:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5852 |                 if (lexeof)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 5853 |                         return END_FILE;[0m
      | [0;1;32m                                        
[0m[1mawkgram.c:5863:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5863 |                         if (get_src_buf())[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 5864 |                                 goto again;[0m
      | [0;1;32m                                           
[0m[1mawkgram.c:5907:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5907 |                 if (check_for_bad || *lexptr == '\0')[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 5908 |                         check_bad_char(*lexptr);[0m
      | [0;1;32m                                                
[0m[1mawkgram.c:5914:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5914 |                         if (lexeof)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 5915 |                                 return END_FILE;[0m
      | [0;1;32m                                                
[0m[1mawkgram.c:5925:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5925 |                                 if (check_for_bad || *lexptr == '\0')[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 5926 |                                         check_bad_char(*lexptr);[0m
      | [0;1;32m                                                                
[0m[1mawkgram.c:5940:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5940 |         if (gawk_mb_cur_max > 1)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5941 |                 cur_ring_idx = (cur_ring_idx == 0)? RING_BUFFER_SIZE - 1 :[0m
 5942 |                         cur_ring_idx - 1;[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:5967:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5967 |                         if (c != '\r')[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 5968 |                                 tokadd(c);[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:5972:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5972 |                         if (c == '\n')[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 5973 |                                 tokadd(c);[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:5986:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5986 |                         if (c == END_FILE)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 5987 |                                 break;[0m
 5988 |                         else if (c != '#') {[0m
      | [0;32m                        } 
[0m[1mawkgram.c:5992:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5992 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5993 |                                 tokadd(c);[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:5994:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5994 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 5995 |                         break;[0m
      | [0;1;32m                              
[0m[1mawkgram.c:6033:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6033 |                                 while ((c = nextc(false)) != '\n' && c != END_FILE)[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m 6034 |                                         continue;[0m
      | [0;1;32m                                                 
[0m[1mawkgram.c:6041:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6041 |                 if (c == '\n')[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 6042 |                         sourceline++;[0m
      | [0;1;32m                                     
[0m[1mawkgram.c:6110:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6110 |         if (lasttok == LEX_EOF)         /* error earlier in current source, must give up !! */[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 6111 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:6114:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6114 |         if (c == END_SRC)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 6115 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:6116:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6116 |         if (c == END_FILE)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 6117 |                 return lasttok = NEWLINE_EOF;[0m
      | [0;1;32m                                             
[0m[1mawkgram.c:6152:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6152 |                         if (gawk_mb_cur_max == 1 || nextc_is_1stbyte) switch (c) {[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m[1mawkgram.c:6154:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6154 |                                 if (nextc(false) == ':' || in_brack == 0) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6155 |                                         in_brack++;[0m
 6156 |                                         if (in_brack == 1)[0m
 6157 |                                                 b_index = tok - tokstart;[0m
 6158 |                                 }[0m
 6159 |                                 pushback();[0m
 6160 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:6156:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6156 |                                         if (in_brack == 1)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 6157 |                                                 b_index = tok - tokstart;[0m
      | [0;1;32m                                                                         
[0m[1mawkgram.c:6162:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6162 |                                 if (in_brack > 0[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6163 |                                     && (cur_index == b_index + 1[0m
 6164 |                                         || (cur_index == b_index + 2 && tok[-1] == '^')))[0m
 6165 |                                         ; /* do nothing */[0m
 6166 |                                 else {[0m
 6167 |                                         in_brack--;[0m
 6168 |                                         if (in_brack == 0)[0m
 6169 |                                                 b_index = -1;[0m
 6170 |                                 }[0m
 6171 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:6164:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6164 |                                         || (cur_index == b_index + 2 && tok[-1] == '^')))[0m
      | [0;1;32m                                                                                         ^
[0m      | [0;32m                                                                                          {
[0m 6165 |                                         ; /* do nothing */[0m
 6166 |                                 else {[0m
      | [0;32m                                } 
[0m[1mawkgram.c:6168:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6168 |                                         if (in_brack == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 6169 |                                                 b_index = -1;[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:6173:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6173 |                                 if ((c = nextc(false)) == END_FILE) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6174 |                                         pushback();[0m
 6175 |                                         yyerror(_("unterminated regexp ends with `\\' at end of file"));[0m
 6176 |                                         goto end_regexp; /* kludge */[0m
 6177 |                                 }[0m
 6178 |                                 if (c == '\r')  /* allow MS-DOS files. bleah */[0m
 6179 |                                         c = nextc(true);[0m
 6180 |                                 if (c == '\n') {[0m
 6181 |                                         sourceline++;[0m
 6182 |                                         continue;[0m
 6183 |                                 } else {[0m
 6184 |                                         tokadd('\\');[0m
 6185 |                                         tokadd(c);[0m
 6186 |                                         continue;[0m
 6187 |                                 }[0m
 6188 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:6178:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6178 |                                 if (c == '\r')  /* allow MS-DOS files. bleah */[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 6179 |                                         c = nextc(true);[0m
      | [0;1;32m                                                        
[0m[1mawkgram.c:6190:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6190 |                                 if (in_brack > 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m[1mawkgram.c:6190:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6190 |                                 if (in_brack > 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 6191 |                                         break;[0m
      | [0;1;32m                                              
[0m[1mawkgram.c:6200:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6200 |                                                 if (source)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 6201 |                                                         lintwarn([0m
 6202 |                                                 _("%s: %d: tawk regex modifier `/.../%c' doesn't work in gawk"),[0m
 6203 |                                                                 source, sourceline, peek);[0m
 6204 |                                                 else[0m
      | [0;32m                                                } 
[0m[1mawkgram.c:6204:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6204 |                                                 else[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 6205 |                                                         lintwarn([0m
 6206 |                                                 _("tawk regex modifier `/.../%c' doesn't work in gawk"),[0m
 6207 |                                                                 peek);[0m
      | [0;1;32m                                                                      
[0m[1mawkgram.c:6213:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6213 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 6214 |                                         lasttok = REGEXP;[0m
      | [0;1;32m                                                         
[0m[1mawkgram.c:6218:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6218 |                                 pushback();[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6219 |                                 yyerror(_("unterminated regexp"));[0m
 6220 |                                 goto end_regexp;        /* kludge */[0m
      | [0;1;32m                                               
[0m      | [0;32m                                               ;} 
[0m[1mawkgram.c:6222:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6222 |                                 pushback();[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6223 |                                 yyerror(_("unterminated regexp at end of file"));[0m
 6224 |                                 goto end_regexp;        /* kludge */[0m
      | [0;1;32m                                               
[0m      | [0;32m                                               ;} 
[0m[1mawkgram.c:6232:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6232 |         while ((c = nextc(true)) == ' ' || c == '\t' || c == '\r')[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 6233 |                 continue;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:6239:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6239 |         if (gawk_mb_cur_max == 1 || nextc_is_1stbyte)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m[1mawkgram.c:6242:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6242 |                 return 0;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mawkgram.c:6245:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6245 |                 return lasttok = NEWLINE_EOF;[0m
      | [0;1;32m                ^                           
[0m      | [0;32m                {                           ;} 
[0m[1mawkgram.c:6248:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6248 |                 sourceline++;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6249 |                 return lasttok = NEWLINE;[0m
      | [0;1;32m                                        
[0m      | [0;32m                                        ;} 
[0m[1mawkgram.c:6252:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6252 |                 yylval = NULL;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mawkgram.c:6260:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6260 |                         if (lasttok == NEWLINE || lasttok == 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 6261 |                                 c = get_comment(BLOCK_COMMENT, & new_comment);[0m
 6262 |                         else[0m
      | [0;32m                        } 
[0m[1mawkgram.c:6262:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6262 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 6263 |                                 c = get_comment(EOL_COMMENT, & new_comment);[0m
      | [0;1;32m                                                                            
[0m[1mawkgram.c:6273:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6273 |                                 if (c == END_FILE)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 6274 |                                         return lasttok = NEWLINE_EOF;[0m
      | [0;1;32m                                                                     
[0m[1mawkgram.c:6281:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6281 |                 c = nextc(true);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6282 |                 if (c == '/') {[0m
 6283 |                         want_regexp = true;[0m
 6284 |                         collecting_typed_regexp = true;[0m
 6285 |                         goto collect_regexp;[0m
 6286 |                 }[0m
 6287 |                 pushback();[0m
 6288 |                 at_seen++;[0m
 6289 |                 return lasttok = '@';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6327:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6327 |                 c = nextc(true);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6328 |                 if (c == '\r')  /* allow MS-DOS files. bleah */[0m
 6329 |                         c = nextc(true);[0m
 6330 |                 if (c == '\n') {[0m
 6331 |                         sourceline++;[0m
 6332 |                         goto retry;[0m
 6333 |                 } else {[0m
 6334 |                         yyerror(_("backslash not last character on line"));[0m
 6335 |                         return lasttok = LEX_EOF;[0m
 6336 |                 }[0m
 6337 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mawkgram.c:6328:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6328 |                 if (c == '\r')  /* allow MS-DOS files. bleah */[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 6329 |                         c = nextc(true);[0m
      | [0;1;32m                                        
[0m[1mawkgram.c:6340:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6340 |                 qm_col_count++;[0m
      | [0;1;32m                ^             
[0m      | [0;32m                {             ;} 
[0m[1mawkgram.c:6343:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6343 |                 yylval = GET_INSTRUCTION(Op_cond_exp);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6344 |                 if (qm_col_count > 0) {[0m
 6345 |                         if (! do_posix) {[0m
 6346 |                                 INSTRUCTION *new_comment = NULL;[0m
 6347 |                                 allow_newline(& new_comment);[0m
 6348 |                                 yylval->comment = new_comment;[0m
 6349 |                         }[0m
 6350 |                         if (c == ':')[0m
 6351 |                                 qm_col_count--;[0m
 6352 |                 }[0m
 6353 |                 return lasttok = c;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mawkgram.c:6350:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6350 |                         if (c == ':')[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 6351 |                                 qm_col_count--;[0m
      | [0;1;32m                                               
[0m[1mawkgram.c:6360:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6360 |                 in_parens--;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6361 |                 return lasttok = c;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mawkgram.c:6364:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6364 |                 in_parens++;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6365 |                 return lasttok = c;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mawkgram.c:6367:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6367 |                 yylval = GET_INSTRUCTION(Op_field_spec);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6368 |                 return lasttok = c;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mawkgram.c:6370:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6370 |                 if (++in_braces == 1)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6371 |                         firstline = sourceline;[0m
      | [0;1;32m                                              
[0m      | [0;32m                                              ;} 
[0m[1mawkgram.c:6370:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6370 |                 if (++in_braces == 1)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 6371 |                         firstline = sourceline;[0m
      | [0;1;32m                                               
[0m[1mawkgram.c:6378:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6378 |                 c = nextc(true);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6379 |                 pushback();[0m
 6380 |                 if (c == '[') {[0m
 6381 |                         if (do_traditional)[0m
 6382 |                                 fatal(_("multidimensional arrays are a gawk extension"));[0m
 6383 |                         if (do_lint_extensions)[0m
 6384 |                                 lintwarn(_("multidimensional arrays are a gawk extension"));[0m
 6385 |                         yylval = GET_INSTRUCTION(Op_sub_array);[0m
 6386 |                         lasttok = ']';[0m
 6387 |                 } else {[0m
 6388 |                         yylval = GET_INSTRUCTION(Op_subscript);[0m
 6389 |                         lasttok = SUBSCRIPT;    /* end of subscripts */[0m
 6390 |                 }[0m
 6391 |                 return ']';[0m
      | [0;1;32m                          
[0m      | [0;32m                          ;} 
[0m[1mawkgram.c:6381:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6381 |                         if (do_traditional)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 6382 |                                 fatal(_("multidimensional arrays are a gawk extension"));[0m
      | [0;1;32m                                                                                         
[0m[1mawkgram.c:6383:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6383 |                         if (do_lint_extensions)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 6384 |                                 lintwarn(_("multidimensional arrays are a gawk extension"));[0m
      | [0;1;32m                                                                                            
[0m[1mawkgram.c:6394:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6394 |                 if ((c = nextc(true)) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mawkgram.c:6408:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6408 |                                         if (do_lint)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 6409 |                                                 lintwarn(_("POSIX does not allow operator `%s'"), "**=");[0m
      | [0;1;32m                                                                                                         
[0m[1mawkgram.c:6410:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6410 |                                         if (do_lint_old)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 6411 |                                                 lintwarn(_("operator `%s' is not supported in old awk"), "**=");[0m
      | [0;1;32m                                                                                                                
[0m[1mawkgram.c:6419:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6419 |                                         if (do_lint)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 6420 |                                                 lintwarn(_("POSIX does not allow operator `%s'"), "**");[0m
      | [0;1;32m                                                                                                        
[0m[1mawkgram.c:6421:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6421 |                                         if (do_lint_old)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 6422 |                                                 lintwarn(_("operator `%s' is not supported in old awk"), "**");[0m
      | [0;1;32m                                                                                                               
[0m[1mawkgram.c:6433:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6433 |                 if (nextc(false) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6434 |                         pushback();[0m
 6435 |                         return lasttok = SLASH_BEFORE_EQUAL;[0m
 6436 |                 }[0m
 6437 |                 pushback();[0m
 6438 |                 yylval = GET_INSTRUCTION(Op_quotient);[0m
 6439 |                 return lasttok = '/';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6442:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6442 |                 if (nextc(true) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6443 |                         yylval = GET_INSTRUCTION(Op_assign_mod);[0m
 6444 |                         return lasttok = ASSIGNOP;[0m
 6445 |                 }[0m
 6446 |                 pushback();[0m
 6447 |                 yylval = GET_INSTRUCTION(Op_mod);[0m
 6448 |                 return lasttok = '%';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6472:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6472 |                 if ((c = nextc(true)) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6473 |                         yylval = GET_INSTRUCTION(Op_assign_plus);[0m
 6474 |                         return lasttok = ASSIGNOP;[0m
 6475 |                 }[0m
 6476 |                 if (c == '+') {[0m
 6477 |                         yylval = GET_INSTRUCTION(Op_symbol);[0m
 6478 |                         return lasttok = INCREMENT;[0m
 6479 |                 }[0m
 6480 |                 pushback();[0m
 6481 |                 yylval = GET_INSTRUCTION(Op_plus);[0m
 6482 |                 return lasttok = '+';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6485:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6485 |                 if ((c = nextc(true)) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6486 |                         yylval = GET_INSTRUCTION(Op_notequal);[0m
 6487 |                         return lasttok = RELOP;[0m
 6488 |                 }[0m
 6489 |                 if (c == '~') {[0m
 6490 |                         yylval = GET_INSTRUCTION(Op_nomatch);[0m
 6491 |                         return lasttok = MATCHOP;[0m
 6492 |                 }[0m
 6493 |                 pushback();[0m
 6494 |                 yylval = GET_INSTRUCTION(Op_symbol);[0m
 6495 |                 return lasttok = '!';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6498:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6498 |                 if (nextc(true) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6499 |                         yylval = GET_INSTRUCTION(Op_leq);[0m
 6500 |                         return lasttok = RELOP;[0m
 6501 |                 }[0m
 6502 |                 yylval = GET_INSTRUCTION(Op_less);[0m
 6503 |                 pushback();[0m
 6504 |                 return lasttok = '<';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6507:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6507 |                 if (nextc(true) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6508 |                         yylval = GET_INSTRUCTION(Op_equal);[0m
 6509 |                         return lasttok = RELOP;[0m
 6510 |                 }[0m
 6511 |                 yylval = GET_INSTRUCTION(Op_assign);[0m
 6512 |                 pushback();[0m
 6513 |                 return lasttok = ASSIGN;[0m
      | [0;1;32m                                       
[0m      | [0;32m                                       ;} 
[0m[1mawkgram.c:6516:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6516 |                 if ((c = nextc(true)) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6517 |                         yylval = GET_INSTRUCTION(Op_geq);[0m
 6518 |                         return lasttok = RELOP;[0m
 6519 |                 } else if (c == '>') {[0m
 6520 |                         yylval = GET_INSTRUCTION(Op_symbol);[0m
 6521 |                         yylval->redir_type = redirect_append;[0m
 6522 |                         return lasttok = IO_OUT;[0m
 6523 |                 }[0m
 6524 |                 pushback();[0m
 6525 |                 if (in_print && in_parens == 0) {[0m
 6526 |                         yylval = GET_INSTRUCTION(Op_symbol);[0m
 6527 |                         yylval->redir_type = redirect_output;[0m
 6528 |                         return lasttok = IO_OUT;[0m
 6529 |                 }[0m
 6530 |                 yylval = GET_INSTRUCTION(Op_greater);[0m
 6531 |                 return lasttok = '>';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6534:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6534 |                 yylval = GET_INSTRUCTION(Op_match);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6535 |                 return lasttok = MATCHOP;[0m
      | [0;1;32m                                        
[0m      | [0;32m                                        ;} 
[0m[1mawkgram.c:6542:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6542 |                 if (did_newline) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6543 |                         did_newline = false;[0m
 6544 |                         if (--in_braces == 0)[0m
 6545 |                                 lastline = sourceline;[0m
 6546 |                         return lasttok = c;[0m
 6547 |                 }[0m
 6548 |                 did_newline = true;[0m
 6549 |                 --lexptr;       /* pick up } next time */[0m
 6550 |                 return lasttok = NEWLINE;[0m
      | [0;1;32m                                        
[0m      | [0;32m                                        ;} 
[0m[1mawkgram.c:6544:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6544 |                         if (--in_braces == 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 6545 |                                 lastline = sourceline;[0m
      | [0;1;32m                                                      
[0m[1mawkgram.c:6553:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6553 |         string:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mawkgram.c:6568:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6568 |                                 if (c == '\r')  /* allow MS-DOS files. bleah */[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 6569 |                                         c = nextc(true);[0m
      | [0;1;32m                                                        
[0m[1mawkgram.c:6571:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6571 |                                         if (do_posix)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 6572 |                                                 fatal(_("POSIX does not allow physical newlines in string values"));[0m
 6573 |                                         else if (do_lint)[0m
      | [0;32m                                        } 
[0m[1mawkgram.c:6573:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6573 |                                         else if (do_lint)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 6574 |                                                 lintwarn(_("backslash string continuation is not portable"));[0m
      | [0;1;32m                                                                                                             
[0m[1mawkgram.c:6579:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6579 |                                 if (! want_source || c != '"')[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 6580 |                                         tokadd('\\');[0m
      | [0;1;32m                                                     
[0m[1mawkgram.c:6593:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6593 |                         if (want_namespace)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 6594 |                                 change_namespace(yylval->lextok);[0m
      | [0;1;32m                                                                 
[0m[1mawkgram.c:6604:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6604 |                         if (do_intl)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 6605 |                                 dumpintlstr(yylval->memory->stptr, yylval->memory->stlen);[0m
      | [0;1;32m                                                                                          
[0m[1mawkgram.c:6610:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6610 |                 if ((c = nextc(true)) == '=') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6611 |                         yylval = GET_INSTRUCTION(Op_assign_minus);[0m
 6612 |                         return lasttok = ASSIGNOP;[0m
 6613 |                 }[0m
 6614 |                 if (c == '-') {[0m
 6615 |                         yylval = GET_INSTRUCTION(Op_symbol);[0m
 6616 |                         return lasttok = DECREMENT;[0m
 6617 |                 }[0m
 6618 |                 pushback();[0m
 6619 |                 yylval = GET_INSTRUCTION(Op_minus);[0m
 6620 |                 return lasttok = '-';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6623:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6623 |                 c = nextc(true);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6624 |                 pushback();[0m
 6625 |                 if (! isdigit(c))[0m
 6626 |                         return lasttok = '.';[0m
 6627 |                 else[0m
 6628 |                         c = '.';[0m
      | [0;1;32m                               
[0m      | [0;32m                               ;} 
[0m[1mawkgram.c:6625:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6625 |                 if (! isdigit(c))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 6626 |                         return lasttok = '.';[0m
 6627 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:6627:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6627 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 6628 |                         c = '.';[0m
      | [0;1;32m                                
[0m[1mawkgram.c:6648:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6648 |                                 if (do_traditional)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 6649 |                                         goto done;[0m
      | [0;1;32m                                                  
[0m[1mawkgram.c:6650:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6650 |                                 if (tok == tokstart + 2) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6651 |                                         int peek = nextc(true);[0m
 6652 | [0m
 6653 |                                         if (isxdigit(peek)) {[0m
 6654 |                                                 inhex = true;[0m
 6655 |                                                 pushback();     /* following digit */[0m
 6656 |                                         } else {[0m
 6657 |                                                 pushback();     /* x or X */[0m
 6658 |                                                 goto done;[0m
 6659 |                                         }[0m
 6660 |                                 }[0m
 6661 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:6664:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6664 |                                 if (seen_point || seen_e) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6665 |                                         gotnumber = true;[0m
 6666 |                                         break;[0m
 6667 |                                 }[0m
 6668 |                                 seen_point = true;[0m
 6669 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:6672:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6672 |                                 if (inhex)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 6673 |                                         break;[0m
      | [0;1;32m                                              
[0m[1mawkgram.c:6674:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6674 |                                 if (seen_e) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m[1mawkgram.c:6707:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6707 |                                 if (do_traditional || ! inhex)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 6708 |                                         goto done;[0m
      | [0;1;32m                                                  
[0m[1mawkgram.c:6722:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6722 |                         done:[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 6723 |                                 gotnumber = true;[0m
      | [0;1;32m                                                
[0m      | [0;32m                                                ;} 
[0m[1mawkgram.c:6725:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6725 |                         if (gotnumber)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 6726 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mawkgram.c:6729:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6729 |                 pushback();[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mawkgram.c:6738:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6738 |                                 if (base == 8)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 6739 |                                         lintwarn("numeric constant `%.*s' treated as octal",[0m
 6740 |                                                 (int) strlen(tokstart)-1, tokstart);[0m
 6741 |                                 else if (base == 16)[0m
      | [0;32m                                } 
[0m[1mawkgram.c:6741:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6741 |                                 else if (base == 16)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 6742 |                                         lintwarn("numeric constant `%.*s' treated as hexadecimal",[0m
 6743 |                                                 (int) strlen(tokstart)-1, tokstart);[0m
      | [0;1;32m                                                                                    
[0m[1mawkgram.c:6766:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6766 |                 if (base != 10)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 6767 |                         d = nondec2awknum(tokstart, strlen(tokstart)-1, NULL);[0m
 6768 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:6768:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6768 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 6769 |                         d = atof(tokstart);[0m
      | [0;1;32m                                           
[0m[1mawkgram.c:6771:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6771 |                 if (d <= INT32_MAX && d >= INT32_MIN && d == (int32_t) d)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 6772 |                         yylval->memory->flags |= NUMINT;[0m
      | [0;1;32m                                                        
[0m[1mawkgram.c:6776:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6776 |                 if ((c = nextc(true)) == '&') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 6777 |                         yylval = GET_INSTRUCTION(Op_and);[0m
 6778 |                         INSTRUCTION *new_comment = NULL;[0m
 6779 |                         allow_newline(& new_comment);[0m
 6780 |                         yylval->comment = new_comment;[0m
 6781 | [0m
 6782 |                         return lasttok = LEX_AND;[0m
 6783 |                 }[0m
 6784 |                 pushback();[0m
 6785 |                 yylval = GET_INSTRUCTION(Op_symbol);[0m
 6786 |                 return lasttok = '&';[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mawkgram.c:6789:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6789 |                 if ((c = nextc(true)) == '|') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mawkgram.c:6855:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6855 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 6856 |                                 pushback();[0m
      | [0;1;32m                                           
[0m[1mawkgram.c:6875:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6875 |                         if (lasttok != '@')[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 6876 |                                 goto out;[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:6878:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6878 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mawkgram.c:6888:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6888 |                                 goto out;[0m
      | [0;1;32m                                ^       
[0m      | [0;32m                                {       ;} 
[0m[1mawkgram.c:6891:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6891 |                                 if ((f = lookup(tokstart)) != NULL) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6892 |                                         if (f->type == Node_builtin_func)[0m
 6893 |                                                 break;[0m
 6894 |                                         else[0m
 6895 |                                                 goto out;[0m
 6896 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mawkgram.c:6892:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6892 |                                         if (f->type == Node_builtin_func)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 6893 |                                                 break;[0m
 6894 |                                         else[0m
      | [0;32m                                        } 
[0m[1mawkgram.c:6894:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6894 |                                         else[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 6895 |                                                 goto out;[0m
      | [0;1;32m                                                         
[0m[1mawkgram.c:6901:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6901 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1mawkgram.c:6903:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6903 |                                 cant_happen("bad value %d for want_param_names", (int) want_param_names);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 6904 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mawkgram.c:6928:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6928 |                 if ((tokentab[mid].flags & BREAK) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 6929 |                         break_allowed++;[0m
      | [0;1;32m                                        
[0m[1mawkgram.c:6930:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6930 |                 if ((tokentab[mid].flags & CONTINUE) != 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 6931 |                         continue_allowed++;[0m
      | [0;1;32m                                           
[0m[1mawkgram.c:6935:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6935 |                         want_namespace = true;[0m
      | [0;1;32m                        ^                    
[0m      | [0;32m                        {                    ;} 
[0m[1mawkgram.c:6940:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6940 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mawkgram.c:6942:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6942 |                         if (in_main_context())[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 6943 |                                 goto out;[0m
 6944 |                         emalloc(tokkey, char *, tok - tokstart + 1, "yylex");[0m
 6945 |                         tokkey[0] = '@';[0m
 6946 |                         memcpy(tokkey + 1, tokstart, tok - tokstart);[0m
 6947 |                         yylval = GET_INSTRUCTION(Op_token);[0m
 6948 |                         yylval->lextok = tokkey;[0m
 6949 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mawkgram.c:6942:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6942 |                         if (in_main_context())[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 6943 |                                 goto out;[0m
      | [0;1;32m                                         
[0m[1mawkgram.c:6957:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6957 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mawkgram.c:6963:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6963 |                         if (! do_pretty_print)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 6964 |                                 return lasttok = class;[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:6967:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6967 |                         yylval = bcalloc(tokentab[mid].value, 2, sourceline);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 6968 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mawkgram.c:6976:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6976 |                         if (! continue_allowed) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 6977 |                                 error_ln(sourceline,[0m
 6978 |                                         _("`continue' is not allowed outside a loop"));[0m
 6979 |                                 errcount++;[0m
 6980 |                         }[0m
 6981 |                         goto make_instruction;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1mawkgram.c:6984:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6984 |                         if (! break_allowed) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 6985 |                                 error_ln(sourceline,[0m
 6986 |                                         _("`break' is not allowed outside a loop or switch"));[0m
 6987 |                                 errcount++;[0m
 6988 |                         }[0m
 6989 |                         goto make_instruction;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1mawkgram.c:6992:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 6992 | make_instruction:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m 6993 |                         yylval = GET_INSTRUCTION(tokentab[mid].value);[0m
 6994 |                         if (class == LEX_BUILTIN || class == LEX_LENGTH)[0m
 6995 |                                 yylval->builtin_idx = mid;[0m
 6996 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mawkgram.c:6994:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 6994 |                         if (class == LEX_BUILTIN || class == LEX_LENGTH)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 6995 |                                 yylval->builtin_idx = mid;[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:7001:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7001 |         if (want_param_names == FUNC_HEADER)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 7002 |                 tokkey = estrdup(tokstart, tok - tokstart - 1);[0m
 7003 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:7003:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7003 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 7004 |                 tokkey = qualify_name(tokstart, tok - tokstart - 1);[0m
      | [0;1;32m                                                                    
[0m[1mawkgram.c:7110:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7110 |                         if (strcmp(operator, "gsub") == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 7111 |                                 r->sub_flags |= GSUB;[0m
      | [0;1;32m                                                     
[0m[1mawkgram.c:7126:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7126 |                                 if (do_lint)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 7127 |                                         lintwarn(_("%s: string literal as last argument of substitute has no effect"),[0m
 7128 |                                                 operator);[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:7131:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7131 |                                 if (make_assignable(ip) == NULL)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 7132 |                                         yyerror(_("%s third parameter is not a changeable object"),[0m
 7133 |                                                 operator);[0m
 7134 |                                 else[0m
      | [0;32m                                } 
[0m[1mawkgram.c:7134:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7134 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 7135 |                                         ip->do_reference = true;[0m
      | [0;1;32m                                                                
[0m[1mawkgram.c:7199:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7199 |                         if (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m 7200 |                                 arg->nexti->opcode = Op_push_arg;       /* argument may be array */[0m
      | [0;1;32m                                                                                                   
[0m[1mawkgram.c:7204:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7204 |                 if (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 7205 |                         arg->nexti->opcode = Op_push_arg_untyped;       /* argument may be untyped */[0m
      | [0;1;32m                                                                                                     
[0m[1mawkgram.c:7208:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7208 |                 if (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 7209 |                         arg->nexti->opcode = Op_push_arg_untyped;       /* argument may be untyped */[0m
      | [0;1;32m                                                                                                     
[0m[1mawkgram.c:7213:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7213 |                         if (ip->opcode == Op_push)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 7214 |                                 ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:7245:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7245 |                         if (/*ip == arg->nexti  && */ ip->opcode == Op_push)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 7246 |                                 ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:7251:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7251 |                 if (ip->opcode == Op_push)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 7252 |                         ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:7261:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7261 |                 if (nexp == 2)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 7262 |                         n->re_flags |= FS_DFLT;[0m
      | [0;1;32m                                               
[0m[1mawkgram.c:7266:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7266 |                         if (ip->opcode == Op_push)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 7267 |                                 ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:7272:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7272 |                 if (ip->opcode == Op_push)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 7273 |                         ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:7285:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7285 |                         if (ip->opcode == Op_push)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 7286 |                                 ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:7307:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7307 |                 if ((str->flags & INTLSTR) != 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 7308 |                         warning(_("use of dcgettext(_\"...\") is incorrect: remove leading underscore"));[0m
 7309 |                         /* don't dump it, the lexer already did */[0m
 7310 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:7310:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7310 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 7311 |                         dumpintlstr(str->stptr, str->stlen);[0m
      | [0;1;32m                                                            
[0m[1mawkgram.c:7322:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7322 |                 if (((str1->flags | str2->flags) & INTLSTR) != 0)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 7323 |                         warning(_("use of dcngettext(_\"...\") is incorrect: remove leading underscore"));[0m
 7324 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:7324:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7324 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 7325 |                         dumpintlstr2(str1->stptr, str1->stlen, str2->stptr, str2->stlen);[0m
      | [0;1;32m                                                                                         
[0m[1mawkgram.c:7329:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7329 |                 if (ip->opcode == Op_push)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 7330 |                         ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:7334:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7334 |                         if (ip->opcode == Op_push)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 7335 |                                 ip->opcode = Op_push_array;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:7341:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7341 |                 if (ip->opcode == Op_match_rec || ip->opcode == Op_push_re)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 7342 |                         fatal(_("index: regexp constant as second argument is not allowed"));[0m
      | [0;1;32m                                                                                             
[0m[1mawkgram.c:7383:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7383 |         if (pcount == 0)                /* no args, no problem */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 7384 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:7410:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7410 |         if (n == Nnull_string)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 7411 |                 print_func(fp, "uninitialized scalar\n");[0m
 7412 |         else if ((n->flags & REGEX) != 0)[0m
      | [0;32m        } 
[0m[1mawkgram.c:7412:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7412 |         else if ((n->flags & REGEX) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 7413 |                 print_func(fp, "@/%.*s/\n", n->stlen, n->stptr);[0m
 7414 |         else if ((n->flags & STRING) != 0) {[0m
      | [0;32m        } 
[0m[1mawkgram.c:7426:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7426 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 7427 |                 print_func(fp, "?? flags %s\n", flags2str(n->flags));[0m
      | [0;1;32m                                                                     
[0m[1mawkgram.c:7439:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7439 |         if (fname == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 7440 |                 fp = stderr;[0m
 7441 |         else if (strcmp(fname, "-") == 0)[0m
      | [0;32m        } 
[0m[1mawkgram.c:7441:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7441 |         else if (strcmp(fname, "-") == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 7442 |                 fp = stdout;[0m
 7443 |         else if ((fp = fopen(fname, "w")) == NULL) {[0m
      | [0;32m        } 
[0m[1mawkgram.c:7452:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7452 |         if (fp != stdout && fp != stderr && fclose(fp) != 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 7453 |                 warning(_("%s: close failed: %s"), fname, strerror(errno));[0m
      | [0;1;32m                                                                           
[0m[1mawkgram.c:7477:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7477 |         if (calls++ != 0)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 7478 |                 fatal(_("shadow_funcs() called twice!"));[0m
      | [0;1;32m                                                         
[0m[1mawkgram.c:7485:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7485 |         if (shadow && lintfunc == r_fatal)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 7486 |                 lintwarn(_("there were shadowed variables"));[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:7567:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7567 |         if (plist != NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 7568 |                 pcount = plist->lasti->param_count + 1;[0m
      | [0;1;32m                                                       
[0m[1mawkgram.c:7619:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7619 |                 } else if (strchr(name, ':') != NULL)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 7620 |                         error_ln(p->source_line,[0m
 7621 |                                 _("function `%s': parameter `%s' cannot contain a namespace"),[0m
 7622 |                                         fname, name);[0m
      | [0;1;32m                                                     
[0m[1mawkgram.c:7667:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7667 |         for (fp = ftable[ind]; fp != NULL; fp = fp->next)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 7668 |                 if (strcmp(fp->name, name) == 0)[0m
 7669 |                         goto update_value;[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:7668:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7668 |                 if (strcmp(fp->name, name) == 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 7669 |                         goto update_value;[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:7680:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7680 |         if (how == FUNC_DEFINE)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 7681 |                 fp->defined++;[0m
 7682 |         else if (how == FUNC_EXT) {[0m
      | [0;32m        } 
[0m[1mawkgram.c:7685:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7685 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 7686 |                 fp->used++;[0m
      | [0;1;32m                           
[0m[1mawkgram.c:7705:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7705 |         if (! in_main_context())[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 7706 |                 goto free_mem;[0m
      | [0;1;32m                              
[0m[1mawkgram.c:7716:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7716 |                                 if (fp->defined == 0)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 7717 |                                         lintwarn(_("function `%s' called but never defined"),[0m
 7718 |                                                 fp->name);[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:7720:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7720 |                                 if (fp->used == 0)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 7721 |                                         lintwarn(_("function `%s' defined but never called directly"),[0m
 7722 |                                                 fp->name);[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:7747:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7747 |         if (arglist == NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 7748 |                 return;[0m
      | [0;1;32m                       
[0m[1mawkgram.c:7751:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7751 |                 if (arg->opcode == Op_match_rec)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 7752 |                         warning_ln(arg->source_line,[0m
 7753 |                                 _("regexp constant for parameter #%d yields boolean value"), i);[0m
      | [0;1;32m                                                                                                
[0m[1mawkgram.c:7767:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7767 |                 if (r->type == Node_func || r->type == Node_ext_func )[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 7768 |                         error_ln(location, _("function `%s' called with space between name and `(',\nor used as a variable or an array"),[0m
 7769 |                                 r->vname);[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:7812:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7812 |         if (ip == list->lasti && ip->opcode == Op_match_rec)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 7813 |                 ip->opcode = Op_push_re;[0m
 7814 |         else if (ip == list->lasti && ip->opcode == Op_push_re)[0m
      | [0;32m        } 
[0m[1mawkgram.c:7814:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7814 |         else if (ip == list->lasti && ip->opcode == Op_push_re)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 7815 |                 ; /* do nothing --- @/.../ */[0m
 7816 |         else {[0m
      | [0;32m        } 
[0m[1mawkgram.c:7874:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7874 |                 break;  /* keeps gcc -Wall happy */[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mawkgram.c:7889:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7889 |                 ip->opcode = Op_push_lhs;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 7890 |                 return ip;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mawkgram.c:7892:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7892 |                 ip->opcode = Op_field_spec_lhs;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 7893 |                 return ip;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mawkgram.c:7895:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7895 |                 ip->opcode = Op_subscript_lhs;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 7896 |                 return ip;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mawkgram.c:7900:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7900 |                 return ip;[0m
      | [0;1;32m                ^        
[0m      | [0;32m                {        ;} 
[0m[1mawkgram.c:7902:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7902 |                 break;  /* keeps gcc -Wall happy */[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mawkgram.c:7926:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7926 |                 for (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 7927 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:7949:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 7949 |                 for (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 7950 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:7986:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7986 |                                 res *= n2->numbr;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 7987 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:7989:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7989 |                                 if ((n2->flags & NUMBER) != 0 && n2->numbr == 0.0) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 7990 |                                         /* don't fatalize, allow parsing rest of the input */[0m
 7991 |                                         error_ln(op->source_line, _("division by zero attempted"));[0m
 7992 |                                         goto regular;[0m
 7993 |                                 }[0m
 7994 | [0m
 7995 |                                 res /= n2->numbr;[0m
 7996 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:7998:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 7998 |                                 if ((n2->flags & NUMBER) != 0 && n2->numbr == 0.0) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 7999 |                                         /* don't fatalize, allow parsing rest of the input */[0m
 8000 |                                         error_ln(op->source_line, _("division by zero attempted in `%%'"));[0m
 8001 |                                         goto regular;[0m
 8002 |                                 }[0m
 8003 | #ifdef HAVE_FMOD[0m
 8004 |                                 res = fmod(res, n2->numbr);[0m
 8005 | #else   /* ! HAVE_FMOD */[0m
 8006 |                                 (void) modf(res / n2->numbr, &res);[0m
 8007 |                                 res = n1->numbr - res * n2->numbr;[0m
 8008 | #endif  /* ! HAVE_FMOD */[0m
 8009 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8011:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8011 |                                 res += n2->numbr;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8012 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8014:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8014 |                                 res -= n2->numbr;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8015 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8017:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8017 |                                 res = calc_exp(res, n2->numbr);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8018 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8020:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8020 |                                 goto regular;[0m
      | [0;1;32m                                ^           
[0m      | [0;32m                                {           ;} 
[0m[1mawkgram.c:8039:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8039 |                                 op->opcode = Op_times_i;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8040 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8042:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8042 |                                 if ((ip2->memory->flags & NUMBER) != 0 && ip2->memory->numbr == 0.0) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8043 |                                         /* don't fatalize, allow parsing rest of the input */[0m
 8044 |                                         error_ln(op->source_line, _("division by zero attempted"));[0m
 8045 |                                         goto regular;[0m
 8046 |                                 }[0m
 8047 | [0m
 8048 |                                 op->opcode = Op_quotient_i;[0m
 8049 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8051:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8051 |                                 if ((ip2->memory->flags & NUMBER) != 0 && ip2->memory->numbr == 0.0) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8052 |                                         /* don't fatalize, allow parsing rest of the input */[0m
 8053 |                                         error_ln(op->source_line, _("division by zero attempted in `%%'"));[0m
 8054 |                                         goto regular;[0m
 8055 |                                 }[0m
 8056 | [0m
 8057 |                                 op->opcode = Op_mod_i;[0m
 8058 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8060:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8060 |                                 if (do_lint)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8061 |                                         goto regular;[0m
 8062 |                                 op->opcode = Op_plus_i;[0m
 8063 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8060:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8060 |                                 if (do_lint)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 8061 |                                         goto regular;[0m
      | [0;1;32m                                                     
[0m[1mawkgram.c:8065:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8065 |                                 op->opcode = Op_minus_i;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8066 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8068:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8068 |                                 op->opcode = Op_exp_i;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 8069 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mawkgram.c:8071:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8071 |                                 goto regular;[0m
      | [0;1;32m                                ^           
[0m      | [0;32m                                {           ;} 
[0m[1mawkgram.c:8133:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8133 |                         if (ip->target_stmt == ip)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 8134 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mawkgram.c:8177:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8177 |                 if (false_branch->lasti->opcode != Op_no_op)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 8178 |                         (void) list_append(false_branch, instruction(Op_no_op));[0m
      | [0;1;32m                                                                                
[0m[1mawkgram.c:8186:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8186 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 8187 |                         bcfree(elsep);[0m
      | [0;1;32m                                      
[0m[1mawkgram.c:8202:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8202 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 8203 |                 bcfree(ifp);[0m
      | [0;1;32m                            
[0m[1mawkgram.c:8205:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8205 |         if (true_branch != NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 8206 |                 list_merge(ip, true_branch);[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:8222:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8222 |                         if (ip->source_line > lineno)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 8223 |                                 lineno = ip->source_line;[0m
      | [0;1;32m                                                         
[0m[1mawkgram.c:8226:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8226 |                                         && (lineno == 0 || ip->source_line < lineno))[0m
      | [0;1;32m                                                                                     ^
[0m      | [0;32m                                                                                      {
[0m 8227 |                                 lineno = ip->source_line;[0m
      | [0;1;32m                                                         
[0m[1mawkgram.c:8229:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8229 |                 if (ip == pattern->lasti)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 8230 |                         break;[0m
      | [0;1;32m                              
[0m[1mawkgram.c:8286:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8286 |                         if (do_pretty_print)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 8287 |                                 (void) list_prepend(action, instruction(Op_exec_count));[0m
      | [0;1;32m                                                                                        
[0m[1mawkgram.c:8302:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8302 |                                 if (do_pretty_print)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 8303 |                                         action = list_prepend(action, instruction(Op_exec_count));[0m
      | [0;1;32m                                                                                                  
[0m[1mawkgram.c:8304:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8304 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 8305 |                                 (rp + 2)->last_line = lastline;[0m
      | [0;1;32m                                                               
[0m[1mawkgram.c:8328:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8328 |         if (rule_block[rule] == NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 8329 |                 rule_block[rule] = ip;[0m
 8330 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:8330:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8330 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 8331 |                 (void) list_merge(rule_block[rule], ip);[0m
      | [0;1;32m                                                        
[0m[1mawkgram.c:8363:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8363 |                 tp->opcode = Op_field_spec_lhs;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 8364 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mawkgram.c:8366:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8366 |                 tp->opcode = Op_subscript_lhs;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 8367 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mawkgram.c:8371:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8371 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mawkgram.c:8373:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8373 |                 yyerror(_("cannot assign a value to the result of a field post-increment expression"));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 8374 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mawkgram.c:8376:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8376 |                 yyerror(_("invalid target of assignment (opcode %s)"),[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 8377 |                                 opcode2str(tp->opcode));[0m
 8378 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mawkgram.c:8383:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8383 |         if (rhs != NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 8384 |                 ip = list_merge(rhs, lhs);[0m
 8385 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:8385:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8385 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 8386 |                 ip = lhs;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:8388:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8388 |         if (tp->opcode != Op_field_spec_lhs || op->opcode != Op_assign)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 8389 |                 (void) list_append(ip, op);[0m
      | [0;1;32m                                           
[0m[1mawkgram.c:8460:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8460 |             && i1->opcode != Op_field_assign)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 8461 |                 return list_append(exp, instruction(Op_pop));[0m
      | [0;1;32m                                                             
[0m[1mawkgram.c:8466:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8466 |                         if (i2->nexti->opcode == Op_push_lhs    /* l.h.s is a simple variable */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mawkgram.c:8484:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8484 |                                                         || i3->opcode == Op_func_call)[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m 8485 |                                                 return list_append(exp, instruction(Op_pop)); /* no optimization */[0m
      | [0;1;32m                                                                                                                   
[0m[1mawkgram.c:8493:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8493 |                                 if (--i2->expr_count == 1)      /* one less expression in Op_concat */[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 8494 |                                         i2->opcode = Op_no_op;[0m
      | [0;1;32m                                                              
[0m[1mawkgram.c:8507:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8507 |                         if (i2->nexti->nexti->opcode == Op_subscript_lhs) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mawkgram.c:8529:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8529 |                         if (i2->nexti == i1[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mawkgram.c:8547:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8547 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 8548 |                                         i2->initval = NULL;[0m
      | [0;1;32m                                                           
[0m[1mawkgram.c:8555:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8555 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mawkgram.c:8616:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8616 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 8617 |                         ip = list_append(var, op);[0m
      | [0;1;32m                                                  
[0m[1mawkgram.c:8618:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8618 |         } else if (redir != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 8619 |                 ip = list_append(redir, op);[0m
 8620 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:8620:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8620 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 8621 |                 ip = list_create(op);[0m
      | [0;1;32m                                     
[0m[1mawkgram.c:8671:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8671 |         if (init != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 8672 |                 ip = list_merge(init, ip);[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:8680:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8680 |         if (body != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 8681 |                 (void) list_merge(ip, body);[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:8685:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8685 |         if (incr == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 8686 |                 tcont = jmp;[0m
 8687 |         else {[0m
      | [0;32m        } 
[0m[1mawkgram.c:8718:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8718 |                 ip = list->lasti;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 8719 |                 if (ip->opcode == Op_var_assign || ip->opcode == Op_field_assign) {[0m
 8720 |                         assert(ip != list->nexti);[0m
 8721 |                         for (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti)[0m
 8722 |                                 ;[0m
 8723 |                 }[0m
 8724 | [0m
 8725 |                 if (ip->opcode == Op_assign || ip->opcode == Op_assign_concat) {[0m
 8726 |                         list_append(list, instruction(Op_lint));[0m
 8727 |                         list->lasti->lint_type = linttype;[0m
 8728 |                 }[0m
 8729 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mawkgram.c:8721:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8721 |                         for (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti)[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m 8722 |                                 ;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:8732:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8732 |                 if (list->lasti->opcode == Op_pop && list->nexti != list->lasti) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mawkgram.c:8739:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8739 |                                 if (ip->source_line != 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 8740 |                                         line = ip->source_line;[0m
      | [0;1;32m                                                               
[0m[1mawkgram.c:8754:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8754 |                                         if (ip->source_line != 0)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 8755 |                                                 line = ip->source_line;[0m
      | [0;1;32m                                                                       
[0m[1mawkgram.c:8766:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8766 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mawkgram.c:8822:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8822 |         if (*list == NULL)      /* error earlier */[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 8823 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:8829:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8829 |                 if (isarg && t1 == t2 && t1->opcode == Op_push)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 8830 |                         t1->opcode = Op_push_param;[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:8831:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8831 |                 if (++count == 1)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 8832 |                         r = expr;[0m
 8833 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:8833:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8833 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 8834 |                         (void) list_merge(r, expr);[0m
      | [0;1;32m                                                   
[0m[1mawkgram.c:8839:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8839 |         if (! isarg && count > max_args)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 8840 |                 max_args = count;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:8858:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8858 |                         if (ip->target_jmp == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 8859 |                                 ip->target_jmp = b_target;[0m
 8860 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mawkgram.c:8858:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8858 |                         if (ip->target_jmp == NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 8859 |                                 ip->target_jmp = b_target;[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:8863:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8863 |                         if (ip->target_jmp == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 8864 |                                 ip->target_jmp = c_target;[0m
 8865 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mawkgram.c:8863:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8863 |                         if (ip->target_jmp == NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 8864 |                                 ip->target_jmp = c_target;[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:8869:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 8869 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mawkgram.c:8943:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8943 |         if (do_traditional)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 8944 |                 non_standard_flags |= GAWKX;[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:8945:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8945 |         if (do_posix)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 8946 |                 non_standard_flags |= NOT_POSIX;[0m
      | [0;1;32m                                                
[0m[1mawkgram.c:8953:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8953 |                 if (i == 0)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 8954 |                         i = strcmp(name, tokentab[mid].operator);[0m
      | [0;1;32m                                                                 
[0m[1mawkgram.c:8956:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8956 |                 if (i < 0)              /* token < mid */[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 8957 |                         high = mid - 1;[0m
 8958 |                 else if (i > 0)         /* token > mid */[0m
      | [0;32m                } 
[0m[1mawkgram.c:8958:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8958 |                 else if (i > 0)         /* token > mid */[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 8959 |                         low = mid + 1;[0m
 8960 |                 else {[0m
      | [0;32m                } 
[0m[1mawkgram.c:8961:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8961 |                         if ((tokentab[mid].flags & non_standard_flags) != 0)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 8962 |                                 return -1;[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:8993:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 8993 |         if (fgets(buf, sizeof buf, fp) == NULL)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 8994 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mawkgram.c:9007:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9007 |         if (fp == NULL || fd != fileno(fp))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 9008 |                 fatal("debugging read/close screwed up!");[0m
      | [0;1;32m                                                          
[0m[1mawkgram.c:9021:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9021 |         if (strncmp(name, "awk::", 5) == 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 9022 |                 name += 5;[0m
      | [0;1;32m                          
[0m[1mawkgram.c:9026:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9026 |         if (mid == -1)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 9027 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mawkgram.c:9034:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 9034 |                 return NULL;[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mawkgram.c:9038:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9038 |         if (tokentab[mid].value == Op_sub_builtin)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 9039 |                 return (builtin_func_t) do_sub;[0m
      | [0;1;32m                                               
[0m[1mawkgram.c:9057:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9057 |         if (do_traditional)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 9058 |                 flags_that_must_be_clear |= GAWKX;[0m
      | [0;1;32m                                                  
[0m[1mawkgram.c:9060:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9060 |         if (do_posix)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 9061 |                 flags_that_must_be_clear |= NOT_POSIX;[0m
      | [0;1;32m                                                      
[0m[1mawkgram.c:9178:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9178 |         if (c1->comment == NULL && c2 == NULL)  // nothing to do[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 9179 |                 return;[0m
      | [0;1;32m                       
[0m[1mawkgram.c:9182:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9182 |         if (c1->comment != NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 9183 |                 total += 1 /* \n */ + c1->comment->memory->stlen;[0m
      | [0;1;32m                                                                 
[0m[1mawkgram.c:9188:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9188 |                 if (c2->comment != NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 9189 |                         total += c2->comment->memory->stlen + 1;[0m
      | [0;1;32m                                                                
[0m[1mawkgram.c:9237:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9237 |         if (stmts == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 9238 |                 ip = list_create(instruction(Op_no_op));[0m
 9239 |         else[0m
      | [0;32m        } 
[0m[1mawkgram.c:9239:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9239 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 9240 |                 ip = stmts;[0m
      | [0;1;32m                           
[0m[1mawkgram.c:9267:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9267 |         if ((cp = strchr(token, ':')) == NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 9268 |                 return true;[0m
      | [0;1;32m                            
[0m[1mawkgram.c:9304:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9304 |         if ((cp = strchr(token, ':')) == NULL && current_namespace == awk_namespace)[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m 9305 |                 return check_special(token);[0m
      | [0;1;32m                                            
[0m[1mawkgram.c:9320:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9320 |                 if (i < 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 9321 |                         return i;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:9324:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9324 |                 if ((tok->flags & GAWKX) != 0 && tok->class == LEX_BUILTIN)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 9325 |                         return -1;[0m
 9326 |                 else[0m
      | [0;32m                } 
[0m[1mawkgram.c:9326:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9326 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 9327 |                         return i;[0m
      | [0;1;32m                                 
[0m[1mawkgram.c:9352:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9352 |                         if ((tokentab[i].flags & GAWKX) != 0 && tokentab[i].class == LEX_BUILTIN)[0m
      | [0;1;32m                                                                                                 ^
[0m      | [0;32m                                                                                                  {
[0m 9353 |                                 ;       // gawk additional builtin function, is ok[0m
 9354 |                         else[0m
      | [0;32m                        } 
[0m[1mawkgram.c:9354:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9354 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 9355 |                                 error_ln(sourceline, _("using reserved identifier `%s' as second component of a qualified name is not allowed"), subname);[0m
      | [0;1;32m                                                                                                                                                          
[0m[1mawkgram.c:9357:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9357 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 9358 |                 i = -1;[0m
      | [0;1;32m                       
[0m[1mawkgram.c:9369:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9369 |         if (ns == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 9370 |                 return;[0m
      | [0;1;32m                       
[0m[1mawkgram.c:9420:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9420 |         if (! is_valid_identifier(new_namespace))[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 9421 |                 return;[0m
      | [0;1;32m                       
[0m[1mawkgram.c:9425:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9425 |         if (mid >= 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 9426 |                 return;[0m
      | [0;1;32m                       
[0m[1mawkgram.c:9428:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9428 |         if (strcmp(new_namespace, current_namespace) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 9429 |                 ;       // nothing to do[0m
 9430 |         else if (strcmp(new_namespace, awk_namespace) == 0) {[0m
      | [0;32m        } 
[0m[1mawkgram.c:9444:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9444 |         if (strchr(name, ':') != NULL)  // already qualified[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 9445 |                 return estrdup(name, len);[0m
      | [0;1;32m                                          
[0m[1mawkgram.c:9448:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 9448 |         if (p != NULL && p->type == Node_param_list)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 9449 |                 return estrdup(name, len);[0m
      | [0;1;32m                                          
[0m679 warnings generated.
Suppressed 25 warnings (25 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[28/54][20.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp75vzmq4d.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/localeinfo.c
[1mlocaleinfo.c:70:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   70 |   if (!native_c_charset || multibyte)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m   71 |     return false;[0m
      | [0;1;32m                 
[0m[1mlocaleinfo.c:79:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   79 |   for (int i = 0; i < UCHAR_MAX; i++)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m   80 |     if (0 <= strcoll (((char []) {i, 0}), ((char []) {i + 1, 0})))[0m
   81 |       return false;[0m
      | [0;1;32m                   
[0m[1mlocaleinfo.c:80:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   80 |     if (0 <= strcoll (((char []) {i, 0}), ((char []) {i + 1, 0})))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m   81 |       return false;[0m
      | [0;1;32m                   
[0m[1mlocaleinfo.c:140:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  140 |   if (uc != c)[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  141 |     folded[n++] = uc;[0m
      | [0;1;32m                     
[0m[1mlocaleinfo.c:142:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  142 |   if (lc != uc && lc != c && towupper (lc) == uc)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  143 |     folded[n++] = lc;[0m
      | [0;1;32m                     
[0m[1mlocaleinfo.c:147:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  147 |       if (li != lc && li != uc && li != c && towupper (li) == uc)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  148 |         folded[n++] = li;[0m
      | [0;1;32m                         
[0m8 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[29/54][18.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpfhwijina.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/random.c
[1mrandom.c:294:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  294 |         if (x == 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  295 |                 x = 123459876;[0m
      | [0;1;32m                              
[0m[1mrandom.c:299:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  299 |         if (x < 0)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  300 |                 x += 0x7fffffff;[0m
      | [0;1;32m                                
[0m[1mrandom.c:325:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  325 |         if (rand_type == TYPE_0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  326 |                 lim = NSHUFF;[0m
  327 |         else {[0m
      | [0;32m        } 
[0m[1mrandom.c:328:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  328 |                 for (i = 1; i < rand_deg; i++)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  329 |                         state[i] = good_rand(state[i - 1]);[0m
      | [0;1;32m                                                           
[0m[1mrandom.c:334:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  334 |         for (i = 0; i < lim; i++)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  335 |                 (void)random();[0m
      | [0;1;32m                               
[0m[1mrandom.c:417:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  417 |         if (rand_type == TYPE_0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  418 |                 state[-1] = rand_type;[0m
  419 |         else[0m
      | [0;32m        } 
[0m[1mrandom.c:419:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  419 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  420 |                 state[-1] = MAX_TYPES * (rptr - state) + rand_type;[0m
      | [0;1;32m                                                                   
[0m[1mrandom.c:422:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  422 |                 (void)fprintf(stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mrandom.c:422:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  422 |                 (void)fprintf(stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mrandom.c:450:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  450 |         if (rand_type == TYPE_0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  451 |                 int_arg_state[0] = rand_type;[0m
  452 |         else[0m
      | [0;32m        } 
[0m[1mrandom.c:452:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  452 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  453 |                 int_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;[0m
      | [0;1;32m                                                                          
[0m[1mrandom.c:484:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  484 |         if (rand_type == TYPE_0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  485 |                 state[-1] = rand_type;[0m
  486 |         else[0m
      | [0;32m        } 
[0m[1mrandom.c:486:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  486 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  487 |                 state[-1] = MAX_TYPES * (rptr - state) + rand_type;[0m
      | [0;1;32m                                                                   
[0m[1mrandom.c:495:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  495 |                 rand_deg = degrees[type];[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  496 |                 rand_sep = seps[type];[0m
  497 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrandom.c:499:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  499 |                 (void)fprintf(stderr,[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  500 |                     "random: state info corrupted; not changed.\n");[0m
      | [0;1;32m                                                                   
[0m      | [0;32m                                                                   ;} 
[0m[1mrandom.c:499:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  499 |                 (void)fprintf(stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mrandom.c:499:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  499 |                 (void)fprintf(stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mrandom.c:623:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  623 |                 for (k = 0; k < SHUFFLE_MAX; k++)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  624 |                         shuffle_buffer[k] = random_old();[0m
      | [0;1;32m                                                         
[0m18 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[30/54][18.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp0bo12ck_.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/inplace.c
[1minplace.c:130:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  130 |         if (state.tname)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  131 |                 fatal(ext_id, _("inplace::begin: in-place editing already active"));[0m
      | [0;1;32m                                                                                    
[0m[1minplace.c:133:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  133 |         if (nargs != 2)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  134 |                 fatal(ext_id, _("inplace::begin: expects 2 arguments but called with %d"), nargs);[0m
      | [0;1;32m                                                                                                  
[0m[1minplace.c:136:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  136 |         if (! get_argument(0, AWK_STRING, &filename))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  137 |                 fatal(ext_id, _("inplace::begin: cannot retrieve 1st argument as a string filename"));[0m
      | [0;1;32m                                                                                                      
[0m[1minplace.c:167:2: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  167 |         sprintf(state.tname, "%s.gawk.XXXXXX", filename.str_value.str);[0m
      | [0;1;32m        ^~~~~~~
[0m[1minplace.c:167:2: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  167 |         sprintf(state.tname, "%s.gawk.XXXXXX", filename.str_value.str);[0m
      | [0;1;32m        ^~~~~~~
[0m[1minplace.c:169:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  169 |         if ((fd = mkstemp(state.tname)) < 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  170 |                 fatal(ext_id, _("inplace::begin: mkstemp(`%s') failed (%s)"),[0m
  171 |                         state.tname, strerror(errno));[0m
      | [0;1;32m                                                      
[0m[1minplace.c:176:7: [0m[0;1;35mwarning: [0m[1mvariable 'junk' set but not used [clang-diagnostic-unused-but-set-variable][0m
  176 |                 int junk;[0m
      | [0;1;32m                    ^
[0m[1minplace.c:181:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  181 |         if (chmod(state.tname, sbuf.st_mode) < 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  182 |                 fatal(ext_id, _("inplace::begin: chmod failed (%s)"),[0m
  183 |                         strerror(errno));[0m
      | [0;1;32m                                         
[0m[1minplace.c:188:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  188 |         if ((state.default_stdout = dup(STDOUT_FILENO)) < 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  189 |                 fatal(ext_id, _("inplace::begin: dup(stdout) failed (%s)"),[0m
  190 |                         strerror(errno));[0m
      | [0;1;32m                                         
[0m[1minplace.c:191:6: [0m[0;1;35mwarning: [0m[1mThe 1st argument to 'dup2' is -1 but should be >= 0 [clang-analyzer-unix.StdCLibraryFunctions][0m
  191 |         if (dup2(fd, STDOUT_FILENO) < 0)[0m
      | [0;1;32m            ^    ~~
[0m[1minplace.c:130:6: [0m[0;1;36mnote: [0mAssuming field 'tname' is null[0m
  130 |         if (state.tname)[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1minplace.c:130:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  130 |         if (state.tname)[0m
      | [0;1;32m        ^
[0m[1minplace.c:133:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is equal to 2[0m
  133 |         if (nargs != 2)[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1minplace.c:133:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  133 |         if (nargs != 2)[0m
      | [0;1;32m        ^
[0m[1minplace.c:136:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  136 |         if (! get_argument(0, AWK_STRING, &filename))[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1minplace.c:136:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  136 |         if (! get_argument(0, AWK_STRING, &filename))[0m
      | [0;1;32m        ^
[0m[1minplace.c:144:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  144 |         if (invalid_filename(&filename.str_value)) {[0m
      | [0;1;32m        ^
[0m[1minplace.c:151:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  151 |         if (stat(filename.str_value.str, & sbuf) < 0) {[0m
      | [0;1;32m        ^
[0m[1minplace.c:158:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  158 |         if (! S_ISREG(sbuf.st_mode)) {[0m
      | [0;1;32m              ^
[0m[1m/usr/include/x86_64-linux-gnu/sys/stat.h:128:24: [0m[0;1;36mnote: [0mexpanded from macro 'S_ISREG'[0m
  128 | #define S_ISREG(mode)    __S_ISTYPE((mode), __S_IFREG)[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/x86_64-linux-gnu/sys/stat.h:123:33: [0m[0;1;36mnote: [0mexpanded from macro '__S_ISTYPE'[0m
  123 | #define __S_ISTYPE(mode, mask)  (((mode) & __S_IFMT) == (mask))[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1minplace.c:158:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  158 |         if (! S_ISREG(sbuf.st_mode)) {[0m
      | [0;1;32m        ^
[0m[1minplace.c:166:2: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  166 |         emalloc(state.tname, char *, filename.str_value.len+14, "do_inplace_begin");[0m
      | [0;1;32m        ^
[0m[1m./../gawkapi.h:964:7: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  964 |                 if ((pointer = (type) gawk_malloc(size)) == 0) \[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1minplace.c:166:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  166 |         emalloc(state.tname, char *, filename.str_value.len+14, "do_inplace_begin");[0m
      | [0;1;32m        ^
[0m[1m./../gawkapi.h:964:3: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  964 |                 if ((pointer = (type) gawk_malloc(size)) == 0) \[0m
      | [0;1;32m                ^
[0m[1minplace.c:166:2: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  166 |         emalloc(state.tname, char *, filename.str_value.len+14, "do_inplace_begin");[0m
      | [0;1;32m        ^
[0m[1m./../gawkapi.h:963:2: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  963 |         do { \[0m
      | [0;1;32m        ^
[0m[1minplace.c:169:12: [0m[0;1;36mnote: [0mAssuming that 'mkstemp' fails[0m
  169 |         if ((fd = mkstemp(state.tname)) < 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~
[0m[1minplace.c:169:7: [0m[0;1;36mnote: [0mValue assigned to 'fd'[0m
  169 |         if ((fd = mkstemp(state.tname)) < 0)[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1minplace.c:169:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  169 |         if ((fd = mkstemp(state.tname)) < 0)[0m
      | [0;1;32m        ^
[0m[1minplace.c:174:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  174 |         if (chown(state.tname, sbuf.st_uid, sbuf.st_gid) < 0) {[0m
      | [0;1;32m        ^
[0m[1minplace.c:181:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  181 |         if (chmod(state.tname, sbuf.st_mode) < 0)[0m
      | [0;1;32m        ^
[0m[1minplace.c:188:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  188 |         if ((state.default_stdout = dup(STDOUT_FILENO)) < 0)[0m
      | [0;1;32m        ^
[0m[1minplace.c:191:6: [0m[0;1;36mnote: [0mThe 1st argument to 'dup2' is -1 but should be >= 0[0m
  191 |         if (dup2(fd, STDOUT_FILENO) < 0)[0m
      | [0;1;32m            ^    ~~
[0m[1minplace.c:191:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  191 |         if (dup2(fd, STDOUT_FILENO) < 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  192 |                 fatal(ext_id, _("inplace::begin: dup2(%d, stdout) failed (%s)"),[0m
  193 |                         fd, strerror(errno));[0m
      | [0;1;32m                                             
[0m[1minplace.c:194:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  194 |         if (close(fd) < 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  195 |                 fatal(ext_id, _("inplace::begin: close(%d) failed (%s)"),[0m
  196 |                         fd, strerror(errno));[0m
      | [0;1;32m                                             
[0m[1minplace.c:210:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  210 |         if (nargs != 2)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  211 |                 fatal(ext_id, _("inplace::end: expects 2 arguments but called with %d"), nargs);[0m
      | [0;1;32m                                                                                                
[0m[1minplace.c:213:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  213 |         if (! get_argument(0, AWK_STRING, &filename))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  214 |                 fatal(ext_id, _("inplace::end: cannot retrieve 1st argument as a string filename"));[0m
      | [0;1;32m                                                                                                    
[0m[1minplace.c:216:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  216 |         if (! get_argument(1, AWK_STRING, &suffix))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  217 |                 suffix.str_value.str = NULL;[0m
      | [0;1;32m                                            
[0m[1minplace.c:220:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  220 |                 if (! invalid_filename(&filename.str_value))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  221 |                         warning(ext_id, _("inplace::end: in-place editing not active"));[0m
      | [0;1;32m                                                                                        
[0m[1minplace.c:226:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  226 |         if (dup2(state.default_stdout, STDOUT_FILENO) < 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  227 |                 fatal(ext_id, _("inplace::end: dup2(%d, stdout) failed (%s)"),[0m
  228 |                         state.default_stdout, strerror(errno));[0m
      | [0;1;32m                                                               
[0m[1minplace.c:229:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  229 |         if (close(state.default_stdout) < 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  230 |                 fatal(ext_id, _("inplace::end: close(%d) failed (%s)"),[0m
  231 |                         state.default_stdout, strerror(errno));[0m
      | [0;1;32m                                                               
[0m[1minplace.c:233:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  233 |         if (state.posrc == 0 && fsetpos(stdout, &state.pos) < 0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  234 |                 fatal(ext_id, _("inplace::end: fsetpos(stdout) failed (%s)"),[0m
  235 |                         strerror(errno));[0m
      | [0;1;32m                                         
[0m[1minplace.c:243:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  243 |                 sprintf(bakname, "%s%s",[0m
      | [0;1;32m                ^~~~~~~
[0m[1minplace.c:243:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  243 |                 sprintf(bakname, "%s%s",[0m
      | [0;1;32m                ^~~~~~~
[0m[1minplace.c:246:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  246 |                 if (link(filename.str_value.str, bakname) < 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  247 |                         fatal(ext_id, _("inplace::end: link(`%s', `%s') failed (%s)"),[0m
  248 |                                 filename.str_value.str, bakname, strerror(errno));[0m
      | [0;1;32m                                                                                  
[0m[1minplace.c:256:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  256 |         if (rename(state.tname, filename.str_value.str) < 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  257 |                 fatal(ext_id, _("inplace::end: rename(`%s', `%s') failed (%s)"),[0m
  258 |                         state.tname, filename.str_value.str, strerror(errno));[0m
      | [0;1;32m                                                                              
[0m[1minplace.c:279:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  279 | dl_load_func(func_table, inplace, "inplace")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1minplace.c:279:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  279 | dl_load_func(func_table, inplace, "inplace")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m38 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[31/54][28.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpogka8aac.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/ext.c
[1mext.c:50:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   50 |         if (do_sandbox)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m   51 |                 fatal(_("extensions are not allowed in sandbox mode"));[0m
      | [0;1;32m                                                                       
[0m[1mext.c:53:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   53 |         if (do_traditional || do_posix)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m   54 |                 fatal(_("-l / @load are gawk extensions"));[0m
      | [0;1;32m                                                           
[0m[1mext.c:56:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   56 |         if (lib_name == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m   57 |                 fatal(_("load_ext: received NULL lib_name"));[0m
      | [0;1;32m                                                             
[0m[1mext.c:59:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   59 |         if ((dl = dlopen(lib_name, flags)) == NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m   60 |                 fatal(_("load_ext: cannot open library `%s': %s"), lib_name,[0m
   61 |                       dlerror());[0m
      | [0;1;32m                                 
[0m[1mext.c:65:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   65 |         if (gpl_compat == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m   66 |                 fatal(_("load_ext: library `%s': does not define `plugin_is_GPL_compatible': %s"),[0m
   67 |                                 lib_name, dlerror());[0m
      | [0;1;32m                                                     
[0m[1mext.c:71:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   71 |         if (install_func == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m   72 |                 fatal(_("load_ext: library `%s': cannot call function `%s': %s"),[0m
   73 |                                 lib_name, INIT_FUNC, dlerror());[0m
      | [0;1;32m                                                                
[0m[1mext.c:75:6: [0m[0;1;35mwarning: [0m[1mCalled function pointer is null (null dereference) [clang-analyzer-core.CallAndMessage][0m
   75 |         if (install_func(& api_impl, NULL /* ext_id */) == 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mext.c:50:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   50 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mext.c:50:2: [0m[0;1;36mnote: [0mTaking false branch[0m
   50 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mext.c:53:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   53 |         if (do_traditional || do_posix)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1178:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_traditional'[0m
 1178 | #define do_traditional      (do_flags & DO_TRADITIONAL)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mext.c:53:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
   53 |         if (do_traditional || do_posix)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1178:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_traditional'[0m
 1178 | #define do_traditional      (do_flags & DO_TRADITIONAL)[0m
      | [0;1;32m                            ^
[0m[1mext.c:53:24: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   53 |         if (do_traditional || do_posix)[0m
      | [0;1;32m                              ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mext.c:53:2: [0m[0;1;36mnote: [0mTaking false branch[0m
   53 |         if (do_traditional || do_posix)[0m
      | [0;1;32m        ^
[0m[1mext.c:56:6: [0m[0;1;36mnote: [0mAssuming 'lib_name' is not equal to NULL[0m
   56 |         if (lib_name == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~
[0m[1mext.c:56:2: [0m[0;1;36mnote: [0mTaking false branch[0m
   56 |         if (lib_name == NULL)[0m
      | [0;1;32m        ^
[0m[1mext.c:59:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   59 |         if ((dl = dlopen(lib_name, flags)) == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mext.c:59:2: [0m[0;1;36mnote: [0mTaking false branch[0m
   59 |         if ((dl = dlopen(lib_name, flags)) == NULL)[0m
      | [0;1;32m        ^
[0m[1mext.c:65:6: [0m[0;1;36mnote: [0mAssuming 'gpl_compat' is not equal to NULL[0m
   65 |         if (gpl_compat == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~
[0m[1mext.c:65:2: [0m[0;1;36mnote: [0mTaking false branch[0m
   65 |         if (gpl_compat == NULL)[0m
      | [0;1;32m        ^
[0m[1mext.c:69:2: [0m[0;1;36mnote: [0mValue assigned to 'install_func'[0m
   69 |         install_func = (int (*)(const gawk_api_t *const, awk_ext_id_t))[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m   70 |                                 dlsym(dl, INIT_FUNC);[0m
      | [0;1;32m                                ~~~~~~~~~~~~~~~~~~~~
[0m[1mext.c:71:6: [0m[0;1;36mnote: [0mAssuming 'install_func' is equal to NULL[0m
   71 |         if (install_func == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mext.c:71:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   71 |         if (install_func == NULL)[0m
      | [0;1;32m        ^
[0m[1mext.c:75:6: [0m[0;1;36mnote: [0mCalled function pointer is null (null dereference)[0m
   75 |         if (install_func(& api_impl, NULL /* ext_id */) == 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mext.c:75:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   75 |         if (install_func(& api_impl, NULL /* ext_id */) == 0)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m   76 |                 warning(_("load_ext: library `%s' initialization routine `%s' failed"),[0m
   77 |                                 lib_name, INIT_FUNC);[0m
      | [0;1;32m                                                     
[0m[1mext.c:91:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   91 |         if (name == NULL || *name == '\0')[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m   92 |                 fatal(_("make_builtin: missing function name"));[0m
      | [0;1;32m                                                                
[0m[1mext.c:94:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   94 |         if (! is_valid_identifier(name))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m   95 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mext.c:99:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   99 |                 if (check_special(name) >= 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  100 |                         fatal(_("make_builtin: cannot use gawk built-in `%s' as function name"), name);[0m
      | [0;1;32m                                                                                                       
[0m[1mext.c:105:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  105 |                 if (! is_valid_identifier(name_space))[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  106 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mext.c:108:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  108 |                 if (check_special(name_space) >= 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  109 |                         fatal(_("make_builtin: cannot use gawk built-in `%s' as namespace name"), name_space);[0m
      | [0;1;32m                                                                                                              
[0m[1mext.c:110:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  110 |                 if (check_special(name) >= 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  111 |                         fatal(_("make_builtin: cannot use gawk built-in `%s' as function name"), name);[0m
      | [0;1;32m                                                                                                       
[0m[1mext.c:116:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  116 |                 sprintf(buf, "%s::%s", name_space, name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mext.c:116:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  116 |                 sprintf(buf, "%s::%s", name_space, name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mext.c:129:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  129 |                         if (do_lint)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  130 |                                 lintwarn(_("make_builtin: function `%s' already defined"), name);[0m
      | [0;1;32m                                                                                                 
[0m[1mext.c:133:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  133 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  134 |                         /* variable name etc. */[0m
  135 |                         fatal(_("make_builtin: function name `%s' previously defined"), name);[0m
      | [0;1;32m                                                                                              
[0m[1mext.c:138:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  138 |         if (count < 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  139 |                 fatal(_("make_builtin: negative argument count for function `%s'"),[0m
  140 |                                 name);[0m
      | [0;1;32m                                      
[0m[1mext.c:166:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  166 |         if (i < 0 || i >= arg_count)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  167 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mext.c:170:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  170 |         if (t->type == Node_param_list)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  171 |                 t = GET_PARAM(t->param_cnt);[0m
      | [0;1;32m                                            
[0m[1mext.c:182:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  182 |         if (t->type == Node_var)        /* See Case Node_var in setup_frame(), eval.c */[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  183 |                 return Nnull_string;[0m
      | [0;1;32m                                    
[0m[1mext.c:204:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  204 |                 if (want_array)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  205 |                         return force_array(t, false);[0m
  206 |                 else {[0m
      | [0;32m                } 
[0m[1mext.c:214:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  214 |                 if (t->type != Node_var_array)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  215 |                         fatal(_("function `%s': argument #%d: attempt to use scalar as an array"),[0m
  216 |                                 fname, i + 1);[0m
      | [0;1;32m                                              
[0m[1mext.c:218:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  218 |                 if (t->type != Node_val)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  219 |                         fatal(_("function `%s': argument #%d: attempt to use array as a scalar"),[0m
  220 |                                 fname, i + 1);[0m
      | [0;1;32m                                              
[0m[1mext.c:244:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  244 |         if (srcfiles == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  245 |                 return;[0m
      | [0;1;32m                       
[0m[1mext.c:247:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  247 |         for (s = srcfiles->next; s != srcfiles; s = s->next)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  248 |                 if (s->stype == SRC_EXTLIB && s->fini_func)[0m
  249 |                         (*s->fini_func)();[0m
      | [0;1;32m                                          
[0m[1mext.c:248:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  248 |                 if (s->stype == SRC_EXTLIB && s->fini_func)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  249 |                         (*s->fini_func)();[0m
      | [0;1;32m                                          
[0m[1mext.c:260:18: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'sp') [clang-analyzer-core.NullDereference][0m
  260 |         if (! is_letter(*sp))[0m
      | [0;1;32m                        ^
[0m[1mext.c:87:2: [0m[0;1;36mnote: [0m'name' initialized here[0m
   87 |         const char *name = funcinfo->name;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~
[0m[1mext.c:91:6: [0m[0;1;36mnote: [0mAssuming 'name' is equal to NULL[0m
   91 |         if (name == NULL || *name == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mext.c:91:19: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
   91 |         if (name == NULL || *name == '\0')[0m
      | [0;1;32m                         ^
[0m[1mext.c:94:28: [0m[0;1;36mnote: [0mPassing null pointer value via 1st parameter 'name'[0m
   94 |         if (! is_valid_identifier(name))[0m
      | [0;1;32m                                  ^~~~
[0m[1mext.c:94:8: [0m[0;1;36mnote: [0mCalling 'is_valid_identifier'[0m
   94 |         if (! is_valid_identifier(name))[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mext.c:257:2: [0m[0;1;36mnote: [0m'sp' initialized to a null pointer value[0m
  257 |         const char *sp = name;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~
[0m[1mext.c:260:18: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'sp')[0m
  260 |         if (! is_letter(*sp))[0m
      | [0;1;32m                        ^~~
[0m[1mext.c:260:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  260 |         if (! is_letter(*sp))[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  261 |                 return false;[0m
      | [0;1;32m                             
[0m[1mext.c:264:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  264 |                 if (! is_identchar(c))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  265 |                         return false;[0m
      | [0;1;32m                                     
[0m60 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[32/54][44.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpjux3ayfe.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/msg.c
[1mmsg.c:58:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   58 |                         if (n != NULL && n->type == Node_var)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m   59 |                                 lineno_val = get_number_d(n->var_value);[0m
      | [0;1;32m                                                                        
[0m[1mmsg.c:65:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   65 |         (void) fprintf(stderr, "%s: ", me);[0m
      | [0;1;32m               ^~~~~~~
[0m[1mmsg.c:65:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   65 |         (void) fprintf(stderr, "%s: ", me);[0m
      | [0;1;32m               ^~~~~~~
[0m[1mmsg.c:68:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   68 |                 fprintf(stderr, "%s:%d:", srcfile, srcline);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmsg.c:68:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   68 |                 fprintf(stderr, "%s:%d:", srcfile, srcline);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmsg.c:73:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   73 |                 if (source != NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m   74 |                         (void) fprintf(stderr, "%s:", source);[0m
   75 |                 else[0m
      | [0;32m                } 
[0m[1mmsg.c:74:11: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   74 |                         (void) fprintf(stderr, "%s:", source);[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mmsg.c:74:11: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   74 |                         (void) fprintf(stderr, "%s:", source);[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mmsg.c:75:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   75 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m   76 |                         (void) fprintf(stderr, _("cmd. line:"));[0m
      | [0;1;32m                                                                
[0m[1mmsg.c:76:11: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   76 |                         (void) fprintf(stderr, _("cmd. line:"));[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mmsg.c:76:11: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   76 |                         (void) fprintf(stderr, _("cmd. line:"));[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mmsg.c:78:10: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   78 |                 (void) fprintf(stderr, "%ld: ", sourceline + lineno_val);[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mmsg.c:78:10: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   78 |                 (void) fprintf(stderr, "%ld: ", sourceline + lineno_val);[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mmsg.c:100:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  100 |                 if (file)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  101 |                         (void) fprintf(stderr, "FILENAME=%.*s ", len, file);[0m
      | [0;1;32m                                                                            
[0m[1mmsg.c:101:11: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  101 |                         (void) fprintf(stderr, "FILENAME=%.*s ", len, file);[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mmsg.c:101:11: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  101 |                         (void) fprintf(stderr, "FILENAME=%.*s ", len, file);[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mmsg.c:102:10: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  102 |                 (void) fprintf(stderr, "FNR=%ld) ", FNR);[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mmsg.c:102:10: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  102 |                 (void) fprintf(stderr, "FNR=%ld) ", FNR);[0m
      | [0;1;32m                       ^~~~~~~
[0m[1mmsg.c:105:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  105 |         (void) fprintf(stderr, "%s", s);[0m
      | [0;1;32m               ^~~~~~~
[0m[1mmsg.c:105:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  105 |         (void) fprintf(stderr, "%s", s);[0m
      | [0;1;32m               ^~~~~~~
[0m[1mmsg.c:107:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  107 |         (void) fprintf(stderr, "\n");[0m
      | [0;1;32m               ^~~~~~~
[0m[1mmsg.c:107:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  107 |         (void) fprintf(stderr, "\n");[0m
      | [0;1;32m               ^~~~~~~
[0m[1mmsg.c:110:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  110 |         if (isfatal)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  111 |                 gawk_exit(EXIT_FATAL);[0m
      | [0;1;32m                                      
[0m[1mmsg.c:155:2: [0m[0;1;35mwarning: [0m[1mValue stored to 'file' is never read [clang-analyzer-deadcode.DeadStores][0m
  155 |         file = srcfile; line = srcline;[0m
      | [0;1;32m        ^      ~~~~~~~
[0m[1mmsg.c:155:2: [0m[0;1;36mnote: [0mValue stored to 'file' is never read[0m
  155 |         file = srcfile; line = srcline;[0m
      | [0;1;32m        ^      ~~~~~~~
[0m[1mmsg.c:155:18: [0m[0;1;35mwarning: [0m[1mValue stored to 'line' is never read [clang-analyzer-deadcode.DeadStores][0m
  155 |         file = srcfile; line = srcline;[0m
      | [0;1;32m                        ^      ~~~~~~~
[0m[1mmsg.c:155:18: [0m[0;1;36mnote: [0mValue stored to 'line' is never read[0m
  155 |         file = srcfile; line = srcline;[0m
      | [0;1;32m                        ^      ~~~~~~~
[0m46 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[33/54][64.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpgffqd8ez.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/testext.c
[1mtestext.c:77:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
   77 |                 strcpy(buf, "<undefined>");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m   78 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:80:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
   80 |                 strcpy(buf, "<array>");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m   81 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:83:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
   83 |                 strcpy(buf, "<scalar>");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m   84 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:86:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
   86 |                 strcpy(buf, "<value-cookie>");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m   87 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:91:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   91 |                 if (value->str_value.len < size)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m   92 |                         size = value->str_value.len;[0m
      | [0;1;32m                                                    
[0m[1mtestext.c:93:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   93 |                 sprintf(buf, "\"%.*s\"",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:93:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
   93 |                 sprintf(buf, "\"%.*s\"",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:93:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
   93 |                 sprintf(buf, "\"%.*s\"",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m   94 |                                 size,[0m
   95 |                                 value->str_value.str);[0m
   96 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:98:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
   98 |                 if (value->str_value.len + 8 < size)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m   99 |                         size = value->str_value.len;[0m
  100 |                 sprintf(buf, "<bool>: %.*s",[0m
  101 |                                 size,[0m
  102 |                                 value->str_value.str);[0m
  103 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:98:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   98 |                 if (value->str_value.len + 8 < size)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m   99 |                         size = value->str_value.len;[0m
      | [0;1;32m                                                    
[0m[1mtestext.c:100:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  100 |                 sprintf(buf, "<bool>: %.*s",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:100:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  100 |                 sprintf(buf, "<bool>: %.*s",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:105:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  105 |                 sprintf(buf, "%g", value->num_value);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:105:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  105 |                 sprintf(buf, "%g", value->num_value);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:105:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  105 |                 sprintf(buf, "%g", value->num_value);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  106 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mtestext.c:153:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  153 |                 if (sym_lookup(name, AWK_ARRAY, & value2))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  154 |                         printf("dump_array_and_delete: sym_lookup of %s passed\n", name);[0m
  155 |                 else {[0m
      | [0;32m                } 
[0m[1mtestext.c:245:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  245 |         if (sym_lookup("ENVIRON", AWK_ARRAY, & value))[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  246 |                 printf("try_modify_environ: sym_lookup of ENVIRON passed\n");[0m
  247 |         else {[0m
      | [0;32m        } 
[0m[1mtestext.c:331:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  331 |         if (sym_lookup("PROCINFO", AWK_ARRAY, & value))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  332 |                 printf("var_test: sym_lookup of PROCINFO passed - got a value!\n");[0m
  333 |         else[0m
      | [0;32m        } 
[0m[1mtestext.c:333:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  333 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  334 |                 printf("var_test: sym_lookup of PROCINFO failed - did not get a value\n");[0m
      | [0;1;32m                                                                                          
[0m[1mtestext.c:337:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  337 |         if (sym_lookup("ARGC", AWK_NUMBER, & value))[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  338 |                 printf("var_test: sym_lookup of ARGC passed - got a value!\n");[0m
  339 |         else[0m
      | [0;32m        } 
[0m[1mtestext.c:339:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  339 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  340 |                 printf("var_test: sym_lookup of ARGC failed - did not get a value\n");[0m
      | [0;1;32m                                                                                      
[0m[1mtestext.c:344:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  344 |         if (sym_update("ARGC", & value))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  345 |                 printf("var_test: sym_update of ARGC passed and should not have!\n");[0m
  346 |         else[0m
      | [0;32m        } 
[0m[1mtestext.c:346:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  346 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  347 |                 printf("var_test: sym_update of ARGC failed - correctly\n");[0m
      | [0;1;32m                                                                            
[0m[1mtestext.c:908:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  908 |         if (sym_lookup(name, AWK_NUMBER, & value))[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  909 |                 printf("test_indirect_var: sym_lookup of %s passed\n", name);[0m
  910 |         else {[0m
      | [0;32m        } 
[0m[1mtestext.c:1021:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1021 |                 if (ibuf->name)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1022 |                         set_array_element(res.array_cookie,[0m
 1023 |                                           make_const_string("input_name", 10, & idx),[0m
 1024 |                                           make_const_string(ibuf->name, strlen(ibuf->name), & val));[0m
      | [0;1;32m                                                                                                    
[0m[1mtestext.c:1032:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1032 |                 if (obuf->name)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1033 |                         set_array_element(res.array_cookie,[0m
 1034 |                                           make_const_string("output_name", 11, & idx),[0m
 1035 |                                           make_const_string(obuf->name, strlen(obuf->name), & val));[0m
      | [0;1;32m                                                                                                    
[0m[1mtestext.c:1072:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1072 |         if (populate_array(a_cookie) < 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1073 |                 return;[0m
      | [0;1;32m                       
[0m[1mtestext.c:1087:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1087 |         if (! sym_update("new_array", & value))[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1088 |                 printf("create_new_array: sym_update(\"new_array\") failed!\n");[0m
      | [0;1;32m                                                                                
[0m[1mtestext.c:1096:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1096 |         if (data)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1097 |                 printf(" data = %p,", data);[0m
 1098 |         else[0m
      | [0;32m        } 
[0m[1mtestext.c:1098:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1098 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1099 |                 printf(" data = NULL,");[0m
      | [0;1;32m                                        
[0m[1mtestext.c:1112:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1112 |                 if (data == & data_for_1)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1113 |                         printf(" (data is & data_for_1),");[0m
 1114 |                 else[0m
      | [0;32m                } 
[0m[1mtestext.c:1114:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1114 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1115 |                         printf(" (data is NOT & data_for_1),");[0m
      | [0;1;32m                                                               
[0m[1mtestext.c:1117:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1117 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1118 |                 printf(" data = NULL,");[0m
      | [0;1;32m                                        
[0m[1mtestext.c:1127:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1127 |         if (data)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1128 |                 printf(" data = %p,", data);[0m
 1129 |         else[0m
      | [0;32m        } 
[0m[1mtestext.c:1129:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1129 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1130 |                 printf(" data = NULL,");[0m
      | [0;1;32m                                        
[0m[1mtestext.c:1177:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1177 |         if (sym_lookup("TESTEXT_QUIET", AWK_NUMBER, & value))[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1178 |                 return awk_true;[0m
      | [0;1;32m                                
[0m[1mtestext.c:1199:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1199 |         if (! sym_update("answer_num", make_number(42, & value)))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 1200 |                 printf("testext: sym_update(\"answer_num\") failed!\n");[0m
      | [0;1;32m                                                                        
[0m[1mtestext.c:1203:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1203 |                         make_const_string(message, strlen(message), & value)))[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1204 |                 printf("testext: sym_update(\"answer_num\") failed!\n");[0m
      | [0;1;32m                                                                        
[0m[1mtestext.c:1207:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1207 |                         make_const_string(message2, strlen(message2), & value)))[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1208 |                 printf("testext: sym_update(\"the_scalar\") failed!\n");[0m
      | [0;1;32m                                                                        
[0m[1mtestext.c:1213:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1213 |                         make_const_string(message3, strlen(message3), & value)))[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1214 |                 printf("testext: sym_update_ns(\"test\", \"testval\") failed!\n");[0m
      | [0;1;32m                                                                                  
[0m[1mtestext.c:1216:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1216 |         if (! add_ext_func("test", & ns_test_func))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1217 |                 printf("testext: add_ext_func(\"test\", ns_test_func) failed!\n");[0m
      | [0;1;32m                                                                                  
[0m[1mtestext.c:1224:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1224 | dl_load_func(func_table, testext, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mtestext.c:1224:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1224 | dl_load_func(func_table, testext, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m45 warnings generated.
Suppressed 5 warnings (5 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[34/54][101.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp0dhb8ewh.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/rwarray.c
[1mrwarray.c:152:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  152 |         if (fp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  153 |                 goto done1;[0m
      | [0;1;32m                           
[0m[1mrwarray.c:155:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  155 |         if (fwrite(MAGIC, 1, strlen(MAGIC), fp) != strlen(MAGIC))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  156 |                 goto done1;[0m
      | [0;1;32m                           
[0m[1mrwarray.c:159:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  159 |         if (fwrite(& major, 1, sizeof(major), fp) != sizeof(major))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  160 |                 goto done1;[0m
      | [0;1;32m                           
[0m[1mrwarray.c:163:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  163 |         if (fwrite(& minor, 1, sizeof(minor), fp) != sizeof(minor))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  164 |                 goto done1;[0m
      | [0;1;32m                           
[0m[1mrwarray.c:231:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  231 |         if (fwrite(& count, 1, sizeof(count), fp) != sizeof(count))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  232 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:258:82: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  258 |         if (fwrite(& indexval_len, 1, sizeof(indexval_len), fp) != sizeof(indexval_len))[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m  259 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:264:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  264 |                 if (write_count != (ssize_t) element->index.str_value.len)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m  265 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:280:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  280 |                 if (fwrite(& code, 1, sizeof(code), fp) != sizeof(code))[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m  281 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:285:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  285 |         if (val->val_type == AWK_NUMBER)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  286 |                 return write_number(fp, val);[0m
      | [0;1;32m                                             
[0m[1mrwarray.c:290:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  290 |                 code = htonl(VT_STRING);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  291 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrwarray.c:293:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  293 |                 code = htonl(VT_STRNUM);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  294 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrwarray.c:296:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  296 |                 code = htonl(VT_REGEX);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  297 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrwarray.c:299:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  299 |                 code = htonl(VT_BOOL);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  300 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrwarray.c:302:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  302 |                 code = htonl(VT_UNDEFINED);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  303 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrwarray.c:306:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  306 |                 code = htonl(VT_UNDEFINED);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  307 |                 warning(ext_id, _("array value has unknown type %d"), val->val_type);[0m
  308 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mrwarray.c:311:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  311 |         if (fwrite(& code, 1, sizeof(code), fp) != sizeof(code))[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  312 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:319:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  319 |                 if (fwrite(& len, 1, sizeof(len), fp) != sizeof(len))[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  320 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:322:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  322 |                 if (fwrite(s, 1, strlen(s), fp) != (ssize_t) strlen(s))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  323 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:326:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  326 |                 if (fwrite(& len, 1, sizeof(len), fp) != sizeof(len))[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  327 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:330:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  330 |                                 != (ssize_t) val->str_value.len)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  331 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:348:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  348 |                 if (fwrite(& code, 1, sizeof(code), fp) != sizeof(code))[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m  349 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:352:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  352 |                 sprintf(buffer, "%.17g", val->num_value);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mrwarray.c:352:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  352 |                 sprintf(buffer, "%.17g", val->num_value);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mrwarray.c:356:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  356 |                 if (fwrite(& network_order_len, 1, sizeof(len), fp) != sizeof(len))[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m  357 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:359:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  359 |                 if (fwrite(buffer, 1, len, fp) != len)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  360 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:412:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  412 |                 destroy_array(v->array_cookie);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  413 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1m./../gawkapi.h:928:30: [0m[0;1;36mnote: [0mexpanded from macro 'destroy_array'[0m
  928 | #define destroy_array(array)    (api->api_destroy_array(ext_id, array))[0m
      | [0;1;32m                                ^
[0m[1mrwarray.c:419:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  419 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mrwarray.c:422:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  422 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mrwarray.c:424:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  424 |                 switch (v->num_type) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mrwarray.c:427:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  427 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mrwarray.c:437:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  437 |                         warning(ext_id, _("cannot free number with unknown type %d"), v->num_type);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  438 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./../gawkapi.h:880:18: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  880 | #define warning         api->api_warning[0m
      | [0;1;32m                        ^
[0m[1mrwarray.c:442:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  442 |                 warning(ext_id, _("cannot free value with unhandled type %d"), v->val_type);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  443 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1m./../gawkapi.h:880:18: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  880 | #define warning         api->api_warning[0m
      | [0;1;32m                        ^
[0m[1mrwarray.c:454:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  454 |         if (e->index.val_type != AWK_STRING)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  455 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:476:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  476 |             && (t.val_type != AWK_UNDEFINED))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  477 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:480:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  480 |                 if (ns[0])[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  481 |                         warning(ext_id, _("readall: unable to set %s::%s"), ns, ident);[0m
  482 |                 else[0m
      | [0;32m                } 
[0m[1mrwarray.c:482:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  482 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  483 |                         warning(ext_id, _("readall: unable to set %s"), ident);[0m
      | [0;1;32m                                                                               
[0m[1mrwarray.c:499:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  499 |         if (fread(& count, 1, sizeof(count), fp) != sizeof(count))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  500 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:506:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  506 |                         if (! do_poke(& new_elem))[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  507 |                                 free_value(& new_elem.value);[0m
      | [0;1;32m                                                             
[0m[1mrwarray.c:508:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  508 |                         if (new_elem.index.str_value.len)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  509 |                                 /* free string allocated by make_const_string */[0m
  510 |                                 gawk_free(new_elem.index.str_value.str);[0m
      | [0;1;32m                                                                        
[0m[1mrwarray.c:511:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  511 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  512 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:554:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  554 |         if (fp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  555 |                 goto done1;[0m
      | [0;1;32m                           
[0m[1mrwarray.c:557:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  557 |         memset(magic_buf, '\0', sizeof(magic_buf));[0m
      | [0;1;32m        ^~~~~~
[0m[1mrwarray.c:557:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  557 |         memset(magic_buf, '\0', sizeof(magic_buf));[0m
      | [0;1;32m        ^~~~~~
[0m[1mrwarray.c:598:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  598 |         if (fp != NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  599 |                 fclose(fp);[0m
      | [0;1;32m                           
[0m[1mrwarray.c:639:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  639 |         if (fread(& count, 1, sizeof(count), fp) != sizeof(count))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  640 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:651:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  651 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  652 |                         break;[0m
      | [0;1;32m                              
[0m[1mrwarray.c:655:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  655 |         if (i != count)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  656 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:671:7: [0m[0;1;35mwarning: [0m[1mAlthough the value stored to 'ret' is used in the enclosing expression, the value is never actually read from 'ret' [clang-analyzer-deadcode.DeadStores][0m
  671 |         if ((ret = fread(& index_len, 1, sizeof(index_len), fp)) != sizeof(index_len)) {[0m
      | [0;1;32m             ^     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mrwarray.c:671:7: [0m[0;1;36mnote: [0mAlthough the value stored to 'ret' is used in the enclosing expression, the value is never actually read from 'ret'[0m
  671 |         if ((ret = fread(& index_len, 1, sizeof(index_len), fp)) != sizeof(index_len)) {[0m
      | [0;1;32m             ^     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mrwarray.c:676:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  676 |         memset(element, 0, sizeof(*element));[0m
      | [0;1;32m        ^~~~~~
[0m[1mrwarray.c:676:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  676 |         memset(element, 0, sizeof(*element));[0m
      | [0;1;32m        ^~~~~~
[0m[1mrwarray.c:687:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  687 |                         if (cp == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  688 |                                 return awk_false;[0m
      | [0;1;32m                                                 
[0m[1mrwarray.c:702:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  702 |         if (! read_value(fp, & element->value, & element->index, vs))[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  703 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:715:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  715 |         if (fread(& code, 1, sizeof(code), fp) != sizeof(code))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  716 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mrwarray.c:723:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  723 |                 if (! read_array(fp, array))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  724 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:740:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  740 |                         value->val_type = AWK_STRING;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  741 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mrwarray.c:743:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  743 |                         value->val_type = AWK_REGEX;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  744 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mrwarray.c:746:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  746 |                         value->val_type = AWK_STRNUM;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  747 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mrwarray.c:749:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  749 |                         value->val_type = AWK_UNDEFINED;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  750 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mrwarray.c:752:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  752 |                         value->val_type = AWK_BOOL;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  753 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mrwarray.c:756:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  756 |                         warning(ext_id, _("treating recovered value with unknown type code %d as a string"), code);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  757 |                         value->val_type = AWK_STRING;[0m
  758 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./../gawkapi.h:880:18: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  880 | #define warning         api->api_warning[0m
      | [0;1;32m                        ^
[0m[1mrwarray.c:793:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  793 |                 if (fread(& len, 1, sizeof(len), fp) != sizeof(len))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  794 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:797:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  797 |                 if (fread(buffer, 1, len, fp) != len)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  798 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mrwarray.c:800:10: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  800 |                 (void) sscanf(buffer, "%lg", & d);[0m
      | [0;1;32m                       ^~~~~~
[0m[1mrwarray.c:800:10: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
  800 |                 (void) sscanf(buffer, "%lg", & d);[0m
      | [0;1;32m                       ^~~~~~
[0m[1mrwarray.c:803:3: [0m[0;1;35mwarning: [0m[1mValue stored to 'value' is never read [clang-analyzer-deadcode.DeadStores][0m
  803 |                 value = make_number(d, value);[0m
      | [0;1;32m                ^       ~~~~~~~~~~~~~~~~~~~~~
[0m[1mrwarray.c:803:3: [0m[0;1;36mnote: [0mValue stored to 'value' is never read[0m
  803 |                 value = make_number(d, value);[0m
      | [0;1;32m                ^       ~~~~~~~~~~~~~~~~~~~~~
[0m[1mrwarray.c:844:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  844 | dl_load_func(func_table, rwarray, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mrwarray.c:844:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  844 | dl_load_func(func_table, rwarray, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m80 warnings generated.
Suppressed 17 warnings (17 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[35/54][103.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmptd6340bq.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/getopt.c
[1mgetopt.c:306:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  306 |   else if (d->__posixly_correct)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  307 |     d->__ordering = REQUIRE_ORDER;[0m
  308 |   else[0m
      | [0;32m  } 
[0m[1mgetopt.c:308:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  308 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  309 |     d->__ordering = PERMUTE;[0m
      | [0;1;32m                            
[0m[1mgetopt.c:407:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  407 |   if (argc < 1)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m  408 |     return -1;[0m
      | [0;1;32m              
[0m[1mgetopt.c:414:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  414 |       if (d->optind == 0)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  415 |         d->optind = 1;  /* Don't scan ARGV[0], the program name.  */[0m
      | [0;1;32m                                                                    
[0m[1mgetopt.c:420:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  420 |   else if (optstring[0] == '-' || optstring[0] == '+')[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  421 |     optstring++;[0m
      | [0;1;32m                
[0m[1mgetopt.c:422:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  422 |   if (optstring[0] == ':')[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  423 |     print_errors = 0;[0m
      | [0;1;32m                     
[0m[1mgetopt.c:443:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  443 |       if (d->__last_nonopt > d->optind)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  444 |         d->__last_nonopt = d->optind;[0m
      | [0;1;32m                                     
[0m[1mgetopt.c:445:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  445 |       if (d->__first_nonopt > d->optind)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  446 |         d->__first_nonopt = d->optind;[0m
      | [0;1;32m                                      
[0m[1mgetopt.c:454:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  454 |               && d->__last_nonopt != d->optind)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  455 |             exchange ((char **) argv, d);[0m
  456 |           else if (d->__last_nonopt != d->optind)[0m
      | [0;32m          } 
[0m[1mgetopt.c:456:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  456 |           else if (d->__last_nonopt != d->optind)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  457 |             d->__first_nonopt = d->optind;[0m
      | [0;1;32m                                          
[0m[1mgetopt.c:462:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  462 |           while (d->optind < argc && NONOPTION_P)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  463 |             d->optind++;[0m
      | [0;1;32m                        
[0m[1mgetopt.c:477:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  477 |               && d->__last_nonopt != d->optind)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  478 |             exchange ((char **) argv, d);[0m
  479 |           else if (d->__first_nonopt == d->__last_nonopt)[0m
      | [0;32m          } 
[0m[1mgetopt.c:479:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  479 |           else if (d->__first_nonopt == d->__last_nonopt)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  480 |             d->__first_nonopt = d->optind;[0m
      | [0;1;32m                                          
[0m[1mgetopt.c:493:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  493 |           if (d->__first_nonopt != d->__last_nonopt)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  494 |             d->optind = d->__first_nonopt;[0m
      | [0;1;32m                                          
[0m[1mgetopt.c:503:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  503 |           if (d->__ordering == REQUIRE_ORDER)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  504 |             return -1;[0m
      | [0;1;32m                      
[0m[1mgetopt.c:550:76: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  550 |       for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m  551 |         /* Do nothing.  */ ;[0m
      | [0;1;32m                            
[0m[1mgetopt.c:556:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  556 |       for (p = longopts, option_index = 0; p->name; p++, option_index++)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m[1mgetopt.c:633:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  633 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mgetopt.c:633:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  633 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mgetopt.c:640:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  640 |                   fprintf (stderr, " '--%s'", ambig_list->p->name);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mgetopt.c:640:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  640 |                   fprintf (stderr, " '--%s'", ambig_list->p->name);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mgetopt.c:642:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  642 |                   if (ambig_list->needs_free)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  643 |                     free(ambig_list);[0m
      | [0;1;32m                                     
[0m[1mgetopt.c:665:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  665 |               if (pfound->has_arg)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  666 |                 d->optarg = nameend + 1;[0m
  667 |               else[0m
      | [0;32m              } 
[0m[1mgetopt.c:684:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  684 |                           fprintf (stderr, _("\[0m
      | [0;1;32m                          ^~~~~~~
[0m[1mgetopt.c:684:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  684 |                           fprintf (stderr, _("\[0m
      | [0;1;32m                          ^~~~~~~
[0m[1mgetopt.c:698:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  698 |                           fprintf (stderr, _("\[0m
      | [0;1;32m                          ^~~~~~~
[0m[1mgetopt.c:698:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  698 |                           fprintf (stderr, _("\[0m
      | [0;1;32m                          ^~~~~~~
[0m[1mgetopt.c:732:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  732 |               if (d->optind < argc)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  733 |                 d->optarg = argv[d->optind++];[0m
  734 |               else[0m
      | [0;32m              } 
[0m[1mgetopt.c:759:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  759 |                       fprintf (stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mgetopt.c:759:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  759 |                       fprintf (stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mgetopt.c:770:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  770 |           if (longind != NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  771 |             *longind = option_index;[0m
      | [0;1;32m                                    
[0m[1mgetopt.c:801:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  801 |                   fprintf (stderr, _("%s: unrecognized option '--%s'\n"),[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mgetopt.c:801:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  801 |                   fprintf (stderr, _("%s: unrecognized option '--%s'\n"),[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mgetopt.c:812:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  812 |                   fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mgetopt.c:812:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  812 |                   fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mgetopt.c:848:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  848 |     if (*d->__nextchar == '\0')[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  849 |       ++d->optind;[0m
      | [0;1;32m                  
[0m[1mgetopt.c:864:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  864 |             fprintf (stderr, _("%s: invalid option -- '%c'\n"), argv[0], c);[0m
      | [0;1;32m            ^~~~~~~
[0m[1mgetopt.c:864:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  864 |             fprintf (stderr, _("%s: invalid option -- '%c'\n"), argv[0], c);[0m
      | [0;1;32m            ^~~~~~~
[0m[1mgetopt.c:898:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  898 |         if (longopts == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  899 |           goto no_longs;[0m
      | [0;1;32m                        
[0m[1mgetopt.c:933:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  933 |                 fprintf (stderr,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgetopt.c:933:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  933 |                 fprintf (stderr,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgetopt.c:939:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  939 |             if (optstring[0] == ':')[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  940 |               c = ':';[0m
  941 |             else[0m
      | [0;32m            } 
[0m[1mgetopt.c:941:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  941 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  942 |               c = '?';[0m
      | [0;1;32m                      
[0m[1mgetopt.c:945:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  945 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  946 |           /* We already incremented `d->optind' once;[0m
  947 |              increment it again when taking next ARGV-elt as argument.  */[0m
  948 |           d->optarg = argv[d->optind++];[0m
      | [0;1;32m                                        
[0m[1mgetopt.c:954:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  954 |              nameend++)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  955 |           /* Do nothing.  */ ;[0m
      | [0;1;32m                              
[0m[1mgetopt.c:959:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  959 |         for (p = longopts, option_index = 0; p->name; p++, option_index++)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m[1mgetopt.c:979:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  979 |                        || pfound->val != p->val)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  980 |                 /* Second or later nonexact match found.  */[0m
  981 |                 ambig = 1;[0m
      | [0;1;32m                          
[0m[1mgetopt.c:1006:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1006 |                 fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgetopt.c:1006:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1006 |                 fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgetopt.c:1021:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1021 |                 if (pfound->has_arg)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1022 |                   d->optarg = nameend + 1;[0m
 1023 |                 else[0m
      | [0;32m                } 
[0m[1mgetopt.c:1048:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1048 |                         fprintf (stderr, _("\[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mgetopt.c:1048:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1048 |                         fprintf (stderr, _("\[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mgetopt.c:1060:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1060 |                 if (d->optind < argc)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1061 |                   d->optarg = argv[d->optind++];[0m
 1062 |                 else[0m
      | [0;32m                } 
[0m[1mgetopt.c:1087:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1087 |                         fprintf (stderr, _("\[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mgetopt.c:1087:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1087 |                         fprintf (stderr, _("\[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mgetopt.c:1096:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1096 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 1097 |               d->optarg = NULL;[0m
      | [0;1;32m                               
[0m[1mgetopt.c:1099:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1099 |             if (longind != NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1100 |               *longind = option_index;[0m
      | [0;1;32m                                      
[0m[1mgetopt.c:1123:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1123 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 1124 |               d->optarg = NULL;[0m
      | [0;1;32m                               
[0m[1mgetopt.c:1161:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1161 |                     fprintf (stderr,[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mgetopt.c:1161:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1161 |                     fprintf (stderr,[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mgetopt.c:1167:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1167 |                 if (optstring[0] == ':')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1168 |                   c = ':';[0m
 1169 |                 else[0m
      | [0;32m                } 
[0m[1mgetopt.c:1169:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1169 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1170 |                   c = '?';[0m
      | [0;1;32m                          
[0m[1mgetopt.c:1172:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1172 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 1173 |               /* We already incremented `optind' once;[0m
 1174 |                  increment it again when taking next ARGV-elt as argument.  */[0m
 1175 |               d->optarg = argv[d->optind++];[0m
      | [0;1;32m                                            
[0m62 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[36/54][110.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmps27oagfb.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/re.c
[1mre.c:68:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   68 |         memset(&mbs, 0, sizeof(mbstate_t)); /* Initialize.  */[0m
      | [0;1;32m        ^~~~~~
[0m[1mre.c:68:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
   68 |         memset(&mbs, 0, sizeof(mbstate_t)); /* Initialize.  */[0m
      | [0;1;32m        ^~~~~~
[0m[1mre.c:110:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  111 |                         ok_to_escape = "{}()|*+?.^$\\[]/-";[0m
  112 |                 else if (do_traditional)[0m
      | [0;32m                } 
[0m[1mre.c:112:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  112 |                 else if (do_traditional)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  113 |                         ok_to_escape = "()|*+?.^$\\[]/-";[0m
  114 |                 else[0m
      | [0;32m                } 
[0m[1mre.c:114:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  114 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  115 |                         ok_to_escape = "<>`'BywWsS{}()|*+?.^$\\[]/-";[0m
      | [0;1;32m                                                                     
[0m[1mre.c:124:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  124 |                                 if (src >= s + len)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  125 |                                         *dest++ = '\\'; // at end of string, will fatal below[0m
  126 |                                 else[0m
  127 |                                         fatal(_("invalid NUL byte in dynamic regexp"));[0m
  128 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mre.c:124:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  124 |                                 if (src >= s + len)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  125 |                                         *dest++ = '\\'; // at end of string, will fatal below[0m
  126 |                                 else[0m
      | [0;32m                                } 
[0m[1mre.c:125:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  125 |                                         *dest++ = '\\'; // at end of string, will fatal below[0m
      | [0;1;32m                                        ~~~~~~~~^~~~~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:122:4: [0m[0;1;36mnote: [0mControl jumps to 'case 0:'  at line 123[0m
  122 |                         switch (c) {[0m
      | [0;1;32m                        ^
[0m[1mre.c:124:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  124 |                                 if (src >= s + len)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~
[0m[1mre.c:124:5: [0m[0;1;36mnote: [0mTaking true branch[0m
  124 |                                 if (src >= s + len)[0m
      | [0;1;32m                                ^
[0m[1mre.c:125:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  125 |                                         *dest++ = '\\'; // at end of string, will fatal below[0m
      | [0;1;32m                                         ^~~~~~
[0m[1mre.c:125:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  125 |                                         *dest++ = '\\'; // at end of string, will fatal below[0m
      | [0;1;32m                                        ~~~~~~~~^~~~~~
[0m[1mre.c:126:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  126 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  127 |                                         fatal(_("invalid NUL byte in dynamic regexp"));[0m
      | [0;1;32m                                                                                       
[0m[1mre.c:146:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  146 |                                 if (c2 < 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m[1mre.c:146:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  146 |                                 if (c2 < 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  147 |                                         cant_happen("received bad result %d from parse_escape()", c2);[0m
      | [0;1;32m                                                                                                      
[0m[1mre.c:156:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  156 |                                     && strchr("()|*+?.^$\\[]", c2) != NULL)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m  157 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                                       
[0m[1mre.c:157:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  157 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                        ~~~~~~~~^~~~~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:122:4: [0m[0;1;36mnote: [0mControl jumps to 'case 55:'  at line 144[0m
  122 |                         switch (c) {[0m
      | [0;1;32m                        ^
[0m[1mre.c:146:9: [0m[0;1;36mnote: [0mAssuming 'c2' is >= 0[0m
  146 |                                 if (c2 < 0)[0m
      | [0;1;32m                                    ^~~~~~
[0m[1mre.c:146:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  146 |                                 if (c2 < 0)[0m
      | [0;1;32m                                ^
[0m[1mre.c:153:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  153 |                                 if (do_traditional[0m
      | [0;1;32m                                    ^
[0m[1m./awk.h:1178:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_traditional'[0m
 1178 | #define do_traditional      (do_flags & DO_TRADITIONAL)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:153:9: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  153 |                                 if (do_traditional[0m
      | [0;1;32m                                    ^
[0m[1m./awk.h:1178:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_traditional'[0m
 1178 | #define do_traditional      (do_flags & DO_TRADITIONAL)[0m
      | [0;1;32m                            ^
[0m[1mre.c:154:12: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  154 |                                     && ! do_posix[0m
      | [0;1;32m                                       ^~~~~~~~~~
[0m[1mre.c:153:9: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  153 |                                 if (do_traditional[0m
      | [0;1;32m                                    ^
[0m[1m./awk.h:1178:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_traditional'[0m
 1178 | #define do_traditional      (do_flags & DO_TRADITIONAL)[0m
      | [0;1;32m                            ^
[0m[1mre.c:155:13: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  155 |                                     && (isdigit(c) || c == 'x')[0m
      | [0;1;32m                                        ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:155:24: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  155 |                                     && (isdigit(c) || c == 'x')[0m
      | [0;1;32m                                                   ^
[0m[1mre.c:156:12: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  156 |                                     && strchr("()|*+?.^$\\[]", c2) != NULL)[0m
      | [0;1;32m                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:153:5: [0m[0;1;36mnote: [0mTaking true branch[0m
  153 |                                 if (do_traditional[0m
      | [0;1;32m                                ^
[0m[1mre.c:157:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  157 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                         ^~~~~~
[0m[1mre.c:157:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  157 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                        ~~~~~~~~^~~~~~
[0m[1mre.c:158:13: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  158 |                                 *dest++ = (char) c2;[0m
      | [0;1;32m                                ~~~~~~~~^~~~~~~~~~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:122:4: [0m[0;1;36mnote: [0mControl jumps to 'case 55:'  at line 144[0m
  122 |                         switch (c) {[0m
      | [0;1;32m                        ^
[0m[1mre.c:146:9: [0m[0;1;36mnote: [0mAssuming 'c2' is >= 0[0m
  146 |                                 if (c2 < 0)[0m
      | [0;1;32m                                    ^~~~~~
[0m[1mre.c:146:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  146 |                                 if (c2 < 0)[0m
      | [0;1;32m                                ^
[0m[1mre.c:153:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  153 |                                 if (do_traditional[0m
      | [0;1;32m                                    ^
[0m[1m./awk.h:1178:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_traditional'[0m
 1178 | #define do_traditional      (do_flags & DO_TRADITIONAL)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:154:9: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  154 |                                     && ! do_posix[0m
      | [0;1;32m                                    ^
[0m[1mre.c:158:6: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  158 |                                 *dest++ = (char) c2;[0m
      | [0;1;32m                                 ^~~~~~
[0m[1mre.c:158:13: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  158 |                                 *dest++ = (char) c2;[0m
      | [0;1;32m                                ~~~~~~~~^~~~~~~~~~~
[0m[1mre.c:168:13: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  168 |                                 *dest++ = c;[0m
      | [0;1;32m                                ~~~~~~~~^~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:122:4: [0m[0;1;36mnote: [0mControl jumps to 'case 57:'  at line 167[0m
  122 |                         switch (c) {[0m
      | [0;1;32m                        ^
[0m[1mre.c:168:6: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  168 |                                 *dest++ = c;[0m
      | [0;1;32m                                 ^~~~~~
[0m[1mre.c:168:13: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  168 |                                 *dest++ = c;[0m
      | [0;1;32m                                ~~~~~~~~^~~
[0m[1mre.c:169:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  169 |                                 src++;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  170 |                         {[0m
  171 |                                 static bool warned[2];[0m
  172 | [0m
  173 |                                 if (! warned[c - '8']) {[0m
  174 |                                         warning(_("regexp escape sequence `\\%c' treated as plain `%c'"), c, c);[0m
  175 |                                         warned[c - '8'] = true;[0m
  176 |                                 }[0m
  177 |                         }[0m
  178 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mre.c:181:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  181 |                                 if (! do_traditional) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  182 |                                         *dest++ = '\\';[0m
  183 |                                         *dest++ = 'b';[0m
  184 |                                         src++;[0m
  185 |                                         break;[0m
  186 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mre.c:182:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  182 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                        ~~~~~~~~^~~~~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:122:4: [0m[0;1;36mnote: [0mControl jumps to 'case 121:'  at line 179[0m
  122 |                         switch (c) {[0m
      | [0;1;32m                        ^
[0m[1mre.c:181:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  181 |                                 if (! do_traditional) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~
[0m[1mre.c:181:5: [0m[0;1;36mnote: [0mTaking true branch[0m
  181 |                                 if (! do_traditional) {[0m
      | [0;1;32m                                ^
[0m[1mre.c:182:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  182 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                         ^~~~~~
[0m[1mre.c:182:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  182 |                                         *dest++ = '\\';[0m
      | [0;1;32m                                        ~~~~~~~~^~~~~~
[0m[1mre.c:189:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  189 |                                 if (strchr(ok_to_escape, c) == NULL) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  190 |                                         static bool warned[256];[0m
  191 | [0m
  192 |                                         if (! warned[c & 0xFF]) {[0m
  193 |                                                 warning(_("regexp escape sequence `\\%c' is not a known regexp operator"), c);[0m
  194 |                                                 warned[c & 0xFF] = true;[0m
  195 |                                         }[0m
  196 |                                 }[0m
  197 |                                 *dest++ = '\\';[0m
  198 |                                 *dest++ = (char) c;[0m
  199 |                                 src++;[0m
  200 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mre.c:197:13: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  197 |                                 *dest++ = '\\';[0m
      | [0;1;32m                                ~~~~~~~~^~~~~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:122:4: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 188[0m
  122 |                         switch (c) {[0m
      | [0;1;32m                        ^
[0m[1mre.c:189:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  189 |                                 if (strchr(ok_to_escape, c) == NULL) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:189:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |                                 if (strchr(ok_to_escape, c) == NULL) {[0m
      | [0;1;32m                                ^
[0m[1mre.c:197:6: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  197 |                                 *dest++ = '\\';[0m
      | [0;1;32m                                 ^~~~~~
[0m[1mre.c:197:13: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  197 |                                 *dest++ = '\\';[0m
      | [0;1;32m                                ~~~~~~~~^~~~~~
[0m[1mre.c:203:4: [0m[0;1;35mwarning: [0m[1mValue stored to 'c' is never read [clang-analyzer-deadcode.DeadStores][0m
  203 |                         c = *src;[0m
      | [0;1;32m                        ^   ~~~~
[0m[1mre.c:203:4: [0m[0;1;36mnote: [0mValue stored to 'c' is never read[0m
  203 |                         c = *src;[0m
      | [0;1;32m                        ^   ~~~~
[0m[1mre.c:204:12: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  204 |                         *dest++ = *src++;       /* not '\\' */[0m
      | [0;1;32m                        ~~~~~~~~^~~~~~~~
[0m[1mre.c:56:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:56:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   56 |         if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {[0m
      | [0;1;32m                    ^
[0m[1mre.c:70:6: [0m[0;1;36mnote: [0m'first' is true[0m
   70 |         if (first) {[0m
      | [0;1;32m            ^~~~~
[0m[1mre.c:70:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   70 |         if (first) {[0m
      | [0;1;32m        ^
[0m[1mre.c:86:6: [0m[0;1;36mnote: [0m'buf' is equal to NULL[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mre.c:86:2: [0m[0;1;36mnote: [0mTaking true branch[0m
   86 |         if (buf == NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:95:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
   95 |         while (src < end) {[0m
      | [0;1;32m        ^
[0m[1mre.c:96:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:96:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
   96 |                 if (gawk_mb_cur_max > 1 && ! is_multibyte) {[0m
      | [0;1;32m                                        ^
[0m[1mre.c:110:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:110:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  110 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mre.c:119:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:119:29: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                                          ^
[0m[1mre.c:120:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  120 |                     (*src == '\\')) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~
[0m[1mre.c:119:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  119 |                 if ((gawk_mb_cur_max == 1 || ! is_multibyte) &&[0m
      | [0;1;32m                ^
[0m[1mre.c:204:5: [0m[0;1;36mnote: [0mNull pointer value stored to 'dest'[0m
  204 |                         *dest++ = *src++;       /* not '\\' */[0m
      | [0;1;32m                         ^~~~~~
[0m[1mre.c:204:12: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  204 |                         *dest++ = *src++;       /* not '\\' */[0m
      | [0;1;32m                        ~~~~~~~~^~~~~~~~
[0m[1mre.c:206:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  206 |                 if (gawk_mb_cur_max > 1 && is_multibyte)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  207 |                         is_multibyte--;[0m
      | [0;1;32m                                       
[0m[1mre.c:273:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  273 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  274 |                 rp->dfareg = NULL;[0m
      | [0;1;32m                                  
[0m[1mre.c:309:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  309 |         if (no_bol)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  310 |                 rp->pat.not_bol = 1;[0m
      | [0;1;32m                                    
[0m[1mre.c:334:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  334 |                 if (superset)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  335 |                         ret = dfaexec(superset, str+start, str+start+len,[0m
  336 |                                                         true, NULL, NULL);[0m
      | [0;1;32m                                                                          
[0m[1mre.c:339:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  339 |                                 || (! superset && dfaisfast(rp->dfareg))))[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m  340 |                         ret = dfaexec(rp->dfareg, str+start, str+start+len,[0m
  341 |                                                 true, NULL, &try_backref);[0m
      | [0;1;32m                                                                          
[0m[1mre.c:356:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  356 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  357 |                         res = 1;[0m
      | [0;1;32m                                
[0m[1mre.c:358:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  358 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  359 |                 res = -1;[0m
      | [0;1;32m                         
[0m[1mre.c:370:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  370 |         if (rp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  371 |                 return;[0m
      | [0;1;32m                       
[0m[1mre.c:374:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  374 |         if (rp->regs.start)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  375 |                 free(rp->regs.start);[0m
      | [0;1;32m                                     
[0m[1mre.c:376:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  376 |         if (rp->regs.end)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  377 |                 free(rp->regs.end);[0m
      | [0;1;32m                                   
[0m[1mre.c:399:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  399 |         if (t->re_reg[IGNORECASE] == NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  400 |                 t->re_reg[IGNORECASE] = make_regexp(t->re_exp->stptr, t->re_exp->stlen, IGNORECASE, t->re_cnt, true);[0m
      | [0;1;32m                                                                                                                     
[0m[1mre.c:411:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  411 |         if (t->type == Node_val && (t->flags & REGEX) != 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  412 |                 return re_cache_get(t->typed_re);[0m
      | [0;1;32m                                                 
[0m[1mre.c:422:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  422 |                 if (cmp_nodes(t->re_text, t1, true) == 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  423 |                         return re_cache_get(t);[0m
      | [0;1;32m                                               
[0m[1mre.c:441:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  441 |         if (t->re_cnt > 0 && ++t->re_cnt > 10)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  442 |                 /*[0m
  443 |                  * The regex appears to update frequently, so disable DFA[0m
  444 |                  * matching (which trades off expensive upfront compilation[0m
  445 |                  * overhead for faster subsequent matching).[0m
  446 |                  */[0m
  447 |                 t->re_cnt = 0;[0m
      | [0;1;32m                              
[0m[1mre.c:447:15: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  447 |                 t->re_cnt = 0;[0m
      | [0;1;32m                            ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mre.c:411:6: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_val[0m
  411 |         if (t->type == Node_val && (t->flags & REGEX) != 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mre.c:411:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  411 |         if (t->type == Node_val && (t->flags & REGEX) != 0)[0m
      | [0;1;32m                                ^
[0m[1mre.c:414:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  414 |         if ((t->re_flags & CONSTANT) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:414:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  414 |         if ((t->re_flags & CONSTANT) != 0) {[0m
      | [0;1;32m        ^
[0m[1mre.c:420:6: [0m[0;1;36mnote: [0mAssuming field 'lptr' is equal to NULL[0m
  420 |         if (t->re_text != NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~
[0m[1mre.c:420:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  420 |         if (t->re_text != NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:433:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  433 |         if (t->re_reg[0] != NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:433:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  433 |         if (t->re_reg[0] != NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:437:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  437 |         if (t->re_reg[1] != NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mre.c:437:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  437 |         if (t->re_reg[1] != NULL) {[0m
      | [0;1;32m        ^
[0m[1mre.c:441:6: [0m[0;1;36mnote: [0mAssuming field 'flags' is > 0[0m
  441 |         if (t->re_cnt > 0 && ++t->re_cnt > 10)[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mre.c:441:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mre.c:441:23: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  441 |         if (t->re_cnt > 0 && ++t->re_cnt > 10)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~
[0m[1mre.c:441:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  441 |         if (t->re_cnt > 0 && ++t->re_cnt > 10)[0m
      | [0;1;32m        ^
[0m[1mre.c:447:15: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  447 |                 t->re_cnt = 0;[0m
      | [0;1;32m                            ^
[0m[1mre.c:472:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  472 |         if (do_posix)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  473 |                 syn = RE_SYNTAX_POSIX_AWK;      /* strict POSIX re's */[0m
  474 |         else if (do_traditional)[0m
      | [0;32m        } 
[0m[1mre.c:474:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  474 |         else if (do_traditional)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  475 |                 syn = RE_SYNTAX_AWK;            /* traditional Unix awk re's */[0m
  476 |         else[0m
      | [0;32m        } 
[0m[1mre.c:476:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  476 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  477 |                 syn = RE_SYNTAX_GNU_AWK;        /* POSIX re's + GNU ops */[0m
      | [0;1;32m                                                                          
[0m[1mre.c:490:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  490 |         if (do_traditional)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  491 |                 syn |= RE_INTERVALS | RE_INVALID_INTERVAL_ORD | RE_NO_BK_BRACES;[0m
      | [0;1;32m                                                                                
[0m[1mre.c:513:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  513 |         if (re->has_meta)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  514 |                 return false;   /* give up early, can't be string match */[0m
      | [0;1;32m                                                                          
[0m[1mre.c:558:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  558 |         if (flagval == RE_SYNTAX_EMACS) /* == 0 */[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  559 |                 return "RE_SYNTAX_EMACS";[0m
      | [0;1;32m                                         
[0m[1mre.c:613:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  613 |         if (length == 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  614 |                 return;[0m
      | [0;1;32m                       
[0m[1mre.c:623:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  623 |         if (sp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  624 |                 goto done;[0m
      | [0;1;32m                          
[0m[1mre.c:627:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  627 |                 if (*sp == '[')[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  628 |                         count++;[0m
      | [0;1;32m                                
[0m[1mre.c:636:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  636 |                              && sp[-1] != '\\')[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  637 |                                  ;[0m
  638 |                          else if ((sp - sp2) >= 2[0m
      | [0;32m                         } 
[0m[1mre.c:639:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  639 |                                   && sp[-1] == '^' && sp[-2] == '[')[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  640 |                                  ;[0m
  641 |                          else[0m
      | [0;32m                         } 
[0m[1mre.c:641:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  641 |                          else[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  642 |                                 count--;[0m
      | [0;1;32m                                        
[0m[1mre.c:658:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  658 |                 if (classes[i].warned)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  659 |                         continue;[0m
      | [0;1;32m                                 
[0m79 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[37/54][114.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp82bllnwq.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/node.c
[1m./awk.h:2108:13: [0m[0;1;35mwarning: [0m[1mThe value '25' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 2108 |         r->flags = (flags|MALLOC|NUMBER|NUMCUR);[0m
      | [0;1;32m                   ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mnode.c:370:12: [0m[0;1;36mnote: [0mCalling 'make_number_node'[0m
  370 |         NODE *r = make_number_node(0);[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:2104:10: [0m[0;1;36mnote: [0mAssuming 'r' is null[0m
 2104 |         getnode(r);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1m./awk.h:2104:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
 2104 |         getnode(r);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1m./awk.h:2108:13: [0m[0;1;36mnote: [0mThe value '25' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 2108 |         r->flags = (flags|MALLOC|NUMBER|NUMCUR);[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:44:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   44 |         if (*str == '-' || *str == '+')[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m   45 |                 str++;[0m
      | [0;1;32m                      
[0m[1mnode.c:47:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   47 |         if (str + 1 < cpend && str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m   48 |                 return true;[0m
      | [0;1;32m                            
[0m[1mnode.c:72:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   72 |         if ((n->flags & NUMCUR) != 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m   73 |                 return n;[0m
      | [0;1;32m                         
[0m[1mnode.c:88:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   88 |              cp < cpend && isspace((unsigned char) *cp); cp++)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m   89 |                 continue;[0m
      | [0;1;32m                         
[0m[1mnode.c:91:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   91 |         if (cp == cpend)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m   92 |                 goto badnum;[0m
      | [0;1;32m                            
[0m[1mnode.c:96:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   96 |         while (isspace((unsigned char) cpend[-1]))[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m   97 |                 cpend--;[0m
      | [0;1;32m                        
[0m[1mnode.c:107:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  107 |                 if (is_alpha((unsigned char) *cp))[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  108 |                         goto badnum;[0m
  109 |                 else if (is_ieee_magic_val(cp)) {[0m
      | [0;32m                } 
[0m[1mnode.c:113:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  113 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  114 |                                 goto badnum;[0m
      | [0;1;32m                                            
[0m[1mnode.c:132:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  132 |                         if (n->stlen == 1)              /* no white space */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  133 |                                 n->flags |= NUMINT;[0m
      | [0;1;32m                                                   
[0m[1mnode.c:153:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  153 |                 if (ptr == cpend)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  154 |                         goto goodnum;[0m
      | [0;1;32m                                     
[0m[1mnode.c:176:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  176 |         if (isnan(n->numbr) && *cp == '-' && signbit(n->numbr) == 0)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  177 |                 n->numbr = -(n->numbr);[0m
      | [0;1;32m                                       
[0m[1mnode.c:267:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  267 |                 if ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  268 |                         efree(s->stptr);[0m
      | [0;1;32m                                        
[0m[1mnode.c:286:11: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  286 |                         (void) sprintf(sp, "%ld", num);[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mnode.c:286:11: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  286 |                         (void) sprintf(sp, "%ld", num);[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mnode.c:298:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  298 |         if ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  299 |                 efree(s->stptr);[0m
      | [0;1;32m                                
[0m[1mnode.c:301:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  301 |         memcpy(s->stptr, sp, s->stlen + 1);[0m
      | [0;1;32m        ^~~~~~
[0m[1mnode.c:301:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  301 |         memcpy(s->stptr, sp, s->stlen + 1);[0m
      | [0;1;32m        ^~~~~~
[0m[1mnode.c:350:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  350 |                 memcpy(r->stptr, n->stptr, n->stlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mnode.c:350:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  350 |                 memcpy(r->stptr, n->stptr, n->stlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mnode.c:356:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  356 |                         memcpy(r->wstptr, n->wstptr, n->wstlen * sizeof(wchar_t));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mnode.c:356:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  356 |                         memcpy(r->wstptr, n->wstptr, n->wstlen * sizeof(wchar_t));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mnode.c:389:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  389 |         if (isnan(t1->numbr))[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  390 |                 return ! isnan(t2->numbr);[0m
      | [0;1;32m                                          
[0m[1mnode.c:391:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  391 |         if (isnan(t2->numbr))[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  392 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mnode.c:394:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  394 |         if (t1->numbr == t2->numbr)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  395 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mnode.c:396:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  396 |         if (t1->numbr < t2->numbr)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  397 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mnode.c:410:13: [0m[0;1;35mwarning: [0m[1mThe value '7' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  410 |         r->flags = (MALLOC|STRING|STRCUR);[0m
      | [0;1;32m                   ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mnode.c:485:8: [0m[0;1;36mnote: [0mCalling 'make_str_node'[0m
  485 |         exp = make_str_node(re, len, ALREADY_MALLOCED);[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:407:10: [0m[0;1;36mnote: [0mAssuming 'r' is null[0m
  407 |         getnode(r);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mnode.c:407:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  407 |         getnode(r);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mnode.c:410:13: [0m[0;1;36mnote: [0mThe value '7' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  410 |         r->flags = (MALLOC|STRING|STRCUR);[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:419:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  419 |         if ((flags & ALREADY_MALLOCED) != 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  420 |                 r->stptr = (char *) s;[0m
  421 |         else {[0m
      | [0;32m        } 
[0m[1mnode.c:423:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  423 |                 memcpy(r->stptr, s, len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mnode.c:423:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  423 |                 memcpy(r->stptr, s, len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mnode.c:434:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  434 |                 memset(& cur_state, 0, sizeof(cur_state));[0m
      | [0;1;32m                ^~~~~~
[0m[1mnode.c:434:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  434 |                 memset(& cur_state, 0, sizeof(cur_state));[0m
      | [0;1;32m                ^~~~~~
[0m[1mnode.c:449:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  449 |                                         for (i = 0; i < mblen; i++)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  450 |                                                 *ptm++ = *pf++;[0m
      | [0;1;32m                                                               
[0m[1mnode.c:459:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  459 |                                         if (do_lint)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  460 |                                                 lintwarn(_("backslash string continuation is not portable"));[0m
      | [0;1;32m                                                                                                             
[0m[1mnode.c:461:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  461 |                                         if ((flags & ELIDE_BACK_NL) != 0)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m  462 |                                                 continue;[0m
      | [0;1;32m                                                         
[0m[1mnode.c:466:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  466 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  467 |                                 *ptm++ = c;[0m
      | [0;1;32m                                           
[0m[1mnode.c:487:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  487 |         if (n == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  488 |                 fatal(_("could not make typed regex"));[0m
      | [0;1;32m                                                       
[0m[1mnode.c:517:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  517 |         if ((tmp->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  518 |                 efree(tmp->stptr);[0m
      | [0;1;32m                                  
[0m[1mnode.c:562:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  562 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mnode.c:568:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  568 |                 return '\a';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:570:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  570 |                 return '\b';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:572:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  572 |                 return '\f';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:574:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  574 |                 return '\n';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:576:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  576 |                 return '\r';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:578:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  578 |                 return '\t';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:580:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  580 |                 return '\v';[0m
      | [0;1;32m                ^          
[0m      | [0;32m                {          ;} 
[0m[1mnode.c:582:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  582 |                 return -2;[0m
      | [0;1;32m                ^        
[0m      | [0;32m                {        ;} 
[0m[1mnode.c:584:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  584 |                 (*string_ptr)--;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  585 |                 return -1;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mnode.c:595:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  595 |                 count = 0;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  596 |                 while (++count < 3) {[0m
  597 |                         if ((c = *(*string_ptr)++) >= '0' && c <= '7') {[0m
  598 |                                 i *= 8;[0m
  599 |                                 i += c - '0';[0m
  600 |                         } else {[0m
  601 |                                 (*string_ptr)--;[0m
  602 |                                 break;[0m
  603 |                         }[0m
  604 |                 }[0m
  605 |                 return i;[0m
      | [0;1;32m                        
[0m      | [0;32m                        ;} 
[0m[1mnode.c:607:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  607 |                 if (do_lint) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mnode.c:615:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  615 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  616 |                         return ('x');[0m
      | [0;1;32m                                     
[0m[1mnode.c:627:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  627 |                                 if (isdigit(c))[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  628 |                                         i += c - '0';[0m
  629 |                                 else if (isupper(c))[0m
      | [0;32m                                } 
[0m[1mnode.c:629:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  629 |                                 else if (isupper(c))[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  630 |                                         i += c - 'A' + 10;[0m
  631 |                                 else[0m
      | [0;32m                                } 
[0m[1mnode.c:631:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  631 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  632 |                                         i += c - 'a' + 10;[0m
      | [0;1;32m                                                          
[0m[1mnode.c:638:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  638 |                 if (do_lint && j == 2 && isxdigit((unsigned char)*(*string_ptr)))[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m  639 |                         lintwarn(_("hex escape \\x%.*s of %d characters probably not interpreted the way you expect"), 3, start, 3);[0m
      | [0;1;32m                                                                                                                                    
[0m[1mnode.c:645:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  645 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m  646 |                 static bool warned[256];[0m
  647 |                 unsigned char uc = (unsigned char) c;[0m
  648 | [0m
  649 |                 /* N.B.: use unsigned char here to avoid Latin-1 problems */[0m
  650 | [0m
  651 |                 if (! warned[uc]) {[0m
  652 |                         warned[uc] = true;[0m
  653 | [0m
  654 |                         warning(_("escape sequence `\\%c' treated as plain `%c'"), uc, uc);[0m
  655 |                 }[0m
  656 |         }[0m
  657 |                 return c;[0m
      | [0;1;32m                        
[0m      | [0;32m                        ;} 
[0m[1mnode.c:674:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  674 |         if (use_locale && loc.decimal_point != NULL && loc.decimal_point[0] != '\0')[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m  675 |                 dec_point = loc.decimal_point[0];       /* XXX --- assumes one char */[0m
      | [0;1;32m                                                                                      
[0m[1mnode.c:678:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  678 |         if (len < 2 || str[0] != '0')[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  679 |                 return 10;[0m
      | [0;1;32m                          
[0m[1mnode.c:682:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  682 |         if (str[1] == 'x' || str[1] == 'X')[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  683 |                 return 16;[0m
      | [0;1;32m                          
[0m[1mnode.c:692:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  692 |                 if (*str == 'e' || *str == 'E' || *str == dec_point)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  693 |                         return 10;[0m
  694 |                 else if (! isdigit((unsigned char) *str))[0m
      | [0;32m                } 
[0m[1mnode.c:694:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  694 |                 else if (! isdigit((unsigned char) *str))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  695 |                         break;[0m
      | [0;1;32m                              
[0m[1mnode.c:700:3: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  700 |         )[0m
      | [0;1;32m         ^
[0m      | [0;32m          {
[0m  701 |                 return 10;[0m
      | [0;1;32m                          
[0m[1mnode.c:724:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  724 |         if (n == Nnull_string || n == Null_field)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  725 |                 return n;[0m
      | [0;1;32m                         
[0m[1mnode.c:728:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  728 |                 if (ptr == NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  729 |                         return n;[0m
      | [0;1;32m                                 
[0m[1mnode.c:765:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  765 |         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m        ^~~~~~
[0m[1mnode.c:765:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  765 |         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m        ^~~~~~
[0m[1mnode.c:776:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  776 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  777 |                         count = mbrtowc(& wc, sp, src_count, & mbs);[0m
      | [0;1;32m                                                                    
[0m[1mnode.c:785:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  785 |                         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mnode.c:785:4: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  785 |                         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mnode.c:788:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  788 |                         if (! warned) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mnode.c:817:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  817 |                         count = 1;[0m
      | [0;1;32m                        ^        
[0m      | [0;32m                        {        ;} 
[0m[1mnode.c:820:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  820 |                 set_wc:[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  821 |                         *wsp++ = wc;[0m
  822 |                         src_count -= count;[0m
  823 |                         while (count--)  {[0m
  824 |                                 if (ptr != NULL)[0m
  825 |                                         (*ptr)[sp - n->stptr] = i;[0m
  826 |                                 sp++;[0m
  827 |                         }[0m
  828 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mnode.c:821:11: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  821 |                         *wsp++ = wc;[0m
      | [0;1;32m                        ~~~~~~~^~~~
[0m[1mnode.c:724:6: [0m[0;1;36mnote: [0mAssuming 'n' is not equal to 'Nnull_string'[0m
  724 |         if (n == Nnull_string || n == Null_field)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~
[0m[1mnode.c:724:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mnode.c:724:27: [0m[0;1;36mnote: [0mAssuming 'n' is not equal to 'Null_field'[0m
  724 |         if (n == Nnull_string || n == Null_field)[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~
[0m[1mnode.c:724:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  724 |         if (n == Nnull_string || n == Null_field)[0m
      | [0;1;32m        ^
[0m[1mnode.c:727:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  727 |         if ((n->flags & WSTRCUR) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:727:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  727 |         if ((n->flags & WSTRCUR) != 0) {[0m
      | [0;1;32m        ^
[0m[1mnode.c:759:6: [0m[0;1;36mnote: [0mAssuming 'ptr' is equal to NULL[0m
  759 |         if (ptr != NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1mnode.c:759:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  759 |         if (ptr != NULL) {[0m
      | [0;1;32m        ^
[0m[1mnode.c:766:14: [0m[0;1;36mnote: [0mAssuming 'src_count' is > 0[0m
  766 |         for (i = 0; src_count > 0; i++) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~
[0m[1mnode.c:766:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  766 |         for (i = 0; src_count > 0; i++) {[0m
      | [0;1;32m        ^
[0m[1mnode.c:773:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  773 |                 if (is_valid_character(*sp)) {[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:1754:32: [0m[0;1;36mnote: [0mexpanded from macro 'is_valid_character'[0m
 1754 | #define is_valid_character(b)   (btowc_cache[(b)&0xFF] != WEOF)[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:773:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  773 |                 if (is_valid_character(*sp)) {[0m
      | [0;1;32m                ^
[0m[1mnode.c:778:3: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 819[0m
  778 |                 switch (count) {[0m
      | [0;1;32m                ^
[0m[1mnode.c:821:5: [0m[0;1;36mnote: [0mNull pointer value stored to 'wsp'[0m
  821 |                         *wsp++ = wc;[0m
      | [0;1;32m                         ^~~~~
[0m[1mnode.c:821:11: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  821 |                         *wsp++ = wc;[0m
      | [0;1;32m                        ~~~~~~~^~~~
[0m[1mnode.c:824:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  824 |                                 if (ptr != NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  825 |                                         (*ptr)[sp - n->stptr] = i;[0m
      | [0;1;32m                                                                  
[0m[1mnode.c:836:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  836 |         if (n->stlen - n->wstlen > ARBITRARY_AMOUNT_TO_GIVE_BACK)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  837 |                 erealloc(n->wstptr, wchar_t *, sizeof(wchar_t) * (n->wstlen + 1), "str2wstr");[0m
      | [0;1;32m                                                                                              
[0m[1mnode.c:861:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  861 |         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m        ^~~~~~
[0m[1mnode.c:861:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  861 |         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m        ^~~~~~
[0m[1mnode.c:869:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  869 |                 if (result == (size_t) -1)      /* what to do? break seems best */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  870 |                         break;[0m
      | [0;1;32m                              
[0m[1mnode.c:874:6: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'cp') [clang-analyzer-core.NullDereference][0m
  874 |         *cp = '\0';[0m
      | [0;1;32m         ~~ ^
[0m[1mnode.c:867:20: [0m[0;1;36mnote: [0mAssuming 'length' is > 0[0m
  867 |         for (cp = newval; length > 0; length--) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mnode.c:867:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  867 |         for (cp = newval; length > 0; length--) {[0m
      | [0;1;32m        ^
[0m[1mnode.c:868:3: [0m[0;1;36mnote: [0mValue assigned to 'result'[0m
  868 |                 result = wcrtomb(cp, *wp, & mbs);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:869:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  869 |                 if (result == (size_t) -1)      /* what to do? break seems best */[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~
[0m[1mnode.c:869:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  869 |                 if (result == (size_t) -1)      /* what to do? break seems best */[0m
      | [0;1;32m                ^
[0m[1mnode.c:871:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'cp'[0m
  871 |                 cp += result;[0m
      | [0;1;32m                ^~~~~~~~~~~~
[0m[1mnode.c:867:20: [0m[0;1;36mnote: [0mAssuming 'length' is <= 0[0m
  867 |         for (cp = newval; length > 0; length--) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mnode.c:867:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 874[0m
  867 |         for (cp = newval; length > 0; length--) {[0m
      | [0;1;32m        ^
[0m[1mnode.c:874:6: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'cp')[0m
  874 |         *cp = '\0';[0m
      | [0;1;32m         ~~ ^
[0m[1mnode.c:903:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  903 |         if (str == NULL || len == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  904 |                 return;[0m
      | [0;1;32m                       
[0m[1mnode.c:906:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  906 |         for (; len--; str++)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  907 |                 putwc(*str, fp);[0m
      | [0;1;32m                                
[0m[1mnode.c:918:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  918 |         if (haystack == NULL || needle == NULL || needle_len > hs_len)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  919 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mnode.c:943:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  943 |         if (haystack == NULL || needle == NULL || needle_len > hs_len)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  944 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mnode.c:959:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  959 |                                 if (h != n)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  960 |                                         goto out;[0m
      | [0;1;32m                                                 
[0m[1mnode.c:1012:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1012 |                 if (val[0] == '-')[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1013 |                         v = -v;[0m
      | [0;1;32m                               
[0m107 warnings generated.
Suppressed 31 warnings (31 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[38/54][120.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmppsa_plqh.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/filefuncs.c
[1mfilefuncs.c:169:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  169 |                 if (ret < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  170 |                         update_ERRNO_int(errno);[0m
      | [0;1;32m                                                
[0m[1mfilefuncs.c:237:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  237 |                 if ((fmode & map[j].mask) != 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  238 |                         outbuf[i] = map[j].rep;[0m
      | [0;1;32m                                               
[0m[1mfilefuncs.c:247:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  247 |                         if (outbuf[setuid_map[j].index] == 'x')[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  248 |                                 outbuf[setuid_map[j].index] = setuid_map[j].small_rep;[0m
  249 |                         else[0m
      | [0;32m                        } 
[0m[1mfilefuncs.c:249:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  249 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  250 |                                 outbuf[setuid_map[j].index] = setuid_map[j].big_rep;[0m
      | [0;1;32m                                                                                    
[0m[1mfilefuncs.c:275:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  275 |         if (bufsize)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  276 |                 bufsize += 2;[0m
  277 |         else[0m
      | [0;32m        } 
[0m[1mfilefuncs.c:277:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  277 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  278 |                 bufsize = BUFSIZ * 2;[0m
      | [0;1;32m                                     
[0m[1mfilefuncs.c:281:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  281 |         if (bufsize > MAXSIZE || bufsize < 2)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  282 |                 bufsize = MAXSIZE;[0m
      | [0;1;32m                                  
[0m[1mfilefuncs.c:299:4: [0m[0;1;35mwarning: [0m[1mPotential out of bound access to the region with tainted index [clang-analyzer-security.ArrayBound][0m
  299 |                         buf[*linksize] = '\0';[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~
[0m[1mfilefuncs.c:275:6: [0m[0;1;36mnote: [0mAssuming 'bufsize' is 0[0m
  275 |         if (bufsize)[0m
      | [0;1;32m            ^~~~~~~
[0m[1mfilefuncs.c:275:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  275 |         if (bufsize)[0m
      | [0;1;32m        ^
[0m[1mfilefuncs.c:281:16: [0m[0;1;36mnote: [0m'?' condition is false[0m
  281 |         if (bufsize > MAXSIZE || bufsize < 2)[0m
      | [0;1;32m                      ^
[0m[1mfilefuncs.c:270:18: [0m[0;1;36mnote: [0mexpanded from macro 'MAXSIZE'[0m
  270 | #define MAXSIZE (SIZE_MAX < SSIZE_MAX ? SIZE_MAX : SSIZE_MAX)[0m
      | [0;1;32m                 ^
[0m[1mfilefuncs.c:264:19: [0m[0;1;36mnote: [0mexpanded from macro 'SIZE_MAX'[0m
  264 | # define SIZE_MAX ((size_t) -1)[0m
      | [0;1;32m                  ^
[0m[1mfilefuncs.c:281:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  281 |         if (bufsize > MAXSIZE || bufsize < 2)[0m
      | [0;1;32m            ^
[0m[1mfilefuncs.c:281:27: [0m[0;1;36mnote: [0m'bufsize' is >= 2[0m
  281 |         if (bufsize > MAXSIZE || bufsize < 2)[0m
      | [0;1;32m                                 ^~~~~~~
[0m[1mfilefuncs.c:281:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  281 |         if (bufsize > MAXSIZE || bufsize < 2)[0m
      | [0;1;32m        ^
[0m[1mfilefuncs.c:284:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  284 |         while (1) {[0m
      | [0;1;32m        ^
[0m[1mfilefuncs.c:287:3: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  287 |                 emalloc(buf, char *, bufsize, "read_symlink");[0m
      | [0;1;32m                ^
[0m[1m./../gawkapi.h:964:7: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  964 |                 if ((pointer = (type) gawk_malloc(size)) == 0) \[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfilefuncs.c:287:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  287 |                 emalloc(buf, char *, bufsize, "read_symlink");[0m
      | [0;1;32m                ^
[0m[1m./../gawkapi.h:964:3: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  964 |                 if ((pointer = (type) gawk_malloc(size)) == 0) \[0m
      | [0;1;32m                ^
[0m[1mfilefuncs.c:287:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  287 |                 emalloc(buf, char *, bufsize, "read_symlink");[0m
      | [0;1;32m                ^
[0m[1m./../gawkapi.h:963:2: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
  963 |         do { \[0m
      | [0;1;32m        ^
[0m[1mfilefuncs.c:288:20: [0m[0;1;36mnote: [0mTaint originated here[0m
  288 |                 if ((*linksize = readlink(fname, buf, bufsize)) < 0) {[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfilefuncs.c:288:20: [0m[0;1;36mnote: [0mTaint propagated to the return value[0m
  288 |                 if ((*linksize = readlink(fname, buf, bufsize)) < 0) {[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfilefuncs.c:288:20: [0m[0;1;36mnote: [0mAssuming that 'readlink' is successful[0m
  288 |                 if ((*linksize = readlink(fname, buf, bufsize)) < 0) {[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfilefuncs.c:288:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  288 |                 if ((*linksize = readlink(fname, buf, bufsize)) < 0) {[0m
      | [0;1;32m                ^
[0m[1mfilefuncs.c:298:12: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  298 |                 else if ((size_t)*linksize <= bufsize-2) {[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfilefuncs.c:298:8: [0m[0;1;36mnote: [0mTaking true branch[0m
  298 |                 else if ((size_t)*linksize <= bufsize-2) {[0m
      | [0;1;32m                     ^
[0m[1mfilefuncs.c:299:4: [0m[0;1;36mnote: [0mAccess of the region with a tainted index that may be too large[0m
  299 |                         buf[*linksize] = '\0';[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~
[0m[1mfilefuncs.c:303:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  303 |                 if (bufsize <= MAXSIZE/2)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  304 |                         bufsize *= 2;[0m
  305 |                 else if (bufsize < MAXSIZE)[0m
      | [0;32m                } 
[0m[1mfilefuncs.c:305:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  305 |                 else if (bufsize < MAXSIZE)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  306 |                         bufsize = MAXSIZE;[0m
  307 |                 else[0m
      | [0;32m                } 
[0m[1mfilefuncs.c:307:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  307 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  308 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mfilefuncs.c:367:14: [0m[0;1;35mwarning: [0m[1mValue stored to 'type' during its initialization is never read [clang-analyzer-deadcode.DeadStores][0m
  367 |         const char *type = "unknown";[0m
      | [0;1;32m                    ^~~~   ~~~~~~~~~
[0m[1mfilefuncs.c:367:14: [0m[0;1;36mnote: [0mValue stored to 'type' during its initialization is never read[0m
  367 |         const char *type = "unknown";[0m
      | [0;1;32m                    ^~~~   ~~~~~~~~~
[0m[1mfilefuncs.c:443:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  443 |                                         & linksize)) != NULL)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  444 |                         array_set(array, "linkval", make_malloced_string(buf, linksize, & tmp));[0m
  445 |                 else[0m
      | [0;32m                } 
[0m[1mfilefuncs.c:445:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  445 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  446 |                         warning(ext_id, _("stat: unable to read symbolic link `%s'"), name);[0m
      | [0;1;32m                                                                                            
[0m[1mfilefuncs.c:719:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  719 |                         if (skipset && fentry->fts_level == 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mfilefuncs.c:719:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  719 |                         if (skipset && fentry->fts_level == 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  720 |                                 fts_set(hierarchy, fentry, FTS_SKIP);[0m
      | [0;1;32m                                                                     
[0m[1mfilefuncs.c:763:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  763 |                         if (seedot && strcmp(fentry->fts_name, ".") == 0)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m  764 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mfilefuncs.c:771:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  771 |                         element_array = create_array();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mfilefuncs.c:794:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  794 |                         dot_array = create_array();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mfilefuncs.c:819:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  819 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mfilefuncs.c:849:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  849 |         if (nargs > 3)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  850 |                 lintwarn(ext_id, _("fts: called with incorrect number of arguments, expecting 3"));[0m
      | [0;1;32m                                                                                                   
[0m[1mfilefuncs.c:889:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  889 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  890 |                         lintwarn(ext_id, _("fts: ignoring sneaky FTS_NOSTAT flag. nyah, nyah, nyah."));[0m
      | [0;1;32m                                                                                                       
[0m[1mfilefuncs.c:894:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  894 |         if (flags & FTS_NON_RECURSIVE)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  895 |                 flags |= FTS_NOCHDIR;[0m
      | [0;1;32m                                     
[0m[1mfilefuncs.c:903:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  903 |         for (i = 0; i < count; i++)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  904 |                 pathvector[i] = path_array->elements[i].value.str_value.str;[0m
      | [0;1;32m                                                                            
[0m[1mfilefuncs.c:918:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  918 |                 if (fts_errors == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  919 |                         ret = 0;[0m
      | [0;1;32m                                
[0m[1mfilefuncs.c:920:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  920 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  921 |                 update_ERRNO_int(errno);[0m
      | [0;1;32m                                        
[0m[1mfilefuncs.c:924:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  924 |         if (pathvector != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  925 |                 gawk_free(pathvector);[0m
      | [0;1;32m                                      
[0m[1mfilefuncs.c:926:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  926 |         if (path_array != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  927 |                 (void) release_flattened_array(pathlist.array_cookie, path_array);[0m
      | [0;1;32m                                                                                  
[0m[1mfilefuncs.c:947:1: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  947 | dl_load_func(func_table, filefuncs, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m[1mfilefuncs.c:947:1: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  947 | dl_load_func(func_table, filefuncs, "")[0m
      | [0;1;32m^
[0m[1m./../gawkapi.h:1157:3: [0m[0;1;36mnote: [0mexpanded from macro 'dl_load_func'[0m
 1157 |                 fprintf(stderr, #extension ": version mismatch with gawk!\n"); \[0m
      | [0;1;32m                ^~~~~~~
[0m45 warnings generated.
Suppressed 15 warnings (15 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[39/54][142.3s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpnf31lmmg.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/gawkapi.c
[1mgawkapi.c:52:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   52 |         if (result == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m   53 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:58:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   58 |         memset(result, 0, sizeof(*result));[0m
      | [0;1;32m        ^~~~~~
[0m[1mgawkapi.c:58:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
   58 |         memset(result, 0, sizeof(*result));[0m
      | [0;1;32m        ^~~~~~
[0m[1mgawkapi.c:68:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   68 |         if (arg == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m   69 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:73:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   73 |                 if (wanted == AWK_UNDEFINED)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m   74 |                         return awk_true;[0m
   75 |                 else if (wanted == AWK_ARRAY) {[0m
      | [0;32m                } 
[0m[1mgawkapi.c:84:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   84 |                 if (wanted != AWK_ARRAY && wanted != AWK_UNDEFINED)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m   85 |                         return awk_false;[0m
      | [0;1;32m                                         
[0m[1mgawkapi.c:87:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   87 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m   88 |                 goto scalar;[0m
      | [0;1;32m                            
[0m[1mgawkapi.c:93:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   93 |         if (arg == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m   94 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:101:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  101 |         if (arg == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  102 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:123:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  123 |         if (array == NULL || array->type != Node_var_array)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  124 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:127:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  127 |             || (arg->type != Node_var_new && arg->type != Node_elem_new))[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m  128 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:131:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  131 |         if (arg == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  132 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:155:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  155 |         if (retval == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  156 |                 fatal(_("awk_value_to_node: received null retval"));[0m
      | [0;1;32m                                                                    
[0m[1mgawkapi.c:160:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  160 |                 ext_ret_val = (NODE *) retval->array_cookie;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  161 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:163:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  163 |                 ext_ret_val = dupnode(Nnull_string);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  164 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:166:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  166 |                 ext_ret_val = make_bool_node(retval->bool_value != awk_false);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  167 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:169:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  169 |                 switch (retval->num_type) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mgawkapi.c:171:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  171 |                         ext_ret_val = make_number(retval->num_value);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  172 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mgawkapi.c:183:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  183 |                         fatal(_("awk_value_to_node: MPFR not supported"));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  184 | #endif[0m
  185 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./awk.h:1388:16: [0m[0;1;36mnote: [0mexpanded from macro 'fatal'[0m
 1388 | #define fatal           (*(set_loc(__FILE__, __LINE__), r_fatal))[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:195:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  195 |                         fatal(_("awk_value_to_node: MPFR not supported"));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  196 | #endif[0m
  197 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./awk.h:1388:16: [0m[0;1;36mnote: [0mexpanded from macro 'fatal'[0m
 1388 | #define fatal           (*(set_loc(__FILE__, __LINE__), r_fatal))[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:199:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  199 |                         fatal(_("awk_value_to_node: invalid number type `%d'"), retval->num_type);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  200 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./awk.h:1388:16: [0m[0;1;36mnote: [0mexpanded from macro 'fatal'[0m
 1388 | #define fatal           (*(set_loc(__FILE__, __LINE__), r_fatal))[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:204:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  204 |                 ext_ret_val = make_str_node(retval->str_value.str,[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  205 |                                 retval->str_value.len, ALREADY_MALLOCED);[0m
  206 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:208:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  208 |                 ext_ret_val = make_str_node(retval->str_value.str,[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  209 |                                 retval->str_value.len, ALREADY_MALLOCED);[0m
  210 |                 ext_ret_val->flags |= USER_INPUT;[0m
  211 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:213:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  213 |                 ext_ret_val = make_typed_regex(retval->str_value.str,[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  214 |                                 retval->str_value.len);[0m
  215 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:217:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  217 |                 v = (NODE *) retval->scalar_cookie;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  218 |                 if (v->type != Node_var)[0m
  219 |                         ext_ret_val = NULL;[0m
  220 |                 else[0m
  221 |                         ext_ret_val = dupnode(v->var_value);[0m
  222 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:218:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  218 |                 if (v->type != Node_var)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  219 |                         ext_ret_val = NULL;[0m
  220 |                 else[0m
      | [0;32m                } 
[0m[1mgawkapi.c:220:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  220 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  221 |                         ext_ret_val = dupnode(v->var_value);[0m
      | [0;1;32m                                                            
[0m[1mgawkapi.c:224:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  224 |                 ext_ret_val = dupnode((NODE *)(retval->value_cookie));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  225 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:227:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  227 |                 ext_ret_val = NULL;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  228 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:303:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  303 |         if (input_parser == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  304 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:316:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  316 |         if (output_wrapper == NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  317 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:330:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  330 |         if (two_way_processor == NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  331 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:356:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  356 |         if (string == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  357 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:382:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  382 |         if (func == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  383 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:385:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  385 |         if (name_space == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  386 |                 fatal(_("add_ext_func: received NULL name_space parameter"));[0m
      | [0;1;32m                                                                             
[0m[1mgawkapi.c:430:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  430 |         if (funcp == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  431 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:457:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  457 |         for (i = 0; i < scopy.i; i++)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  458 |                 free(scopy.strings[i]);[0m
      | [0;1;32m                                       
[0m[1mgawkapi.c:478:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  478 |                         if (scopy.size == 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  479 |                                 scopy.size = 8; /* initial size */[0m
  480 |                         else[0m
      | [0;32m                        } 
[0m[1mgawkapi.c:480:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  480 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  481 |                                 scopy.size *= 2;[0m
      | [0;1;32m                                                
[0m[1mgawkapi.c:485:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  485 |                 memcpy(s, node->stptr, node->stlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mgawkapi.c:485:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  485 |                 memcpy(s, node->stptr, node->stlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mgawkapi.c:489:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  489 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  490 |                 val->str_value.str = node->stptr;[0m
      | [0;1;32m                                                 
[0m[1mgawkapi.c:561:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  561 |         if (node == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  562 |                 fatal(_("node_to_awk_value: received null node"));[0m
      | [0;1;32m                                                                  
[0m[1mgawkapi.c:564:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  564 |         if (val == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  565 |                 fatal(_("node_to_awk_value: received null val"));[0m
      | [0;1;32m                                                                 
[0m[1mgawkapi.c:567:10: [0m[0;1;35mwarning: [0m[1mAccess to field 'type' results in a dereference of a null pointer (loaded from variable 'node') [clang-analyzer-core.NullDereference][0m
  567 |         switch (node->type) {[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:1248:9: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to NULL[0m
 1248 |         if (   array == NULL[0m
      | [0;1;32m               ^~~~~~~~~~~~~
[0m[1mgawkapi.c:1248:9: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkapi.c:1249:9: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_var_array[0m
 1249 |             || array->type != Node_var_array[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1248:9: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1248 |         if (   array == NULL[0m
      | [0;1;32m               ^
[0m[1mgawkapi.c:1250:9: [0m[0;1;36mnote: [0mAssuming field 'reflags' is not equal to 0[0m
 1250 |             || assoc_empty(array)[0m
      | [0;1;32m               ^
[0m[1m./awk.h:1394:25: [0m[0;1;36mnote: [0mexpanded from macro 'assoc_empty'[0m
 1394 | #define assoc_empty(a)  (assoc_length(a) == 0)[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:1393:25: [0m[0;1;36mnote: [0mexpanded from macro 'assoc_length'[0m
 1393 | #define assoc_length(a) ((a)->table_size)[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:1248:9: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1248 |         if (   array == NULL[0m
      | [0;1;32m               ^
[0m[1mgawkapi.c:1251:9: [0m[0;1;36mnote: [0mAssuming 'data' is not equal to NULL[0m
 1251 |             || data == NULL)[0m
      | [0;1;32m               ^~~~~~~~~~~~
[0m[1mgawkapi.c:1248:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1248 |         if (   array == NULL[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:1266:7: [0m[0;1;36mnote: [0mThe value 0 is assigned to 'i'[0m
 1266 |         for (i = j = 0; i < 2 * array->table_size; i += 2, j++) {[0m
      | [0;1;32m             ^~~~~~~~~
[0m[1mgawkapi.c:1266:18: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1266 |         for (i = j = 0; i < 2 * array->table_size; i += 2, j++) {[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1266:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1266 |         for (i = j = 0; i < 2 * array->table_size; i += 2, j++) {[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:1269:3: [0m[0;1;36mnote: [0mValue assigned to 'index'[0m
 1269 |                 index = list[i];[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1273:27: [0m[0;1;36mnote: [0mPassing value via 1st parameter 'node'[0m
 1273 |                 if (! node_to_awk_value(index,[0m
      | [0;1;32m                                        ^~~~~
[0m[1mgawkapi.c:1273:9: [0m[0;1;36mnote: [0mCalling 'node_to_awk_value'[0m
 1273 |                 if (! node_to_awk_value(index,[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m 1274 |                                 & (*data)->elements[j].index, index_type)) {[0m
      | [0;1;32m                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:561:6: [0m[0;1;36mnote: [0mAssuming 'node' is equal to NULL[0m
  561 |         if (node == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mgawkapi.c:561:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  561 |         if (node == NULL)[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:564:6: [0m[0;1;36mnote: [0m'val' is not equal to NULL[0m
  564 |         if (val == NULL)[0m
      | [0;1;32m            ^~~
[0m[1mgawkapi.c:564:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  564 |         if (val == NULL)[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:567:10: [0m[0;1;36mnote: [0mAccess to field 'type' results in a dereference of a null pointer (loaded from variable 'node')[0m
  567 |         switch (node->type) {[0m
      | [0;1;32m                ^~~~
[0m[1mgawkapi.c:571:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  571 |                 if (wanted == AWK_UNDEFINED) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  572 |                         ret = awk_true;[0m
  573 |                 }[0m
  574 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:578:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  578 |                 if (wanted == AWK_SCALAR) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  579 |                         val->val_type = AWK_SCALAR;[0m
  580 |                         val->scalar_cookie = (void *) node;[0m
  581 |                         ret = awk_true;[0m
  582 |                         break;[0m
  583 |                 }[0m
  584 | [0m
  585 |                 node = node->var_value;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mgawkapi.c:589:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  589 |                 switch (wanted) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mgawkapi.c:591:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  591 |                         if ((node->flags & BOOLVAL) != 0) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  592 |                                 assign_bool(node, val);[0m
  593 |                                 ret = awk_true;[0m
  594 |                         } else[0m
  595 |                                 ret = awk_false;[0m
  596 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mgawkapi.c:594:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  594 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  595 |                                 ret = awk_false;[0m
      | [0;1;32m                                                
[0m[1mgawkapi.c:599:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  599 |                         if ((node->flags & REGEX) != 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  600 |                                 val->val_type = AWK_REGEX;[0m
  601 |                         else {[0m
  602 |                                 (void) force_number(node);[0m
  603 |                                 assign_number(node, val);[0m
  604 |                                 ret = awk_true;[0m
  605 |                         }[0m
  606 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mgawkapi.c:599:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  599 |                         if ((node->flags & REGEX) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  600 |                                 val->val_type = AWK_REGEX;[0m
  601 |                         else {[0m
      | [0;32m                        } 
[0m[1mgawkapi.c:609:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  609 |                         switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mgawkapi.c:611:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  611 |                                 val->val_type = AWK_BOOL;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  612 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:614:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  614 |                                 val->val_type = AWK_STRING;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  615 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:617:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  617 |                                 (void) force_string(node);[0m
      | [0;1;32m                                ^                        
[0m      | [0;32m                                {                        ;} 
[0m[1mgawkapi.c:620:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  620 |                                 assign_string(node, val, AWK_STRNUM);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  621 |                                 ret = awk_true;[0m
  622 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:624:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  624 |                                 val->val_type = AWK_REGEX;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  625 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:627:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  627 |                                 if (node == Nnull_string) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  628 |                                         val->val_type = AWK_UNDEFINED;[0m
  629 |                                         break;[0m
  630 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mgawkapi.c:633:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  633 |                                 warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  634 |                                 val->val_type = AWK_UNDEFINED;[0m
  635 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1m./awk.h:170:17: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  170 | #define warning (*(set_loc(__FILE__, __LINE__),r_warning))[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:640:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  640 |                         (void) force_string(node);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  641 |                         assign_string(node, val, AWK_STRING);[0m
  642 |                         ret = awk_true;[0m
  643 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mgawkapi.c:646:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  646 |                         switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mgawkapi.c:648:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  648 |                                 val->val_type = AWK_STRING;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  649 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:651:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  651 |                                 val->val_type = AWK_BOOL;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  652 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:654:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  654 |                                 val->val_type = AWK_NUMBER;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  655 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:657:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  657 |                                 val->val_type = AWK_STRNUM;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  658 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:660:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  660 |                                 assign_regex(node, val);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  661 |                                 ret = awk_true;[0m
  662 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:664:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  664 |                                 if (node == Nnull_string) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  665 |                                         val->val_type = AWK_UNDEFINED;[0m
  666 |                                         break;[0m
  667 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mgawkapi.c:670:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  670 |                                 warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  671 |                                 val->val_type = AWK_UNDEFINED;[0m
  672 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1m./awk.h:170:17: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  170 | #define warning (*(set_loc(__FILE__, __LINE__),r_warning))[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:677:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  677 |                         switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mgawkapi.c:679:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  679 |                                 val->val_type = AWK_BOOL;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  680 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:682:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  682 |                                 val->val_type = AWK_STRING;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  683 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:685:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  685 |                                 val->val_type = AWK_NUMBER;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  686 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:688:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  688 |                                 val->val_type = AWK_STRNUM;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  689 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:691:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  691 |                                 val->val_type = AWK_REGEX;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  692 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:694:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  694 |                                 if (node == Nnull_string) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  695 |                                         val->val_type = AWK_UNDEFINED;[0m
  696 |                                         break;[0m
  697 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mgawkapi.c:700:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  700 |                                 warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  701 |                                 val->val_type = AWK_UNDEFINED;[0m
  702 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1m./awk.h:170:17: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  170 | #define warning (*(set_loc(__FILE__, __LINE__),r_warning))[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:708:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  708 |                         switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mgawkapi.c:710:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  710 |                                 assign_bool(node, val);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  711 |                                 ret = awk_true;[0m
  712 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:714:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  714 |                                 assign_string(node, val, AWK_STRING);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  715 |                                 ret = awk_true;[0m
  716 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:718:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  718 |                                 assign_number(node, val);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  719 |                                 ret = awk_true;[0m
  720 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:722:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  722 |                                 assign_string(node, val, AWK_STRNUM);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  723 |                                 ret = awk_true;[0m
  724 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:726:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  726 |                                 assign_regex(node, val);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  727 |                                 ret = awk_true;[0m
  728 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:730:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  730 |                                 if (node == Nnull_string) {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  731 |                                         val->val_type = AWK_UNDEFINED;[0m
  732 |                                         ret = awk_true;[0m
  733 |                                         break;[0m
  734 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mgawkapi.c:737:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  737 |                                 warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  738 |                                 val->val_type = AWK_UNDEFINED;[0m
  739 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1m./awk.h:170:17: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  170 | #define warning (*(set_loc(__FILE__, __LINE__),r_warning))[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:750:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  750 |                 val->val_type = AWK_ARRAY;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  751 |                 if (wanted == AWK_ARRAY || wanted == AWK_UNDEFINED) {[0m
  752 |                         val->array_cookie = node;[0m
  753 |                         ret = awk_true;[0m
  754 |                 } else[0m
  755 |                         ret = awk_false;[0m
  756 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:754:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  754 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  755 |                         ret = awk_false;[0m
      | [0;1;32m                                        
[0m[1mgawkapi.c:759:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  759 |                 val->val_type = AWK_UNDEFINED;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  760 |                 ret = awk_false;[0m
  761 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:800:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  800 |             || (name_space[0] != '\0' && ! is_valid_identifier(name_space)))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m  801 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:803:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  803 |         if ((node = ns_lookup(name_space, name, NULL)) == NULL)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  804 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:806:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  806 |         if (is_off_limits_var(name))    /* a built-in variable */[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  807 |                 node->flags |= NO_EXT_SET;[0m
      | [0;1;32m                                          
[0m[1mgawkapi.c:824:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  824 |             || node->type != Node_var)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  825 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:848:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  848 |             || (name_space[0] != '\0' && ! is_valid_identifier(name_space)))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m  849 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:864:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  864 |                 return awk_false;[0m
      | [0;1;32m                ^               
[0m      | [0;32m                {               ;} 
[0m[1mgawkapi.c:919:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  919 |                     && value->val_type != AWK_UNDEFINED)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  920 |                         node->type = Node_var;[0m
      | [0;1;32m                                              
[0m[1mgawkapi.c:940:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  940 |             || (node->flags & NO_EXT_SET) != 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  941 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:953:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  953 |                 if (node->var_value->valref == 1 && ! do_mpfr) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  954 |                         NODE *r = node->var_value;[0m
  955 | [0m
  956 |                         /* r_unref: */[0m
  957 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
  958 |                                 efree(r->stptr);[0m
  959 |                         free_wstr(r);[0m
  960 | [0m
  961 |                         /* r_make_number: */[0m
  962 |                         r->numbr = value->num_value;[0m
  963 |                         r->flags = MALLOC|NUMBER|NUMCUR;[0m
  964 |                         r->stptr = NULL;[0m
  965 |                         r->stlen = 0;[0m
  966 |                         return awk_true;[0m
  967 |                 }[0m
  968 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:957:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  957 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m  958 |                                 efree(r->stptr);[0m
      | [0;1;32m                                                
[0m[1mgawkapi.c:963:15: [0m[0;1;35mwarning: [0m[1mThe value '25' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  963 |                         r->flags = MALLOC|NUMBER|NUMCUR;[0m
      | [0;1;32m                                   ^~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mAssuming 'value' is not equal to NULL[0m
  937 |         if (value == NULL[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkapi.c:938:9: [0m[0;1;36mnote: [0mAssuming 'node' is not equal to NULL[0m
  938 |             || node == NULL[0m
      | [0;1;32m               ^~~~~~~~~~~~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  937 |         if (value == NULL[0m
      | [0;1;32m            ^
[0m[1mgawkapi.c:939:9: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_var[0m
  939 |             || node->type != Node_var[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  937 |         if (value == NULL[0m
      | [0;1;32m            ^
[0m[1mgawkapi.c:940:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  940 |             || (node->flags & NO_EXT_SET) != 0)[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:937:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  937 |         if (value == NULL[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:951:2: [0m[0;1;36mnote: [0mControl jumps to 'case AWK_NUMBER:'  at line 952[0m
  951 |         switch (value->val_type) {[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:953:7: [0m[0;1;36mnote: [0mAssuming field 'valref' is equal to 1[0m
  953 |                 if (node->var_value->valref == 1 && ! do_mpfr) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:953:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mgawkapi.c:953:39: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  953 |                 if (node->var_value->valref == 1 && ! do_mpfr) {[0m
      | [0;1;32m                                                    ^~~~~~~~~
[0m[1mgawkapi.c:953:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  953 |                 if (node->var_value->valref == 1 && ! do_mpfr) {[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:957:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  957 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:957:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  957 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:959:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  959 |                         free_wstr(r);[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1750:31: [0m[0;1;36mnote: [0mexpanded from macro 'free_wstr'[0m
 1750 | #define free_wstr(n)    do { if ((n)->flags & WSTRCUR) r_free_wstr(n); } while(0)[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:959:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  959 |                         free_wstr(r);[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1750:27: [0m[0;1;36mnote: [0mexpanded from macro 'free_wstr'[0m
 1750 | #define free_wstr(n)    do { if ((n)->flags & WSTRCUR) r_free_wstr(n); } while(0)[0m
      | [0;1;32m                             ^
[0m[1mgawkapi.c:959:4: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  959 |                         free_wstr(r);[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1750:22: [0m[0;1;36mnote: [0mexpanded from macro 'free_wstr'[0m
 1750 | #define free_wstr(n)    do { if ((n)->flags & WSTRCUR) r_free_wstr(n); } while(0)[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:963:15: [0m[0;1;36mnote: [0mThe value '25' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  963 |                         r->flags = MALLOC|NUMBER|NUMCUR;[0m
      | [0;1;32m                                   ^~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:976:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  976 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m  977 |                                 efree(r->stptr);[0m
      | [0;1;32m                                                
[0m[1mgawkapi.c:984:15: [0m[0;1;35mwarning: [0m[1mThe value '7' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  984 |                         r->flags = (MALLOC|STRING|STRCUR);[0m
      | [0;1;32m                                   ^~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mAssuming 'value' is not equal to NULL[0m
  937 |         if (value == NULL[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkapi.c:938:9: [0m[0;1;36mnote: [0mAssuming 'node' is not equal to NULL[0m
  938 |             || node == NULL[0m
      | [0;1;32m               ^~~~~~~~~~~~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  937 |         if (value == NULL[0m
      | [0;1;32m            ^
[0m[1mgawkapi.c:939:9: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_var[0m
  939 |             || node->type != Node_var[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:937:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  937 |         if (value == NULL[0m
      | [0;1;32m            ^
[0m[1mgawkapi.c:940:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  940 |             || (node->flags & NO_EXT_SET) != 0)[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:937:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  937 |         if (value == NULL[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:951:2: [0m[0;1;36mnote: [0mControl jumps to 'case AWK_STRNUM:'  at line 971[0m
  951 |         switch (value->val_type) {[0m
      | [0;1;32m        ^
[0m[1mgawkapi.c:972:7: [0m[0;1;36mnote: [0mAssuming field 'valref' is equal to 1[0m
  972 |                 if (node->var_value->valref == 1) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:972:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  972 |                 if (node->var_value->valref == 1) {[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:976:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  976 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:976:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  976 |                         if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:980:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  980 |                         free_wstr(r);[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1750:31: [0m[0;1;36mnote: [0mexpanded from macro 'free_wstr'[0m
 1750 | #define free_wstr(n)    do { if ((n)->flags & WSTRCUR) r_free_wstr(n); } while(0)[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:980:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  980 |                         free_wstr(r);[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1750:27: [0m[0;1;36mnote: [0mexpanded from macro 'free_wstr'[0m
 1750 | #define free_wstr(n)    do { if ((n)->flags & WSTRCUR) r_free_wstr(n); } while(0)[0m
      | [0;1;32m                             ^
[0m[1mgawkapi.c:980:4: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  980 |                         free_wstr(r);[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1750:22: [0m[0;1;36mnote: [0mexpanded from macro 'free_wstr'[0m
 1750 | #define free_wstr(n)    do { if ((n)->flags & WSTRCUR) r_free_wstr(n); } while(0)[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:984:15: [0m[0;1;36mnote: [0mThe value '7' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  984 |                         r->flags = (MALLOC|STRING|STRCUR);[0m
      | [0;1;32m                                   ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:985:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  985 |                         if (value->val_type == AWK_STRNUM)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  986 |                                 r->flags |= USER_INPUT;[0m
      | [0;1;32m                                                       
[0m[1mgawkapi.c:995:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  995 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mgawkapi.c:1005:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1005 |                 return awk_false;[0m
      | [0;1;32m                ^               
[0m      | [0;32m                {               ;} 
[0m[1mgawkapi.c:1033:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1033 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mgawkapi.c:1060:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1060 |             || ! valid_subscript_type(index->val_type))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1061 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1103:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1103 |             || ! valid_subscript_type(index->val_type))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1104 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1128:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1128 |         if (array == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1129 |                 fatal(_("remove_element: received null array"));[0m
      | [0;1;32m                                                                
[0m[1mgawkapi.c:1131:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1131 |         if (subscript == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1132 |                 fatal(_("remove_element: received null subscript"));[0m
      | [0;1;32m                                                                    
[0m[1mgawkapi.c:1136:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1136 |         if (val == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1137 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:1144:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1144 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1145 |                 unref(val);[0m
      | [0;1;32m                           
[0m[1mgawkapi.c:1166:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1166 |             || ! valid_subscript_type(index->val_type))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1167 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1187:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1187 |         if (count == NULL || node == NULL || node->type != Node_var_array)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 1188 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1202:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1202 |         memset(n, 0, sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1mgawkapi.c:1202:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1202 |         memset(n, 0, sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1mgawkapi.c:1217:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1217 |             || (node->flags & NO_EXT_SET) != 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1218 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1229:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1229 |         if (! api_clear_array(id, a_cookie))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1230 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1251:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1251 |             || data == NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1252 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1307:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1307 |             || data->opaque2 == NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1308 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1334:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1334 |         if (value == NULL || result == NULL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1335 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1345:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1345 |                 return awk_false;[0m
      | [0;1;32m                ^               
[0m      | [0;32m                {               ;} 
[0m[1mgawkapi.c:1358:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1358 |         if (val == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1359 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1414:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1414 |                         if (nextfile(& curfile, false) <= 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1415 |                                 return awk_false;[0m
      | [0;1;32m                                                 
[0m[1mgawkapi.c:1423:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1423 |                                 if (pc == NULL)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1424 |                                         fatal(_("cannot find end of BEGINFILE rule"));[0m
      | [0;1;32m                                                                                      
[0m[1mgawkapi.c:1425:9: [0m[0;1;35mwarning: [0m[1mAccess to field 'opcode' results in a dereference of a null pointer (loaded from variable 'pc') [clang-analyzer-core.NullDereference][0m
 1425 |                                 if (pc->opcode == Op_after_beginfile)[0m
      | [0;1;32m                                    ^~
[0m[1mgawkapi.c:1408:6: [0m[0;1;36mnote: [0mAssuming 'name' is equal to NULL[0m
 1408 |         if (name == NULL || namelen == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mgawkapi.c:1408:19: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1408 |         if (name == NULL || namelen == 0) {[0m
      | [0;1;32m                         ^
[0m[1mgawkapi.c:1409:7: [0m[0;1;36mnote: [0mAssuming 'curfile' is equal to NULL[0m
 1409 |                 if (curfile == NULL) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1409:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1409 |                 if (curfile == NULL) {[0m
      | [0;1;32m                ^
[0m[1mgawkapi.c:1414:8: [0m[0;1;36mnote: [0mValue assigned to 'main_beginfile'[0m
 1414 |                         if (nextfile(& curfile, false) <= 0)[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1414:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1414 |                         if (nextfile(& curfile, false) <= 0)[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1414:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1414 |                         if (nextfile(& curfile, false) <= 0)[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:1417:4: [0m[0;1;36mnote: [0mValue assigned to 'pc'[0m
 1417 |                         pc = main_beginfile;[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~
[0m[1mgawkapi.c:1422:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1422 |                         for (;;) {[0m
      | [0;1;32m                        ^
[0m[1mgawkapi.c:1423:9: [0m[0;1;36mnote: [0mAssuming 'pc' is equal to NULL[0m
 1423 |                                 if (pc == NULL)[0m
      | [0;1;32m                                    ^~~~~~~~~~
[0m[1mgawkapi.c:1423:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1423 |                                 if (pc == NULL)[0m
      | [0;1;32m                                ^
[0m[1mgawkapi.c:1425:9: [0m[0;1;36mnote: [0mAccess to field 'opcode' results in a dereference of a null pointer (loaded from variable 'pc')[0m
 1425 |                                 if (pc->opcode == Op_after_beginfile)[0m
      | [0;1;32m                                    ^~
[0m[1mgawkapi.c:1425:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1425 |                                 if (pc->opcode == Op_after_beginfile)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1426 |                                         break;[0m
      | [0;1;32m                                              
[0m[1mgawkapi.c:1446:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1446 |                 if (filetype[1] == '\0')[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1447 |                         redirtype = redirect_input;[0m
 1448 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:1446:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1446 |                 if (filetype[1] == '\0')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1447 |                         redirtype = redirect_input;[0m
      | [0;1;32m                                                   
[0m[1mgawkapi.c:1450:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1450 |                 switch (filetype[1]) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1451 |                 case '\0':[0m
 1452 |                         redirtype = redirect_output;[0m
 1453 |                         break;[0m
 1454 |                 case '>':[0m
 1455 |                         if (filetype[2] == '\0')[0m
 1456 |                                 redirtype = redirect_append;[0m
 1457 |                         break;[0m
 1458 |                 }[0m
 1459 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:1452:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1452 |                         redirtype = redirect_output;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1453 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mgawkapi.c:1455:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1455 |                         if (filetype[2] == '\0')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1456 |                                 redirtype = redirect_append;[0m
 1457 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mgawkapi.c:1455:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1455 |                         if (filetype[2] == '\0')[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1456 |                                 redirtype = redirect_append;[0m
      | [0;1;32m                                                            
[0m[1mgawkapi.c:1461:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1461 |                 if (filetype[2] == '\0') {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1462 |                         switch (filetype[1]) {[0m
 1463 |                         case '>':[0m
 1464 |                                 redirtype = redirect_pipe;[0m
 1465 |                                 break;[0m
 1466 |                         case '<':[0m
 1467 |                                 redirtype = redirect_pipein;[0m
 1468 |                                 break;[0m
 1469 |                         case '&':[0m
 1470 |                                 redirtype = redirect_twoway;[0m
 1471 |                                 break;[0m
 1472 |                         }[0m
 1473 |                 }[0m
 1474 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mgawkapi.c:1464:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1464 |                                 redirtype = redirect_pipe;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 1465 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:1467:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1467 |                                 redirtype = redirect_pipein;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 1468 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:1470:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1470 |                                 redirtype = redirect_twoway;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 1471 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mgawkapi.c:1483:83: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1483 |         if ((f = redirect_string(name, namelen, 0, redirtype, &flag, fd, false)) == NULL)[0m
      | [0;1;32m                                                                                         ^
[0m      | [0;32m                                                                                          {
[0m 1484 |                 return awk_false;[0m
      | [0;1;32m                                 
[0m[1mgawkapi.c:1509:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1509 |         if (version == NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1510 |                 return;[0m
      | [0;1;32m                       
[0m[1mgawkapi.c:1626:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1626 |         for (p = vi_head; p != NULL; p = p->next)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1627 |                 printf("%s\n", p->version);[0m
      | [0;1;32m                                           
[0m[1mgawkapi.c:1649:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1649 |         if (AWK_UNDEFINED <= type && type <= AWK_VALUE_COOKIE)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1650 |                 return values[(int) type];[0m
      | [0;1;32m                                          
[0m[1mgawkapi.c:1652:2: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1652 |         sprintf(buf, "unknown type! (%d)", (int) type);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkapi.c:1652:2: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1652 |         sprintf(buf, "unknown type! (%d)", (int) type);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkapi.c:1666:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1666 |                 if (fullname != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1667 |                         *fullname = estrdup(name, strlen(name));[0m
      | [0;1;32m                                                                
[0m[1mgawkapi.c:1674:2: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1674 |         sprintf(buf, "%s::%s", name_space, name);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkapi.c:1674:2: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1674 |         sprintf(buf, "%s::%s", name_space, name);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkapi.c:1677:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1677 |         if (fullname != NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1678 |                 *fullname = buf;[0m
 1679 |         else[0m
      | [0;32m        } 
[0m[1mgawkapi.c:1679:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1679 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1680 |                 efree((void *) buf);[0m
      | [0;1;32m                                    
[0m172 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[40/54][152.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpdc3_j35t.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/pma.c
[1mpma.c:144:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  144 |     case     IU:  return      iu;[0m
      | [0;1;32m                  ^             
[0m      | [0;32m                  {             ;} 
[0m[1mpma.c:145:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  145 |     case    PIU:  return     piu;[0m
      | [0;1;32m                  ^             
[0m      | [0;32m                  {             ;} 
[0m[1mpma.c:146:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  146 |     case  GROWN:  return   grown;[0m
      | [0;1;32m                  ^             
[0m      | [0;32m                  {             ;} 
[0m[1mpma.c:148:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  148 |       ERR("bad bit: %d\n", bit);[0m
      | [0;1;32m      ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:148:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  148 |       ERR("bad bit: %d\n", bit);[0m
      | [0;1;32m      ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:148:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  148 |       ERR("bad bit: %d\n", bit);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  149 |       SE;[0m
  150 |       assert(0);[0m
  151 |       return INT_MIN;[0m
      | [0;1;32m                    
[0m      | [0;32m                    ;} 
[0m[1mpma.c:54:18: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                 ^
[0m[1mpma.c:179:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  179 |   DP("    AO at %p:  size %lu B / %lu w\n"[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:179:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  179 |   DP("    AO at %p:  size %lu B / %lu w\n"[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:197:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  197 |   FYI("integrity_check called from line %d\n", line);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:197:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  197 |   FYI("integrity_check called from line %d\n", line);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:199:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  199 |   WRN("integrity check relies on assertions, which are disabled (call at line %d)\n", line);[0m
      | [0;1;32m  ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:199:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  199 |   WRN("integrity check relies on assertions, which are disabled (call at line %d)\n", line);[0m
      | [0;1;32m  ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:209:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  209 |       WRN("integrity check discontinued; anext list too long (call at line %d)\n", line);[0m
      | [0;1;32m      ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:209:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  209 |       WRN("integrity check discontinued; anext list too long (call at line %d)\n", line);[0m
      | [0;1;32m      ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:213:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  213 |     if (0 == getbit(a, IU))[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  214 |       ++naddfree;[0m
      | [0;1;32m                 
[0m[1mpma.c:219:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  219 |   FYI("anext list length: %d  tiu %d  tpiu %d  nallocs %" PRIu64 "  nfrees %" PRIu64 "\n",[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:219:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  219 |   FYI("anext list length: %d  tiu %d  tpiu %d  nallocs %" PRIu64 "  nfrees %" PRIu64 "\n",[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:226:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  226 |     if (f->fprev == f)   // empty list[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  227 |       assert(f->fnext == f);[0m
  228 |     else {[0m
      | [0;32m    } 
[0m[1mpma.c:240:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  240 |         if (0 < i)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  241 |           assert(capwords > UB[i-1]);[0m
      | [0;1;32m                                     
[0m[1mpma.c:245:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  245 |   FYI("total free aos: %d  naddfree %d  integrity check line %d\n", tf, naddfree, line);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:245:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  245 |   FYI("total free aos: %d  naddfree %d  integrity check line %d\n", tf, naddfree, line);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:254:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  254 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:254:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  254 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:255:26: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  255 |   if (2 == state.init) { ERR("check_and_dump" NM); SE; assert(0); return; }[0m
      | [0;1;32m                         ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:255:26: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  255 |   if (2 == state.init) { ERR("check_and_dump" NM); SE; assert(0); return; }[0m
      | [0;1;32m                         ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:256:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  256 |   if (IC) ERR("integrity check failed\n");  // proceed with dump anyway (?)[0m
      | [0;1;32m         ^                                                                 
[0m      | [0;32m          {
[0m[1mpma.c:256:11: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  256 |   if (IC) ERR("integrity check failed\n");  // proceed with dump anyway (?)[0m
      | [0;1;32m          ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:256:11: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  256 |   if (IC) ERR("integrity check failed\n");  // proceed with dump anyway (?)[0m
      | [0;1;32m          ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:257:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  257 |   DP(COORDS "check data structures and dump\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:257:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  257 |   DP(COORDS "check data structures and dump\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:258:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  258 |   DP("header version:    %s\n", PMA_H_VERSION);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:258:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  258 |   DP("header version:    %s\n", PMA_H_VERSION);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:259:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  259 |   DP("software version:  %s\n", pma_version);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:259:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  259 |   DP("software version:  %s\n", pma_version);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:260:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  260 |   DP("sizeof state:  %lu\n", sizeof state);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:260:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  260 |   DP("sizeof state:  %lu\n", sizeof state);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:261:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  261 |   DP("sizeof header: %lu\n", sizeof(pma_hdr_t));[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:261:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  261 |   DP("sizeof header: %lu\n", sizeof(pma_hdr_t));[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:262:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  262 |   DP("state:\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:262:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  262 |   DP("state:\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:263:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  263 |   DP("  init: %d\n", state.init);  assert(0 == state.init || 1 == state.init || 2 == state.init);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:263:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  263 |   DP("  init: %d\n", state.init);  assert(0 == state.init || 1 == state.init || 2 == state.init);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:264:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  264 |   DP("  vrb:  %d\n", state.vrb);   assert(0 <= state.vrb && 3 >= state.vrb);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:264:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  264 |   DP("  vrb:  %d\n", state.vrb);   assert(0 <= state.vrb && 3 >= state.vrb);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:265:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  265 |   DP("  file: %p \"%s\"\n", (const void *)state.file, state.file);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:265:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  265 |   DP("  file: %p \"%s\"\n", (const void *)state.file, state.file);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:266:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  266 |   DP("  hdr:  %p\n", VS h);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:266:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  266 |   DP("  hdr:  %p\n", VS h);[0m
      | [0;1;32m  ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:268:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  268 |     DP("header:\n");   // nallocs & nfrees not printed; they'd add noise to initial/final state diff[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:268:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  268 |     DP("header:\n");   // nallocs & nfrees not printed; they'd add noise to initial/final state diff[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:269:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  269 |     DP("  mapaddr: %p\n", h->mapaddr);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:269:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  269 |     DP("  mapaddr: %p\n", h->mapaddr);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:270:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  270 |     DP("  bf_vers: %" PRIu64 "\n", h->bf_vers);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:270:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  270 |     DP("  bf_vers: %" PRIu64 "\n", h->bf_vers);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:271:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  271 |     DP("  root:   %p\n", h->root);    assert(NULL == h->root || (h->root >= VS h->afirst && h->root < VS h->abound));[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:271:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  271 |     DP("  root:   %p\n", h->root);    assert(NULL == h->root || (h->root >= VS h->afirst && h->root < VS h->abound));[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:272:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  272 |     DP("  afirst: %p\n", VS h->afirst);  assert(VS h->afirst > h->mapaddr);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:272:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  272 |     DP("  afirst: %p\n", VS h->afirst);  assert(VS h->afirst > h->mapaddr);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:273:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  273 |     DP("  abound: %p\n", VS h->abound);  assert(h->abound > h->afirst);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:273:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  273 |     DP("  abound: %p\n", VS h->abound);  assert(h->abound > h->afirst);[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:274:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  274 |     DP("  all allocated objects in addr order:\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:274:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  274 |     DP("  all allocated objects in addr order:\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:281:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  281 |       if (f->fprev == f)   // empty list[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  282 |         assert(f->fnext == f);[0m
  283 |       else {[0m
      | [0;32m      } 
[0m[1mpma.c:284:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  284 |         DP("  free list of size class %d UB %lu (prev %lu) list head %p:\n", i, UB[i], i > 0 ? UB[i-1] : 0, VS f);[0m
      | [0;1;32m        ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:284:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  284 |         DP("  free list of size class %d UB %lu (prev %lu) list head %p:\n", i, UB[i], i > 0 ? UB[i-1] : 0, VS f);[0m
      | [0;1;32m        ^
[0m[1mpma.c:155:23: [0m[0;1;36mnote: [0mexpanded from macro 'DP'[0m
  155 | #define DP(...) (void)fprintf(stderr, __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:285:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  285 |         for (ao_t *p = f->fnext; p != f; p = p->fnext)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  286 |           pao(p);[0m
      | [0;1;32m                 
[0m[1mpma.c:299:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  299 |     FYI("initializing UB[]\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:299:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  299 |     FYI("initializing UB[]\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:305:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  305 |       else                               UB[c] = (size_t)hi;[0m
      | [0;1;32m          ^                                                 
[0m      | [0;32m           {
[0m[1mpma.c:312:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  312 |   for (c = 0; NFL > c; c++)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  313 |     if (nwords <= UB[c])[0m
  314 |       break;[0m
      | [0;1;32m            
[0m[1mpma.c:313:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  313 |     if (nwords <= UB[c])[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  314 |       break;[0m
      | [0;1;32m            
[0m[1mpma.c:327:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  327 |   FYI("fli(%p) h == %p h->fn %p h->fp %p\n", VS p, VS h, VS h->fnext, VS h->fprev);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:327:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  327 |   FYI("fli(%p) h == %p h->fn %p h->fp %p\n", VS p, VS h, VS h->fnext, VS h->fprev);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:352:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  352 |   FYI("addrgap(%jd)\n", (intmax_t)n);  // TODO: better way to handle off_t[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:352:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  352 |   FYI("addrgap(%jd)\n", (intmax_t)n);  // TODO: better way to handle off_t[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:353:40: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  353 |   if (N < sizeof(pma_hdr_t) + 40960) { ERR("file size %zu too small\n", N); SERN; }[0m
      | [0;1;32m                                       ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:353:40: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  353 |   if (N < sizeof(pma_hdr_t) + 40960) { ERR("file size %zu too small\n", N); SERN; }[0m
      | [0;1;32m                                       ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:363:76: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  363 |     if (MAP_FAILED != (A = MMAP(M))) { assert(Max < M); Max = M; Amax = A; MUNMAP(A, M); if (UINT64_MAX == M) break; L = M + 1; }[0m
      | [0;1;32m                                                                           ^
[0m[1mpma.c:349:56: [0m[0;1;36mnote: [0mexpanded from macro 'MUNMAP'[0m
  349 | #define MUNMAP(A, N) do { if (0 != munmap((A), (N))) { ERR("munmap()" ERN); SERN; } } while (0)[0m
      | [0;1;32m                                                       ^~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:363:76: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  363 |     if (MAP_FAILED != (A = MMAP(M))) { assert(Max < M); Max = M; Amax = A; MUNMAP(A, M); if (UINT64_MAX == M) break; L = M + 1; }[0m
      | [0;1;32m                                                                           ^
[0m[1mpma.c:349:56: [0m[0;1;36mnote: [0mexpanded from macro 'MUNMAP'[0m
  349 | #define MUNMAP(A, N) do { if (0 != munmap((A), (N))) { ERR("munmap()" ERN); SERN; } } while (0)[0m
      | [0;1;32m                                                       ^~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:363:110: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  363 |     if (MAP_FAILED != (A = MMAP(M))) { assert(Max < M); Max = M; Amax = A; MUNMAP(A, M); if (UINT64_MAX == M) break; L = M + 1; }[0m
      | [0;1;32m                                                                                                             ^
[0m      | [0;32m                                                                                                              {
[0m[1mpma.c:366:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  366 |   FYI("max gap: %zu bytes at %p\n", Max, Amax);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:366:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  366 |   FYI("max gap: %zu bytes at %p\n", Max, Amax);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:368:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  368 |     ERR("max gap %zu too small for required %zu\n", Max, N);[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:368:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  368 |     ERR("max gap %zu too small for required %zu\n", Max, N);[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:372:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  372 |   if ((uintptr_t)r % ALGN)  // align on conservative boundary[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  373 |     r += (uintptr_t)ALGN - ((uintptr_t)r % ALGN);[0m
      | [0;1;32m                                                 
[0m[1mpma.c:375:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  375 |   FYI("addrgap returns %p == %lu\n", VS r, (uintptr_t)r);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:375:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  375 |   FYI("addrgap returns %p == %lu\n", VS r, (uintptr_t)r);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:388:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  388 |   FYI("pma_init(%d,\"%s\")\n", verbose, file);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:388:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  388 |   FYI("pma_init(%d,\"%s\")\n", verbose, file);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:391:14: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  391 |     if (1 != sscanf(ev, "%1d", &newvrb)) { ERR("parsing envar verbosity \"%s\"\n", ev); SERL; }[0m
      | [0;1;32m             ^~~~~~
[0m[1mpma.c:391:14: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
  391 |     if (1 != sscanf(ev, "%1d", &newvrb)) { ERR("parsing envar verbosity \"%s\"\n", ev); SERL; }[0m
      | [0;1;32m             ^~~~~~
[0m[1mpma.c:391:44: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  391 |     if (1 != sscanf(ev, "%1d", &newvrb)) { ERR("parsing envar verbosity \"%s\"\n", ev); SERL; }[0m
      | [0;1;32m                                           ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:391:44: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  391 |     if (1 != sscanf(ev, "%1d", &newvrb)) { ERR("parsing envar verbosity \"%s\"\n", ev); SERL; }[0m
      | [0;1;32m                                           ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:392:44: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  392 |     if (! (0 <= newvrb && 3 >= newvrb))  { ERR("bad envar verbosity %d\n", newvrb);     SERL; }[0m
      | [0;1;32m                                           ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:392:44: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  392 |     if (! (0 <= newvrb && 3 >= newvrb))  { ERR("bad envar verbosity %d\n", newvrb);     SERL; }[0m
      | [0;1;32m                                           ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:394:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  394 |     WRN("envar verbosity over-ride %d -> %d\n", verbose, newvrb);[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:394:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  394 |     WRN("envar verbosity over-ride %d -> %d\n", verbose, newvrb);[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:396:21: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  396 |   if (state.init) { ERR("already initialized\n"); SE; assert(0); RL; }[0m
      | [0;1;32m                    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:396:21: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  396 |   if (state.init) { ERR("already initialized\n"); SE; assert(0); RL; }[0m
      | [0;1;32m                    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:397:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  397 |   FYI("software version '%s' expects backing file format version %d\n",[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:397:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  397 |   FYI("software version '%s' expects backing file format version %d\n",[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:400:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  400 |     ERR("software version mismatch: '%s' / '%s'\n", pma_version, PMA_H_VERSION);[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:400:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  400 |     ERR("software version mismatch: '%s' / '%s'\n", pma_version, PMA_H_VERSION);[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:408:44: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  408 |          WDSZ == sizeof(unsigned long))) { ERR("word size not 64 bits\n"); SERL; }[0m
      | [0;1;32m                                           ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:408:44: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  408 |          WDSZ == sizeof(unsigned long))) { ERR("word size not 64 bits\n"); SERL; }[0m
      | [0;1;32m                                           ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:411:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  411 |     WRN("no backing file provided; falling back on standard malloc\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:411:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  411 |     WRN("no backing file provided; falling back on standard malloc\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:418:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  418 |     ERR("bad page size %ld, errno '%s'\n", ps, strerror(errno)); SERL; }[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:418:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  418 |     ERR("bad page size %ld, errno '%s'\n", ps, strerror(errno)); SERL; }[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:419:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  419 |   for (pwr2 = 4096; pwr2 <= ALGN; pwr2 *= 2)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  420 |     if (pwr2 == ps) { pwr2flag = 1; break; }[0m
      | [0;1;32m                                            
[0m[1mpma.c:422:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  422 |     ERR("page size %ld not a reasonable power of two\n", ps); SERL; }[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:422:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  422 |     ERR("page size %ld not a reasonable power of two\n", ps); SERL; }[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:424:45: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  424 |   if (0 > (fd = open(file, O_RDWR)))      { ERR("open()"    ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:424:45: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  424 |   if (0 > (fd = open(file, O_RDWR)))      { ERR("open()"    ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:425:45: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  425 |   if (0 != fstat(fd, &s))                 { ERR("fstat()"   ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:425:45: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  425 |   if (0 != fstat(fd, &s))                 { ERR("fstat()"   ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:426:31: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  426 |   if (!S_ISREG(s.st_mode))  { ERR("%s not regular file\n", file); SERL; }[0m
      | [0;1;32m                              ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:426:31: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  426 |   if (!S_ISREG(s.st_mode))  { ERR("%s not regular file\n", file); SERL; }[0m
      | [0;1;32m                              ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:427:45: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  427 |   if ((ssize_t)as != read(fd, &a1, as))   { ERR("read()"    ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:427:45: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  427 |   if ((ssize_t)as != read(fd, &a1, as))   { ERR("read()"    ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:428:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  428 |   if (NULL == a1) a1 = addrgap(s.st_size);[0m
      | [0;1;32m                 ^                        
[0m      | [0;32m                  {
[0m[1mpma.c:429:45: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  429 |   if (NULL == a1)                         { ERR("addrgap()" ERN);   RL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:429:45: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  429 |   if (NULL == a1)                         { ERR("addrgap()" ERN);   RL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:430:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  430 |   FYI("map at %p\n", a1);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:430:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  430 |   FYI("map at %p\n", a1);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:431:45: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  431 |   if (a1 != (a2 = MM(a1, s.st_size, fd))) { ERR("mmap()"    ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:431:45: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  431 |   if (a1 != (a2 = MM(a1, s.st_size, fd))) { ERR("mmap()"    ERN); SERL; }[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:432:45: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  432 |   if (0 != close(fd))                     { ERR("close()"   ERN); SE;   }  // carry on[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:432:45: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  432 |   if (0 != close(fd))                     { ERR("close()"   ERN); SE;   }  // carry on[0m
      | [0;1;32m                                            ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:439:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  439 |     FYI("initializing persistent heap\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:439:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  439 |     FYI("initializing persistent heap\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:441:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  441 |       ERR("backing file size %jd not multiple of page size %ld\n", (intmax_t)s.st_size, ps);[0m
      | [0;1;32m      ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:441:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  441 |       ERR("backing file size %jd not multiple of page size %ld\n", (intmax_t)s.st_size, ps);[0m
      | [0;1;32m      ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:476:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  476 |     FYI("persistent heap already initialized\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:476:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  476 |     FYI("persistent heap already initialized\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:480:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  480 |     if (s.st_size % ps)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  481 |       WRN("backing file size %jd not multiple of page size %ld\n", (intmax_t)s.st_size, ps);[0m
      | [0;1;32m                                                                                            
[0m[1mpma.c:481:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  481 |       WRN("backing file size %jd not multiple of page size %ld\n", (intmax_t)s.st_size, ps);[0m
      | [0;1;32m      ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:481:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  481 |       WRN("backing file size %jd not multiple of page size %ld\n", (intmax_t)s.st_size, ps);[0m
      | [0;1;32m      ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:483:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  483 |       ERR("backing file version mismatch: %d vs. %" PRIu64 "\n", VERS, h->bf_vers);[0m
      | [0;1;32m      ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:483:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  483 |       ERR("backing file version mismatch: %d vs. %" PRIu64 "\n", VERS, h->bf_vers);[0m
      | [0;1;32m      ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:498:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  498 |   if (s < 24) s = 24;  // increase request size to minimum allocation size if necessary; TODO: magic number here[0m
      | [0;1;32m             ^                                                                                                  
[0m      | [0;32m              {
[0m[1mpma.c:503:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  503 |   FYI("split_ao(%p,%zu) AOCAP %zu words req %zu words cap %zu\n", VS p, s, c, Sw, Cw);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:503:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  503 |   FYI("split_ao(%p,%zu) AOCAP %zu words req %zu words cap %zu\n", VS p, s, c, Sw, Cw);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:508:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  508 |     FYI("splitting at %p\n", VS rem);[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:508:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  508 |     FYI("splitting at %p\n", VS rem);[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:509:10: [0m[0;1;35mwarning: [0m[1mOut of bound access to memory after the end of the field 'fprev' [clang-analyzer-security.ArrayBound][0m
  509 |     rem->anext = HIBH(p->anext);  // set header of remainder[0m
      | [0;1;32m         ^
[0m[1mpma.c:579:3: [0m[0;1;36mnote: [0mAssuming 2 is >= field 'vrb'[0m
  579 |   FYI("realloc(%p,%zu)\n", ptr, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:27: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mpma.c:579:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  579 |   FYI("realloc(%p,%zu)\n", ptr, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:23: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                      ^
[0m[1mpma.c:579:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  579 |   FYI("realloc(%p,%zu)\n", ptr, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:18: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                 ^
[0m[1mpma.c:580:3: [0m[0;1;36mnote: [0mAssuming 1 is equal to field 'init'[0m
  580 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:15: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~
[0m[1mpma.c:580:3: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  580 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:31: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                              ^
[0m[1mpma.c:580:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  580 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:8: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m       ^
[0m[1mpma.c:580:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  580 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:3: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m  ^
[0m[1mpma.c:581:7: [0m[0;1;36mnote: [0m2 is not equal to field 'init'[0m
  581 |   if (2 == state.init) return realloc(ptr, size);[0m
      | [0;1;32m      ^
[0m[1mpma.c:581:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  581 |   if (2 == state.init) return realloc(ptr, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:582:7: [0m[0;1;36mnote: [0mAssuming 'ptr' is equal to NULL[0m
  582 |   if (NULL == ptr) return pma_malloc(size);[0m
      | [0;1;32m      ^
[0m[1m/home/C00536225/dev/tcc/build/lib/clang/21/include/__stddef_null.h:26:14: [0m[0;1;36mnote: [0mexpanded from macro 'NULL'[0m
   26 | #define NULL ((void*)0)[0m
      | [0;1;32m             ^
[0m[1mpma.c:582:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  582 |   if (NULL == ptr) return pma_malloc(size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:582:27: [0m[0;1;36mnote: [0mCalling 'pma_malloc'[0m
  582 |   if (NULL == ptr) return pma_malloc(size);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~
[0m[1mpma.c:530:3: [0m[0;1;36mnote: [0m2 is >= field 'vrb'[0m
  530 |   FYI("malloc(%zu)\n", size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:27: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                          ^
[0m[1mpma.c:530:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  530 |   FYI("malloc(%zu)\n", size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:23: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                      ^
[0m[1mpma.c:530:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  530 |   FYI("malloc(%zu)\n", size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:18: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                 ^
[0m[1mpma.c:531:3: [0m[0;1;36mnote: [0m1 is equal to field 'init'[0m
  531 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:15: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m              ^
[0m[1mpma.c:531:3: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  531 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:31: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                              ^
[0m[1mpma.c:531:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  531 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:8: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m       ^
[0m[1mpma.c:531:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  531 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:3: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m  ^
[0m[1mpma.c:532:7: [0m[0;1;36mnote: [0m2 is not equal to field 'init'[0m
  532 |   if (2 == state.init) return malloc(size);[0m
      | [0;1;32m      ^
[0m[1mpma.c:532:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  532 |   if (2 == state.init) return malloc(size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:534:7: [0m[0;1;36mnote: [0mAssuming 'size' is > 0[0m
  534 |   if (0 >= size) {[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mpma.c:534:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  534 |   if (0 >= size) {[0m
      | [0;1;32m  ^
[0m[1mpma.c:536:26: [0m[0;1;36mnote: [0mAssuming 'c' is < NFL[0m
  536 |   for (int c = sc(size); c < NFL; c++) {[0m
      | [0;1;32m                         ^~~~~~~
[0m[1mpma.c:536:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  536 |   for (int c = sc(size); c < NFL; c++) {[0m
      | [0;1;32m  ^
[0m[1mpma.c:539:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  539 |     for (ao_t *f = h->fnext; f != h; f = f->fnext) {[0m
      | [0;1;32m    ^
[0m[1mpma.c:541:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  541 |       if (AOCAP(f) >= size) {[0m
      | [0;1;32m          ^
[0m[1mpma.c:92:25: [0m[0;1;36mnote: [0mexpanded from macro 'AOCAP'[0m
   92 | #define AOCAP(ao_t_ptr) (AOSZ(ao_t_ptr) - WDSZ)[0m
      | [0;1;32m                        ^
[0m[1mpma.c:541:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  541 |       if (AOCAP(f) >= size) {[0m
      | [0;1;32m      ^
[0m[1mpma.c:543:9: [0m[0;1;36mnote: [0mControl jumps to line 548[0m
  543 |         goto end;[0m
      | [0;1;32m        ^
[0m[1mpma.c:548:15: [0m[0;1;36mnote: [0m'r' is not equal to NULL[0m
  548 |   if (NULL != r) {[0m
      | [0;1;32m              ^
[0m[1mpma.c:548:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  548 |   if (NULL != r) {[0m
      | [0;1;32m  ^
[0m[1mpma.c:550:9: [0m[0;1;36mnote: [0mCalling 'split_ao'[0m
  550 |     r = split_ao(r, size);[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~
[0m[1mpma.c:498:7: [0m[0;1;36mnote: [0mAssuming 's' is < 24[0m
  498 |   if (s < 24) s = 24;  // increase request size to minimum allocation size if necessary; TODO: magic number here[0m
      | [0;1;32m      ^~~~~~
[0m[1mpma.c:498:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  498 |   if (s < 24) s = 24;  // increase request size to minimum allocation size if necessary; TODO: magic number here[0m
      | [0;1;32m  ^
[0m[1mpma.c:503:3: [0m[0;1;36mnote: [0mAssuming 2 is >= field 'vrb'[0m
  503 |   FYI("split_ao(%p,%zu) AOCAP %zu words req %zu words cap %zu\n", VS p, s, c, Sw, Cw);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:27: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mpma.c:503:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  503 |   FYI("split_ao(%p,%zu) AOCAP %zu words req %zu words cap %zu\n", VS p, s, c, Sw, Cw);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:23: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                      ^
[0m[1mpma.c:503:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  503 |   FYI("split_ao(%p,%zu) AOCAP %zu words req %zu words cap %zu\n", VS p, s, c, Sw, Cw);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:18: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                 ^
[0m[1mpma.c:505:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  505 |   if (4 <= Cw - Sw) {  // split ao if remainder is large enough to be allocatable[0m
      | [0;1;32m      ^~~~~~~~~~~~
[0m[1mpma.c:505:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  505 |   if (4 <= Cw - Sw) {  // split ao if remainder is large enough to be allocatable[0m
      | [0;1;32m  ^
[0m[1mpma.c:508:5: [0m[0;1;36mnote: [0m2 is >= field 'vrb'[0m
  508 |     FYI("splitting at %p\n", VS rem);[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:27: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                          ^
[0m[1mpma.c:508:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  508 |     FYI("splitting at %p\n", VS rem);[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:23: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                      ^
[0m[1mpma.c:508:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  508 |     FYI("splitting at %p\n", VS rem);[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:18: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                 ^
[0m[1mpma.c:509:10: [0m[0;1;36mnote: [0mAccess of the field 'fprev' at byte offset 24, while it holds only 8 bytes[0m
  509 |     rem->anext = HIBH(p->anext);  // set header of remainder[0m
      | [0;1;32m    ~~~~~^~~~~
[0m[1mpma.c:530:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  530 |   FYI("malloc(%zu)\n", size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:530:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  530 |   FYI("malloc(%zu)\n", size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:531:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  531 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:531:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  531 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:532:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  532 |   if (2 == state.init) return malloc(size);[0m
      | [0;1;32m                      ^                    
[0m      | [0;32m                       {
[0m[1mpma.c:535:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  535 |     WRN("malloc(%zu) argument <= zero\n", size);  SERN;  }[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:535:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  535 |     WRN("malloc(%zu) argument <= zero\n", size);  SERN;  }[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:551:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  551 |     FYI("malloc returning %p\n", VS &(r->fprev));[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:551:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  551 |     FYI("malloc returning %p\n", VS &(r->fprev));[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:557:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  557 |     WRN("malloc(%zu) cannot satisfy request at this time\n", size);[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:557:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  557 |     WRN("malloc(%zu) cannot satisfy request at this time\n", size);[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:564:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  564 |   FYI("calloc(%zu,%zu)\n", nmemb, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:564:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  564 |   FYI("calloc(%zu,%zu)\n", nmemb, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:565:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  565 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:565:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  565 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:566:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  566 |   if (2 == state.init) return calloc(nmemb, size);[0m
      | [0;1;32m                      ^                           
[0m      | [0;32m                       {
[0m[1mpma.c:568:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  568 |     WRN("calloc(%zu,%zu) argument <= zero\n", nmemb, size);  SERN;  }[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:568:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  568 |     WRN("calloc(%zu,%zu) argument <= zero\n", nmemb, size);  SERN;  }[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:571:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  571 |     WRN("calloc(%zu,%zu) arguments overflow\n", nmemb, size);  SERN;  }[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:571:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  571 |     WRN("calloc(%zu,%zu) arguments overflow\n", nmemb, size);  SERN;  }[0m
      | [0;1;32m    ^
[0m[1mpma.c:55:42: [0m[0;1;36mnote: [0mexpanded from macro 'WRN'[0m
   55 | #define WRN(...) do { if (1 < state.vrb) FP("Warning: " __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:572:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  572 |   if (NULL != (p = pma_malloc(nmemb * size)))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  573 |     (void)memset(p, 0, nmemb * size);[0m
      | [0;1;32m                                     
[0m[1mpma.c:573:11: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  573 |     (void)memset(p, 0, nmemb * size);[0m
      | [0;1;32m          ^~~~~~
[0m[1mpma.c:573:11: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  573 |     (void)memset(p, 0, nmemb * size);[0m
      | [0;1;32m          ^~~~~~
[0m[1mpma.c:579:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  579 |   FYI("realloc(%p,%zu)\n", ptr, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:579:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  579 |   FYI("realloc(%p,%zu)\n", ptr, size);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:580:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  580 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:580:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  580 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:581:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  581 |   if (2 == state.init) return realloc(ptr, size);[0m
      | [0;1;32m                      ^                          
[0m      | [0;32m                       {
[0m[1mpma.c:582:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  582 |   if (NULL == ptr) return pma_malloc(size);[0m
      | [0;1;32m                  ^                        
[0m      | [0;32m                   {
[0m[1mpma.c:585:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  585 |   if (AOCAP(p) >= size)  // no growth needed[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  586 |     return ptr;[0m
      | [0;1;32m               
[0m[1mpma.c:588:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  588 |   if (NULL == nu)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m  589 |     SERN;[0m
      | [0;1;32m         
[0m[1mpma.c:590:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  590 |   (void)memcpy(nu, ptr, AOCAP(p));[0m
      | [0;1;32m        ^~~~~~
[0m[1mpma.c:590:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  590 |   (void)memcpy(nu, ptr, AOCAP(p));[0m
      | [0;1;32m        ^~~~~~
[0m[1mpma.c:600:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  600 |   FYI("coalesce(%p)\n", VS p);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:600:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  600 |   FYI("coalesce(%p)\n", VS p);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:601:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  601 |   if (n >= state.hdr->abound)  // *p is final ao on anext list[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  602 |     return 0;[0m
      | [0;1;32m             
[0m[1mpma.c:612:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  612 |   else  // next ao is in use, therefore do not coalesce[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  613 |     return 0;[0m
      | [0;1;32m             
[0m[1mpma.c:618:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  618 |   FYI("free(%p)\n", ptr);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:618:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  618 |   FYI("free(%p)\n", ptr);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:619:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  619 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:619:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  619 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:622:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  622 |   if (NULL == ptr) return;  // allowed by C & POSIX[0m
      | [0;1;32m                  ^                                
[0m      | [0;32m                   {
[0m[1mpma.c:624:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  624 |     ERR("freed ptr %p outside allocatable area bounds %p %p\n",[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:624:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  624 |     ERR("freed ptr %p outside allocatable area bounds %p %p\n",[0m
      | [0;1;32m    ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:637:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  637 |   if (n < state.hdr->abound)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  638 |     assert(1 == getbit(n, PIU));[0m
      | [0;1;32m                                
[0m[1mpma.c:639:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  639 |   FYI("merge with right/higher ao\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:639:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  639 |   FYI("merge with right/higher ao\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:641:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  641 |   FYI("%s\n", r ? "yes" : "no");[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:641:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  641 |   FYI("%s\n", r ? "yes" : "no");[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:645:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  645 |     FYI("merge with left/lower ao\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:645:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  645 |     FYI("merge with left/lower ao\n");[0m
      | [0;1;32m    ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:646:5: [0m[0;1;35mwarning: [0m[1mValue stored to 'r' is never read [clang-analyzer-deadcode.DeadStores][0m
  646 |     r = coalesce(prev, 0);[0m
      | [0;1;32m    ^   ~~~~~~~~~~~~~~~~~
[0m[1mpma.c:646:5: [0m[0;1;36mnote: [0mValue stored to 'r' is never read[0m
  646 |     r = coalesce(prev, 0);[0m
      | [0;1;32m    ^   ~~~~~~~~~~~~~~~~~
[0m[1mpma.c:657:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  657 |   if (n < state.hdr->abound)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  658 |     slobh(n, getbit(n, IU), 0, getbit(n, GROWN));  // clear prev-in-use bit of next[0m
      | [0;1;32m                                                                                   
[0m[1mpma.c:665:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  665 |   FYI("set_root(%p)\n", p);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:665:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  665 |   FYI("set_root(%p)\n", p);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:666:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  666 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:666:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  666 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:667:34: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  667 |   if (2 == state.init)         { ERR("set_root" NM);      SE; assert(0); return; }[0m
      | [0;1;32m                                 ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:667:34: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  667 |   if (2 == state.init)         { ERR("set_root" NM);      SE; assert(0); return; }[0m
      | [0;1;32m                                 ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:668:34: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  668 |   if (! (NULL == p || VAO(p))) { ERR("bad root %p\n", p); SE; assert(0); return; }[0m
      | [0;1;32m                                 ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:668:34: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  668 |   if (! (NULL == p || VAO(p))) { ERR("bad root %p\n", p); SE; assert(0); return; }[0m
      | [0;1;32m                                 ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:676:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  676 |   FYI("get_root()\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:676:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  676 |   FYI("get_root()\n");[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:677:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  677 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:677:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  677 |   ASI(NULL);[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:678:26: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  678 |   if (2 == state.init) { ERR("get_root" NM); SE; assert(0); RN; }[0m
      | [0;1;32m                         ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:678:26: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  678 |   if (2 == state.init) { ERR("get_root" NM); SE; assert(0); RN; }[0m
      | [0;1;32m                         ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:686:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  686 |   FYI("set_avail_mem(0x%lx)\n", v);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:686:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  686 |   FYI("set_avail_mem(0x%lx)\n", v);[0m
      | [0;1;32m  ^
[0m[1mpma.c:56:42: [0m[0;1;36mnote: [0mexpanded from macro 'FYI'[0m
   56 | #define FYI(...) do { if (2 < state.vrb) FP("FYI: "     __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:687:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  687 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:687:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  687 |   ASI();[0m
      | [0;1;32m  ^
[0m[1mpma.c:136:54: [0m[0;1;36mnote: [0mexpanded from macro 'ASI'[0m
  136 |   do { if (! (1 == state.init || 2 == state.init)) { ERR("not initialized\n"); SE; assert(0); return __VA_ARGS__ ; } } while(0)[0m
      | [0;1;32m                                                     ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:688:26: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  688 |   if (2 == state.init) { ERR("set_avail_mem" NM); SE; assert(0); return; }[0m
      | [0;1;32m                         ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:688:26: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  688 |   if (2 == state.init) { ERR("set_avail_mem" NM); SE; assert(0); return; }[0m
      | [0;1;32m                         ^
[0m[1mpma.c:54:42: [0m[0;1;36mnote: [0mexpanded from macro 'ERR'[0m
   54 | #define ERR(...) do { if (0 < state.vrb) FP("ERROR: "   __VA_ARGS__); } while (0)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpma.c:52:23: [0m[0;1;36mnote: [0mexpanded from macro 'FP'[0m
   52 | #define FP(...) (void)fprintf(stderr, COORDS __VA_ARGS__)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpma.c:692:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  692 |     if (f->fprev != f)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  693 |       for (p = f->fnext; p != f; p = p->fnext) {[0m
  694 |         ul_t *q = (ul_t *)(1 + p),[0m
  695 |              *e = (ul_t *)(HIBH(p->anext)) - 1;[0m
  696 |         for ( ; q != e; q++)[0m
  697 |           if (*q != v)  // avoid over-writing same value; gratuitous modification is a Bad Thing for persistent memory[0m
  698 |             *q = v;[0m
  699 |         for ( ; q != e; q++)[0m
  700 |           assert(*q == v);[0m
  701 |       }[0m
      | [0;1;32m       
[0m[1mpma.c:696:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  696 |         for ( ; q != e; q++)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  697 |           if (*q != v)  // avoid over-writing same value; gratuitous modification is a Bad Thing for persistent memory[0m
  698 |             *q = v;[0m
      | [0;1;32m                   
[0m[1mpma.c:697:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  697 |           if (*q != v)  // avoid over-writing same value; gratuitous modification is a Bad Thing for persistent memory[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  698 |             *q = v;[0m
      | [0;1;32m                   
[0m[1mpma.c:699:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  699 |         for ( ; q != e; q++)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  700 |           assert(*q == v);[0m
      | [0;1;32m                          
[0m132 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[41/54][162.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpl78wkrqw.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/symbol.c
[1msymbol.c:67:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   67 |         memset(global_table, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:67:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
   67 |         memset(global_table, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:71:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   71 |         memset(param_table, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:71:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
   71 |         memset(param_table, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:101:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  101 |                 memset(root_pointers, 0, sizeof(struct root_pointers));[0m
      | [0;1;32m                ^~~~~~
[0m[1msymbol.c:101:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  101 |                 memset(root_pointers, 0, sizeof(struct root_pointers));[0m
      | [0;1;32m                ^~~~~~
[0m[1msymbol.c:113:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  113 |                 memcpy(nextfree, root_pointers->nextfree, sizeof(nextfree));[0m
      | [0;1;32m                ^~~~~~
[0m[1msymbol.c:113:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  113 |                 memcpy(nextfree, root_pointers->nextfree, sizeof(nextfree));[0m
      | [0;1;32m                ^~~~~~
[0m[1msymbol.c:117:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  117 |                 memset(param_table, '\0', sizeof(NODE));[0m
      | [0;1;32m                ^~~~~~
[0m[1msymbol.c:117:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  117 |                 memset(param_table, '\0', sizeof(NODE));[0m
      | [0;1;32m                ^~~~~~
[0m[1msymbol.c:127:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  127 |         if (! using_persistent_malloc)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  128 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:136:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  136 |         if (root_pointers->mpfr != do_mpfr)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  137 |                 fatal(_("current setting of -M/--bignum does not match saved setting in PMA backing file"));[0m
      | [0;1;32m                                                                                                            
[0m[1msymbol.c:145:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  145 |         if (! using_persistent_malloc)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  146 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:150:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  150 |         memcpy(root_pointers->nextfree, nextfree, sizeof(nextfree));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:150:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  150 |         memcpy(root_pointers->nextfree, nextfree, sizeof(nextfree));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:190:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  190 |                 if (assoc_empty(tables[i]))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  191 |                         continue;[0m
      | [0;1;32m                                 
[0m[1msymbol.c:193:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  193 |                 if ((do_posix || do_traditional) && tables[i] == global_table)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  194 |                         continue;[0m
      | [0;1;32m                                 
[0m[1msymbol.c:197:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  197 |                 if (n != NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  198 |                         break;[0m
      | [0;1;32m                              
[0m[1msymbol.c:202:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  202 |         if (n == NULL || n->type == Node_val)   /* non-variable in SYMTAB */[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  203 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1msymbol.c:215:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  215 |         if (pcount <= 0 || pnames == NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  216 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1msymbol.c:237:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  237 |         if (func == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  238 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:243:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  243 |             || (parms = func->fparms) == NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  244 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:246:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  246 |         for (i = 0; i < pcount; i++)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  247 |                 (void) install(parms[i].param, parms + i, Node_param_list);[0m
      | [0;1;32m                                                                           
[0m[1msymbol.c:261:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  261 |         if (func == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  262 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:267:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  267 |             || (parms = func->fparms) == NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  268 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:278:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  278 |                 if (tmp2 != NULL && tmp2->dup_ent != NULL)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  279 |                         tmp2->dup_ent = tmp2->dup_ent->dup_ent;[0m
  280 |                 else[0m
      | [0;32m                } 
[0m[1msymbol.c:280:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  280 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  281 |                         (void) assoc_remove(param_table, tmp);[0m
      | [0;1;32m                                                              
[0m[1msymbol.c:297:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  297 |         if (n == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  298 |                 return n;[0m
      | [0;1;32m                         
[0m[1msymbol.c:317:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  317 |         if (r == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  318 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:322:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  322 |                 if (r->param_cnt > 0) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  323 |                         NODE *n;[0m
  324 |                         int i;[0m
  325 |                         int pcount = r->param_cnt;[0m
  326 | [0m
  327 |                         /* function parameters of type Node_param_list */[0m
  328 |                         for (i = 0; i < pcount; i++) {[0m
  329 |                                 n = r->fparms + i;[0m
  330 |                                 efree(n->param);[0m
  331 |                         }[0m
  332 |                         efree(r->fparms);[0m
  333 |                 }[0m
  334 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:337:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  337 |                 bcfree(r->code_ptr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  338 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:341:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  341 |                 assoc_clear(r);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  342 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1m./awk.h:1398:24: [0m[0;1;36mnote: [0mexpanded from macro 'assoc_clear'[0m
 1398 | #define assoc_clear(a)  (void) ((a)->aclear(a, NULL))[0m
      | [0;1;32m                        ^
[0m[1msymbol.c:345:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  345 |                 unref(r->var_value);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  346 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:350:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  350 |                 break;  /* use break so that storage is freed */[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1msymbol.c:366:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  366 |         memset(r, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:366:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  366 |         memset(r, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:367:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  367 |         if (type == Node_var_array)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  368 |                 null_array(r);[0m
  369 |         else if (type == Node_var)[0m
      | [0;32m        } 
[0m[1msymbol.c:369:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  369 |         else if (type == Node_var)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  370 |                 r->var_value = dupnode(Nnull_string);[0m
      | [0;1;32m                                                     
[0m[1msymbol.c:402:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  402 |         if (parm != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  403 |                 r = parm;[0m
  404 |         else {[0m
      | [0;32m        } 
[0m[1msymbol.c:411:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  411 |                 if (prev == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  412 |                         goto simple;[0m
      | [0;1;32m                                    
[0m[1msymbol.c:422:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  422 |         if (install_func)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  423 |                 (*install_func)(r);[0m
      | [0;1;32m                                   
[0m[1msymbol.c:445:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  445 |         if (n1_is_in_ns && n2_is_in_ns)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  446 |                 return strcmp(n1->vname, n2->vname);[0m
  447 |         else if (n1_is_in_ns && ! n2_is_in_ns)[0m
      | [0;32m        } 
[0m[1msymbol.c:447:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  447 |         else if (n1_is_in_ns && ! n2_is_in_ns)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  448 |                 return 1;[0m
  449 |         else if (! n1_is_in_ns && n2_is_in_ns)[0m
      | [0;32m        } 
[0m[1msymbol.c:449:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  449 |         else if (! n1_is_in_ns && n2_is_in_ns)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  450 |                 return -1;[0m
  451 |         else[0m
      | [0;32m        } 
[0m[1msymbol.c:451:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  451 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  452 |                 return strcmp(n1->vname, n2->vname);[0m
      | [0;1;32m                                                    
[0m[1msymbol.c:487:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  487 |                         if (r->type == Node_ext_func || r->type == Node_builtin_func)[0m
      | [0;1;32m                                                                                     ^
[0m      | [0;32m                                                                                      {
[0m  488 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1msymbol.c:504:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  504 |                         if (r->type == Node_val)        /* non-variable in SYMTAB */[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  505 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1msymbol.c:515:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  515 |         if (sort && count > 1)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  516 |                 qsort(table, count, sizeof(NODE *), comp_symbol);       /* Shazzam! */[0m
      | [0;1;32m                                                                                      
[0m[1msymbol.c:549:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  549 |                 if (r->type == Node_func || r->type == Node_ext_func)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  550 |                         continue;[0m
      | [0;1;32m                                 
[0m[1msymbol.c:552:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  552 |                 if (r->type == Node_var_array)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  553 |                         print_func(fp, "array, %ld elements\n", assoc_length(r));[0m
  554 |                 else if (r->type == Node_var_new)[0m
      | [0;32m                } 
[0m[1msymbol.c:554:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  554 |                 else if (r->type == Node_var_new)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  555 |                         print_func(fp, "untyped variable\n");[0m
  556 |                 else if (r->type == Node_var)[0m
      | [0;32m                } 
[0m[1msymbol.c:556:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  556 |                 else if (r->type == Node_var)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  557 |                         valinfo(r->var_value, print_func, fp);[0m
  558 |                 else[0m
      | [0;32m                } 
[0m[1msymbol.c:558:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  558 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  559 |                         cant_happen("unexpected node type: %s", nodetype2str(r->type));[0m
      | [0;1;32m                                                                                       
[0m[1msymbol.c:576:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  576 |                 if ((ret = pfunc(r->code_ptr, data)) != 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  577 |                         break;[0m
      | [0;1;32m                              
[0m[1msymbol.c:643:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  643 |         if (PROCINFO_node == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  644 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:655:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  655 |         memset(sym_array, '\0', sizeof(NODE));  /* PPC Mac OS X wants this */[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:655:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  655 |         memset(sym_array, '\0', sizeof(NODE));  /* PPC Mac OS X wants this */[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:675:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  675 |                 if (max == 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  676 |                         continue;[0m
      | [0;1;32m                                 
[0m[1msymbol.c:685:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  685 |                                 if (strncmp(r->vname, "awk::", 5) == 0)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  686 |                                         tmp = make_string(r->vname + 5, strlen(r->vname) - 5);[0m
  687 |                                 else[0m
      | [0;32m                                } 
[0m[1msymbol.c:687:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  687 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  688 |                                         tmp = make_string(r->vname, strlen(r->vname));[0m
      | [0;1;32m                                                                                      
[0m[1msymbol.c:694:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  694 |                                         *aptr = dupnode(extension);[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  695 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1msymbol.c:697:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  697 |                                         *aptr = dupnode(user);[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  698 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1msymbol.c:700:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  700 |                                         *aptr = dupnode(built_in);[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  701 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1msymbol.c:703:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  703 |                                         *aptr = dupnode(scalar);[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  704 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1msymbol.c:706:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  706 |                                         *aptr = dupnode(array);[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  707 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1msymbol.c:709:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  709 |                                         *aptr = dupnode(untyped);[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  710 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1msymbol.c:712:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  712 |                                         cant_happen("unexpected node type %s", nodetype2str(r->type));[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m  713 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1msymbol.c:740:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  740 |         if (assoc_empty(func_table))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  741 |                 return result;[0m
      | [0;1;32m                              
[0m[1msymbol.c:745:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  745 |         memset(& n, 0, sizeof n);[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:745:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  745 |         memset(& n, 0, sizeof n);[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:747:12: [0m[0;1;35mwarning: [0m[1mThe value '6' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  747 |         n.flags = STRING|STRCUR;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1msymbol.c:740:6: [0m[0;1;36mnote: [0mAssuming field 'reflags' is not equal to 0[0m
  740 |         if (assoc_empty(func_table))[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1394:25: [0m[0;1;36mnote: [0mexpanded from macro 'assoc_empty'[0m
 1394 | #define assoc_empty(a)  (assoc_length(a) == 0)[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:1393:25: [0m[0;1;36mnote: [0mexpanded from macro 'assoc_length'[0m
 1393 | #define assoc_length(a) ((a)->table_size)[0m
      | [0;1;32m                        ^
[0m[1msymbol.c:740:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  740 |         if (assoc_empty(func_table))[0m
      | [0;1;32m        ^
[0m[1msymbol.c:747:12: [0m[0;1;36mnote: [0mThe value '6' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  747 |         n.flags = STRING|STRCUR;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~
[0m[1msymbol.c:767:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  767 |                 if (f->type == Node_builtin_func || f->param_cnt == 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  768 |                         continue;[0m
      | [0;1;32m                                 
[0m[1msymbol.c:844:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  844 |         memset(cp, 0, size * sizeof(INSTRUCTION));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:844:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  844 |         memset(cp, 0, size * sizeof(INSTRUCTION));[0m
      | [0;1;32m        ^~~~~~
[0m[1msymbol.c:909:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  909 |         if (curr_ctxt->prev == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  910 |                 fatal(_("cannot pop main context"));[0m
      | [0;1;32m                                                    
[0m[1msymbol.c:935:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  935 |         if (ctxt == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  936 |                 return;[0m
      | [0;1;32m                       
[0m[1msymbol.c:952:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  952 |                 if (s->stype != SRC_CMDLINE && s->stype != SRC_STDIN)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  953 |                         efree(s->fullpath);[0m
      | [0;1;32m                                           
[0m[1msymbol.c:970:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  970 |                 if (cp->func_name != NULL)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  971 |                         efree(cp->func_name);[0m
  972 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:970:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  970 |                 if (cp->func_name != NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  971 |                         efree(cp->func_name);[0m
      | [0;1;32m                                             
[0m[1msymbol.c:978:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  978 |                 if (m->re_reg[0] != NULL)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  979 |                         refree(m->re_reg[0]);[0m
  980 |                 if (m->re_reg[1] != NULL)[0m
  981 |                         refree(m->re_reg[1]);[0m
  982 |                 if (m->re_exp != NULL)[0m
  983 |                         unref(m->re_exp);[0m
  984 |                 if (m->re_text != NULL)[0m
  985 |                         unref(m->re_text);[0m
  986 |                 freenode(m);[0m
  987 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:978:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  978 |                 if (m->re_reg[0] != NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  979 |                         refree(m->re_reg[0]);[0m
      | [0;1;32m                                             
[0m[1msymbol.c:980:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  980 |                 if (m->re_reg[1] != NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  981 |                         refree(m->re_reg[1]);[0m
      | [0;1;32m                                             
[0m[1msymbol.c:982:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  982 |                 if (m->re_exp != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  983 |                         unref(m->re_exp);[0m
      | [0;1;32m                                         
[0m[1msymbol.c:984:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  984 |                 if (m->re_text != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  985 |                         unref(m->re_text);[0m
      | [0;1;32m                                          
[0m[1msymbol.c:990:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  990 |                 if (cp->lextok != NULL)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  991 |                         efree(cp->lextok);[0m
  992 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:990:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  990 |                 if (cp->lextok != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  991 |                         efree(cp->lextok);[0m
      | [0;1;32m                                          
[0m[1msymbol.c:994:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  994 |                 m = cp->memory;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  995 |                 unref(m);[0m
  996 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:998:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  998 |                 m = cp->initval;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  999 |                 if (m != NULL)[0m
 1000 |                         unref(m);[0m
 1001 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1msymbol.c:999:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  999 |                 if (m != NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1000 |                         unref(m);[0m
      | [0;1;32m                                 
[0m[1msymbol.c:1003:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1003 |                 cant_happen("unexpected opcode %s", opcode2str(cp->opcode));[0m
      | [0;1;32m                ^                                                          
[0m      | [0;32m                {                                                          ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1msymbol.c:1005:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1005 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1msymbol.c:1022:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1022 |                         if (cp->opcode != Op_illegal)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1023 |                                 free_bc_internal(cp);[0m
      | [0;1;32m                                                     
[0m[1msymbol.c:1039:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1039 |         for (i = 0; i < MAX_INSTRUCTION_ALLOC; i++)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1040 |                 free_bc_mempool(& pl->pool[i], i + 1);[0m
      | [0;1;32m                                                      
[0m[1msymbol.c:1062:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1062 |                         return false;[0m
      | [0;1;32m                        ^           
[0m      | [0;32m                        {           ;} 
[0m[1msymbol.c:1076:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1076 |         if (strncmp(name, "awk::", 5) == 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1077 |                 tmp = make_string(name + 5, strlen(name) - 5);[0m
 1078 |         else[0m
      | [0;32m        } 
[0m[1msymbol.c:1078:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1078 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1079 |                 tmp = make_string(name, strlen(name));[0m
      | [0;1;32m                                                      
[0m116 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[42/54][164.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpy4a51br5.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/main.c
[1mmain.c:245:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  245 |                 fprintf(stderr, _("%s: fatal: persistent memory allocator failed to initialize: return value %d, pma.c line: %d.\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:245:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  245 |                 fprintf(stderr, _("%s: fatal: persistent memory allocator failed to initialize: return value %d, pma.c line: %d.\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:260:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  260 |         if (getenv("TIDYMEM") != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  261 |                 do_flags |= DO_TIDY_MEM;[0m
      | [0;1;32m                                        
[0m[1mmain.c:265:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  266 |                 mtrace();[0m
      | [0;1;32m                         
[0m[1mmain.c:272:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  272 |         if (argc < 2)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  273 |                 usage(EXIT_FAILURE, stderr);[0m
      | [0;1;32m                                            
[0m[1mmain.c:275:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  275 |         if ((cp = getenv("GAWK_LOCALE_DIR")) != NULL)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  276 |                 locale_dir = cp;[0m
      | [0;1;32m                                
[0m[1mmain.c:355:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  355 |         if (gawk_mb_cur_max == 1)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  356 |                 load_casetable();[0m
      | [0;1;32m                                 
[0m[1mmain.c:358:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  358 |         if (do_nostalgia)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  359 |                 nostalgia();[0m
      | [0;1;32m                            
[0m[1mmain.c:364:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  364 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  365 |                         lintwarn([0m
  366 |         _("environment variable `POSIXLY_CORRECT' set: turning on `--posix'"));[0m
      | [0;1;32m                                                                               
[0m[1mmain.c:372:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  372 |                 if (do_traditional)     /* both on command line */[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  373 |                         warning(_("`--posix' overrides `--traditional'"));[0m
  374 |                 else[0m
      | [0;32m                } 
[0m[1mmain.c:374:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  374 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  375 |                         do_flags |= DO_TRADITIONAL;[0m
      | [0;1;32m                                                   
[0m[1mmain.c:388:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  388 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  389 |                         warning(_("`--posix' overrides `--characters-as-bytes'"));[0m
  390 |                 else {[0m
      | [0;32m                } 
[0m[1mmain.c:399:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  399 |                 if (os_is_setuid())[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  400 |                         lintwarn(_("running %s setuid root may be a security problem"), myname);[0m
      | [0;1;32m                                                                                                
[0m[1mmain.c:401:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  401 |                 if (do_intervals)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  402 |                         lintwarn(_("The -r/--re-interval options no longer have any effect"));[0m
      | [0;1;32m                                                                                              
[0m[1mmain.c:405:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  405 |         if (do_debug)   /* Need to register the debugger pre-exec hook before any other */[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  406 |                 init_debug();[0m
      | [0;1;32m                             
[0m[1mmain.c:425:25: [0m[0;1;35mwarning: [0m[1mThe value '31' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  425 |                 Nnull_string->flags = (MALLOC|STRCUR|STRING|NUMCUR|NUMBER);[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mmain.c:243:6: [0m[0;1;36mnote: [0mAssuming 'pma_result' is equal to 0[0m
  243 |         if (pma_result != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mmain.c:243:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  243 |         if (pma_result != 0) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:260:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  260 |         if (getenv("TIDYMEM") != NULL)[0m
      | [0;1;32m        ^
[0m[1mmain.c:265:8: [0m[0;1;36mnote: [0m'using_persistent_malloc' is false[0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:265:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m            ^
[0m[1mmain.c:265:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m        ^
[0m[1mmain.c:272:6: [0m[0;1;36mnote: [0mAssuming 'argc' is >= 2[0m
  272 |         if (argc < 2)[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mmain.c:272:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  272 |         if (argc < 2)[0m
      | [0;1;32m        ^
[0m[1mmain.c:275:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  275 |         if ((cp = getenv("GAWK_LOCALE_DIR")) != NULL)[0m
      | [0;1;32m        ^
[0m[1mmain.c:283:6: [0m[0;1;36mnote: [0mAssuming 'flags' is < 0[0m
  283 |         if (flags >= 0 && (flags & O_APPEND) == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mmain.c:283:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  283 |         if (flags >= 0 && (flags & O_APPEND) == 0) {[0m
      | [0;1;32m                       ^
[0m[1mmain.c:355:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is not equal to 1[0m
  355 |         if (gawk_mb_cur_max == 1)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:355:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  355 |         if (gawk_mb_cur_max == 1)[0m
      | [0;1;32m        ^
[0m[1mmain.c:358:6: [0m[0;1;36mnote: [0m'do_nostalgia' is 0[0m
  358 |         if (do_nostalgia)[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mmain.c:358:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  358 |         if (do_nostalgia)[0m
      | [0;1;32m        ^
[0m[1mmain.c:362:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  362 |         if (! do_posix && getenv("POSIXLY_CORRECT") != NULL) {[0m
      | [0;1;32m            ^
[0m[1mmain.c:362:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  362 |         if (! do_posix && getenv("POSIXLY_CORRECT") != NULL) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:370:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  370 |         if (do_posix) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:382:21: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  382 |         if (do_traditional && do_non_decimal_data) {[0m
      | [0;1;32m                           ^
[0m[1mmain.c:387:6: [0m[0;1;36mnote: [0m'do_binary' is 0[0m
  387 |         if (do_binary) {[0m
      | [0;1;32m            ^~~~~~~~~
[0m[1mmain.c:387:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  387 |         if (do_binary) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:398:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  398 |         if (do_lint) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:405:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  405 |         if (do_debug)   /* Need to register the debugger pre-exec hook before any other */[0m
      | [0;1;32m        ^
[0m[1mmain.c:425:25: [0m[0;1;36mnote: [0mThe value '31' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  425 |                 Nnull_string->flags = (MALLOC|STRCUR|STRING|NUMCUR|NUMBER);[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:444:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  444 |                 if (preassigns[i].type == PRE_ASSIGN)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  445 |                         dash_v_errs += (arg_assign(preassigns[i].val, true) == false);[0m
  446 |                 else    /* PRE_ASSIGN_FS */[0m
      | [0;32m                } 
[0m[1mmain.c:446:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  446 |                 else    /* PRE_ASSIGN_FS */[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  447 |                         cmdline_fs(preassigns[i].val);[0m
      | [0;1;32m                                                      
[0m[1mmain.c:451:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  451 |         if (preassigns != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  452 |                 efree(preassigns);[0m
      | [0;1;32m                                  
[0m[1mmain.c:454:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  454 |         if ((BINMODE & BINMODE_INPUT) != 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  455 |                 if (os_setbinmode(fileno(stdin), O_BINARY) == -1)[0m
  456 |                         fatal(_("cannot set binary mode on stdin: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                         
[0m[1mmain.c:455:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  455 |                 if (os_setbinmode(fileno(stdin), O_BINARY) == -1)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  456 |                         fatal(_("cannot set binary mode on stdin: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                         
[0m[1mmain.c:458:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  458 |                 if (os_setbinmode(fileno(stdout), O_BINARY) == -1)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  459 |                         fatal(_("cannot set binary mode on stdout: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                          
[0m[1mmain.c:460:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  460 |                 if (os_setbinmode(fileno(stderr), O_BINARY) == -1)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  461 |                         fatal(_("cannot set binary mode on stderr: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                          
[0m[1mmain.c:467:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  467 |         if (os_isatty(fileno(stdout)))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  468 |                 output_is_tty = true;[0m
      | [0;1;32m                                     
[0m[1mmain.c:478:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  478 |                 if (s->stype == SRC_EXTLIB)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  479 |                         load_ext(s->fullpath);[0m
  480 |                 else if (s->stype != SRC_INC)[0m
      | [0;32m                } 
[0m[1mmain.c:480:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  480 |                 else if (s->stype != SRC_INC)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  481 |                         have_srcfile = true;[0m
      | [0;1;32m                                            
[0m[1mmain.c:485:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  485 |         if (do_version)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  486 |                 version();[0m
      | [0;1;32m                          
[0m[1mmain.c:490:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  490 |                 if (optind > argc - 1 || stopped_early) /* no args left or no program */[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  491 |                         usage(EXIT_FAILURE, stderr);[0m
      | [0;1;32m                                                    
[0m[1mmain.c:512:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  512 |         if (parse_program(& code_block, false) != 0 || dash_v_errs > 0)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  513 |                 exit(EXIT_FAILURE);[0m
      | [0;1;32m                                   
[0m[1mmain.c:515:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  515 |         if (do_intl)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  516 |                 exit(EXIT_SUCCESS);[0m
      | [0;1;32m                                   
[0m[1mmain.c:522:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  522 |         if (do_lint)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  523 |                 shadow_funcs();[0m
      | [0;1;32m                               
[0m[1mmain.c:525:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  525 |         if (do_lint && code_block->nexti->opcode == Op_atexit)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  526 |                 lintwarn(_("no program text at all!"));[0m
      | [0;1;32m                                                       
[0m[1mmain.c:530:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  530 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  531 |                 init_profiling_signals();[0m
      | [0;1;32m                                         
[0m[1mmain.c:549:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  549 |         if (use_lc_numeric)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  550 |                 setlocale(LC_NUMERIC, locale);[0m
      | [0;1;32m                                              
[0m[1mmain.c:556:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  556 |         if (do_debug)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  557 |                 debug_prog(code_block);[0m
  558 |         else if (do_pretty_print && ! do_profile)[0m
      | [0;32m        } 
[0m[1mmain.c:558:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  558 |         else if (do_pretty_print && ! do_profile)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  559 |                 ;       /* run pretty printer only. */[0m
  560 |         else[0m
      | [0;32m        } 
[0m[1mmain.c:560:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  560 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  561 |                 interpret(code_block);[0m
      | [0;1;32m                                      
[0m[1mmain.c:569:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  569 |         if (do_dump_vars)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  570 |                 dump_vars(varfile);[0m
      | [0;1;32m                                   
[0m[1mmain.c:577:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  577 |         if (do_tidy_mem)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  578 |                 release_all_vars();[0m
      | [0;1;32m                                   
[0m[1mmain.c:581:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  581 |         if (extra_stack)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  582 |                 efree(extra_stack);[0m
      | [0;1;32m                                   
[0m[1mmain.c:609:29: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  609 |         preassigns[numassigns].val = estrdup(val, strlen(val));[0m
      | [0;1;32m                                   ^
[0m[1mmain.c:243:6: [0m[0;1;36mnote: [0mAssuming 'pma_result' is equal to 0[0m
  243 |         if (pma_result != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mmain.c:243:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  243 |         if (pma_result != 0) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:260:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  260 |         if (getenv("TIDYMEM") != NULL)[0m
      | [0;1;32m        ^
[0m[1mmain.c:265:8: [0m[0;1;36mnote: [0m'using_persistent_malloc' is false[0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:265:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m            ^
[0m[1mmain.c:265:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  265 |         if (! using_persistent_malloc && do_tidy_mem)[0m
      | [0;1;32m        ^
[0m[1mmain.c:272:6: [0m[0;1;36mnote: [0mAssuming 'argc' is >= 2[0m
  272 |         if (argc < 2)[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mmain.c:272:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  272 |         if (argc < 2)[0m
      | [0;1;32m        ^
[0m[1mmain.c:275:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  275 |         if ((cp = getenv("GAWK_LOCALE_DIR")) != NULL)[0m
      | [0;1;32m        ^
[0m[1mmain.c:283:6: [0m[0;1;36mnote: [0mAssuming 'flags' is < 0[0m
  283 |         if (flags >= 0 && (flags & O_APPEND) == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mmain.c:283:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  283 |         if (flags >= 0 && (flags & O_APPEND) == 0) {[0m
      | [0;1;32m                       ^
[0m[1mmain.c:337:2: [0m[0;1;36mnote: [0mCalling 'parse_args'[0m
  337 |         parse_args(argc, argv);[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:1641:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1641 |              (c = getopt_long(argc, argv, optlist, optab, NULL)) != EOF;[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:1640:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1640 |         for (optopt = 0, old_optind = 1;[0m
      | [0;1;32m        ^
[0m[1mmain.c:1643:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1643 |                 if (do_posix)[0m
      | [0;1;32m                ^
[0m[1mmain.c:1646:3: [0m[0;1;36mnote: [0mControl jumps to 'case 118:'  at line 1674[0m
 1646 |                 switch (c) {[0m
      | [0;1;32m                ^
[0m[1mmain.c:1675:4: [0m[0;1;36mnote: [0mCalling 'add_preassign'[0m
 1675 |                         add_preassign(PRE_ASSIGN, optarg);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:599:6: [0m[0;1;36mnote: [0m'preassigns' is equal to NULL[0m
  599 |         if (preassigns == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mmain.c:599:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  599 |         if (preassigns == NULL) {[0m
      | [0;1;32m        ^
[0m[1mmain.c:609:31: [0m[0;1;36mnote: [0mCalling 'estrdup'[0m
  609 |         preassigns[numassigns].val = estrdup(val, strlen(val));[0m
      | [0;1;32m                                     ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:1535:2: [0m[0;1;36mnote: [0mCalling 'emalloc_real'[0m
 1535 |         emalloc(s, char *, len + 1, "estrdup");[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1382:50: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
 1382 | #define emalloc(var,ty,x,str)   (void) (var = (ty) emalloc_real((size_t)(x), str, #var, __FILE__, __LINE__))[0m
      | [0;1;32m                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:2051:6: [0m[0;1;36mnote: [0m'count' is not equal to 0[0m
 2051 |         if (count == 0)[0m
      | [0;1;32m            ^~~~~
[0m[1m./awk.h:2051:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2051 |         if (count == 0)[0m
      | [0;1;32m        ^
[0m[1m./awk.h:2054:17: [0m[0;1;36mnote: [0mNull pointer value stored to 'preassigns'[0m
 2054 |         ret = (void *) malloc(count);[0m
      | [0;1;32m                       ^
[0m[1m./custom.h:130:16: [0m[0;1;36mnote: [0mexpanded from macro 'malloc'[0m
  130 | #define malloc  pma_malloc[0m
      | [0;1;32m                ^
[0m[1m./awk.h:2055:6: [0m[0;1;36mnote: [0mAssuming 'ret' is not equal to NULL[0m
 2055 |         if (ret == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1m./awk.h:2055:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2055 |         if (ret == NULL)[0m
      | [0;1;32m        ^
[0m[1mmain.c:1535:2: [0m[0;1;36mnote: [0mReturning from 'emalloc_real'[0m
 1535 |         emalloc(s, char *, len + 1, "estrdup");[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1382:50: [0m[0;1;36mnote: [0mexpanded from macro 'emalloc'[0m
 1382 | #define emalloc(var,ty,x,str)   (void) (var = (ty) emalloc_real((size_t)(x), str, #var, __FILE__, __LINE__))[0m
      | [0;1;32m                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:609:31: [0m[0;1;36mnote: [0mReturning from 'estrdup'[0m
  609 |         preassigns[numassigns].val = estrdup(val, strlen(val));[0m
      | [0;1;32m                                     ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:609:29: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  609 |         preassigns[numassigns].val = estrdup(val, strlen(val));[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:625:2: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  625 |         sscanf(PACKAGE_VERSION, "%d.%d.%d", & major_version, & minor_version, & patchlevel);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:625:2: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
  625 |         sscanf(PACKAGE_VERSION, "%d.%d.%d", & major_version, & minor_version, & patchlevel);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:628:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  628 |         fprintf(fp, _("Usage: %s [POSIX or GNU style options] -f progfile [--] file ...\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:628:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  628 |         fprintf(fp, _("Usage: %s [POSIX or GNU style options] -f progfile [--] file ...\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:630:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  630 |         fprintf(fp, _("Usage: %s [POSIX or GNU style options] [--] %cprogram%c file ...\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:630:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  630 |         fprintf(fp, _("Usage: %s [POSIX or GNU style options] [--] %cprogram%c file ...\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:692:84: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  692 |         if (patchlevel >= 60 || isalpha((int) PACKAGE_VERSION[strlen(PACKAGE_VERSION)-1]))[0m
      | [0;1;32m                                                                                          ^
[0m      | [0;32m                                                                                           {
[0m  693 |                 url = beta_url;[0m
  694 |         else[0m
      | [0;32m        } 
[0m[1mmain.c:694:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  694 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  695 |                 url = gnu_url;[0m
      | [0;1;32m                              
[0m[1mmain.c:698:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  698 |         fprintf(fp, _("Source code for gawk may be obtained from\n%s/gawk-%s.tar.gz\n\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:698:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  698 |         fprintf(fp, _("Source code for gawk may be obtained from\n%s/gawk-%s.tar.gz\n\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:706:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  706 |         fprintf(fp, _("Examples:\n\t%s '{ sum += $1 }; END { print sum }' file\n\[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:706:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  706 |         fprintf(fp, _("Examples:\n\t%s '{ sum += $1 }; END { print sum }' file\n\[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:715:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  715 |                 if (errno == EPIPE)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  716 |                         die_via_sigpipe();[0m
      | [0;1;32m                                          
[0m[1mmain.c:718:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  718 |                 if (fp == stdout)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  719 |                         warning(_("error writing standard output: %s"), strerror(errno));[0m
  720 |                 else if (fp == stderr)[0m
      | [0;32m                } 
[0m[1mmain.c:720:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  720 |                 else if (fp == stderr)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  721 |                         warning(_("error writing standard error: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                        
[0m[1mmain.c:763:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  763 |                 if (errno != EPIPE)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  764 |                         warning(_("error writing standard output: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                         
[0m[1mmain.c:788:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  788 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  789 |                         lintwarn(_("-Ft does not set FS to tab in POSIX awk"));[0m
      | [0;1;32m                                                                               
[0m[1mmain.c:790:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  790 |                 if (do_traditional && ! do_posix)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  791 |                         str[0] = '\t';[0m
      | [0;1;32m                                      
[0m[1mmain.c:837:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  837 |         if (do_sandbox)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  838 |                 init_argv_array(ARGV_node, shadow_node);[0m
      | [0;1;32m                                                        
[0m[1mmain.c:905:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  905 |                 if ((vp->flags & NO_INSTALL) != 0)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  906 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mmain.c:908:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  908 |                 if (vp->strval != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  909 |                         n->var_value = make_string(vp->strval, strlen(vp->strval));[0m
  910 |                 else[0m
      | [0;32m                } 
[0m[1mmain.c:910:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  910 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  911 |                         n->var_value = make_number(vp->numval);[0m
      | [0;1;32m                                                               
[0m[1mmain.c:914:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  914 |                 if (vp->do_assign)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  915 |                         (*(vp->assign))();[0m
      | [0;1;32m                                          
[0m[1mmain.c:919:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  919 |         if (! do_traditional)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  920 |                 load_procinfo();[0m
      | [0;1;32m                                
[0m[1mmain.c:939:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  939 |         if (val == NULL || *val == '\0')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  940 |                 val = dflt;[0m
      | [0;1;32m                           
[0m[1mmain.c:967:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  967 |         if (been_here)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  968 |                 return ENVIRON_node;[0m
      | [0;1;32m                                    
[0m[1mmain.c:984:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  984 |                 if (val != NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  985 |                         *val++ = '\0';[0m
  986 |                 else[0m
      | [0;32m                } 
[0m[1mmain.c:986:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  986 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  987 |                         val = nullstr;[0m
      | [0;1;32m                                      
[0m[1mmain.c:994:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  994 |                 if (val != nullstr)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  995 |                         *--val = '=';[0m
      | [0;1;32m                                     
[0m[1mmain.c:1027:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1027 |         memset(argv_array, '\0', sizeof(NODE));  /* valgrind wants this */[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1027:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1027 |         memset(argv_array, '\0', sizeof(NODE));  /* valgrind wants this */[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1056:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1056 |         if (been_here)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1057 |                 return PROCINFO_node;[0m
      | [0;1;32m                                     
[0m[1mmain.c:1118:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1118 |                 sprintf(name, "group%d", i + 1);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1118:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1118 |                 sprintf(name, "group%d", i + 1);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1145:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1145 |                         if ((do_traditional || do_posix) && (vp->flags & NON_STANDARD) != 0)[0m
      | [0;1;32m                                                                                            ^
[0m      | [0;32m                                                                                             {
[0m 1146 |                                 return false;[0m
      | [0;1;32m                                             
[0m[1mmain.c:1166:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1166 |                 if (strcmp(vp->name, var) == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1167 |                         return ((vp->flags & NOT_OFF_LIMITS) == 0);[0m
      | [0;1;32m                                                                   
[0m[1mmain.c:1182:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1182 |         if (! fptr)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 1183 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mmain.c:1185:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1185 |                 if (vp->assign == fptr || vp->update == fptr)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1186 |                         return vp->name;[0m
      | [0;1;32m                                        
[0m[1mmain.c:1204:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1204 |         if (! initing && disallow_var_assigns)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1205 |                 return false;   /* --exec */[0m
      | [0;1;32m                                            
[0m[1mmain.c:1210:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1210 |                 if (! initing)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1211 |                         return false;   /* This is file name, not assignment. */[0m
      | [0;1;32m                                                                                
[0m[1mmain.c:1213:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1213 |                 fprintf(stderr,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1213:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1213 |                 fprintf(stderr,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1229:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1229 |         if (! is_letter((unsigned char) arg[0]))[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1230 |                 badvar = true;[0m
 1231 |         else[0m
      | [0;32m        } 
[0m[1mmain.c:1231:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1231 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1232 |                 for (cp2 = arg+1; *cp2; cp2++)[0m
 1233 |                         if (! is_identchar((unsigned char) *cp2) && *cp2 != ':') {[0m
 1234 |                                 badvar = true;[0m
 1235 |                                 break;[0m
 1236 |                         }[0m
      | [0;1;32m                         
[0m[1mmain.c:1232:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1232 |                 for (cp2 = arg+1; *cp2; cp2++)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1233 |                         if (! is_identchar((unsigned char) *cp2) && *cp2 != ':') {[0m
 1234 |                                 badvar = true;[0m
 1235 |                                 break;[0m
 1236 |                         }[0m
      | [0;1;32m                         
[0m[1mmain.c:1239:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1239 |                 if (initing)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1240 |                         fatal(_("`%s' is not a legal variable name"), arg);[0m
      | [0;1;32m                                                                           
[0m[1mmain.c:1242:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1242 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1243 |                         lintwarn(_("`%s' is not a variable name, looking for file `%s=%s'"),[0m
 1244 |                                 arg, arg, cp);[0m
      | [0;1;32m                                              
[0m[1mmain.c:1256:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1256 |         if (check_special(arg) >= 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1257 |                 fatal(_("cannot use gawk builtin `%s' as variable name"), arg);[0m
      | [0;1;32m                                                                               
[0m[1mmain.c:1261:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1261 |                 if (var != NULL && var->type == Node_func)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1262 |                         fatal(_("cannot use function `%s' as variable name"), arg);[0m
      | [0;1;32m                                                                                   
[0m[1mmain.c:1273:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1273 |                 memcpy(cp2, cp + 2, len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mmain.c:1273:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1273 |                 memcpy(cp2, cp + 2, len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mmain.c:1283:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1283 |                 if (do_posix && strchr(cp, '\n') != NULL)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1284 |                         fatal(_("POSIX does not allow physical newlines in string values"));[0m
      | [0;1;32m                                                                                            
[0m[1mmain.c:1297:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1297 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1298 |                         setlocale(LC_NUMERIC, "C");[0m
      | [0;1;32m                                                   
[0m[1mmain.c:1302:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1302 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1303 |                         setlocale(LC_NUMERIC, locale);[0m
      | [0;1;32m                                                      
[0m[1mmain.c:1316:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1316 |         if (var == NULL)        /* error */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1317 |                 final_exit(EXIT_FATAL);[0m
      | [0;1;32m                                       
[0m[1mmain.c:1319:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1319 |         if (var->type == Node_var && var->var_update)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1320 |                 var->var_update();[0m
      | [0;1;32m                                  
[0m[1mmain.c:1325:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1325 |         if (var->type == Node_var && var->var_assign)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1326 |                 var->var_assign();[0m
      | [0;1;32m                                  
[0m[1mmain.c:1329:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1329 |         if (! initing)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1330 |                 *--cp = '=';    /* restore original text of ARGV */[0m
      | [0;1;32m                                                                   
[0m[1mmain.c:1347:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1347 |                 if (errcount > 0)       // assume a syntax error corrupted our data structures[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1348 |                         exit(EXIT_FATAL);[0m
      | [0;1;32m                                         
[0m[1mmain.c:1401:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1401 |         fprintf(stderr, "awk: bailing out near line 1\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:1401:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1401 |         fprintf(stderr, "awk: bailing out near line 1\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:1424:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1424 |         if (open == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1425 |                 return pma_version;     // sigh.[0m
      | [0;1;32m                                                
[0m[1mmain.c:1429:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1429 |         if (close == NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1430 |                 return pma_version;     // sigh, again.[0m
      | [0;1;32m                                                       
[0m[1mmain.c:1433:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1433 |         for (out = buf, in = open; in < close;)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1434 |                 *out++ = *in++;[0m
      | [0;1;32m                               
[0m[1mmain.c:1487:4: [0m[0;1;35mwarning: [0m[1mValue stored to 'newfd' is never read [clang-analyzer-deadcode.DeadStores][0m
 1487 |                         newfd += 0;[0m
      | [0;1;32m                        ^        ~
[0m[1mmain.c:1487:4: [0m[0;1;36mnote: [0mValue stored to 'newfd' is never read[0m
 1487 |                         newfd += 0;[0m
      | [0;1;32m                        ^        ~
[0m[1mmain.c:1513:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1513 |         if (ngroups <= 0)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1514 |                 return;[0m
      | [0;1;32m                       
[0m[1mmain.c:1536:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1536 |         memcpy(s, str, len);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1536:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1536 |         memcpy(s, str, len);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1581:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1581 |         for (i = 0; i < argc; i++)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1582 |                 d_argv[i] = estrdup(argv[i], strlen(argv[i]));[0m
      | [0;1;32m                                                              
[0m[1mmain.c:1599:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1599 |                 if (vp->update != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1600 |                         vp->update();[0m
      | [0;1;32m                                     
[0m[1mmain.c:1611:38: [0m[0;1;35mwarning: [0m[1mPotential out of bound access to the region with tainted index [clang-analyzer-security.ArrayBound][0m
 1611 |         if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {[0m
      | [0;1;32m                                            ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:1611:13: [0m[0;1;36mnote: [0mTaint originated here[0m
 1611 |         if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~
[0m[1mmain.c:1611:13: [0m[0;1;36mnote: [0mTaint propagated to the return value[0m
 1611 |         if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~
[0m[1mmain.c:1611:13: [0m[0;1;36mnote: [0mAssuming the environment variable exists[0m
 1611 |         if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~
[0m[1mmain.c:1611:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1611 |         if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {[0m
      | [0;1;32m            ^
[0m[1mmain.c:1611:38: [0m[0;1;36mnote: [0mAccess of the region with a tainted index that may be too large[0m
 1611 |         if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {[0m
      | [0;1;32m                                            ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:1612:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1612 |                 for (newval = 0; *val && isdigit((unsigned char) *val); val++)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1613 |                         newval = (newval * 10) + *val - '0';[0m
      | [0;1;32m                                                            
[0m[1mmain.c:1643:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1643 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1644 |                         opterr = true;[0m
      | [0;1;32m                                      
[0m[1mmain.c:1648:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1648 |                         add_preassign(PRE_ASSIGN_FS, optarg);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1649 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1652:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1652 |                         disallow_var_assigns = true;[0m
      | [0;1;32m                        ^                          
[0m      | [0;32m                        {                          ;} 
[0m[1mmain.c:1663:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1663 |                         scan = optarg;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1664 |                         if (argv[optind-1] != optarg)[0m
 1665 |                                 while (isspace((unsigned char) *scan))[0m
 1666 |                                         scan++;[0m
 1667 |                         src = (*scan == '\0' ? argv[optind++] : optarg);[0m
 1668 |                         (void) add_srcfile((src && src[0] == '-' && src[1] == '\0') ?[0m
 1669 |                                         SRC_STDIN : SRC_FILE,[0m
 1670 |                                         src, srcfiles, NULL, NULL);[0m
 1671 | [0m
 1672 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1664:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1664 |                         if (argv[optind-1] != optarg)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1665 |                                 while (isspace((unsigned char) *scan))[0m
 1666 |                                         scan++;[0m
      | [0;1;32m                                               
[0m[1mmain.c:1665:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1665 |                                 while (isspace((unsigned char) *scan))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1666 |                                         scan++;[0m
      | [0;1;32m                                               
[0m[1mmain.c:1675:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1675 |                         add_preassign(PRE_ASSIGN, optarg);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1676 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1679:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1679 |                         do_binary = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1680 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1683:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1683 |                         do_flags |= DO_TRADITIONAL;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1684 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1687:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1687 |                         copyleft();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1688 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1691:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1691 |                         do_flags |= DO_DUMP_VARS;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1692 |                         if (optarg != NULL && optarg[0] != '\0')[0m
 1693 |                                 varfile = optarg;[0m
 1694 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1692:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1692 |                         if (optarg != NULL && optarg[0] != '\0')[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 1693 |                                 varfile = optarg;[0m
      | [0;1;32m                                                 
[0m[1mmain.c:1697:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1697 |                         do_flags |= DO_DEBUG;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1698 |                         if (optarg != NULL && optarg[0] != '\0')[0m
 1699 |                                 command_file = optarg;[0m
 1700 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1698:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1698 |                         if (optarg != NULL && optarg[0] != '\0')[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 1699 |                                 command_file = optarg;[0m
      | [0;1;32m                                                      
[0m[1mmain.c:1703:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1703 |                         if (optarg[0] == '\0')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1704 |                                 warning(_("empty argument to `-e/--source' ignored"));[0m
 1705 |                         else[0m
 1706 |                                 (void) add_srcfile(SRC_CMDLINE, optarg, srcfiles, NULL, NULL);[0m
 1707 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1703:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1703 |                         if (optarg[0] == '\0')[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1704 |                                 warning(_("empty argument to `-e/--source' ignored"));[0m
 1705 |                         else[0m
      | [0;32m                        } 
[0m[1mmain.c:1705:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1705 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1706 |                                 (void) add_srcfile(SRC_CMDLINE, optarg, srcfiles, NULL, NULL);[0m
      | [0;1;32m                                                                                              
[0m[1mmain.c:1710:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1710 |                         do_flags |= DO_INTL;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1711 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1715:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1715 |                         usage(EXIT_SUCCESS, stdout);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1716 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1719:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1719 |                         (void) add_srcfile(SRC_INC, optarg, srcfiles, NULL, NULL);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1720 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1723:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1723 |                         do_itrace = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1724 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1727:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1727 |                         (void) add_srcfile(SRC_EXTLIB, optarg, srcfiles, NULL, NULL);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1728 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1732:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1732 |                         do_flags |= (DO_LINT_ALL|DO_LINT_EXTENSIONS);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1733 |                         if (optarg != NULL) {[0m
 1734 |                                 if (strcmp(optarg, "fatal") == 0)[0m
 1735 |                                         lintfunc = r_fatal;[0m
 1736 |                                 else if (strcmp(optarg, "invalid") == 0) {[0m
 1737 |                                         do_flags &= ~DO_LINT_ALL;[0m
 1738 |                                         do_flags |= DO_LINT_INVALID;[0m
 1739 |                                 }[0m
 1740 |                                 else if (strcmp(optarg, "no-ext") == 0) {[0m
 1741 |                                         do_flags &= ~DO_LINT_EXTENSIONS;[0m
 1742 |                                 }[0m
 1743 |                         }[0m
 1744 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1734:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1734 |                                 if (strcmp(optarg, "fatal") == 0)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 1735 |                                         lintfunc = r_fatal;[0m
 1736 |                                 else if (strcmp(optarg, "invalid") == 0) {[0m
      | [0;32m                                } 
[0m[1mmain.c:1747:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1747 |                         do_flags |= DO_LINT_OLD;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1748 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1756:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1756 |                         do_flags |= DO_NON_DEC_DATA;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1757 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1760:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1760 |                         use_lc_numeric = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1761 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1764:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1764 |                         do_optimize = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1765 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1768:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1768 |                         if (do_pretty_print)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1769 |                                 warning(_("`--profile' overrides `--pretty-print'"));[0m
 1770 |                         do_flags |= DO_PROFILE;[0m
      | [0;1;32m                                              
[0m      | [0;32m                                              ;} 
[0m[1mmain.c:1768:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1768 |                         if (do_pretty_print)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1769 |                                 warning(_("`--profile' overrides `--pretty-print'"));[0m
      | [0;1;32m                                                                                     
[0m[1mmain.c:1773:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1773 |                         if (c == 'o' && do_profile)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1774 |                                 warning(_("`--profile' overrides `--pretty-print'"));[0m
 1775 |                         do_flags |= DO_PRETTY_PRINT;[0m
 1776 |                         if (optarg != NULL)[0m
 1777 |                                 set_prof_file(optarg);[0m
 1778 |                         else[0m
 1779 |                                 set_prof_file(DEFAULT_PROFILE);[0m
 1780 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1773:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1773 |                         if (c == 'o' && do_profile)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1774 |                                 warning(_("`--profile' overrides `--pretty-print'"));[0m
      | [0;1;32m                                                                                     
[0m[1mmain.c:1776:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1776 |                         if (optarg != NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1777 |                                 set_prof_file(optarg);[0m
 1778 |                         else[0m
      | [0;32m                        } 
[0m[1mmain.c:1778:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1778 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1779 |                                 set_prof_file(DEFAULT_PROFILE);[0m
      | [0;1;32m                                                               
[0m[1mmain.c:1786:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1786 |                         warning(_("-M ignored: MPFR/GMP support not compiled in"));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1787 | #endif[0m
 1788 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./awk.h:170:17: [0m[0;1;36mnote: [0mexpanded from macro 'warning'[0m
  170 | #define warning (*(set_loc(__FILE__, __LINE__),r_warning))[0m
      | [0;1;32m                ^
[0m[1mmain.c:1791:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1791 |                         do_flags |= DO_POSIX;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1792 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1797:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1797 |                         do_flags |= DO_INTERVALS;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1798 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1801:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1801 |                         do_optimize = false;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1802 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1805:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1805 |                         do_flags |= DO_SANDBOX;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1806 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1810:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1810 |                         if (optarg == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1811 |                                 optarg = "/some/file";[0m
 1812 |                         fatal(_("Use `GAWK_PERSIST_FILE=%s gawk ...' instead of --persist."), optarg);[0m
 1813 | #else[0m
 1814 |                         warning(_("Persistent memory is not supported."));[0m
 1815 | #endif /* USE_PERSISTENT_MALLOC */[0m
 1816 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1810:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1810 |                         if (optarg == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1811 |                                 optarg = "/some/file";[0m
      | [0;1;32m                                                      
[0m[1mmain.c:1819:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1819 |                         do_version = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1820 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1823:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1823 |                         fprintf(stderr, _("%s: option `-W %s' unrecognized, ignored\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mmain.c:1823:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1823 |                         fprintf(stderr, _("%s: option `-W %s' unrecognized, ignored\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mmain.c:1823:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1823 |                         fprintf(stderr, _("%s: option `-W %s' unrecognized, ignored\n"),[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1824 |                                 argv[0], optarg);[0m
 1825 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mmain.c:1833:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1833 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mmain.c:1875:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1875 |                                 fprintf(stderr,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mmain.c:1875:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1875 |                                 fprintf(stderr,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mmain.c:1882:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1882 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mmain.c:1884:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1884 |                 if (c == 'E')   /* --exec ends option processing */[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1885 |                         break;[0m
      | [0;1;32m                              
[0m[1mmain.c:1958:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1958 |         if (current_namespace != awk_namespace)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1959 |                 efree((void *) current_namespace);[0m
      | [0;1;32m                                                  
[0m[1mmain.c:1976:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1976 |         if (pma_file == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1977 |                 return;[0m
 1978 |         else if (stat(pma_file, & sbuf) < 0) {[0m
      | [0;32m        } 
[0m[1mmain.c:1979:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1979 |                 fprintf(stderr, _("%s: fatal: cannot stat %s: %s\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1979:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1979 |                 fprintf(stderr, _("%s: fatal: cannot stat %s: %s\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1983:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1983 |                 fprintf(stderr, _("%s: fatal: using persistent memory is not allowed when running as root.\n"), myname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1983:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1983 |                 fprintf(stderr, _("%s: fatal: using persistent memory is not allowed when running as root.\n"), myname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1986:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1986 |                 fprintf(stderr, _("%s: warning: %s is not owned by euid %d.\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:1986:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1986 |                 fprintf(stderr, _("%s: warning: %s is not owned by euid %d.\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m185 warnings generated.
Suppressed 31 warnings (31 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[43/54][170.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp7nqown5g.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/str_array.c
[1mstr_array.c:114:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  114 |                 if ((newval = getenv_long("STR_CHAIN_MAX")) > 0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  115 |                         STR_CHAIN_MAX = newval;[0m
      | [0;1;32m                                               
[0m[1mstr_array.c:118:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  118 |                         if (strcmp(val, "gst") == 0)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  119 |                                 hash = gst_hash_string;[0m
  120 |                         else if (strcmp(val, "fnv1a") == 0)[0m
      | [0;32m                        } 
[0m[1mstr_array.c:120:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  120 |                         else if (strcmp(val, "fnv1a") == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  121 |                                 hash = fnv1a_hash_string;[0m
      | [0;1;32m                                                         
[0m[1mstr_array.c:123:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  123 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  124 |                 null_array(symbol);[0m
      | [0;1;32m                                   
[0m[1mstr_array.c:149:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  149 |         if (symbol->buckets == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  150 |                 grow_table(symbol);[0m
      | [0;1;32m                                   
[0m[1mstr_array.c:153:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  153 |         if ((lhs = str_find(symbol, subs, code1, hash1)) != NULL)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  154 |                 return lhs;[0m
      | [0;1;32m                           
[0m[1mstr_array.c:235:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  235 |         if (symbol->table_size == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  236 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mstr_array.c:260:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  260 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  261 |                                 unref(r);[0m
      | [0;1;32m                                         
[0m[1mstr_array.c:268:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  268 |         if (symbol->buckets != NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  269 |                 efree(symbol->buckets);[0m
      | [0;1;32m                                       
[0m[1mstr_array.c:285:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  285 |         if (symbol->table_size == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  286 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mstr_array.c:297:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  297 |                 if (s1_len != s2->stlen)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  298 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mstr_array.c:304:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  304 |                         if (prev != NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  305 |                                 prev->ahnext = b->ahnext;[0m
  306 |                         else[0m
      | [0;32m                        } 
[0m[1mstr_array.c:306:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  306 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  307 |                                 symbol->buckets[hash1] = b->ahnext;[0m
      | [0;1;32m                                                                   
[0m[1mstr_array.c:314:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  314 |                                 if (symbol->buckets != NULL)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  315 |                                         efree(symbol->buckets);[0m
      | [0;1;32m                                                               
[0m[1mstr_array.c:364:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  364 |                         if (oldval->type == Node_val)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  365 |                                 newchain->ahvalue = dupnode(oldval);[0m
  366 |                         else {[0m
      | [0;32m                        } 
[0m[1mstr_array.c:402:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  402 |         if (symbol->table_size == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  403 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mstr_array.c:406:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  406 |         if ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  407 |                 elem_size = 2;[0m
      | [0;1;32m                              
[0m[1mstr_array.c:411:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  411 |         if ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  412 |                 num_elems = 1;[0m
      | [0;1;32m                              
[0m[1mstr_array.c:423:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  423 |                         if ((assoc_kind & AINUM) != 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  424 |                                 (void) force_number(subs);[0m
      | [0;1;32m                                                          
[0m[1mstr_array.c:431:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  431 |                                         if ((assoc_kind & AVNUM) != 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  432 |                                                 (void) force_number(val);[0m
  433 |                                         else if ((assoc_kind & AVSTR) != 0)[0m
      | [0;32m                                        } 
[0m[1mstr_array.c:433:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  433 |                                         else if ((assoc_kind & AVSTR) != 0)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m  434 |                                                 val = force_string(val);[0m
      | [0;1;32m                                                                        
[0m[1mstr_array.c:438:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  438 |                         if (k >= list_size)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  439 |                                 return list;[0m
      | [0;1;32m                                            
[0m[1mstr_array.c:477:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  477 |         if ((symbol->flags & XARRAY) == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  478 |                 fprintf(output_fp, "%s `%s'\n",[0m
  479 |                                 (symbol->parent_array == NULL) ? "array" : "sub-array",[0m
  480 |                                 array_vname(symbol));[0m
      | [0;1;32m                                                     
[0m[1mstr_array.c:478:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  478 |                 fprintf(output_fp, "%s `%s'\n",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mstr_array.c:478:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  478 |                 fprintf(output_fp, "%s `%s'\n",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mstr_array.c:483:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  483 |         fprintf(output_fp, "array_func: str_array_func\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:483:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  483 |         fprintf(output_fp, "array_func: str_array_func\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:486:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  486 |                 fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mstr_array.c:486:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  486 |                 fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mstr_array.c:489:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  489 |         fprintf(output_fp, "STR_CHAIN_MAX: %lu\n", (unsigned long) STR_CHAIN_MAX);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:489:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  489 |         fprintf(output_fp, "STR_CHAIN_MAX: %lu\n", (unsigned long) STR_CHAIN_MAX);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:491:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  491 |         fprintf(output_fp, "array_size: %lu\n", (unsigned long) symbol->array_size);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:491:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  491 |         fprintf(output_fp, "array_size: %lu\n", (unsigned long) symbol->array_size);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:493:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  493 |         fprintf(output_fp, "table_size: %lu\n", (unsigned long) symbol->table_size);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:493:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  493 |         fprintf(output_fp, "table_size: %lu\n", (unsigned long) symbol->table_size);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:495:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  495 |         fprintf(output_fp, "Avg # of items per chain: %.2g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:495:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  495 |         fprintf(output_fp, "Avg # of items per chain: %.2g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:499:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  499 |         fprintf(output_fp, "memory: %.2g kB\n", str_kilobytes(symbol));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:499:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  499 |         fprintf(output_fp, "memory: %.2g kB\n", str_kilobytes(symbol));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:503:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  503 |         memset(hash_dist, '\0', (HCNT + 1) * sizeof(size_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mstr_array.c:503:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  503 |         memset(hash_dist, '\0', (HCNT + 1) * sizeof(size_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mstr_array.c:506:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  506 |                 for (b = symbol->buckets[i]; b != NULL; b = b->ahnext)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  507 |                         bucket_cnt++;[0m
      | [0;1;32m                                     
[0m[1mstr_array.c:508:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  508 |                 if (bucket_cnt >= HCNT)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  509 |                         bucket_cnt = HCNT;[0m
      | [0;1;32m                                          
[0m[1mstr_array.c:514:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  514 |         fprintf(output_fp, "Hash distribution:\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:514:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  514 |         fprintf(output_fp, "Hash distribution:\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mstr_array.c:519:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  519 |                         if (i == HCNT)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  520 |                                 fprintf(output_fp, "[>=%lu]:%lu\n",[0m
  521 |                                         (unsigned long) HCNT, (unsigned long) hash_dist[i]);[0m
  522 |                         else[0m
      | [0;32m                        } 
[0m[1mstr_array.c:520:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  520 |                                 fprintf(output_fp, "[>=%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mstr_array.c:520:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  520 |                                 fprintf(output_fp, "[>=%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mstr_array.c:522:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  522 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  523 |                                 fprintf(output_fp, "[%lu]:%lu\n",[0m
  524 |                                         (unsigned long) i, (unsigned long) hash_dist[i]);[0m
      | [0;1;32m                                                                                         
[0m[1mstr_array.c:523:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  523 |                                 fprintf(output_fp, "[%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mstr_array.c:523:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  523 |                                 fprintf(output_fp, "[%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mstr_array.c:534:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  534 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mstr_array.c:534:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  534 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mstr_array.c:537:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  537 |                         for (b = symbol->buckets[i]; b != NULL; b = b->ahnext)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  538 |                                 assoc_info(b->ahname, b->ahvalue, ndump, aname);[0m
      | [0;1;32m                                                                                
[0m[1mstr_array.c:590:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  590 |                         do {    /* All fall throughs */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  591 |                                 HASHC;[0m
  592 |                 case 7:         HASHC;[0m
  593 |                 case 6:         HASHC;[0m
  594 |                 case 5:         HASHC;[0m
  595 |                 case 4:         HASHC;[0m
  596 |                 case 3:         HASHC;[0m
  597 |                 case 2:         HASHC;[0m
  598 |                 case 1:         HASHC;[0m
  599 |                         } while (--loop);[0m
      | [0;1;32m                                        
[0m      | [0;32m                                        ;} 
[0m[1mstr_array.c:603:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  603 |         if (code != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  604 |                 *code = h;[0m
      | [0;1;32m                          
[0m[1mstr_array.c:606:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  606 |         if (h >= hsize)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  607 |                 h %= hsize;[0m
      | [0;1;32m                           
[0m[1mstr_array.c:607:5: [0m[0;1;35mwarning: [0m[1mDivision by zero [clang-analyzer-core.DivideZero][0m
  607 |                 h %= hsize;[0m
      | [0;1;32m                ~~^~~~~~~~
[0m[1mstr_array.c:585:6: [0m[0;1;36mnote: [0mAssuming 'len' is <= 0[0m
  585 |         if (len > 0) {[0m
      | [0;1;32m            ^~~~~~~
[0m[1mstr_array.c:585:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  585 |         if (len > 0) {[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:603:6: [0m[0;1;36mnote: [0mAssuming 'code' is equal to NULL[0m
  603 |         if (code != NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mstr_array.c:603:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  603 |         if (code != NULL)[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:606:6: [0m[0;1;36mnote: [0mAssuming 'h' is >= 'hsize'[0m
  606 |         if (h >= hsize)[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mstr_array.c:606:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  606 |         if (h >= hsize)[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:607:5: [0m[0;1;36mnote: [0mDivision by zero[0m
  607 |                 h %= hsize;[0m
      | [0;1;32m                ~~^~~~~~~~
[0m[1mstr_array.c:631:4: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  631 |                 )[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m  632 |                         return & (b->ahvalue);[0m
      | [0;1;32m                                              
[0m[1mstr_array.c:690:24: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  690 |                 symbol->table_size = 0;[0m
      | [0;1;32m                                     ^
[0m[1m./awk.h:360:9: [0m[0;1;36mnote: [0menum declared here[0m
  360 |                         enum reflagvals {[0m
      | [0;1;32m                        ~~~~~^~~~~~~~~~~~
[0m  361 |                                 CONSTANT = 1,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  362 |                                 FS_DFLT  = 2,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  363 |                         } reflags;[0m
      | [0;1;32m                        ~
[0m[1mstr_array.c:149:6: [0m[0;1;36mnote: [0mAssuming field 'bv' is equal to NULL[0m
  149 |         if (symbol->buckets == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mstr_array.c:149:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  149 |         if (symbol->buckets == NULL)[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:150:3: [0m[0;1;36mnote: [0mCalling 'grow_table'[0m
  150 |                 grow_table(symbol);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~
[0m[1mstr_array.c:670:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  670 |         for (i = 0, j = sizeof(sizes)/sizeof(sizes[0]); i < j; i++) {[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:671:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  671 |                 if (oldsize < sizes[i]) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~
[0m[1mstr_array.c:671:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  671 |                 if (oldsize < sizes[i]) {[0m
      | [0;1;32m                ^
[0m[1mstr_array.c:673:4: [0m[0;1;36mnote: [0m Execution continues on line 676[0m
  673 |                         break;[0m
      | [0;1;32m                        ^
[0m[1mstr_array.c:676:6: [0m[0;1;36mnote: [0m'newsize' is not equal to 'oldsize'[0m
  676 |         if (newsize == oldsize) {       /* table already at max (!) */[0m
      | [0;1;32m            ^~~~~~~
[0m[1mstr_array.c:676:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  676 |         if (newsize == oldsize) {       /* table already at max (!) */[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:689:6: [0m[0;1;36mnote: [0m'old' is equal to NULL[0m
  689 |         if (old == NULL) {[0m
      | [0;1;32m            ^~~
[0m[1mstr_array.c:689:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  689 |         if (old == NULL) {[0m
      | [0;1;32m        ^
[0m[1mstr_array.c:690:24: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals'[0m
  690 |                 symbol->table_size = 0;[0m
      | [0;1;32m                                     ^
[0m[1mstr_array.c:753:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  753 |         if (code != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  754 |                 *code = ret;[0m
      | [0;1;32m                            
[0m[1mstr_array.c:756:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  756 |         if (ret >= hsize)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  757 |                 ret %= hsize;[0m
      | [0;1;32m                             
[0m[1mstr_array.c:801:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  801 |         if (code != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  802 |                 *code = ret;[0m
      | [0;1;32m                            
[0m[1mstr_array.c:804:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  804 |         if (ret >= hsize)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  805 |                 ret %= hsize;[0m
      | [0;1;32m                             
[0m[1mstr_array.c:854:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  854 |         if (newval == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  855 |                 newval = "";[0m
      | [0;1;32m                            
[0m[1mstr_array.c:868:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  868 |         if (do_posix)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  869 |                 return;[0m
      | [0;1;32m                       
[0m83 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[44/54][181.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpc2pwa_vc.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/int_array.c
[1mint_array.c:73:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   73 |                 if ((newval = getenv_long("INT_CHAIN_MAX")) > 0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m   74 |                         INT_CHAIN_MAX = newval;[0m
      | [0;1;32m                                               
[0m[1mint_array.c:75:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   75 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m   76 |                 null_array(symbol);[0m
      | [0;1;32m                                   
[0m[1mint_array.c:93:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   93 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m   94 |                 return false;[0m
      | [0;1;32m                             
[0m[1mint_array.c:95:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   95 |         if (*s == '0' && len == 1)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m   96 |                 return true;[0m
      | [0;1;32m                            
[0m[1mint_array.c:99:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   99 |         if (*s == '-' && ++s == end)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  100 |                 return false;[0m
      | [0;1;32m                             
[0m[1mint_array.c:102:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  102 |         if (*s < '1' || *s > '9')[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  103 |                 return false;[0m
      | [0;1;32m                             
[0m[1mint_array.c:105:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  105 |                 if (*s < '0' || *s > '9')[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  106 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mint_array.c:121:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  121 |         if ((subs->flags & NUMINT) != 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  122 |                 /* quick exit */[0m
  123 |                 return & success_node;[0m
      | [0;1;32m                                      
[0m[1mint_array.c:125:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  125 |         if (subs == Nnull_string || do_mpfr)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  126 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:175:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  175 |         if (len == 0 || (! isdigit((unsigned char) *cp) && *cp != '-'))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  176 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:182:3: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  182 |         )[0m
      | [0;1;32m         ^
[0m      | [0;32m          {
[0m  183 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:202:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  202 |         if (errno != 0 || ptr != cpend)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  203 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:250:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  250 |                 } else if ((lhs = xn->aexists(xn, subs)) != NULL)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  251 |                         return lhs;[0m
      | [0;1;32m                                   
[0m[1mint_array.c:257:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  257 |         if (symbol->buckets == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  258 |                 grow_int_table(symbol);[0m
      | [0;1;32m                                       
[0m[1mint_array.c:261:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  261 |         if ((lhs = int_find(symbol, k, hash1)) != NULL)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  262 |                 return lhs;[0m
      | [0;1;32m                           
[0m[1mint_array.c:270:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  270 |         if ((xn = symbol->xarray) != NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  271 |                 size -= xn->table_size;[0m
      | [0;1;32m                                       
[0m[1mint_array.c:297:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  297 |                 if (xn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  298 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mint_array.c:301:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  301 |         if (symbol->buckets == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  302 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:335:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  335 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  336 |                                         unref(r);[0m
      | [0;1;32m                                                 
[0m[1mint_array.c:342:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  342 |         if (symbol->buckets != NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  343 |                 efree(symbol->buckets);[0m
      | [0;1;32m                                       
[0m[1mint_array.c:360:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  360 |         if (symbol->table_size == 0 || symbol->buckets == NULL)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  361 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:364:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  364 |                 if (xn == NULL || xn->aremove(xn, subs) == NULL)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  365 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mint_array.c:380:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  380 |                         if (k != b->ainum[i])[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  381 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mint_array.c:396:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  396 |         if (b == NULL)  /* item not in array */[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  397 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:404:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  404 |                 if (prev != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  405 |                         prev->ainext = b->ainext;[0m
  406 |                 else[0m
      | [0;32m                } 
[0m[1mint_array.c:406:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  406 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  407 |                         symbol->buckets[hash1] = b->ainext;[0m
      | [0;1;32m                                                           
[0m[1mint_array.c:482:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  482 |                                 if (oldval->type == Node_val)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  483 |                                         newchain->aivalue[j] = dupnode(oldval);[0m
  484 |                                 else {[0m
      | [0;32m                                } 
[0m[1mint_array.c:506:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  506 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  507 |                 newsymb->xarray = NULL;[0m
      | [0;1;32m                                       
[0m[1mint_array.c:532:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  532 |         if (symbol->table_size == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  533 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mint_array.c:537:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  537 |         if ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  538 |                 num_elems = 1;[0m
      | [0;1;32m                              
[0m[1mint_array.c:540:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  540 |         if ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  541 |                 elem_size = 2;[0m
      | [0;1;32m                              
[0m[1mint_array.c:548:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  548 |                 if (num_elems == 1 || num_elems == xn->table_size)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  549 |                         return list;[0m
      | [0;1;32m                                    
[0m[1mint_array.c:552:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  552 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  553 |                 emalloc(list, NODE **, list_size * sizeof(NODE *), "int_list");[0m
      | [0;1;32m                                                                               
[0m[1mint_array.c:563:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  563 |                                         sprintf(buf, "%ld", num);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mint_array.c:563:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  563 |                                         sprintf(buf, "%ld", num);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mint_array.c:577:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  577 |                                                 if ((assoc_kind & AVNUM) != 0)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  578 |                                                         (void) force_number(r);[0m
  579 |                                                 else if ((assoc_kind & AVSTR) != 0)[0m
      | [0;32m                                                } 
[0m[1mint_array.c:579:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  579 |                                                 else if ((assoc_kind & AVSTR) != 0)[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m  580 |                                                         r = force_string(r);[0m
      | [0;1;32m                                                                            
[0m[1mint_array.c:585:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  585 |                                 if (k >= list_size)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  586 |                                         return list;[0m
      | [0;1;32m                                                    
[0m[1mint_array.c:605:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  605 |                 for (b = symbol->buckets[i]; b != NULL; b = b->ainext)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  606 |                         bucket_cnt++;[0m
      | [0;1;32m                                     
[0m[1mint_array.c:611:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  611 |         if (symbol->xarray != NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  612 |                 kb += str_kilobytes(symbol->xarray);[0m
      | [0;1;32m                                                    
[0m[1mint_array.c:641:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  641 |         if ((symbol->flags & XARRAY) == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  642 |                 fprintf(output_fp, "%s `%s'\n",[0m
  643 |                                 (symbol->parent_array == NULL) ? "array" : "sub-array",[0m
  644 |                                 array_vname(symbol));[0m
      | [0;1;32m                                                     
[0m[1mint_array.c:642:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  642 |                 fprintf(output_fp, "%s `%s'\n",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:642:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  642 |                 fprintf(output_fp, "%s `%s'\n",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:648:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  648 |         fprintf(output_fp, "array_func: int_array_func\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:648:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  648 |         fprintf(output_fp, "array_func: int_array_func\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:651:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  651 |                 fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:651:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  651 |                 fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:654:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  654 |         fprintf(output_fp, "INT_CHAIN_MAX: %lu\n", (unsigned long) INT_CHAIN_MAX);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:654:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  654 |         fprintf(output_fp, "INT_CHAIN_MAX: %lu\n", (unsigned long) INT_CHAIN_MAX);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:656:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  656 |         fprintf(output_fp, "array_size: %lu (int)\n", (unsigned long) symbol->array_size);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:656:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  656 |         fprintf(output_fp, "array_size: %lu (int)\n", (unsigned long) symbol->array_size);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:658:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  658 |         fprintf(output_fp, "table_size: %lu (total), %lu (int), %lu (str)\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:658:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  658 |         fprintf(output_fp, "table_size: %lu (total), %lu (int), %lu (str)\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:661:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  661 |         fprintf(output_fp, "Avg # of items per chain (int): %.2g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:661:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  661 |         fprintf(output_fp, "Avg # of items per chain (int): %.2g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:665:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  665 |         fprintf(output_fp, "memory: %.2g kB (total)\n", int_kilobytes(symbol));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:665:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  665 |         fprintf(output_fp, "memory: %.2g kB (total)\n", int_kilobytes(symbol));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:669:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  669 |         memset(hash_dist, '\0', (HCNT + 1) * sizeof(size_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mint_array.c:669:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  669 |         memset(hash_dist, '\0', (HCNT + 1) * sizeof(size_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mint_array.c:672:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  672 |                 for (b = symbol->buckets[i]; b != NULL; b = b->ainext)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  673 |                         bucket_cnt += b->aicount;[0m
      | [0;1;32m                                                 
[0m[1mint_array.c:674:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  674 |                 if (bucket_cnt >= HCNT)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  675 |                         bucket_cnt = HCNT;[0m
      | [0;1;32m                                          
[0m[1mint_array.c:680:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  680 |         fprintf(output_fp, "Hash distribution:\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:680:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  680 |         fprintf(output_fp, "Hash distribution:\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mint_array.c:685:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  685 |                         if (j == HCNT)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  686 |                                 fprintf(output_fp, "[>=%lu]:%lu\n",[0m
  687 |                                         (unsigned long) HCNT, (unsigned long) hash_dist[j]);[0m
  688 |                         else[0m
      | [0;32m                        } 
[0m[1mint_array.c:686:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  686 |                                 fprintf(output_fp, "[>=%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mint_array.c:686:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  686 |                                 fprintf(output_fp, "[>=%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mint_array.c:688:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  688 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  689 |                                 fprintf(output_fp, "[%lu]:%lu\n",[0m
  690 |                                         (unsigned long) j, (unsigned long) hash_dist[j]);[0m
      | [0;1;32m                                                                                         
[0m[1mint_array.c:689:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  689 |                                 fprintf(output_fp, "[%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mint_array.c:689:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  689 |                                 fprintf(output_fp, "[%lu]:%lu\n",[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mint_array.c:701:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  701 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:701:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  701 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:719:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  719 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:719:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  719 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mint_array.c:750:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  750 |         if (k >= hsize)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  751 |                 k %= hsize;[0m
      | [0;1;32m                           
[0m[1mint_array.c:766:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  766 |                         if (b->ainum[i] == k)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  767 |                                 return (b->aivalue + i);[0m
      | [0;1;32m                                                        
[0m[1mint_array.c:851:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  851 |         if (old == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  852 |                 return;         /* DO NOT initialize symbol->table_size */[0m
      | [0;1;32m                                                                          
[0m91 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[45/54][216.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp17nbt7pp.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/extension/gawkfts.c
[1mgawkfts.c:165:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  165 |         if ((sp = calloc(1, (unsigned int)sizeof(FTS))) == NULL)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  166 |                 return (NULL);[0m
      | [0;1;32m                              
[0m[1mgawkfts.c:171:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  171 |         if (ISSET(FTS_LOGICAL))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  172 |                 SET(FTS_NOCHDIR);[0m
      | [0;1;32m                                 
[0m[1mgawkfts.c:178:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  178 |         if (fts_palloc(sp, MAX(fts_maxarglen(argv), MAXPATHLEN)))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  179 |                 goto mem1;[0m
      | [0;1;32m                          
[0m[1mgawkfts.c:182:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  182 |         if ((parent = fts_alloc(sp, "", 0)) == NULL)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  183 |                 goto mem2;[0m
      | [0;1;32m                          
[0m[1mgawkfts.c:194:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  194 |                 if ((p = fts_alloc(sp, *argv, len)) == NULL)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  195 |                         goto mem3;[0m
      | [0;1;32m                                  
[0m[1mgawkfts.c:202:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  202 |                 if (p->fts_info == FTS_DOT)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  203 |                         p->fts_info = FTS_D;[0m
      | [0;1;32m                                            
[0m[1mgawkfts.c:214:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  214 |                         if (root == NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  215 |                                 tmp = root = p;[0m
  216 |                         else {[0m
      | [0;32m                        } 
[0m[1mgawkfts.c:222:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  222 |         if (compar && nitems > 1)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  223 |                 root = fts_sort(sp, root, nitems);[0m
      | [0;1;32m                                                  
[0m[1mgawkfts.c:230:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  230 |         if ((sp->fts_cur = fts_alloc(sp, "", 0)) == NULL)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  231 |                 goto mem4;[0m
      | [0;1;32m                          
[0m[1mgawkfts.c:246:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  246 |                 if ((sp->fts_rfd = open(".", O_RDONLY | O_CLOEXEC, 0)) == -1)[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m  247 |                         SET(FTS_NOCHDIR);[0m
      | [0;1;32m                                         
[0m[1mgawkfts.c:250:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  250 |         if (nitems == 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  251 |                 fts_free(parent);[0m
      | [0;1;32m                                 
[0m[1mgawkfts.c:255:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  255 | mem4:   if (sp->fts_array != NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  256 |                 free(sp->fts_array);[0m
      | [0;1;32m                                    
[0m[1mgawkfts.c:281:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  281 |         memmove(sp->fts_path, p->fts_name, len + 1);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkfts.c:281:2: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  281 |         memmove(sp->fts_path, p->fts_name, len + 1);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkfts.c:284:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  284 |                 memmove(p->fts_name, cp, len + 1);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgawkfts.c:284:3: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  284 |                 memmove(p->fts_name, cp, len + 1);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgawkfts.c:305:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  305 |                 if (sp->fts_cur->fts_flags & FTS_SYMFOLLOW)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  306 |                         (void)close(sp->fts_cur->fts_symfd);[0m
      | [0;1;32m                                                            
[0m[1mgawkfts.c:316:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  316 |         if (sp->fts_child)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  317 |                 fts_lfree(sp->fts_child);[0m
      | [0;1;32m                                         
[0m[1mgawkfts.c:318:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  318 |         if (sp->fts_array)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  319 |                 free(sp->fts_array);[0m
      | [0;1;32m                                    
[0m[1mgawkfts.c:324:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  324 |                 if (fchdir(sp->fts_rfd) == -1)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  325 |                         saved_errno = errno;[0m
      | [0;1;32m                                            
[0m[1mgawkfts.c:375:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  375 |         if (sp->fts_cur == NULL || ISSET(FTS_STOP))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  376 |                 return (NULL);[0m
      | [0;1;32m                              
[0m[1mgawkfts.c:405:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  405 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  406 |                                 p->fts_flags |= FTS_SYMFOLLOW;[0m
      | [0;1;32m                                                              
[0m[1mgawkfts.c:416:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  416 |                         if (p->fts_flags & FTS_SYMFOLLOW)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  417 |                                 (void)close(p->fts_symfd);[0m
      | [0;1;32m                                                          
[0m[1mgawkfts.c:449:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  449 |                                 for (p = sp->fts_child; p; p = p->fts_link)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m  450 |                                         p->fts_accpath =[0m
  451 |                                             p->fts_parent->fts_accpath;[0m
      | [0;1;32m                                                                       
[0m[1mgawkfts.c:454:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  454 |                         if (ISSET(FTS_STOP))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  455 |                                 return (NULL);[0m
      | [0;1;32m                                              
[0m[1mgawkfts.c:486:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  486 |                 if (p->fts_instr == FTS_SKIP)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  487 |                         goto next;[0m
      | [0;1;32m                                  
[0m[1mgawkfts.c:495:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  495 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  496 |                                         p->fts_flags |= FTS_SYMFOLLOW;[0m
      | [0;1;32m                                                                      
[0m[1mgawkfts.c:503:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  503 |                 memmove(t, p->fts_name, (size_t)(p->fts_namelen + 1));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgawkfts.c:503:3: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  503 |                 memmove(t, p->fts_name, (size_t)(p->fts_namelen + 1));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mgawkfts.c:598:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  598 |         if (ISSET(FTS_STOP))[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  599 |                 return (NULL);[0m
      | [0;1;32m                              
[0m[1mgawkfts.c:602:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  602 |         if (p->fts_info == FTS_INIT)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  603 |                 return (p->fts_link);[0m
      | [0;1;32m                                     
[0m[1mgawkfts.c:610:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  610 |         if (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  611 |                 return (NULL);[0m
      | [0;1;32m                              
[0m[1mgawkfts.c:614:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  614 |         if (sp->fts_child)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  615 |                 fts_lfree(sp->fts_child);[0m
      | [0;1;32m                                         
[0m[1mgawkfts.c:620:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  620 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  621 |                 instr = BCHILD;[0m
      | [0;1;32m                               
[0m[1mgawkfts.c:631:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  631 |             ISSET(FTS_NOCHDIR))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  632 |                 return (sp->fts_child = fts_build(sp, instr));[0m
      | [0;1;32m                                                              
[0m[1mgawkfts.c:634:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  634 |         if ((fd = open(".", O_RDONLY, 0)) == -1)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  635 |                 return (sp->fts_child = NULL);[0m
      | [0;1;32m                                              
[0m[1mgawkfts.c:740:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  740 |                         if (nlinks && type == BREAD)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  741 |                                 cur->fts_errno = errno;[0m
      | [0;1;32m                                                       
[0m[1mgawkfts.c:745:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  745 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  746 |                         descend = 1;[0m
      | [0;1;32m                                    
[0m[1mgawkfts.c:747:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  747 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  748 |                 descend = 0;[0m
      | [0;1;32m                            
[0m[1mgawkfts.c:784:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  785 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mgawkfts.c:792:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  792 |                 if ((p = fts_alloc(sp, dp->d_name, dnamlen)) == NULL)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  793 |                         goto mem1;[0m
      | [0;1;32m                                  
[0m[1mgawkfts.c:803:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  803 |                                 if (p)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  804 |                                         fts_free(p);[0m
      | [0;1;32m                                                    
[0m[1mgawkfts.c:815:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  815 |                                 if (ISSET(FTS_NOCHDIR))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  816 |                                         cp = sp->fts_path + len;[0m
      | [0;1;32m                                                                
[0m[1mgawkfts.c:852:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  852 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  853 |                                 p->fts_info = FTS_NSOK;[0m
      | [0;1;32m                                                       
[0m[1mgawkfts.c:868:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
  868 |                                 memmove(cp, p->fts_name,[0m
      | [0;1;32m                                ^       ~~
[0m[1mgawkfts.c:674:2: [0m[0;1;36mnote: [0m'cp' initialized to a null pointer value[0m
  674 |         char *cp = NULL;        /* pacify gcc */[0m
      | [0;1;32m        ^~~~~~~~
[0m[1mgawkfts.c:693:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  693 |         if ((dirp = __opendir2(cur->fts_accpath, oflag)) == NULL) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:706:6: [0m[0;1;36mnote: [0mAssuming 'type' is not equal to BNAMES[0m
  706 |         if (type == BNAMES) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~
[0m[1mgawkfts.c:706:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  706 |         if (type == BNAMES) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:709:13: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  709 |         } else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {[0m
      | [0;1;32m                   ^
[0m[1mgawkfts.c:125:21: [0m[0;1;36mnote: [0mexpanded from macro 'ISSET'[0m
  125 | #define ISSET(opt)      (sp->fts_options & (opt))[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:709:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  709 |         } else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {[0m
      | [0;1;32m                                     ^
[0m[1mgawkfts.c:738:6: [0m[0;1;36mnote: [0m'nlinks' is -1[0m
  738 |         if (nlinks || type == BREAD) {[0m
      | [0;1;32m            ^~~~~~
[0m[1mgawkfts.c:738:13: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  738 |         if (nlinks || type == BREAD) {[0m
      | [0;1;32m                   ^
[0m[1mgawkfts.c:739:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  739 |                 if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:739:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  739 |                 if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:760:16: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  760 |         len = NAPPEND(cur);[0m
      | [0;1;32m                      ^
[0m[1mgawkfts.c:346:3: [0m[0;1;36mnote: [0mexpanded from macro 'NAPPEND'[0m
  346 |         (p->fts_path[p->fts_pathlen - 1] == '/'                         \[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:760:16: [0m[0;1;36mnote: [0m'?' condition is false[0m
  760 |         len = NAPPEND(cur);[0m
      | [0;1;32m                      ^
[0m[1mgawkfts.c:761:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  761 |         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m            ^
[0m[1mgawkfts.c:125:21: [0m[0;1;36mnote: [0mexpanded from macro 'ISSET'[0m
  125 | #define ISSET(opt)      (sp->fts_options & (opt))[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:761:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  761 |         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:782:39: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:782:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:784:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:784:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                                       ^
[0m[1mgawkfts.c:792:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  792 |                 if ((p = fts_alloc(sp, dp->d_name, dnamlen)) == NULL)[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:794:7: [0m[0;1;36mnote: [0mAssuming 'dnamlen' is < 'maxlen'[0m
  794 |                 if (dnamlen >= maxlen) {        /* include space for NUL */[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:794:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  794 |                 if (dnamlen >= maxlen) {        /* include space for NUL */[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:840:20: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  840 |                 p->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);[0m
      | [0;1;32m                                 ^
[0m[1mgawkfts.c:111:6: [0m[0;1;36mnote: [0mexpanded from macro 'ftsent_pathlen_truncate'[0m
  111 |     ((a) > UINT_MAX ? UINT_MAX : (unsigned int)(a))[0m
      | [0;1;32m     ^~~~~~~~~~~~~~
[0m[1mgawkfts.c:840:20: [0m[0;1;36mnote: [0m'?' condition is true[0m
  840 |                 p->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);[0m
      | [0;1;32m                                 ^
[0m[1mgawkfts.c:111:6: [0m[0;1;36mnote: [0mexpanded from macro 'ftsent_pathlen_truncate'[0m
  111 |     ((a) > UINT_MAX ? UINT_MAX : (unsigned int)(a))[0m
      | [0;1;32m     ^
[0m[1mgawkfts.c:848:7: [0m[0;1;36mnote: [0m'cderrno' is 0[0m
  848 |                 if (cderrno) {[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mgawkfts.c:848:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  848 |                 if (cderrno) {[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:855:14: [0m[0;1;36mnote: [0m'nlinks' is not equal to 0[0m
  855 |                 } else if (nlinks == 0[0m
      | [0;1;32m                           ^~~~~~
[0m[1mgawkfts.c:855:14: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkfts.c:857:11: [0m[0;1;36mnote: [0m'nostat' is 0[0m
  857 |                     || (nostat &&[0m
      | [0;1;32m                        ^~~~~~
[0m[1mgawkfts.c:857:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  857 |                     || (nostat &&[0m
      | [0;1;32m                               ^
[0m[1mgawkfts.c:866:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  866 |                         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m                        ^
[0m[1mgawkfts.c:876:8: [0m[0;1;36mnote: [0m'nlinks' is <= 0[0m
  876 |                         if (nlinks > 0 && (p->fts_info == FTS_D ||[0m
      | [0;1;32m                            ^~~~~~
[0m[1mgawkfts.c:876:19: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  876 |                         if (nlinks > 0 && (p->fts_info == FTS_D ||[0m
      | [0;1;32m                                       ^
[0m[1mgawkfts.c:883:7: [0m[0;1;36mnote: [0m'head' is equal to NULL[0m
  883 |                 if (head == NULL)[0m
      | [0;1;32m                    ^~~~
[0m[1mgawkfts.c:883:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  883 |                 if (head == NULL)[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:782:39: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:782:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:784:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:784:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                                       ^
[0m[1mgawkfts.c:792:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  792 |                 if ((p = fts_alloc(sp, dp->d_name, dnamlen)) == NULL)[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:794:7: [0m[0;1;36mnote: [0mAssuming 'dnamlen' is < 'maxlen'[0m
  794 |                 if (dnamlen >= maxlen) {        /* include space for NUL */[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:794:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  794 |                 if (dnamlen >= maxlen) {        /* include space for NUL */[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:840:20: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  840 |                 p->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);[0m
      | [0;1;32m                                 ^
[0m[1mgawkfts.c:111:6: [0m[0;1;36mnote: [0mexpanded from macro 'ftsent_pathlen_truncate'[0m
  111 |     ((a) > UINT_MAX ? UINT_MAX : (unsigned int)(a))[0m
      | [0;1;32m     ^~~~~~~~~~~~~~
[0m[1mgawkfts.c:840:20: [0m[0;1;36mnote: [0m'?' condition is true[0m
  840 |                 p->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);[0m
      | [0;1;32m                                 ^
[0m[1mgawkfts.c:111:6: [0m[0;1;36mnote: [0mexpanded from macro 'ftsent_pathlen_truncate'[0m
  111 |     ((a) > UINT_MAX ? UINT_MAX : (unsigned int)(a))[0m
      | [0;1;32m     ^
[0m[1mgawkfts.c:848:7: [0m[0;1;36mnote: [0m'cderrno' is 0[0m
  848 |                 if (cderrno) {[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mgawkfts.c:848:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  848 |                 if (cderrno) {[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:855:14: [0m[0;1;36mnote: [0m'nlinks' is not equal to 0[0m
  855 |                 } else if (nlinks == 0[0m
      | [0;1;32m                           ^~~~~~
[0m[1mgawkfts.c:855:14: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkfts.c:857:11: [0m[0;1;36mnote: [0m'nostat' is 0[0m
  857 |                     || (nostat &&[0m
      | [0;1;32m                        ^~~~~~
[0m[1mgawkfts.c:857:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  857 |                     || (nostat &&[0m
      | [0;1;32m                               ^
[0m[1mgawkfts.c:866:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  866 |                         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m                            ^
[0m[1mgawkfts.c:125:21: [0m[0;1;36mnote: [0mexpanded from macro 'ISSET'[0m
  125 | #define ISSET(opt)      (sp->fts_options & (opt))[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:866:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  866 |                         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m                        ^
[0m[1mgawkfts.c:868:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
  868 |                                 memmove(cp, p->fts_name,[0m
      | [0;1;32m                                ^       ~~
[0m[1mgawkfts.c:868:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  868 |                                 memmove(cp, p->fts_name,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mgawkfts.c:868:5: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  868 |                                 memmove(cp, p->fts_name,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mgawkfts.c:870:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  870 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  871 |                                 p->fts_accpath = p->fts_name;[0m
      | [0;1;32m                                                             
[0m[1mgawkfts.c:877:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  877 |                             p->fts_info == FTS_DC || p->fts_info == FTS_DOT))[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m  878 |                                 --nlinks;[0m
      | [0;1;32m                                         
[0m[1mgawkfts.c:883:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  883 |                 if (head == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  884 |                         head = tail = p;[0m
  885 |                 else {[0m
      | [0;32m                } 
[0m[1mgawkfts.c:897:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  897 |         if (doadjust)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  898 |                 fts_padjust(sp, head);[0m
      | [0;1;32m                                      
[0m[1mgawkfts.c:905:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  905 |                 if (len == sp->fts_pathlen || nitems == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  906 |                         --cp;[0m
      | [0;1;32m                             
[0m[1mgawkfts.c:907:7: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'cp') [clang-analyzer-core.NullDereference][0m
  907 |                 *cp = '\0';[0m
      | [0;1;32m                 ~~ ^
[0m[1mgawkfts.c:674:2: [0m[0;1;36mnote: [0m'cp' initialized to a null pointer value[0m
  674 |         char *cp = NULL;        /* pacify gcc */[0m
      | [0;1;32m        ^~~~~~~~
[0m[1mgawkfts.c:693:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  693 |         if ((dirp = __opendir2(cur->fts_accpath, oflag)) == NULL) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:706:6: [0m[0;1;36mnote: [0mAssuming 'type' is not equal to BNAMES[0m
  706 |         if (type == BNAMES) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~
[0m[1mgawkfts.c:706:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  706 |         if (type == BNAMES) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:709:13: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  709 |         } else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {[0m
      | [0;1;32m                   ^
[0m[1mgawkfts.c:125:21: [0m[0;1;36mnote: [0mexpanded from macro 'ISSET'[0m
  125 | #define ISSET(opt)      (sp->fts_options & (opt))[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:709:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  709 |         } else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {[0m
      | [0;1;32m                                     ^
[0m[1mgawkfts.c:738:6: [0m[0;1;36mnote: [0m'nlinks' is -1[0m
  738 |         if (nlinks || type == BREAD) {[0m
      | [0;1;32m            ^~~~~~
[0m[1mgawkfts.c:738:13: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  738 |         if (nlinks || type == BREAD) {[0m
      | [0;1;32m                   ^
[0m[1mgawkfts.c:739:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  739 |                 if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:739:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  739 |                 if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:760:16: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  760 |         len = NAPPEND(cur);[0m
      | [0;1;32m                      ^
[0m[1mgawkfts.c:346:3: [0m[0;1;36mnote: [0mexpanded from macro 'NAPPEND'[0m
  346 |         (p->fts_path[p->fts_pathlen - 1] == '/'                         \[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:760:16: [0m[0;1;36mnote: [0m'?' condition is false[0m
  760 |         len = NAPPEND(cur);[0m
      | [0;1;32m                      ^
[0m[1mgawkfts.c:761:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  761 |         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m            ^
[0m[1mgawkfts.c:125:21: [0m[0;1;36mnote: [0mexpanded from macro 'ISSET'[0m
  125 | #define ISSET(opt)      (sp->fts_options & (opt))[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:761:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  761 |         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:782:39: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:782:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:784:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:784:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  784 |                 if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))[0m
      | [0;1;32m                                       ^
[0m[1mgawkfts.c:792:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  792 |                 if ((p = fts_alloc(sp, dp->d_name, dnamlen)) == NULL)[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:794:7: [0m[0;1;36mnote: [0mAssuming 'dnamlen' is < 'maxlen'[0m
  794 |                 if (dnamlen >= maxlen) {        /* include space for NUL */[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:794:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  794 |                 if (dnamlen >= maxlen) {        /* include space for NUL */[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:840:20: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  840 |                 p->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);[0m
      | [0;1;32m                                 ^
[0m[1mgawkfts.c:111:6: [0m[0;1;36mnote: [0mexpanded from macro 'ftsent_pathlen_truncate'[0m
  111 |     ((a) > UINT_MAX ? UINT_MAX : (unsigned int)(a))[0m
      | [0;1;32m     ^~~~~~~~~~~~~~
[0m[1mgawkfts.c:840:20: [0m[0;1;36mnote: [0m'?' condition is true[0m
  840 |                 p->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);[0m
      | [0;1;32m                                 ^
[0m[1mgawkfts.c:111:6: [0m[0;1;36mnote: [0mexpanded from macro 'ftsent_pathlen_truncate'[0m
  111 |     ((a) > UINT_MAX ? UINT_MAX : (unsigned int)(a))[0m
      | [0;1;32m     ^
[0m[1mgawkfts.c:848:7: [0m[0;1;36mnote: [0m'cderrno' is 0[0m
  848 |                 if (cderrno) {[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mgawkfts.c:848:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  848 |                 if (cderrno) {[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:855:14: [0m[0;1;36mnote: [0m'nlinks' is not equal to 0[0m
  855 |                 } else if (nlinks == 0[0m
      | [0;1;32m                           ^~~~~~
[0m[1mgawkfts.c:855:14: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkfts.c:857:11: [0m[0;1;36mnote: [0m'nostat' is 0[0m
  857 |                     || (nostat &&[0m
      | [0;1;32m                        ^~~~~~
[0m[1mgawkfts.c:857:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  857 |                     || (nostat &&[0m
      | [0;1;32m                               ^
[0m[1mgawkfts.c:866:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  866 |                         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m                        ^
[0m[1mgawkfts.c:876:8: [0m[0;1;36mnote: [0m'nlinks' is <= 0[0m
  876 |                         if (nlinks > 0 && (p->fts_info == FTS_D ||[0m
      | [0;1;32m                            ^~~~~~
[0m[1mgawkfts.c:876:19: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  876 |                         if (nlinks > 0 && (p->fts_info == FTS_D ||[0m
      | [0;1;32m                                       ^
[0m[1mgawkfts.c:883:7: [0m[0;1;36mnote: [0m'head' is equal to NULL[0m
  883 |                 if (head == NULL)[0m
      | [0;1;32m                    ^~~~
[0m[1mgawkfts.c:883:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  883 |                 if (head == NULL)[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:782:39: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:782:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 891[0m
  782 |         for (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:897:6: [0m[0;1;36mnote: [0m'doadjust' is 0[0m
  897 |         if (doadjust)[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mgawkfts.c:897:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  897 |         if (doadjust)[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:904:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  904 |         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m            ^
[0m[1mgawkfts.c:125:21: [0m[0;1;36mnote: [0mexpanded from macro 'ISSET'[0m
  125 | #define ISSET(opt)      (sp->fts_options & (opt))[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:904:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  904 |         if (ISSET(FTS_NOCHDIR)) {[0m
      | [0;1;32m        ^
[0m[1mgawkfts.c:905:7: [0m[0;1;36mnote: [0mAssuming 'len' is not equal to field 'fts_pathlen'[0m
  905 |                 if (len == sp->fts_pathlen || nitems == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mgawkfts.c:905:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mgawkfts.c:905:33: [0m[0;1;36mnote: [0m'nitems' is not equal to 0[0m
  905 |                 if (len == sp->fts_pathlen || nitems == 0)[0m
      | [0;1;32m                                              ^~~~~~
[0m[1mgawkfts.c:905:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  905 |                 if (len == sp->fts_pathlen || nitems == 0)[0m
      | [0;1;32m                ^
[0m[1mgawkfts.c:907:7: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'cp')[0m
  907 |                 *cp = '\0';[0m
      | [0;1;32m                 ~~ ^
[0m[1mgawkfts.c:929:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  929 |                 if (type == BREAD)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  930 |                         cur->fts_info = FTS_DP;[0m
      | [0;1;32m                                               
[0m[1mgawkfts.c:935:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  935 |         if (sp->fts_compar && nitems > 1)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  936 |                 head = fts_sort(sp, head, nitems);[0m
      | [0;1;32m                                                  
[0m[1mgawkfts.c:983:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  983 | err:            memset(sbp, 0, sizeof(*sbp));[0m
      | [0;1;32m                ^~~~~~
[0m[1mgawkfts.c:983:7: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  983 | err:            memset(sbp, 0, sizeof(*sbp));[0m
      | [0;1;32m                ^~~~~~
[0m[1mgawkfts.c:999:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  999 |                 if (ISDOT(p->fts_name))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1000 |                         return (FTS_DOT);[0m
      | [0;1;32m                                         
[0m[1mgawkfts.c:1009:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1009 |                     t->fts_level >= FTS_ROOTLEVEL; t = t->fts_parent)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1010 |                         if (ino == t->fts_ino && dev == t->fts_dev) {[0m
 1011 |                                 p->fts_cycle = t;[0m
 1012 |                                 return (FTS_DC);[0m
 1013 |                         }[0m
      | [0;1;32m                         
[0m[1mgawkfts.c:1016:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1016 |         if (S_ISLNK(sbp->st_mode))[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1017 |                 return (FTS_SL);[0m
      | [0;1;32m                                
[0m[1mgawkfts.c:1018:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1018 |         if (S_ISREG(sbp->st_mode))[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1019 |                 return (FTS_F);[0m
      | [0;1;32m                               
[0m[1mgawkfts.c:1042:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1042 |                 if (new == 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1043 |                         return (head);[0m
      | [0;1;32m                                      
[0m[1mgawkfts.c:1047:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1047 |         for (ap = sp->fts_array, p = head; p; p = p->fts_link)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1048 |                 *ap++ = p;[0m
      | [0;1;32m                          
[0m[1mgawkfts.c:1051:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1051 |         for (head = *(ap = sp->fts_array); --nitems; ++ap)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1052 |                 ap[0]->fts_link = ap[1];[0m
      | [0;1;32m                                        
[0m[1mgawkfts.c:1087:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1087 |         if ((p = malloc(sizeof(FTSENT) + namelen)) == NULL)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1088 |                 return (NULL);[0m
      | [0;1;32m                              
[0m[1mgawkfts.c:1090:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1090 |         if (!ISSET(FTS_NOSTAT))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1091 |                 if ((p->fts_statp = malloc(sizeof(*(p->fts_statp)))) == NULL) {[0m
 1092 |                         free(p);[0m
 1093 |                         return (NULL);[0m
 1094 |                 }[0m
      | [0;1;32m                 
[0m[1mgawkfts.c:1097:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1097 |         if (ISSET(FTS_NOSTAT))[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1098 |                 p->fts_statp = NULL;[0m
      | [0;1;32m                                    
[0m[1mgawkfts.c:1101:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1101 |         memmove(p->fts_name, name, namelen + 1);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkfts.c:1101:2: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
 1101 |         memmove(p->fts_name, name, namelen + 1);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mgawkfts.c:1117:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1117 |         if (p->fts_statp)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1118 |                 free(p->fts_statp);[0m
      | [0;1;32m                                   
[0m[1mgawkfts.c:1179:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1179 |         if (new == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1180 |                 return (1);[0m
      | [0;1;32m                           
[0m[1mgawkfts.c:1208:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1208 |         for (p = sp->fts_child; p; p = p->fts_link)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1209 |                 ADJUST(p);[0m
      | [0;1;32m                          
[0m[1mgawkfts.c:1225:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1225 |         for (max = 0; *argv; ++argv)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1226 |                 if ((len = strlen(*argv)) > max)[0m
 1227 |                         max = len;[0m
      | [0;1;32m                                  
[0m[1mgawkfts.c:1226:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1226 |                 if ((len = strlen(*argv)) > max)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1227 |                         max = len;[0m
      | [0;1;32m                                  
[0m[1mgawkfts.c:1242:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1242 |         if (ISSET(FTS_NOCHDIR))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1243 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mgawkfts.c:1245:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1245 |         if (oldfd < 0 && (path == NULL || (fd = open(path, O_RDONLY)) == -1))[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m 1246 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mgawkfts.c:1248:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1248 |         if (fstat(fd, &sb) == -1)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1249 |                 goto bail;[0m
      | [0;1;32m                          
[0m73 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[46/54][223.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpfqeupu2j.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/profile.c
[1mprofile.c:91:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   91 |         if (fd == INVALID_HANDLE)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m   92 |                 prof_fp = NULL;[0m
   93 |         else if (fd == fileno(stdout))[0m
      | [0;32m        } 
[0m[1mprofile.c:93:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   93 |         else if (fd == fileno(stdout))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m   94 |                 prof_fp = stdout;[0m
   95 |         else if (fd == fileno(stderr))[0m
      | [0;32m        } 
[0m[1mprofile.c:95:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   95 |         else if (fd == fileno(stderr))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m   96 |                 prof_fp = stderr;[0m
   97 |         else[0m
      | [0;32m        } 
[0m[1mprofile.c:97:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   97 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m   98 |                 prof_fp = fdopen(fd, "w");[0m
      | [0;1;32m                                          
[0m[1mprofile.c:105:16: [0m[0;1;35mwarning: [0m[1mStream pointer might be NULL [clang-analyzer-unix.Stream][0m
  105 |                     && fd != fileno(stdout)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~
[0m[1mprofile.c:91:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
   91 |         if (fd == INVALID_HANDLE)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:91:2: [0m[0;1;36mnote: [0mTaking false branch[0m
   91 |         if (fd == INVALID_HANDLE)[0m
      | [0;1;32m        ^
[0m[1mprofile.c:93:17: [0m[0;1;36mnote: [0mValue assigned to 'stdout'[0m
   93 |         else if (fd == fileno(stdout))[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~
[0m[1mprofile.c:93:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
   93 |         else if (fd == fileno(stdout))[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:93:7: [0m[0;1;36mnote: [0mTaking true branch[0m
   93 |         else if (fd == fileno(stdout))[0m
      | [0;1;32m             ^
[0m[1mprofile.c:100:6: [0m[0;1;36mnote: [0mAssuming 'prof_fp' is equal to NULL[0m
  100 |         if (prof_fp == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mprofile.c:100:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  100 |         if (prof_fp == NULL) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:104:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  104 |                 if (   fd != INVALID_HANDLE[0m
      | [0;1;32m                       ^
[0m[1mprofile.c:105:16: [0m[0;1;36mnote: [0mStream pointer might be NULL[0m
  105 |                     && fd != fileno(stdout)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~
[0m[1mprofile.c:106:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  106 |                     && fd != fileno(stderr))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  107 |                         (void) close(fd);[0m
      | [0;1;32m                                         
[0m[1mprofile.c:138:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  138 |                 if (count == 0)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  139 |                         fprintf(prof_fp, "\t");[0m
  140 |                 else[0m
      | [0;32m                } 
[0m[1mprofile.c:139:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  139 |                         fprintf(prof_fp, "\t");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:139:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  139 |                         fprintf(prof_fp, "\t");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:140:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  140 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  141 |                         fprintf(prof_fp, EXEC_COUNT_PROFILE_FMT "  ", count);[0m
      | [0;1;32m                                                                             
[0m[1mprofile.c:141:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  141 |                         fprintf(prof_fp, EXEC_COUNT_PROFILE_FMT "  ", count);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:141:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  141 |                         fprintf(prof_fp, EXEC_COUNT_PROFILE_FMT "  ", count);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:145:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  145 |         for (i = 0; i < indent_level; i++)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  146 |                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                                       
[0m[1mprofile.c:146:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  146 |                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:146:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  146 |                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '120' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_cond_exp:'  at line 1122[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:1153:8: [0m[0;1;36mnote: [0mAssuming 'qm_comment' is not equal to NULL[0m
 1153 |                         if (qm_comment == NULL && colon_comment == NULL) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1153:27: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1153 |                         if (qm_comment == NULL && colon_comment == NULL) {[0m
      | [0;1;32m                                               ^
[0m[1mprofile.c:1157:15: [0m[0;1;36mnote: [0m'qm_comment' is not equal to NULL[0m
 1157 |                         } else if (qm_comment != NULL && colon_comment != NULL) {[0m
      | [0;1;32m                                   ^~~~~~~~~~
[0m[1mprofile.c:1157:15: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprofile.c:1157:37: [0m[0;1;36mnote: [0mAssuming 'colon_comment' is equal to NULL[0m
 1157 |                         } else if (qm_comment != NULL && colon_comment != NULL) {[0m
      | [0;1;32m                                                         ^~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1157:11: [0m[0;1;36mnote: [0mTaking false branch[0m
 1157 |                         } else if (qm_comment != NULL && colon_comment != NULL) {[0m
      | [0;1;32m                               ^
[0m[1mprofile.c:1177:15: [0m[0;1;36mnote: [0m'qm_comment' is not equal to NULL[0m
 1177 |                         } else if (qm_comment != NULL) {[0m
      | [0;1;32m                                   ^~~~~~~~~~
[0m[1mprofile.c:1177:11: [0m[0;1;36mnote: [0mTaking true branch[0m
 1177 |                         } else if (qm_comment != NULL) {[0m
      | [0;1;32m                               ^
[0m[1mprofile.c:1178:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1178 |                                 check_indent_level();[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:71:6: [0m[0;1;36mnote: [0mexpanded from macro 'check_indent_level'[0m
   71 |         if (indent_level + 1 > tabs_len) \[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1178:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1178 |                                 check_indent_level();[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:71:2: [0m[0;1;36mnote: [0mexpanded from macro 'check_indent_level'[0m
   71 |         if (indent_level + 1 > tabs_len) \[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1214:12: [0m[0;1;36mnote: [0mPassing the value 120 via 1st parameter 'type'[0m
 1214 |                         pp_push(Op_cond_exp, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~
[0m[1mprofile.c:1214:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
 1214 |                         pp_push(Op_cond_exp, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '120' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '121' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_parens:'  at line 467[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:471:12: [0m[0;1;36mnote: [0mPassing the value 121 via 1st parameter 'type'[0m
  471 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:471:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  471 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '121' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '21' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_postdecrement:'  at line 498[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:500:12: [0m[0;1;36mnote: [0mField 'opcode' is not equal to Op_preincrement[0m
  500 |                         if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:500:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  500 |                         if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)[0m
      | [0;1;32m                            ^
[0m[1mprofile.c:500:45: [0m[0;1;36mnote: [0mField 'opcode' is not equal to Op_predecrement[0m
  500 |                         if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)[0m
      | [0;1;32m                                                                 ^
[0m[1mprofile.c:500:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  500 |                         if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:505:12: [0m[0;1;36mnote: [0mPassing the value 21 via 1st parameter 'type'[0m
  505 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:505:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  505 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '21' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '24' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_field_spec:'  at line 508[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:514:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  514 |                         if (is_binary(t1->type)[0m
      | [0;1;32m                            ^
[0m[1mprofile.c:515:12: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to field 'opcode'[0m
  515 |                             || (((OPCODE) t1->type) == pc->opcode[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:516:9: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  516 |                                     && (pc->opcode == Op_unary_minus[0m
      | [0;1;32m                                    ^
[0m[1mprofile.c:523:12: [0m[0;1;36mnote: [0mPassing the value 24 via 1st parameter 'type'[0m
  523 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:523:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  523 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '24' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '26' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_assign:'  at line 526[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:538:12: [0m[0;1;36mnote: [0mPassing the value 26 via 1st parameter 'type'[0m
  538 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:538:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  538 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '26' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '28' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_store_sub:'  at line 343[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:352:4: [0m[0;1;36mnote: [0mControl jumps to 'case Node_param_list:'  at line 353[0m
  352 |                         switch (m->type) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:354:13: [0m[0;1;36mnote: [0mPassing the value 28 via 1st parameter 'type'[0m
  354 |                                 pp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                        ^~~~~~~~~~
[0m[1mprofile.c:354:5: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  354 |                                 pp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '28' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '38' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_and:'  at line 419[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:425:8: [0m[0;1;36mnote: [0mAssuming field 'comment' is not equal to NULL[0m
  425 |                         if (pc->comment == NULL)[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:425:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  425 |                         if (pc->comment == NULL)[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:428:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  428 |                                 check_indent_level();[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:71:6: [0m[0;1;36mnote: [0mexpanded from macro 'check_indent_level'[0m
   71 |         if (indent_level + 1 > tabs_len) \[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:428:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  428 |                                 check_indent_level();[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:71:2: [0m[0;1;36mnote: [0mexpanded from macro 'check_indent_level'[0m
   71 |         if (indent_level + 1 > tabs_len) \[0m
      | [0;1;32m        ^
[0m[1mprofile.c:442:12: [0m[0;1;36mnote: [0mPassing the value 38 via 1st parameter 'type'[0m
  442 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:442:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  442 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '38' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '49' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_match_rec:'  at line 716[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:718:8: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_regex[0m
  718 |                         if (pc->memory->type == Node_regex) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:718:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  718 |                         if (pc->memory->type == Node_regex) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:725:12: [0m[0;1;36mnote: [0mPassing the value 49 via 1st parameter 'type'[0m
  725 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:725:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  725 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '49' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '50' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_nomatch:'  at line 729[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:734:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  734 |                         if (is_binary(t1->type))[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:738:8: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_dynregex[0m
  738 |                         if (m->type == Node_dynregex) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:738:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  738 |                         if (m->type == Node_dynregex) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:746:15: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_val[0m
  746 |                         } else if (m->type == Node_val && (m->flags & REGEX) != 0) {[0m
      | [0;1;32m                                   ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:746:35: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  746 |                         } else if (m->type == Node_val && (m->flags & REGEX) != 0) {[0m
      | [0;1;32m                                                       ^
[0m[1mprofile.c:757:12: [0m[0;1;36mnote: [0mPassing the value 50 via 1st parameter 'type'[0m
  757 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:757:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  757 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '50' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '66' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_K_getline:'  at line 761[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:763:8: [0m[0;1;36mnote: [0mAssuming field 'xl' is 0[0m
  763 |                         if (pc->into_var) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~
[0m[1mprofile.c:763:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  763 |                         if (pc->into_var) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:770:8: [0m[0;1;36mnote: [0mAssuming field 'dl' is equal to 0[0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:770:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:785:12: [0m[0;1;36mnote: [0mPassing the value 66 via 1st parameter 'type'[0m
  785 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:785:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  785 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '66' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '69' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_builtin:'  at line 652[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:656:12: [0m[0;1;36mnote: [0mField 'opcode' is equal to Op_builtin[0m
  656 |                         if (pc->opcode == Op_builtin) {[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:656:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  656 |                         if (pc->opcode == Op_builtin) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:657:25: [0m[0;1;36mnote: [0mAssuming 'current_namespace' is equal to 'awk_namespace'[0m
  657 |                                 bool prepend_awk = (current_namespace != awk_namespace && strcmp(current_namespace, awk_namespace) != 0);[0m
      | [0;1;32m                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:657:60: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  657 |                                 bool prepend_awk = (current_namespace != awk_namespace && strcmp(current_namespace, awk_namespace) != 0);[0m
      | [0;1;32m                                                                                       ^
[0m[1mprofile.c:661:8: [0m[0;1;36mnote: [0mAssuming 'fname' is not equal to NULL[0m
  661 |                         if (fname != NULL) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~
[0m[1mprofile.c:661:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  661 |                         if (fname != NULL) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:662:9: [0m[0;1;36mnote: [0mAssuming field 'xl' is <= 0[0m
  662 |                                 if (pc->expr_count > 0) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:662:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  662 |                                 if (pc->expr_count > 0) {[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:668:13: [0m[0;1;36mnote: [0mPassing the value 69 via 1st parameter 'type'[0m
  668 |                                 pp_push(Op_builtin, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                        ^~~~~~~~~~
[0m[1mprofile.c:668:5: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  668 |                                 pp_push(Op_builtin, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '69' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '70' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_sub_builtin:'  at line 638[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:641:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  641 |                         if ((pc->sub_flags & GSUB) != 0)[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:641:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  641 |                         if ((pc->sub_flags & GSUB) != 0)[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:643:13: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  643 |                         else if ((pc->sub_flags & GENSUB) != 0)[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:643:9: [0m[0;1;36mnote: [0mTaking false branch[0m
  643 |                         else if ((pc->sub_flags & GENSUB) != 0)[0m
      | [0;1;32m                             ^
[0m[1mprofile.c:648:12: [0m[0;1;36mnote: [0mPassing the value 70 via 1st parameter 'type'[0m
  648 |                         pp_push(Op_sub_builtin, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~
[0m[1mprofile.c:648:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  648 |                         pp_push(Op_sub_builtin, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '70' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '72' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_in_array:'  at line 594[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:599:8: [0m[0;1;36mnote: [0mAssuming field 'xl' is <= 1[0m
  599 |                         if (pc->expr_count > 1) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:599:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  599 |                         if (pc->expr_count > 1) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:605:5: [0m[0;1;36mnote: [0mTaking true branch[0m
  605 |                                 if (prec_level(t2->type) < prec_level(Op_in_array)) {[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:613:12: [0m[0;1;36mnote: [0mPassing the value 72 via 1st parameter 'type'[0m
  613 |                         pp_push(Op_in_array, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~
[0m[1mprofile.c:613:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  613 |                         pp_push(Op_in_array, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '72' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '74' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_indirect_func_call:'  at line 788[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:796:12: [0m[0;1;36mnote: [0mField 'opcode' is equal to Op_indirect_func_call[0m
  796 |                         if (pc->opcode == Op_indirect_func_call)[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:796:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  796 |                         if (pc->opcode == Op_indirect_func_call)[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:801:8: [0m[0;1;36mnote: [0mAssuming 'pcount' is <= 0[0m
  801 |                         if (pcount > 0) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mprofile.c:801:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  801 |                         if (pcount > 0) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:807:12: [0m[0;1;36mnote: [0mField 'opcode' is equal to Op_indirect_func_call[0m
  807 |                         if (pc->opcode == Op_indirect_func_call) {[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:807:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  807 |                         if (pc->opcode == Op_indirect_func_call) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:812:12: [0m[0;1;36mnote: [0mPassing the value 74 via 1st parameter 'type'[0m
  812 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~
[0m[1mprofile.c:812:4: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  812 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is non-null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '74' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '77' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_push_arg_untyped:'  at line 350[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:352:4: [0m[0;1;36mnote: [0mControl jumps to 'case Node_param_list:'  at line 353[0m
  352 |                         switch (m->type) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:354:13: [0m[0;1;36mnote: [0mPassing the value 77 via 1st parameter 'type'[0m
  354 |                                 pp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                        ^~~~~~~~~~
[0m[1mprofile.c:354:5: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  354 |                                 pp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '77' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:177:12: [0m[0;1;35mwarning: [0m[1mThe value '78' provided to the cast expression is not in the valid range of values for 'nodevals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:241:14: [0m[0;1;36mnote: [0menum declared here[0m
  241 | typedef enum nodevals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  242 |         /* illegal entry == 0 */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~
[0m  243 |         Node_illegal,[0m
      | [0;1;32m        ~~~~~~~~~~~~~
[0m  244 | [0m
  245 |         Node_val,               /* node is a value - type in flags */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  246 |         Node_regex,             /* a regexp, text, compiled, flags, etc */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  247 |         Node_dynregex,          /* a dynamic regexp */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  248 | [0m
  249 |         /* symbol table values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  250 |         Node_var,               /* scalar variable, lnode is value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  251 |         Node_var_array,         /* array is ptr to elements, table_size num of eles */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  252 |         Node_var_new,           /* newly created variable, may become an array */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  253 |         Node_elem_new,          /* newly created array element, may become a subarray */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  254 |         Node_param_list,        /* lnode is a variable, rnode is more list */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  255 |         Node_func,              /* lnode is param. list, rnode is body */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  256 |         Node_ext_func,          /* extension function, code_ptr is builtin code */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_push_i:'  at line 322[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:324:8: [0m[0;1;36mnote: [0mAssuming 'm' is equal to 'Nnull_string'[0m
  324 |                         if (m == Nnull_string)  /* optional return or exit value; don't print 0 or "" */[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~
[0m[1mprofile.c:324:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  324 |                         if (m == Nnull_string)  /* optional return or exit value; don't print 0 or "" */[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:325:13: [0m[0;1;36mnote: [0mPassing the value 78 via 1st parameter 'type'[0m
  325 |                                 pp_push(pc->opcode, m->stptr, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                        ^~~~~~~~~~
[0m[1mprofile.c:325:5: [0m[0;1;36mnote: [0mCalling 'pp_push'[0m
  325 |                                 pp_push(pc->opcode, m->stptr, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:173:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  173 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mprofile.c:173:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  173 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mprofile.c:177:12: [0m[0;1;36mnote: [0mThe value '78' provided to the cast expression is not in the valid range of values for 'nodevals'[0m
  177 |         n->type = (NODETYPE) type;[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~
[0m[1mprofile.c:203:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  203 |         if ((n->flags & CAN_FREE) != 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  204 |                 efree(n->pp_str);[0m
      | [0;1;32m                                 
[0m[1mprofile.c:226:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  227 |                         sourceline = pc->source_line;[0m
      | [0;1;32m                                                     
[0m[1mprofile.c:254:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  254 |                         source = pc->source_file;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:263:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  263 |                                     && pc->nexti->memory->comment_type == BLOCK_COMMENT)[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m  264 |                                         print_comment(pc->nexti, -1);[0m
      | [0;1;32m                                                                     
[0m[1mprofile.c:269:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  269 |                                         if (! rule_count[rule]++)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  270 |                                                 fprintf(prof_fp, _("\t# %s rule(s)\n\n"), ruletab[rule]);[0m
      | [0;1;32m                                                                                                         
[0m[1mprofile.c:270:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  270 |                                                 fprintf(prof_fp, _("\t# %s rule(s)\n\n"), ruletab[rule]);[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:270:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  270 |                                                 fprintf(prof_fp, _("\t# %s rule(s)\n\n"), ruletab[rule]);[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:273:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  273 |                                 fprintf(prof_fp, "%s {", ruletab[rule]);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:273:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  273 |                                 fprintf(prof_fp, "%s {", ruletab[rule]);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:277:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  277 |                                 if (do_profile && ! rule_count[rule]++)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  278 |                                         fprintf(prof_fp, _("\t# Rule(s)\n\n"));[0m
      | [0;1;32m                                                                               
[0m[1mprofile.c:278:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  278 |                                         fprintf(prof_fp, _("\t# Rule(s)\n\n"));[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:278:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  278 |                                         fprintf(prof_fp, _("\t# Rule(s)\n\n"));[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:287:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  287 |                                                 fprintf(prof_fp, "%s {", t1->pp_str);[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:287:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  287 |                                                 fprintf(prof_fp, "%s {", t1->pp_str);[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:289:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  289 |                                         } else[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  290 |                                                 fprintf(prof_fp, "{");[0m
      | [0;1;32m                                                                      
[0m[1mprofile.c:290:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  290 |                                                 fprintf(prof_fp, "{");[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:290:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  290 |                                                 fprintf(prof_fp, "{");[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:294:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  294 |                                         if (do_profile && ip1->exec_count > 0)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  295 |                                                 fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);[0m
      | [0;1;32m                                                                                                        
[0m[1mprofile.c:295:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  295 |                                                 fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:295:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  295 |                                                 fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mprofile.c:300:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  300 |                                         fprintf(prof_fp, "{\n");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:300:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  300 |                                         fprintf(prof_fp, "{\n");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:309:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  309 |                         if (do_profile)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  310 |                                 indent(0);[0m
      | [0;1;32m                                          
[0m[1mprofile.c:311:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  311 |                         fprintf(prof_fp, "}\n\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:311:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  311 |                         fprintf(prof_fp, "}\n\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:316:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  316 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mprofile.c:319:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  319 |                         memset(rule_count, 0, MAXRULE * sizeof(int));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:319:4: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  319 |                         memset(rule_count, 0, MAXRULE * sizeof(int));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:319:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  319 |                         memset(rule_count, 0, MAXRULE * sizeof(int));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  320 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:323:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  323 |                         m = pc->memory;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  324 |                         if (m == Nnull_string)  /* optional return or exit value; don't print 0 or "" */[0m
  325 |                                 pp_push(pc->opcode, m->stptr, DONT_FREE, pc->comment);[0m
  326 |                         else if ((m->flags & NUMBER) != 0)[0m
  327 |                                 pp_push(pc->opcode, pp_number(m), CAN_FREE, pc->comment);[0m
  328 |                         else {[0m
  329 |                                 str = pp_string(m->stptr, m->stlen, '"');[0m
  330 |                                 if ((m->flags & INTLSTR) != 0) {[0m
  331 |                                         char *tmp = str;[0m
  332 |                                         str = pp_group3("_", tmp, "");[0m
  333 |                                         efree(tmp);[0m
  334 |                                 }[0m
  335 |                                 pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  336 |                         }[0m
  337 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:324:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  324 |                         if (m == Nnull_string)  /* optional return or exit value; don't print 0 or "" */[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  325 |                                 pp_push(pc->opcode, m->stptr, DONT_FREE, pc->comment);[0m
  326 |                         else if ((m->flags & NUMBER) != 0)[0m
      | [0;32m                        } 
[0m[1mprofile.c:326:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  326 |                         else if ((m->flags & NUMBER) != 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  327 |                                 pp_push(pc->opcode, pp_number(m), CAN_FREE, pc->comment);[0m
  328 |                         else {[0m
      | [0;32m                        } 
[0m[1mprofile.c:340:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  340 |                         if (pc->initval != NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  341 |                                 pp_push(Op_push_i, pp_node(pc->initval), CAN_FREE, pc->comment);[0m
      | [0;1;32m                                                                                               
[0m      | [0;32m                                                                                               ;} 
[0m[1mprofile.c:340:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  340 |                         if (pc->initval != NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  341 |                                 pp_push(Op_push_i, pp_node(pc->initval), CAN_FREE, pc->comment);[0m
      | [0;1;32m                                                                                                
[0m[1mprofile.c:352:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  352 |                         switch (m->type) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:354:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  354 |                                 pp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE, pc->comment);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  355 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mprofile.c:365:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  365 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  366 |                                         fatal(_("internal error: %s with null vname"),[0m
  367 |                                                         nodetype2str(m->type));[0m
      | [0;1;32m                                                                               
[0m[1mprofile.c:368:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  368 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1mprofile.c:371:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  371 |                                 cant_happen("got unexpected type %s", nodetype2str(m->type));[0m
      | [0;1;32m                                ^                                                           
[0m      | [0;32m                                {                                                           ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mprofile.c:376:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  376 |                                 t2 = pp_pop(); /* l.h.s. */[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  377 |                                 t1 = pp_pop(); /* r.h.s. */[0m
  378 |                                 fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(pc->opcode), t1->pp_str);[0m
  379 |                                 goto cleanup;[0m
      | [0;1;32m                                            
[0m      | [0;32m                                            ;} 
[0m[1mprofile.c:378:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  378 |                                 fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(pc->opcode), t1->pp_str);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:378:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  378 |                                 fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(pc->opcode), t1->pp_str);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:382:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  382 |                                 t1 = pp_pop();  /* array */[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  383 |                                 tmp = pp_list(pc->expr_count, op2str(Op_subscript), ", "); /*subscript*/[0m
  384 |                                 t2 = pp_pop(); /* r.h.s. */[0m
  385 |                                 fprintf(prof_fp, "%s%s%s%s", t1->pp_str, tmp,[0m
  386 |                                                                         op2str(pc->opcode), t2->pp_str);[0m
  387 |                                 efree(tmp);[0m
  388 |                                 goto cleanup;[0m
      | [0;1;32m                                            
[0m      | [0;32m                                            ;} 
[0m[1mprofile.c:385:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  385 |                                 fprintf(prof_fp, "%s%s%s%s", t1->pp_str, tmp,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:385:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  385 |                                 fprintf(prof_fp, "%s%s%s%s", t1->pp_str, tmp,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:391:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  391 |                                 t2 = pp_pop(); /* l.h.s. */[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  392 |                                 t1 = pp_pop();[0m
  393 |                                 tmp = pp_group3(t2->pp_str, op2str(Op_concat), t1->pp_str);[0m
  394 |                                 fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(Op_assign), tmp);[0m
  395 |                                 efree(tmp);[0m
  396 | cleanup:[0m
  397 |                                 pp_free(t2);[0m
  398 |                                 pp_free(t1);[0m
  399 |                                 if ((flags & IN_FOR_HEADER) == 0)[0m
  400 |                                         pc = end_line(pc);[0m
  401 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mprofile.c:394:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  394 |                                 fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(Op_assign), tmp);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:394:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  394 |                                 fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(Op_assign), tmp);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:399:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  399 |                                 if ((flags & IN_FOR_HEADER) == 0)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  400 |                                         pc = end_line(pc);[0m
      | [0;1;32m                                                          
[0m[1mprofile.c:404:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  404 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1mprofile.c:412:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  412 |                         t1 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  413 |                         str = pp_group3(t1->pp_str, tmp, "");[0m
  414 |                         efree(tmp);[0m
  415 |                         pp_free(t1);[0m
  416 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  417 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:422:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  422 |                         t2 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:425:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  425 |                         if (pc->comment == NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  426 |                                 str = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);[0m
  427 |                         else {[0m
      | [0;32m                        } 
[0m[1mprofile.c:436:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  436 |                                 sprintf(str, "%s%s%s%.*s %s", t1->pp_str, op2str(pc->opcode),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:436:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  436 |                                 sprintf(str, "%s%s%s%.*s %s", t1->pp_str, op2str(pc->opcode),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:453:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  453 |                         t1 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  454 |                         if (prec_level(pc->opcode) > prec_level(t1->type)[0m
  455 |                                         && is_binary(t1->type))  /* (a - b) * 1 */[0m
  456 |                                 pp_parenthesize(t1);[0m
  457 |                         if ((m->flags & NUMBER) != 0)[0m
  458 |                                 tmp = pp_number(m);[0m
  459 |                         else[0m
  460 |                                 tmp = pp_string(m->stptr, m->stlen, '"');[0m
  461 |                         str = pp_group3(t1->pp_str, op2str(pc->opcode), tmp);[0m
  462 |                         efree(tmp);[0m
  463 |                         pp_free(t1);[0m
  464 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  465 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:455:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  455 |                                         && is_binary(t1->type))  /* (a - b) * 1 */[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  456 |                                 pp_parenthesize(t1);[0m
      | [0;1;32m                                                    
[0m[1mprofile.c:457:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  457 |                         if ((m->flags & NUMBER) != 0)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  458 |                                 tmp = pp_number(m);[0m
  459 |                         else[0m
      | [0;32m                        } 
[0m[1mprofile.c:459:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  459 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  460 |                                 tmp = pp_string(m->stptr, m->stlen, '"');[0m
      | [0;1;32m                                                                         
[0m[1mprofile.c:468:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  468 |                         t1 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  469 |                         str = pp_group3("(", t1->pp_str, ")");[0m
  470 |                         pp_free(t1);[0m
  471 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  472 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:487:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  487 |                         t1 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  488 |                         parenthesize(pc->opcode, t1, t2);[0m
  489 |                         str = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);[0m
  490 |                         pp_free(t1);[0m
  491 |                         pp_free(t2);[0m
  492 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  493 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:500:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  500 |                         if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  501 |                                 str = pp_group3(op2str(pc->opcode), t1->pp_str, "");[0m
  502 |                         else[0m
  503 |                                 str = pp_group3(t1->pp_str, op2str(pc->opcode), "");[0m
  504 |                         pp_free(t1);[0m
  505 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  506 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:500:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  500 |                         if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)[0m
      | [0;1;32m                                                                                           ^
[0m      | [0;32m                                                                                            {
[0m  501 |                                 str = pp_group3(op2str(pc->opcode), t1->pp_str, "");[0m
  502 |                         else[0m
      | [0;32m                        } 
[0m[1mprofile.c:502:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  502 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  503 |                                 str = pp_group3(t1->pp_str, op2str(pc->opcode), "");[0m
      | [0;1;32m                                                                                    
[0m[1mprofile.c:514:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  514 |                         if (is_binary(t1->type)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  515 |                             || (((OPCODE) t1->type) == pc->opcode[0m
  516 |                                     && (pc->opcode == Op_unary_minus[0m
  517 |                                             || pc->opcode == Op_unary_plus)))[0m
  518 |                                 pp_parenthesize(t1);[0m
  519 | [0m
  520 |                         /* optypes table (eval.c) includes space after ! */[0m
  521 |                         str = pp_group3(op2str(pc->opcode), t1->pp_str, "");[0m
  522 |                         pp_free(t1);[0m
  523 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  524 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:517:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  517 |                                             || pc->opcode == Op_unary_plus)))[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m  518 |                                 pp_parenthesize(t1);[0m
      | [0;1;32m                                                    
[0m[1mprofile.c:534:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  534 |                         t1 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  535 |                         str = pp_group3(t2->pp_str, op2str(pc->opcode), t1->pp_str);[0m
  536 |                         pp_free(t2);[0m
  537 |                         pp_free(t1);[0m
  538 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  539 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:547:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  547 |                         if (is_binary(t1->type))[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  548 |                                 pp_parenthesize(t1);[0m
      | [0;1;32m                                                    
[0m[1mprofile.c:555:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  555 |                         if (pc->opcode == Op_store_field_exp)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  556 |                                 pp_push(pc->opcode, final, CAN_FREE, NULL);[0m
  557 |                         else {[0m
      | [0;32m                        } 
[0m[1mprofile.c:558:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  558 |                                 fprintf(prof_fp, "%s", final);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:558:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  558 |                                 fprintf(prof_fp, "%s", final);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:560:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  560 |                                 if ((flags & IN_FOR_HEADER) == 0)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  561 |                                         pc = end_line(pc);[0m
      | [0;1;32m                                                          
[0m[1mprofile.c:564:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  564 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mprofile.c:567:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  567 |                         str = pp_concat(pc->expr_count);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  568 |                         pp_push(Op_concat, str, CAN_FREE, pc->comment);[0m
  569 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:572:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  572 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  573 |                         char *array;[0m
  574 |                         t1 = pp_pop();[0m
  575 |                         array = t1->pp_str;[0m
  576 |                         if (pc->expr_count > 0) {[0m
  577 |                                 char *sub;[0m
  578 |                                 sub = pp_list(pc->expr_count, NULL, pc->expr_count > 1 ? "][" : ", ");[0m
  579 |                                 fprintf(prof_fp, "%s %s[%s]", op2str(Op_K_delete), array, sub);[0m
  580 |                                 efree(sub);[0m
  581 |                         } else[0m
  582 |                                 fprintf(prof_fp, "%s %s", op2str(Op_K_delete), array);[0m
  583 |                         if ((flags & IN_FOR_HEADER) == 0)[0m
  584 |                                 pc = end_line(pc);[0m
  585 |                         pp_free(t1);[0m
  586 |                 }[0m
  587 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:579:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  579 |                                 fprintf(prof_fp, "%s %s[%s]", op2str(Op_K_delete), array, sub);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:579:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  579 |                                 fprintf(prof_fp, "%s %s[%s]", op2str(Op_K_delete), array, sub);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:581:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  581 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  582 |                                 fprintf(prof_fp, "%s %s", op2str(Op_K_delete), array);[0m
      | [0;1;32m                                                                                      
[0m[1mprofile.c:582:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  582 |                                 fprintf(prof_fp, "%s %s", op2str(Op_K_delete), array);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:582:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  582 |                                 fprintf(prof_fp, "%s %s", op2str(Op_K_delete), array);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:583:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  583 |                         if ((flags & IN_FOR_HEADER) == 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  584 |                                 pc = end_line(pc);[0m
      | [0;1;32m                                                  
[0m[1mprofile.c:591:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  591 |                         cant_happen("unexpected opcode %s", opcode2str(pc->opcode));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  592 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mprofile.c:595:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  595 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mprofile.c:639:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  639 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  640 |                         const char *fname = "sub";[0m
  641 |                         if ((pc->sub_flags & GSUB) != 0)[0m
  642 |                                 fname = "gsub";[0m
  643 |                         else if ((pc->sub_flags & GENSUB) != 0)[0m
  644 |                                 fname = "gensub";[0m
  645 |                         tmp = pp_list(pc->expr_count, "()", ", ");[0m
  646 |                         str = pp_group3(fname, tmp, "");[0m
  647 |                         efree(tmp);[0m
  648 |                         pp_push(Op_sub_builtin, str, CAN_FREE, pc->comment);[0m
  649 |                 }[0m
  650 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:641:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  641 |                         if ((pc->sub_flags & GSUB) != 0)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  642 |                                 fname = "gsub";[0m
  643 |                         else if ((pc->sub_flags & GENSUB) != 0)[0m
      | [0;32m                        } 
[0m[1mprofile.c:643:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  643 |                         else if ((pc->sub_flags & GENSUB) != 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  644 |                                 fname = "gensub";[0m
      | [0;1;32m                                                 
[0m[1mprofile.c:659:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  659 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  660 |                                 fname = (pc + 1)->func_name;[0m
      | [0;1;32m                                                            
[0m[1mprofile.c:666:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  666 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  667 |                                         str = pp_group3(fname, "()", "");[0m
      | [0;1;32m                                                                         
[0m[1mprofile.c:669:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  669 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  670 |                                 fatal(_("internal error: builtin with null fname"));[0m
      | [0;1;32m                                                                                    
[0m[1mprofile.c:672:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  672 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mprofile.c:677:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  677 |                         if (pc->opcode == Op_K_print_rec)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  678 |                                 // instead of `print $0', just `print'[0m
  679 |                                 tmp = estrdup("", 0);[0m
  680 |                         else if (pc->redir_type != 0) {[0m
      | [0;32m                        } 
[0m[1mprofile.c:691:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  691 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  692 |                                         tmp = pp_list(pc->expr_count, "()", ", ");[0m
      | [0;1;32m                                                                                  
[0m[1mprofile.c:698:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  698 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  699 |                                 t1 = pp_pop();[0m
  700 |                                 if (is_binary(t1->type))[0m
  701 |                                         pp_parenthesize(t1);[0m
  702 |                                 fprintf(prof_fp, "%s%s%s%s", op2str(pc->opcode),[0m
  703 |                                                         tmp, redir2str(pc->redir_type), t1->pp_str);[0m
  704 |                                 pp_free(t1);[0m
  705 |                         } else[0m
  706 |                                 fprintf(prof_fp, "%s%s", op2str(pc->opcode), tmp);[0m
  707 |                         efree(tmp);[0m
  708 |                         if ((flags & IN_FOR_HEADER) == 0)[0m
  709 |                                 pc = end_line(pc);[0m
  710 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:700:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  700 |                                 if (is_binary(t1->type))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  701 |                                         pp_parenthesize(t1);[0m
      | [0;1;32m                                                            
[0m[1mprofile.c:702:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  702 |                                 fprintf(prof_fp, "%s%s%s%s", op2str(pc->opcode),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:702:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  702 |                                 fprintf(prof_fp, "%s%s%s%s", op2str(pc->opcode),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:705:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  705 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  706 |                                 fprintf(prof_fp, "%s%s", op2str(pc->opcode), tmp);[0m
      | [0;1;32m                                                                                  
[0m[1mprofile.c:706:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  706 |                                 fprintf(prof_fp, "%s%s", op2str(pc->opcode), tmp);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:706:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  706 |                                 fprintf(prof_fp, "%s%s", op2str(pc->opcode), tmp);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:708:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  708 |                         if ((flags & IN_FOR_HEADER) == 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  709 |                                 pc = end_line(pc);[0m
      | [0;1;32m                                                  
[0m[1mprofile.c:713:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  713 |                         if (pc->memory->type != Node_regex && (pc->memory->flags & REGEX) == 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  714 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mprofile.c:713:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  713 |                         if (pc->memory->type != Node_regex && (pc->memory->flags & REGEX) == 0)[0m
      | [0;1;32m                                                                                               ^
[0m      | [0;32m                                                                                                {
[0m  714 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mprofile.c:717:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  717 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  718 |                         if (pc->memory->type == Node_regex) {[0m
  719 |                                 NODE *re = pc->memory->re_exp;[0m
  720 |                                 str = pp_string(re->stptr, re->stlen, '/');[0m
  721 |                         } else {[0m
  722 |                                 assert((pc->memory->flags & REGEX) != 0);[0m
  723 |                                 str = pp_typed_regex(pc->memory->stptr, pc->memory->stlen, '/');[0m
  724 |                         }[0m
  725 |                         pp_push(pc->opcode, str, CAN_FREE, pc->comment);[0m
  726 |                 }[0m
  727 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:734:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  734 |                         if (is_binary(t1->type))[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  735 |                                 pp_parenthesize(t1);[0m
      | [0;1;32m                                                    
[0m[1mprofile.c:741:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  741 |                                 if (is_binary(t2->type))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  742 |                                         pp_parenthesize(t2);[0m
      | [0;1;32m                                                            
[0m[1mprofile.c:759:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  759 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mprofile.c:767:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  767 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  768 |                                 tmp = pp_group3(op2str(Op_K_getline), "", "");[0m
      | [0;1;32m                                                                              
[0m[1mprofile.c:770:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:775:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  775 |                                 if (is_binary(t2->type))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  776 |                                         pp_parenthesize(t2);[0m
      | [0;1;32m                                                            
[0m[1mprofile.c:777:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  777 |                                 if (before)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  778 |                                         str = pp_group3(t2->pp_str, redir2str(pc->redir_type), tmp);[0m
  779 |                                 else[0m
      | [0;32m                                } 
[0m[1mprofile.c:779:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  779 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  780 |                                         str = pp_group3(tmp, redir2str(pc->redir_type), t2->pp_str);[0m
      | [0;1;32m                                                                                                    
[0m[1mprofile.c:783:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  783 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  784 |                                 str = tmp;[0m
      | [0;1;32m                                          
[0m[1mprofile.c:796:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  796 |                         if (pc->opcode == Op_indirect_func_call)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  797 |                                 pre = "@";[0m
  798 |                         else[0m
      | [0;32m                        } 
[0m[1mprofile.c:798:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  798 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  799 |                                 pre = "";[0m
      | [0;1;32m                                         
[0m[1mprofile.c:805:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  805 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  806 |                                 str = pp_group3(pre, fname, "()");[0m
      | [0;1;32m                                                                  
[0m[1mprofile.c:813:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  813 |                         if (malloced)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  814 |                                 efree((void *) fname);[0m
      | [0;1;32m                                                      
[0m[1mprofile.c:816:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  816 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mprofile.c:822:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  822 |                         fprintf(prof_fp, "%s", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:822:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  822 |                         fprintf(prof_fp, "%s", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:823:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  823 |                         pc = end_line(pc);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  824 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:829:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  829 |                         if (is_binary(t1->type))[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  830 |                                 pp_parenthesize(t1);[0m
  831 |                         if (pc->source_line > 0) {      /* don't print implicit 'return' at end of function */[0m
  832 |                                 // avoid final trailing space to keep whiny users happy[0m
  833 |                                 if (t1->pp_str[0] != '\0')[0m
  834 |                                         fprintf(prof_fp, "%s %s", op2str(pc->opcode), t1->pp_str);[0m
  835 |                                 else[0m
  836 |                                         fprintf(prof_fp, "%s", op2str(pc->opcode));[0m
  837 |                                 pc = end_line(pc);[0m
  838 |                         }[0m
  839 |                         pp_free(t1);[0m
  840 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:829:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  829 |                         if (is_binary(t1->type))[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  830 |                                 pp_parenthesize(t1);[0m
      | [0;1;32m                                                    
[0m[1mprofile.c:833:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  833 |                                 if (t1->pp_str[0] != '\0')[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  834 |                                         fprintf(prof_fp, "%s %s", op2str(pc->opcode), t1->pp_str);[0m
  835 |                                 else[0m
      | [0;32m                                } 
[0m[1mprofile.c:834:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  834 |                                         fprintf(prof_fp, "%s %s", op2str(pc->opcode), t1->pp_str);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:834:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  834 |                                         fprintf(prof_fp, "%s %s", op2str(pc->opcode), t1->pp_str);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:835:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  835 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  836 |                                         fprintf(prof_fp, "%s", op2str(pc->opcode));[0m
      | [0;1;32m                                                                                   
[0m[1mprofile.c:836:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  836 |                                         fprintf(prof_fp, "%s", op2str(pc->opcode));[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:836:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  836 |                                         fprintf(prof_fp, "%s", op2str(pc->opcode));[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:843:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  843 |                         t1 = pp_pop();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  844 |                         fprintf(prof_fp, "%s", t1->pp_str);[0m
  845 |                         if ((flags & IN_FOR_HEADER) == 0)[0m
  846 |                                 pc = end_line(pc);[0m
  847 |                         pp_free(t1);[0m
  848 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:844:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  844 |                         fprintf(prof_fp, "%s", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:844:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  844 |                         fprintf(prof_fp, "%s", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:845:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  845 |                         if ((flags & IN_FOR_HEADER) == 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  846 |                                 pc = end_line(pc);[0m
      | [0;1;32m                                                  
[0m[1mprofile.c:851:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  851 |                         ip1 = pc + 1;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  852 |                         pprint(pc->nexti, ip1->condpair_left, NO_PPRINT_FLAGS);[0m
  853 |                         pprint(ip1->condpair_left->nexti, ip1->condpair_right, NO_PPRINT_FLAGS);[0m
  854 |                         t2 = pp_pop();[0m
  855 |                         t1 = pp_pop();[0m
  856 |                         str = pp_group3(t1->pp_str, ", ", t2->pp_str);[0m
  857 |                         pp_free(t1);[0m
  858 |                         pp_free(t2);[0m
  859 |                         pp_push(Op_line_range, str, CAN_FREE, pc->comment);[0m
  860 |                         pc = ip1->condpair_right;[0m
  861 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:864:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  864 |                         ip1 = pc + 1;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  865 |                         indent(ip1->while_body->exec_count);[0m
  866 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
  867 |                         pprint(pc->nexti, ip1->while_body, NO_PPRINT_FLAGS);[0m
  868 |                         t1 = pp_pop();[0m
  869 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
  870 |                         pp_free(t1);[0m
  871 |                         ip1->while_body = end_line(ip1->while_body);[0m
  872 |                         indent_in();[0m
  873 |                         pprint(ip1->while_body->nexti, pc->target_break, NO_PPRINT_FLAGS);[0m
  874 |                         indent_out();[0m
  875 |                         indent(SPACEOVER);[0m
  876 |                         fprintf(prof_fp, "}");[0m
  877 |                         pc = end_line(pc->target_break);[0m
  878 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:866:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  866 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:866:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  866 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:869:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  869 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:869:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  869 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:876:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  876 |                         fprintf(prof_fp, "}");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:876:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  876 |                         fprintf(prof_fp, "}");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:881:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  881 |                         ip1 = pc + 1;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:883:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  883 |                         fprintf(prof_fp, "%s {", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:883:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  883 |                         fprintf(prof_fp, "%s {", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:892:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  892 |                         fprintf(prof_fp, "} %s (%s)", op2str(Op_K_while), t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:892:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  892 |                         fprintf(prof_fp, "} %s (%s)", op2str(Op_K_while), t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:893:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  893 |                         if (pc->comment)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  894 |                                 fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);[0m
  895 |                         else {[0m
      | [0;32m                        } 
[0m[1mprofile.c:894:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  894 |                                 fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:894:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  894 |                                 fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:904:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  904 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mprofile.c:923:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  923 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:923:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  923 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:930:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  930 |                                 fprintf(prof_fp, ";;");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:930:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  930 |                                 fprintf(prof_fp, ";;");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:933:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  933 |                                 fprintf(prof_fp, "; ");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:933:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  933 |                                 fprintf(prof_fp, "; ");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:942:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  942 |                                                 ip1->forloop_cond->nexti == ip1->forloop_body)[0m
      | [0;1;32m                                                                                              ^
[0m      | [0;32m                                                                                               {
[0m  943 |                                         fprintf(prof_fp, "; ");[0m
  944 |                                 else {[0m
      | [0;32m                                } 
[0m[1mprofile.c:943:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  943 |                                         fprintf(prof_fp, "; ");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:943:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  943 |                                         fprintf(prof_fp, "; ");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:947:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  947 |                                         fprintf(prof_fp, "%s; ", t1->pp_str);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:947:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  947 |                                         fprintf(prof_fp, "%s; ", t1->pp_str);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:959:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  959 |                         fprintf(prof_fp, ") {");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:959:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  959 |                         fprintf(prof_fp, ") {");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:966:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  966 |                         fprintf(prof_fp, "}");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:966:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  966 |                         fprintf(prof_fp, "}");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:974:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  974 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mprofile.c:982:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  982 |                         if (m->type == Node_param_list)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  983 |                                 item = func_params[m->param_cnt].param;[0m
  984 |                         else[0m
      | [0;32m                        } 
[0m[1mprofile.c:984:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  984 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  985 |                                 item = m->vname;[0m
      | [0;1;32m                                                
[0m[1mprofile.c:987:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  987 |                         fprintf(prof_fp, "%s (%s%s%s) {", op2str(Op_K_arrayfor),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:987:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  987 |                         fprintf(prof_fp, "%s (%s%s%s) {", op2str(Op_K_arrayfor),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:996:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  996 |                         fprintf(prof_fp, "}");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:996:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  996 |                         fprintf(prof_fp, "}");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1004:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1004 |                         ip1 = pc + 1;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:1005:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1005 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1005:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1005 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1008:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1008 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1008:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1008 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1009:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1009 |                         if (pc->comment)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1010 |                                 print_comment(pc->comment, 0);[0m
 1011 |                         else[0m
      | [0;32m                        } 
[0m[1mprofile.c:1011:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1011 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1012 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                                       
[0m[1mprofile.c:1012:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1012 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1012:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1012 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1016:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1016 |                         fprintf(prof_fp, "}\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1016:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1016 |                         fprintf(prof_fp, "}\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1017:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1017 |                         if (ip1->switch_end->comment)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1018 |                                 print_comment(ip1->switch_end->comment, 0);[0m
      | [0;1;32m                                                                           
[0m[1mprofile.c:1025:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1025 |                         if (pc->opcode == Op_K_case) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:1027:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1027 |                                 fprintf(prof_fp, "%s %s:", op2str(pc->opcode), t1->pp_str);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1027:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1027 |                                 fprintf(prof_fp, "%s %s:", op2str(pc->opcode), t1->pp_str);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1029:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1029 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1030 |                                 fprintf(prof_fp, "%s:", op2str(pc->opcode));[0m
      | [0;1;32m                                                                            
[0m[1mprofile.c:1030:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1030 |                                 fprintf(prof_fp, "%s:", op2str(pc->opcode));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1030:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1030 |                                 fprintf(prof_fp, "%s:", op2str(pc->opcode));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1035:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1035 |                                         fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:1035:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1035 |                                         fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:1036:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1036 |                                         if (pc->comment->comment != NULL)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 1037 |                                                 print_comment(pc->comment->comment, indent_level);[0m
      | [0;1;32m                                                                                                  
[0m[1mprofile.c:1039:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1039 |                                         fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:1039:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1039 |                                         fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:1042:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1042 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1043 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                                       
[0m[1mprofile.c:1043:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1043 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1043:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1043 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1049:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1049 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1049:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1049 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1049:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1049 |                         fprintf(prof_fp, "%s (", op2str(pc->opcode));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:1052:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1052 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1052:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1052 |                         fprintf(prof_fp, "%s) {", t1->pp_str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1056:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1056 |                         if (ip1->exec_count > 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1057 |                                 fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);[0m
      | [0;1;32m                                                                                        
[0m[1mprofile.c:1057:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1057 |                                 fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1057:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1057 |                                 fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1060:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1060 |                         if (pc->comment != NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1061 |                                 print_comment(pc->comment, indent_level);[0m
      | [0;1;32m                                                                         
[0m[1mprofile.c:1067:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1067 |                                 fprintf(prof_fp, "}");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1067:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1067 |                                 fprintf(prof_fp, "}");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1069:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1069 |                                     || pc->nexti->nexti->memory->comment_type == BLOCK_COMMENT)[0m
      | [0;1;32m                                                                                               ^
[0m      | [0;32m                                                                                                {
[0m 1070 |                                         fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                                               
[0m[1mprofile.c:1070:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1070 |                                         fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:1070:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1070 |                                         fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mprofile.c:1096:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1096 |                         fprintf(prof_fp, "} %s ", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1096:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1096 |                         fprintf(prof_fp, "} %s ", op2str(pc->opcode));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1096:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1096 |                         fprintf(prof_fp, "} %s ", op2str(pc->opcode));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mprofile.c:1101:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1101 |                                 fprintf(prof_fp, "{");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1101:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1101 |                                 fprintf(prof_fp, "{");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1105:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1105 |                                 if (pc->comment != NULL)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1106 |                                         print_comment(pc->comment, indent_level);[0m
      | [0;1;32m                                                                                 
[0m[1mprofile.c:1110:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1110 |                                 fprintf(prof_fp, "}");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1110:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1110 |                                 fprintf(prof_fp, "}");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1123:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1123 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mprofile.c:1156:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1156 |                                 sprintf(str, "%s ? %s : %s", cond->pp_str, t->pp_str, f->pp_str);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1156:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1156 |                                 sprintf(str, "%s ? %s : %s", cond->pp_str, t->pp_str, f->pp_str);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1164:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1164 |                                 sprintf(str,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1164:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1164 |                                 sprintf(str,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1183:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1183 |                                 sprintf(str,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1183:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1183 |                                 sprintf(str,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1199:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1199 |                                 sprintf(str,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1199:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1199 |                                 sprintf(str,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1220:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1220 |                         if (flags == NO_PPRINT_FLAGS)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1221 |                                 indent(pc->exec_count);[0m
 1222 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:1220:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1220 |                         if (flags == NO_PPRINT_FLAGS)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1221 |                                 indent(pc->exec_count);[0m
      | [0;1;32m                                                       
[0m[1mprofile.c:1225:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1225 |                         print_comment(pc, 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1226 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mprofile.c:1229:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1229 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mprofile.c:1232:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1232 |                         cant_happen("unexpected opcode %s", opcode2str(pc->opcode));[0m
      | [0;1;32m                        ^                                                          
[0m      | [0;32m                        {                                                          ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mprofile.c:1235:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1235 |                 if (pc == endp)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1236 |                         break;[0m
      | [0;1;32m                              
[0m[1mprofile.c:1249:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1249 |                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1249:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1249 |                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1253:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1253 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1254 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                       
[0m[1mprofile.c:1254:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1254 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1254:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1254 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1321:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1321 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1322 |                 indent = "\t";[0m
      | [0;1;32m                              
[0m[1mprofile.c:1328:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1328 |                                 fprintf(prof_fp, _("%s# Loaded extensions (-l and/or @load)\n\n"), indent);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1328:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1328 |                                 fprintf(prof_fp, _("%s# Loaded extensions (-l and/or @load)\n\n"), indent);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1331:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1331 |                         fprintf(prof_fp, "%s@load \"%s\"", indent, s->src);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1331:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1331 |                         fprintf(prof_fp, "%s@load \"%s\"", indent, s->src);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1333:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1333 |                                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1333:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1333 |                                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1335:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1335 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1336 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                                       
[0m[1mprofile.c:1336:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1336 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1336:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1336 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1339:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1339 |         if (found)      /* we found some */[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1340 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                       
[0m[1mprofile.c:1340:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1340 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1340:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1340 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1352:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1352 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1353 |                 return;[0m
      | [0;1;32m                       
[0m[1mprofile.c:1359:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1359 |                                 fprintf(prof_fp, _("\n# Included files (-i and/or @include)\n\n"));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1359:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1359 |                                 fprintf(prof_fp, _("\n# Included files (-i and/or @include)\n\n"));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1362:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1362 |                         fprintf(prof_fp, "# @include \"%s\"", s->src);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1362:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1362 |                         fprintf(prof_fp, "# @include \"%s\"", s->src);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1364:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1364 |                                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1364:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1364 |                                 fprintf(prof_fp, "\t");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1366:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1366 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1367 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                                       
[0m[1mprofile.c:1367:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1367 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1367:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1367 |                                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mprofile.c:1370:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1370 |         if (found)      /* we found some */[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1371 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                                       
[0m[1mprofile.c:1371:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1371 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1371:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1371 |                 fprintf(prof_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1386:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1386 |         if (in >= 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1387 |                 indent(in);    /* is this correct? Where should comments go?  */[0m
      | [0;1;32m                                                                                
[0m[1mprofile.c:1391:4: [0m[0;1;35mwarning: [0m[1mValue stored to 'after_newline' is never read [clang-analyzer-deadcode.DeadStores][0m
 1391 |                         after_newline = false;[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:1391:4: [0m[0;1;36mnote: [0mValue stored to 'after_newline' is never read[0m
[1mprofile.c:1402:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1402 |                 if (pc->memory->comment_type == EOL_COMMENT)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1403 |                         in++;[0m
      | [0;1;32m                             
[0m[1mprofile.c:1422:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1422 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1423 |                 fprintf(prof_fp, _("\t# gawk profile, created %s\n"), ctime(& now));[0m
      | [0;1;32m                                                                                    
[0m[1mprofile.c:1423:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1423 |                 fprintf(prof_fp, _("\t# gawk profile, created %s\n"), ctime(& now));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1423:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1423 |                 fprintf(prof_fp, _("\t# gawk profile, created %s\n"), ctime(& now));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:1503:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1503 |                 return 5;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mprofile.c:1506:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1506 |                 return 4;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mprofile.c:1509:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1509 |                 return 3;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mprofile.c:1512:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1512 |                 return 2;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mprofile.c:1524:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1524 |                 return 0;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mprofile.c:1556:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1556 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mprofile.c:1604:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1604 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mprofile.c:1616:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1616 |         if (p[0] == '(')        // already parenthesized[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1617 |                 return;[0m
      | [0;1;32m                       
[0m[1mprofile.c:1621:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1621 |         memcpy(p + 1, sp->pp_str, len);[0m
      | [0;1;32m        ^~~~~~
[0m[1mprofile.c:1621:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1621 |         memcpy(p + 1, sp->pp_str, len);[0m
      | [0;1;32m        ^~~~~~
[0m[1mprofile.c:1624:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1624 |         if ((sp->flags & CAN_FREE) != 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1625 |                 efree(sp->pp_str);[0m
      | [0;1;32m                                  
[0m[1mprofile.c:1640:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1640 |         if (lprec < prec)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1641 |                 pp_parenthesize(left);[0m
      | [0;1;32m                                      
[0m[1mprofile.c:1642:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1642 |         if (rprec < prec)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1643 |                 pp_parenthesize(right);[0m
      | [0;1;32m                                       
[0m[1mprofile.c:1704:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1704 |         if (typed_regex)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1705 |                 *obufout++ = '@';[0m
      | [0;1;32m                                 
[0m[1mprofile.c:1705:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 1705 |                 *obufout++ = '@';[0m
      | [0;1;32m                           ^
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_match_rec:'  at line 716[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:718:8: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_regex[0m
  718 |                         if (pc->memory->type == Node_regex) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:718:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  718 |                         if (pc->memory->type == Node_regex) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:723:11: [0m[0;1;36mnote: [0mCalling 'pp_typed_regex'[0m
  723 |                                 str = pp_typed_regex(pc->memory->stptr, pc->memory->stlen, '/');[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1659:9: [0m[0;1;36mnote: [0mCalling 'pp_string_or_typed_regex'[0m
 1659 |         return pp_string_or_typed_regex(in_str, len, delim, true);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1681:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1681 |         if (delim == '/') {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1704:6: [0m[0;1;36mnote: [0m'typed_regex' is true[0m
 1704 |         if (typed_regex)[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1mprofile.c:1704:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1704 |         if (typed_regex)[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1705:4: [0m[0;1;36mnote: [0mNull pointer value stored to 'obufout'[0m
 1705 |                 *obufout++ = '@';[0m
      | [0;1;32m                 ^~~~~~~~~
[0m[1mprofile.c:1705:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 1705 |                 *obufout++ = '@';[0m
      | [0;1;32m                ~~~~~~~~~~~^~~~~
[0m[1mprofile.c:1707:13: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 1707 |         *obufout++ = delim;[0m
      | [0;1;32m                   ^
[0m[1mprofile.c:1270:12: [0m[0;1;36mnote: [0mCalling 'pp_string'[0m
 1270 |         char *s = pp_string(in_str, len, delim);[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1651:9: [0m[0;1;36mnote: [0mCalling 'pp_string_or_typed_regex'[0m
 1651 |         return pp_string_or_typed_regex(in_str, len, delim, false);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1681:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1681 |         if (delim == '/') {[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mprofile.c:1681:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1681 |         if (delim == '/') {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1704:6: [0m[0;1;36mnote: [0m'typed_regex' is false[0m
 1704 |         if (typed_regex)[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1mprofile.c:1704:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1704 |         if (typed_regex)[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1707:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'obufout'[0m
 1707 |         *obufout++ = delim;[0m
      | [0;1;32m         ^~~~~~~~~
[0m[1mprofile.c:1707:13: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 1707 |         *obufout++ = delim;[0m
      | [0;1;32m        ~~~~~~~~~~~^~~~~~~
[0m[1mprofile.c:1732:4: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1732 |                         sprintf(obufout, "\\%03o", *str & 0xff);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1732:4: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1732 |                         sprintf(obufout, "\\%03o", *str & 0xff);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1754:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1754 |         strcpy(str, n->stptr);[0m
      | [0;1;32m        ^~~~~~
[0m[1mprofile.c:1754:2: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 1754 |         strcpy(str, n->stptr);[0m
      | [0;1;32m        ^~~~~~
[0m[1mprofile.c:1763:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1763 |         if ((n->flags & NUMBER) != 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1764 |                 return pp_number(n);[0m
      | [0;1;32m                                    
[0m[1mprofile.c:1792:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1792 |         if (nargs == 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1793 |                 len = 2;[0m
 1794 |         else {[0m
      | [0;32m        } 
[0m[1mprofile.c:1813:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1813 |         if (paren != NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1814 |                 *s++ = paren[0];[0m
      | [0;1;32m                                
[0m[1mprofile.c:1814:8: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 1814 |                 *s++ = paren[0];[0m
      | [0;1;32m                     ^
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_K_print:'  at line 674[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:677:12: [0m[0;1;36mnote: [0mField 'opcode' is not equal to Op_K_print_rec[0m
  677 |                         if (pc->opcode == Op_K_print_rec)[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:677:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  677 |                         if (pc->opcode == Op_K_print_rec)[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:680:13: [0m[0;1;36mnote: [0mAssuming field 'dl' is equal to 0[0m
  680 |                         else if (pc->redir_type != 0) {[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:680:9: [0m[0;1;36mnote: [0mTaking false branch[0m
  680 |                         else if (pc->redir_type != 0) {[0m
      | [0;1;32m                             ^
[0m[1mprofile.c:694:11: [0m[0;1;36mnote: [0mCalling 'pp_list'[0m
  694 |                                 tmp = pp_list(pc->expr_count, "  ", ", ");[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:1783:6: [0m[0;1;36mnote: [0mAssuming 'pp_args' is not equal to NULL[0m
 1783 |         if (pp_args == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mprofile.c:1783:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1783 |         if (pp_args == NULL) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1786:13: [0m[0;1;36mnote: [0mAssuming 'nargs' is <= 'npp_args'[0m
 1786 |         } else if (nargs > npp_args) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~
[0m[1mprofile.c:1786:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1786 |         } else if (nargs > npp_args) {[0m
      | [0;1;32m               ^
[0m[1mprofile.c:1792:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is equal to 0[0m
 1792 |         if (nargs == 0)[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mprofile.c:1792:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1792 |         if (nargs == 0)[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1813:6: [0m[0;1;36mnote: [0m'paren' is not equal to NULL[0m
 1813 |         if (paren != NULL)[0m
      | [0;1;32m            ^~~~~
[0m[1mprofile.c:1813:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1813 |         if (paren != NULL)[0m
      | [0;1;32m        ^
[0m[1mprofile.c:1814:4: [0m[0;1;36mnote: [0mNull pointer value stored to 's'[0m
 1814 |                 *s++ = paren[0];[0m
      | [0;1;32m                 ^~~
[0m[1mprofile.c:1814:8: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 1814 |                 *s++ = paren[0];[0m
      | [0;1;32m                ~~~~~^~~~~~~~~~
[0m[1mprofile.c:1819:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1819 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1819:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1819 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1824:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1824 |                         memcpy(s, delim, delimlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1824:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1824 |                         memcpy(s, delim, delimlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1832:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1832 |                         memcpy(s, comment->memory->stptr, comment->memory->stlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1832:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1832 |                         memcpy(s, comment->memory->stptr, comment->memory->stlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1834:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1834 |                         memcpy(s, tabs, indent_level + 1);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1834:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1834 |                         memcpy(s, tabs, indent_level + 1);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1840:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1840 |         if (paren != NULL)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1841 |                 *s++ = paren[1];[0m
      | [0;1;32m                                
[0m[1mprofile.c:1898:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1898 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1898:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1898 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1902:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1902 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1902:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1902 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1906:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1906 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1906:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1906 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1910:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1910 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1910:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1910 |                                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mprofile.c:1914:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1914 |                         memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1914:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1914 |                         memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mprofile.c:1927:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1927 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1927:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1927 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1931:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1931 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1931:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1931 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1935:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1935 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1935:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1935 |                 memcpy(s, r->pp_str, r->pp_len);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1962:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1962 |                 memcpy(s, s1, len1);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1962:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1962 |                 memcpy(s, s1, len1);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1966:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1966 |                 memcpy(s, s2, len2);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1966:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1966 |                 memcpy(s, s2, len2);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1970:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1970 |                 memcpy(s, s3, len3);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1970:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1970 |                 memcpy(s, s3, len3);[0m
      | [0;1;32m                ^~~~~~
[0m[1mprofile.c:1990:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1990 |                 if (do_profile)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1991 |                         fprintf(prof_fp, _("\n\t# Functions, listed alphabetically\n"));[0m
      | [0;1;32m                                                                                        
[0m[1mprofile.c:1991:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1991 |                         fprintf(prof_fp, _("\n\t# Functions, listed alphabetically\n"));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1991:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1991 |                         fprintf(prof_fp, _("\n\t# Functions, listed alphabetically\n"));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:1998:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1998 |         fprintf(prof_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:1998:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1998 |         fprintf(prof_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2001:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2001 |         if (pc->comment != NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 2002 |                 print_comment(pc->comment, -1); /* -1 ==> don't indent */[0m
      | [0;1;32m                                                                         
[0m[1mprofile.c:2008:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2008 |         fprintf(prof_fp, "%s %s(", op2str(Op_K_function), name);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2008:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2008 |         fprintf(prof_fp, "%s %s(", op2str(Op_K_function), name);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2009:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2009 |         if (malloced)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2010 |                 free(name);[0m
      | [0;1;32m                           
[0m[1mprofile.c:2014:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2014 |                 fprintf(prof_fp, "%s", func_params[j].param);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2014:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2014 |                 fprintf(prof_fp, "%s", func_params[j].param);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2015:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2015 |                 if (j < pcount - 1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2016 |                         fprintf(prof_fp, ", ");[0m
      | [0;1;32m                                               
[0m[1mprofile.c:2016:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2016 |                         fprintf(prof_fp, ", ");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:2016:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2016 |                         fprintf(prof_fp, ", ");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mprofile.c:2020:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2020 |                 fprintf(prof_fp, ")");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2020:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2020 |                 fprintf(prof_fp, ")");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2022:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2022 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2023 |                 fprintf(prof_fp, ")\n");[0m
      | [0;1;32m                                        
[0m[1mprofile.c:2023:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2023 |                 fprintf(prof_fp, ")\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2023:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2023 |                 fprintf(prof_fp, ")\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2024:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2024 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2025 |                 indent(0);[0m
      | [0;1;32m                          
[0m[1mprofile.c:2026:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2026 |         fprintf(prof_fp, "{\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2026:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2026 |         fprintf(prof_fp, "{\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2030:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2030 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2031 |                 indent(0);[0m
      | [0;1;32m                          
[0m[1mprofile.c:2032:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2032 |         fprintf(prof_fp, "}\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2032:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2032 |         fprintf(prof_fp, "}\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2051:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2051 |         if (redirtype < 0 || redirtype > redirect_twoway)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 2052 |                 fatal(_("redir2str: unknown redirection type %d"), redirtype);[0m
      | [0;1;32m                                                                              
[0m[1mprofile.c:2053:9: [0m[0;1;35mwarning: [0m[1mOut of bound access to memory after the end of 'redirtab' [clang-analyzer-security.ArrayBound][0m
 2053 |         return redirtab[redirtype];[0m
      | [0;1;32m               ^
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_K_getline:'  at line 761[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:763:8: [0m[0;1;36mnote: [0mAssuming field 'xl' is 0[0m
  763 |                         if (pc->into_var) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~
[0m[1mprofile.c:763:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  763 |                         if (pc->into_var) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:770:8: [0m[0;1;36mnote: [0mAssuming field 'dl' is not equal to 0[0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:770:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:771:19: [0m[0;1;36mnote: [0mAssuming field 'dl' is not equal to redirect_pipein[0m
  771 |                                 int before = (pc->redir_type == redirect_pipein[0m
      | [0;1;32m                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:771:19: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprofile.c:772:11: [0m[0;1;36mnote: [0mAssuming field 'dl' is not equal to redirect_twoway[0m
  772 |                                                         || pc->redir_type == redirect_twoway);[0m
      | [0;1;32m                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:775:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  775 |                                 if (is_binary(t2->type))[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:777:9: [0m[0;1;36mnote: [0m'before' is 0[0m
  777 |                                 if (before)[0m
      | [0;1;32m                                    ^~~~~~
[0m[1mprofile.c:777:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  777 |                                 if (before)[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:780:27: [0m[0;1;36mnote: [0mCalling 'redir2str'[0m
  780 |                                         str = pp_group3(tmp, redir2str(pc->redir_type), t2->pp_str);[0m
      | [0;1;32m                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:2051:6: [0m[0;1;36mnote: [0mAssuming 'redirtype' is >= 0[0m
 2051 |         if (redirtype < 0 || redirtype > redirect_twoway)[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mprofile.c:2051:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprofile.c:2051:23: [0m[0;1;36mnote: [0mAssuming 'redirtype' is > redirect_twoway[0m
 2051 |         if (redirtype < 0 || redirtype > redirect_twoway)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:2051:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 2051 |         if (redirtype < 0 || redirtype > redirect_twoway)[0m
      | [0;1;32m        ^
[0m[1mprofile.c:2053:9: [0m[0;1;36mnote: [0mAccess of 'redirtab' at an overflowing index, while it holds only 7 'const char *' elements[0m
 2053 |         return redirtab[redirtype];[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:2053:9: [0m[0;1;35mwarning: [0m[1mOut of bound access to memory preceding 'redirtab' [clang-analyzer-security.ArrayBound][0m
 2053 |         return redirtab[redirtype];[0m
      | [0;1;32m               ^
[0m[1mprofile.c:225:20: [0m[0;1;36mnote: [0mAssuming 'pc' is not equal to 'endp'[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m                          ^~~~~~~~~~
[0m[1mprofile.c:225:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  225 |         for (pc = startp; pc != endp; pc = pc->nexti) {[0m
      | [0;1;32m        ^
[0m[1mprofile.c:226:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:226:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  226 |                 if (pc->source_line > 0)[0m
      | [0;1;32m                ^
[0m[1mprofile.c:230:7: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_comment[0m
  230 |                 if (pc->opcode == Op_comment[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:231:7: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  231 |                     && pc->memory->comment_type == EOL_COMMENT[0m
      | [0;1;32m                    ^
[0m[1mprofile.c:238:3: [0m[0;1;36mnote: [0mControl jumps to 'case Op_K_getline:'  at line 761[0m
  238 |                 switch (pc->opcode) {[0m
      | [0;1;32m                ^
[0m[1mprofile.c:763:8: [0m[0;1;36mnote: [0mAssuming field 'xl' is 0[0m
  763 |                         if (pc->into_var) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~
[0m[1mprofile.c:763:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  763 |                         if (pc->into_var) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:770:8: [0m[0;1;36mnote: [0mAssuming field 'dl' is not equal to 0[0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:770:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  770 |                         if (pc->redir_type != 0) {[0m
      | [0;1;32m                        ^
[0m[1mprofile.c:771:19: [0m[0;1;36mnote: [0mAssuming field 'dl' is not equal to redirect_pipein[0m
  771 |                                 int before = (pc->redir_type == redirect_pipein[0m
      | [0;1;32m                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:771:19: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprofile.c:772:11: [0m[0;1;36mnote: [0mAssuming field 'dl' is not equal to redirect_twoway[0m
  772 |                                                         || pc->redir_type == redirect_twoway);[0m
      | [0;1;32m                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:775:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  775 |                                 if (is_binary(t2->type))[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:777:9: [0m[0;1;36mnote: [0m'before' is 0[0m
  777 |                                 if (before)[0m
      | [0;1;32m                                    ^~~~~~
[0m[1mprofile.c:777:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  777 |                                 if (before)[0m
      | [0;1;32m                                ^
[0m[1mprofile.c:780:27: [0m[0;1;36mnote: [0mCalling 'redir2str'[0m
  780 |                                         str = pp_group3(tmp, redir2str(pc->redir_type), t2->pp_str);[0m
      | [0;1;32m                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:2051:6: [0m[0;1;36mnote: [0mAssuming 'redirtype' is < 0[0m
 2051 |         if (redirtype < 0 || redirtype > redirect_twoway)[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mprofile.c:2051:20: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 2051 |         if (redirtype < 0 || redirtype > redirect_twoway)[0m
      | [0;1;32m                          ^
[0m[1mprofile.c:2053:9: [0m[0;1;36mnote: [0mAccess of 'redirtab' at negative byte offset[0m
 2053 |         return redirtab[redirtype];[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~
[0m[1mprofile.c:2063:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2063 |         if (! namespace_changed)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 2064 |                 return;[0m
      | [0;1;32m                       
[0m[1mprofile.c:2066:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2066 |         if (strcmp(current_namespace, name) == 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2067 |                 return;[0m
      | [0;1;32m                       
[0m[1mprofile.c:2074:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2074 |         fprintf(prof_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2074:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2074 |         fprintf(prof_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2076:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2076 |         if (do_profile)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2077 |                 indent(SPACEOVER);[0m
      | [0;1;32m                                  
[0m[1mprofile.c:2079:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2079 |         fprintf(prof_fp, "@namespace \"%s\"", name);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2079:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2079 |         fprintf(prof_fp, "@namespace \"%s\"", name);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprofile.c:2085:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2085 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2086 |                 fprintf(prof_fp, "\n\n");[0m
      | [0;1;32m                                         
[0m[1mprofile.c:2086:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2086 |                 fprintf(prof_fp, "\n\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2086:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2086 |                 fprintf(prof_fp, "\n\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2094:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2094 |         if (list == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 2095 |                 return;[0m
      | [0;1;32m                       
[0m[1mprofile.c:2117:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2117 |                 sprintf(buf, "awk::%s", name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mprofile.c:2117:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 2117 |                 sprintf(buf, "awk::%s", name);[0m
      | [0;1;32m                ^~~~~~~
[0m323 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[47/54][228.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp7_6gx7m3.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/array.c
[1marray.c:66:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   66 |                 if (afunc != & str_array_func && afunc->type_of == NULL)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m   67 |                         return false;[0m
      | [0;1;32m                                     
[0m[1marray.c:69:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   69 |                 if (afunc->init)        /* execute init routine if any */[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m   70 |                         (void) (*afunc->init)(NULL, NULL);[0m
      | [0;1;32m                                                          
[0m[1marray.c:97:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   97 |         memset(array, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1marray.c:97:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
   97 |         memset(array, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1marray.c:114:23: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  114 |         symbol->table_size = 0;[0m
      | [0;1;32m                             ^
[0m[1m./awk.h:360:9: [0m[0;1;36mnote: [0menum declared here[0m
  360 |                         enum reflagvals {[0m
      | [0;1;32m                        ~~~~~^~~~~~~~~~~~
[0m  361 |                                 CONSTANT = 1,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  362 |                                 FS_DFLT  = 2,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  363 |                         } reflags;[0m
      | [0;1;32m                        ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:856:10: [0m[0;1;36mnote: [0mCalling 'POP_PARAM'[0m
  856 |         array = POP_PARAM();[0m
      | [0;1;32m                ^~~~~~~~~~~
[0m[1m./awk.h:1870:10: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_var_array[0m
 1870 |         return (t->type == Node_var_array) ? t : force_array(t, false);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:1870:9: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1870 |         return (t->type == Node_var_array) ? t : force_array(t, false);[0m
      | [0;1;32m               ^
[0m[1m./awk.h:1870:43: [0m[0;1;36mnote: [0mCalling 'force_array'[0m
 1870 |         return (t->type == Node_var_array) ? t : force_array(t, false);[0m
      | [0;1;32m                                                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:329:6: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_param_list[0m
  329 |         if (symbol->type == Node_param_list) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:329:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  329 |         if (symbol->type == Node_param_list) {[0m
      | [0;1;32m        ^
[0m[1marray.c:336:2: [0m[0;1;36mnote: [0mControl jumps to 'case Node_var_new:'  at line 342[0m
  336 |         switch (symbol->type) {[0m
      | [0;1;32m        ^
[0m[1marray.c:344:3: [0m[0;1;36mnote: [0mCalling 'null_array'[0m
  344 |                 null_array(symbol);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~
[0m[1marray.c:114:23: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals'[0m
  114 |         symbol->table_size = 0;[0m
      | [0;1;32m                             ^
[0m[1marray.c:117:18: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  117 |         symbol->flags = 0;[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:856:10: [0m[0;1;36mnote: [0mCalling 'POP_PARAM'[0m
  856 |         array = POP_PARAM();[0m
      | [0;1;32m                ^~~~~~~~~~~
[0m[1m./awk.h:1870:10: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_var_array[0m
 1870 |         return (t->type == Node_var_array) ? t : force_array(t, false);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:1870:9: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1870 |         return (t->type == Node_var_array) ? t : force_array(t, false);[0m
      | [0;1;32m               ^
[0m[1m./awk.h:1870:43: [0m[0;1;36mnote: [0mCalling 'force_array'[0m
 1870 |         return (t->type == Node_var_array) ? t : force_array(t, false);[0m
      | [0;1;32m                                                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:329:6: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_param_list[0m
  329 |         if (symbol->type == Node_param_list) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:329:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  329 |         if (symbol->type == Node_param_list) {[0m
      | [0;1;32m        ^
[0m[1marray.c:336:2: [0m[0;1;36mnote: [0mControl jumps to 'case Node_var_new:'  at line 342[0m
  336 |         switch (symbol->type) {[0m
      | [0;1;32m        ^
[0m[1marray.c:344:3: [0m[0;1;36mnote: [0mCalling 'null_array'[0m
  344 |                 null_array(symbol);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~
[0m[1marray.c:117:18: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  117 |         symbol->flags = 0;[0m
      | [0;1;32m                        ^
[0m[1marray.c:141:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  141 |                 if (afunc->type_of(symbol, subs) != NULL)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  142 |                         break;[0m
      | [0;1;32m                              
[0m[1marray.c:144:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  144 |         if (i == 0 || afunc == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  145 |                 afunc = array_types[0]; /* default is str_array_func */[0m
      | [0;1;32m                                                                       
[0m[1marray.c:166:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  166 |         fprintf(output_fp, "array `%s' is empty\n", array_vname(symbol));[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:166:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  166 |         fprintf(output_fp, "array `%s' is empty\n", array_vname(symbol));[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:191:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  191 |         if (symbol->adump)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  192 |                 (void) symbol->adump(symbol, ndump);[0m
      | [0;1;32m                                                    
[0m[1marray.c:215:11: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  215 |                 alen += sprintf(aname + alen, "[\"%s\"]", symbol->vname);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1marray.c:215:11: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  215 |                 alen += sprintf(aname + alen, "[\"%s\"]", symbol->vname);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1marray.c:225:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  225 |                 memcpy(aname, symbol->vname, alen + 1);[0m
      | [0;1;32m                ^~~~~~
[0m[1marray.c:225:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  225 |                 memcpy(aname, symbol->vname, alen + 1);[0m
      | [0;1;32m                ^~~~~~
[0m[1marray.c:255:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  255 |                 if (symbol->type != Node_var_array || symbol->parent_array == NULL)[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m  256 |                         return symbol->vname;[0m
      | [0;1;32m                                             
[0m[1marray.c:271:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  271 |         if (symbol->parent_array == NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  272 |                 aname = symbol->vname;[0m
  273 |         else[0m
      | [0;32m        } 
[0m[1marray.c:273:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  273 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  274 |                 aname = make_aname(symbol);[0m
      | [0;1;32m                                           
[0m[1marray.c:301:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  301 |         s += sprintf(s, "%s (", symbol->vname);[0m
      | [0;1;32m             ^~~~~~~
[0m[1marray.c:301:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  301 |         s += sprintf(s, "%s (", symbol->vname);[0m
      | [0;1;32m             ^~~~~~~
[0m[1marray.c:304:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  304 |                 if (symbol->type != Node_array_ref)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  305 |                         break;[0m
      | [0;1;32m                              
[0m[1marray.c:306:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  306 |                 s += sprintf(s, from, symbol->vname);[0m
      | [0;1;32m                     ^~~~~~~
[0m[1marray.c:306:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  306 |                 s += sprintf(s, from, symbol->vname);[0m
      | [0;1;32m                     ^~~~~~~
[0m[1marray.c:307:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  307 |                 s += sprintf(s, ", ");[0m
      | [0;1;32m                     ^~~~~~~
[0m[1marray.c:307:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  307 |                 s += sprintf(s, ", ");[0m
      | [0;1;32m                     ^~~~~~~
[0m[1marray.c:309:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  309 |         s += sprintf(s, from, aname);[0m
      | [0;1;32m             ^~~~~~~
[0m[1marray.c:309:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  309 |         s += sprintf(s, from, aname);[0m
      | [0;1;32m             ^~~~~~~
[0m[1marray.c:310:2: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
  310 |         strcpy(s, ")");[0m
      | [0;1;32m        ^
[0m[1marray.c:560:6: [0m[0;1;36mnote: [0mAssuming 'nsubs' is not equal to 0[0m
  560 |         if (nsubs == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:560:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  560 |         if (nsubs == 0) {[0m
      | [0;1;32m        ^
[0m[1marray.c:570:18: [0m[0;1;36mnote: [0mAssuming 'i' is > 0[0m
  570 |         for (i = nsubs; i > 0; i--) {[0m
      | [0;1;32m                        ^~~~~
[0m[1marray.c:570:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  570 |         for (i = nsubs; i > 0; i--) {[0m
      | [0;1;32m        ^
[0m[1marray.c:572:7: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_val[0m
  572 |                 if (subs->type != Node_val) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:572:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  572 |                 if (subs->type != Node_val) {[0m
      | [0;1;32m                ^
[0m[1marray.c:573:4: [0m[0;1;36mnote: [0mField 'type' is not equal to Node_val[0m
  573 |                         free_subs(i);[0m
      | [0;1;32m                        ^
[0m[1marray.c:554:12: [0m[0;1;36mnote: [0mexpanded from macro 'free_subs'[0m
  554 |     if (s->type == Node_val) {                                  \[0m
      | [0;1;32m           ^
[0m[1marray.c:573:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  573 |                         free_subs(i);[0m
      | [0;1;32m                        ^
[0m[1marray.c:554:5: [0m[0;1;36mnote: [0mexpanded from macro 'free_subs'[0m
  554 |     if (s->type == Node_val) {                                  \[0m
      | [0;1;32m    ^
[0m[1marray.c:573:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  573 |                         free_subs(i);[0m
      | [0;1;32m                        ^
[0m[1marray.c:558:10: [0m[0;1;36mnote: [0mexpanded from macro 'free_subs'[0m
  558 | } while (--n > 0)[0m
      | [0;1;32m         ^~~~~~~
[0m[1marray.c:573:4: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  573 |                         free_subs(i);[0m
      | [0;1;32m                        ^
[0m[1marray.c:552:25: [0m[0;1;36mnote: [0mexpanded from macro 'free_subs'[0m
  552 | #define free_subs(n)    do {                                    \[0m
      | [0;1;32m                        ^
[0m[1marray.c:574:62: [0m[0;1;36mnote: [0mCalling 'array_vname'[0m
  574 |                         fatal(_("attempt to use array `%s' in a scalar context"), array_vname(subs));[0m
      | [0;1;32m                                                                                  ^~~~~~~~~~~~~~~~~
[0m[1marray.c:252:6: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_array_ref[0m
  252 |         if (symbol->type != Node_array_ref[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:252:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1marray.c:253:7: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_var_array[0m
  253 |                         || symbol->orig_array->type != Node_var_array[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:252:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  252 |         if (symbol->type != Node_array_ref[0m
      | [0;1;32m        ^
[0m[1marray.c:264:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  264 |         while (symbol->type == Node_array_ref) {[0m
      | [0;1;32m        ^
[0m[1marray.c:264:9: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_array_ref[0m
  264 |         while (symbol->type == Node_array_ref) {[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:264:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 271[0m
  264 |         while (symbol->type == Node_array_ref) {[0m
      | [0;1;32m        ^
[0m[1marray.c:271:6: [0m[0;1;36mnote: [0mAssuming field 'extra' is equal to NULL[0m
  271 |         if (symbol->parent_array == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:271:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  271 |         if (symbol->parent_array == NULL)[0m
      | [0;1;32m        ^
[0m[1marray.c:284:6: [0m[0;1;36mnote: [0m'message' is equal to NULL[0m
  284 |         if (message == NULL) {[0m
      | [0;1;32m            ^~~~~~~
[0m[1marray.c:284:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  284 |         if (message == NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:302:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  302 |         for (;;) {[0m
      | [0;1;32m        ^
[0m[1marray.c:304:15: [0m[0;1;36mnote: [0mField 'type' is not equal to Node_array_ref[0m
  304 |                 if (symbol->type != Node_array_ref)[0m
      | [0;1;32m                            ^
[0m[1marray.c:304:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  304 |                 if (symbol->type != Node_array_ref)[0m
      | [0;1;32m                ^
[0m[1marray.c:305:4: [0m[0;1;36mnote: [0m Execution continues on line 309[0m
  305 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:309:2: [0m[0;1;36mnote: [0mNull pointer value stored to 's'[0m
  309 |         s += sprintf(s, from, aname);[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:310:2: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
  310 |         strcpy(s, ")");[0m
      | [0;1;32m        ^      ~
[0m[1marray.c:310:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  310 |         strcpy(s, ")");[0m
      | [0;1;32m        ^~~~~~
[0m[1marray.c:310:2: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  310 |         strcpy(s, ")");[0m
      | [0;1;32m        ^~~~~~
[0m[1marray.c:332:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  332 |                 if (symbol->type == Node_array_ref)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  333 |                         symbol = symbol->orig_array;[0m
      | [0;1;32m                                                    
[0m[1marray.c:338:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  338 |                 efree(symbol->stptr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  339 |                 symbol->stptr = NULL;[0m
  340 |                 symbol->stlen = 0;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1m./awk.h:1386:18: [0m[0;1;36mnote: [0mexpanded from macro 'efree'[0m
 1386 | #define efree(p)        free(p)[0m
      | [0;1;32m                        ^
[0m[1m./custom.h:133:14: [0m[0;1;36mnote: [0mexpanded from macro 'free'[0m
  133 | #define free    pma_free[0m
      | [0;1;32m                ^
[0m[1marray.c:343:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  343 |                 symbol->xarray = NULL;  /* make sure union is as it should be */[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  344 |                 null_array(symbol);[0m
  345 |                 symbol->parent_array = NULL;    /* main array has no parent */[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1marray.c:348:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  348 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1marray.c:354:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  354 |                         if (symbol->type == Node_val)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  355 |                                 fatal(_("attempt to use a scalar value as array"));[0m
      | [0;1;32m                                                                                   
[0m[1marray.c:356:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  356 |                         if (isparam)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  357 |                                 fatal(_("attempt to use scalar parameter `%s' as an array"),[0m
  358 |                                         save_symbol->vname);[0m
  359 |                         else[0m
      | [0;32m                        } 
[0m[1marray.c:359:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  359 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  360 |                                 fatal(_("attempt to use scalar `%s' as an array"),[0m
  361 |                                         save_symbol->vname);[0m
      | [0;1;32m                                                            
[0m[1marray.c:362:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  362 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  363 |                         break;[0m
      | [0;1;32m                              
[0m[1marray.c:395:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  395 |         if (nargs == 1)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  396 |                 return POP_STRING();[0m
      | [0;1;32m                                    
[0m[1marray.c:398:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  398 |         if (do_subsep)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  399 |                 subseplen = SUBSEPlen;[0m
      | [0;1;32m                                      
[0m[1marray.c:405:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  405 |                         while (--i > 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  406 |                                 DEREF(args_array[i]);   /* avoid memory leak */[0m
      | [0;1;32m                                                                               
[0m[1marray.c:418:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  418 |         memcpy(str, r->stptr, r->stlen);[0m
      | [0;1;32m        ^~~~~~
[0m[1marray.c:418:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  418 |         memcpy(str, r->stptr, r->stlen);[0m
      | [0;1;32m        ^~~~~~
[0m[1marray.c:422:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  422 |                 if (subseplen == 1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  423 |                         *s++ = *SUBSEP;[0m
  424 |                 else if (subseplen > 0) {[0m
      | [0;32m                } 
[0m[1marray.c:425:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  425 |                         memcpy(s, SUBSEP, subseplen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1marray.c:425:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  425 |                         memcpy(s, SUBSEP, subseplen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1marray.c:429:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  429 |                 memcpy(s, r->stptr, r->stlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1marray.c:429:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  429 |                 memcpy(s, r->stptr, r->stlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1marray.c:470:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  470 |         if (func == NULL)       /* in main */[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  471 |                 return;[0m
      | [0;1;32m                       
[0m[1marray.c:478:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  478 |                                 || r->orig_array->type != Node_var_array)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m  479 |                         continue;[0m
      | [0;1;32m                                 
[0m[1marray.c:605:6: [0m[0;1;35mwarning: [0m[1mAccess to field 'type' results in a dereference of a null pointer (loaded from variable 'val') [clang-analyzer-core.NullDereference][0m
  605 |         if (val->type == Node_var_array) {[0m
      | [0;1;32m            ^~~
[0m[1marray.c:540:9: [0m[0;1;36mnote: [0mNull pointer value stored to 'val'[0m
  540 |         subs = val = NULL;      /* silence the compiler */[0m
      | [0;1;32m               ^~~~~~~~~~
[0m[1marray.c:560:6: [0m[0;1;36mnote: [0mAssuming 'nsubs' is not equal to 0[0m
  560 |         if (nsubs == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:560:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  560 |         if (nsubs == 0) {[0m
      | [0;1;32m        ^
[0m[1marray.c:570:18: [0m[0;1;36mnote: [0mAssuming 'i' is <= 0[0m
  570 |         for (i = nsubs; i > 0; i--) {[0m
      | [0;1;32m                        ^~~~~
[0m[1marray.c:570:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 605[0m
  570 |         for (i = nsubs; i > 0; i--) {[0m
      | [0;1;32m        ^
[0m[1marray.c:605:6: [0m[0;1;36mnote: [0mAccess to field 'type' results in a dereference of a null pointer (loaded from variable 'val')[0m
  605 |         if (val->type == Node_var_array) {[0m
      | [0;1;32m            ^~~
[0m[1marray.c:611:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  611 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  612 |                 unref(val);[0m
      | [0;1;32m                           
[0m[1marray.c:616:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  616 |         if (assoc_empty(symbol))[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  617 |                 /* last element was removed, so reset array type to null */[0m
  618 |                 null_array(symbol);[0m
      | [0;1;32m                                   
[0m[1marray.c:638:16: [0m[0;1;35mwarning: [0m[1mThe value '257' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  638 |         akind.flags = AINDEX|ADELETE;   /* need a single index */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:638:16: [0m[0;1;36mnote: [0mThe value '257' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  638 |         akind.flags = AINDEX|ADELETE;   /* need a single index */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~
[0m[1marray.c:641:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  641 |         if (assoc_empty(symbol))[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  642 |                 return;[0m
      | [0;1;32m                       
[0m[1marray.c:663:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  663 |                 fprintf(output_fp, "<(null)>");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:663:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  663 |                 fprintf(output_fp, "<(null)>");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:668:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  668 |                 fprintf(output_fp, "<");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:668:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  668 |                 fprintf(output_fp, "<");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:669:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  669 |                 fprintf(output_fp, "\"%.*s\"", (int) n->stlen, n->stptr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:669:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  669 |                 fprintf(output_fp, "\"%.*s\"", (int) n->stlen, n->stptr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:679:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  679 |                         fprintf(output_fp, ":%.*g", PREC_NUM, n->numbr);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1marray.c:679:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  679 |                         fprintf(output_fp, ":%.*g", PREC_NUM, n->numbr);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1marray.c:681:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  681 |                 fprintf(output_fp, ">");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:681:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  681 |                 fprintf(output_fp, ">");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:691:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  691 |                 fprintf(output_fp, "<%.*g>", PREC_NUM, n->numbr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:691:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  691 |                 fprintf(output_fp, "<%.*g>", PREC_NUM, n->numbr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:694:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  694 |         fprintf(output_fp, ":%s", flags2str(n->flags));[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:694:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  694 |         fprintf(output_fp, ":%s", flags2str(n->flags));[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:696:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  696 |         if ((n->flags & MALLOC) != 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  697 |                 fprintf(output_fp, ":%ld", n->valref);[0m
  698 |         else[0m
      | [0;32m        } 
[0m[1marray.c:697:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  697 |                 fprintf(output_fp, ":%ld", n->valref);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:697:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  697 |                 fprintf(output_fp, ":%ld", n->valref);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:698:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  698 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  699 |                 fprintf(output_fp, ":");[0m
      | [0;1;32m                                        
[0m[1marray.c:699:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  699 |                 fprintf(output_fp, ":");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:699:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  699 |                 fprintf(output_fp, ":");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:704:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  704 |                 fprintf(output_fp, "][");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:704:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  704 |                 fprintf(output_fp, "][");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:705:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  705 |                 fprintf(output_fp, "stfmt=%d, ", n->stfmt);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:705:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  705 |                 fprintf(output_fp, "stfmt=%d, ", n->stfmt);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:714:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  714 |                 fprintf(output_fp, "FMT=\"%s\"",[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:714:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  714 |                 fprintf(output_fp, "FMT=\"%s\"",[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:730:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  730 |         for (i = 0; i < indent_level; i++)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  731 |                 fprintf(output_fp, "%s", indent_char);[0m
      | [0;1;32m                                                      
[0m[1marray.c:731:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  731 |                 fprintf(output_fp, "%s", indent_char);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:731:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  731 |                 fprintf(output_fp, "%s", indent_char);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:743:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  743 |         fprintf(output_fp, "I: [%s:", aname);[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:743:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  743 |         fprintf(output_fp, "I: [%s:", aname);[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:744:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  744 |         if ((subs->flags & (MPFN|MPZN|INTIND)) == INTIND)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  745 |                 fprintf(output_fp, "<%ld>", (long) subs->numbr);[0m
  746 |         else[0m
      | [0;32m        } 
[0m[1marray.c:745:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  745 |                 fprintf(output_fp, "<%ld>", (long) subs->numbr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:745:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  745 |                 fprintf(output_fp, "<%ld>", (long) subs->numbr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:746:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  746 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  747 |                 value_info(subs);[0m
      | [0;1;32m                                 
[0m[1marray.c:748:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  748 |         fprintf(output_fp, "]\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:748:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  748 |         fprintf(output_fp, "]\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:753:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  753 |                 fprintf(output_fp, "V: [scalar: ");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:753:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  753 |                 fprintf(output_fp, "V: [scalar: ");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:753:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  753 |                 fprintf(output_fp, "V: [scalar: ");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  754 |                 value_info(val);[0m
  755 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1marray.c:757:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  757 |                 fprintf(output_fp, "V: [scalar: ");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:757:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  757 |                 fprintf(output_fp, "V: [scalar: ");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:757:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  757 |                 fprintf(output_fp, "V: [scalar: ");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  758 |                 value_info(val->var_value);[0m
  759 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1marray.c:761:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  761 |                 fprintf(output_fp, "V: [");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:761:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  761 |                 fprintf(output_fp, "V: [");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:761:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  761 |                 fprintf(output_fp, "V: [");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  762 |                 ndump->alevel++;[0m
  763 |                 ndump->adepth--;[0m
  764 |                 assoc_dump(val, ndump);[0m
  765 |                 ndump->adepth++;[0m
  766 |                 ndump->alevel--;[0m
  767 |                 indent(indent_level);[0m
  768 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1marray.c:770:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  770 |                 fprintf(output_fp, "V: [user_defined_function");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:770:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  770 |                 fprintf(output_fp, "V: [user_defined_function");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:770:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  770 |                 fprintf(output_fp, "V: [user_defined_function");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  771 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1marray.c:773:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  773 |                 fprintf(output_fp, "V: [external_function");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:773:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  773 |                 fprintf(output_fp, "V: [external_function");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:773:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  773 |                 fprintf(output_fp, "V: [external_function");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  774 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1marray.c:776:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  776 |                 fprintf(output_fp, "V: [builtin_function");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:776:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  776 |                 fprintf(output_fp, "V: [builtin_function");[0m
      | [0;1;32m                ^~~~~~~
[0m[1marray.c:776:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  776 |                 fprintf(output_fp, "V: [builtin_function");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  777 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1marray.c:779:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  779 |                 cant_happen("unexpected node type %s", nodetype2str(val->type));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  780 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1marray.c:782:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  782 |         fprintf(output_fp, "]\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:782:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  782 |         fprintf(output_fp, "]\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1marray.c:807:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  807 |         if (symbol->type != Node_var_array)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  808 |                 fatal(_("%s: first argument is not an array"), "adump");[0m
      | [0;1;32m                                                                        
[0m[1marray.c:831:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  832 |                 s = POP_STRING();[0m
  833 |         else[0m
      | [0;32m        } 
[0m[1marray.c:833:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  833 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  834 |                 s = dupnode(Nnull_string);      /* "" => default sorting */[0m
      | [0;1;32m                                                                           
[0m[1marray.c:841:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  841 |                 if (ctxt == ASORT)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  842 |                         sort_str = "@val_type_asc";[0m
  843 |                 else[0m
      | [0;32m                } 
[0m[1marray.c:843:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  843 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  844 |                         sort_str = "@ind_str_asc";[0m
      | [0;1;32m                                                  
[0m[1marray.c:860:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  861 |                 fatal(_("%s: first argument cannot be SYMTAB without a second argument"), name);[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;32m        } 
[0m[1marray.c:862:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  863 |                 fatal(_("%s: first argument cannot be FUNCTAB without a second argument"), name);[0m
      | [0;1;32m                                                                                                 
[0m[1marray.c:874:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  874 |                         if (r == array)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  875 |                                 fatal(_("%s: cannot use a subarray of first argument for second argument"),[0m
  876 |                                         name);[0m
      | [0;1;32m                                              
[0m[1marray.c:879:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  879 |                         if (r == dest)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  880 |                                 fatal(_("%s: cannot use a subarray of second argument for first argument"),[0m
  881 |                                         name);[0m
      | [0;1;32m                                              
[0m[1marray.c:893:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  893 |                 if (dest != NULL && dest != array)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  894 |                         assoc_clear(dest);[0m
      | [0;1;32m                                          
[0m[1marray.c:895:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  895 |                 if (list != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  896 |                         efree(list);[0m
      | [0;1;32m                                    
[0m[1marray.c:940:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  940 |                                 value = dupnode(r);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  941 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1marray.c:944:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  944 |                                 value = dupnode(r->var_value);[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  945 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1marray.c:949:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  949 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1marray.c:955:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  955 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1marray.c:972:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  972 |                                 cant_happen("asort_actual: got unexpected type %s", nodetype2str(r->type));[0m
      | [0;1;32m                                ^                                                                         
[0m      | [0;32m                                {                                                                         ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1marray.c:1027:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1027 |         if (len1 == 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1028 |                 return len2 == 0 ? 0 : -1;[0m
      | [0;1;32m                                          
[0m[1marray.c:1029:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1029 |         if (len2 == 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1030 |                 return 1;[0m
      | [0;1;32m                         
[0m[1marray.c:1047:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1047 |                         for (ret = 0; count-- > 0 && ret == 0; cp1++, cp2++)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 1048 |                                 ret = casetable[*cp1] - casetable[*cp2];[0m
      | [0;1;32m                                                                        
[0m[1marray.c:1050:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1050 |                 if (ret != 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1051 |                         return ret;[0m
      | [0;1;32m                                   
[0m[1marray.c:1059:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1059 |         if (ret != 0 || len1 == len2)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1060 |                 return ret;[0m
      | [0;1;32m                           
[0m[1marray.c:1108:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1108 |         if (ret != 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1109 |                 return ret;[0m
      | [0;1;32m                           
[0m[1marray.c:1137:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1137 |         if (t1->type != Node_val || t2->type != Node_val)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1138 |                 return sort_up_value_type(p1, p2);[0m
      | [0;1;32m                                                  
[0m[1marray.c:1142:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1142 |         if (ret != 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1143 |                 return ret;[0m
      | [0;1;32m                           
[0m[1marray.c:1168:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1168 |         if (t1->type != Node_val || t2->type != Node_val)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1169 |                 return sort_up_value_type(p1, p2);[0m
      | [0;1;32m                                                  
[0m[1marray.c:1172:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1172 |         if (ret != 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1173 |                 return ret;[0m
      | [0;1;32m                           
[0m[1marray.c:1180:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1180 |         if (ret != 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1181 |                 return ret;[0m
      | [0;1;32m                           
[0m[1marray.c:1239:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1239 |                         if (n1->type == element_types[i])[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1240 |                                 n1_pos = i;[0m
      | [0;1;32m                                           
[0m[1marray.c:1242:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1242 |                         if (n2->type == element_types[i])[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1243 |                                 n2_pos = i;[0m
      | [0;1;32m                                           
[0m[1marray.c:1308:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1308 |         if (val1->type == Node_val)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1309 |                 UPREF(val1);[0m
      | [0;1;32m                            
[0m[1marray.c:1314:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1314 |         if (val2->type == Node_val)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1315 |                 UPREF(val2);[0m
      | [0;1;32m                            
[0m[1marray.c:1352:41: [0m[0;1;35mwarning: [0m[1mThe value '73' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1352 | { "@ind_str_asc",       sort_up_index_string,   AINDEX|AISTR|AASC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1352:41: [0m[0;1;36mnote: [0mThe value '73' provided to the cast expression is not in the valid range of values for the enum[0m
 1352 | { "@ind_str_asc",       sort_up_index_string,   AINDEX|AISTR|AASC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~
[0m[1marray.c:1353:41: [0m[0;1;35mwarning: [0m[1mThe value '69' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1353 | { "@ind_num_asc",       sort_up_index_number,   AINDEX|AINUM|AASC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1353:41: [0m[0;1;36mnote: [0mThe value '69' provided to the cast expression is not in the valid range of values for the enum[0m
 1353 | { "@ind_num_asc",       sort_up_index_number,   AINDEX|AINUM|AASC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~
[0m[1marray.c:1354:41: [0m[0;1;35mwarning: [0m[1mThe value '98' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1354 | { "@val_str_asc",       sort_up_value_string,   AVALUE|AVSTR|AASC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1354:41: [0m[0;1;36mnote: [0mThe value '98' provided to the cast expression is not in the valid range of values for the enum[0m
 1354 | { "@val_str_asc",       sort_up_value_string,   AVALUE|AVSTR|AASC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~
[0m[1marray.c:1355:41: [0m[0;1;35mwarning: [0m[1mThe value '82' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1355 | { "@val_num_asc",       sort_up_value_number,   AVALUE|AVNUM|AASC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1355:41: [0m[0;1;36mnote: [0mThe value '82' provided to the cast expression is not in the valid range of values for the enum[0m
 1355 | { "@val_num_asc",       sort_up_value_number,   AVALUE|AVNUM|AASC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~
[0m[1marray.c:1356:44: [0m[0;1;35mwarning: [0m[1mThe value '137' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1356 | { "@ind_str_desc",      sort_down_index_string, AINDEX|AISTR|ADESC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1356:44: [0m[0;1;36mnote: [0mThe value '137' provided to the cast expression is not in the valid range of values for the enum[0m
 1356 | { "@ind_str_desc",      sort_down_index_string, AINDEX|AISTR|ADESC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~~
[0m[1marray.c:1357:44: [0m[0;1;35mwarning: [0m[1mThe value '133' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1357 | { "@ind_num_desc",      sort_down_index_number, AINDEX|AINUM|ADESC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1357:44: [0m[0;1;36mnote: [0mThe value '133' provided to the cast expression is not in the valid range of values for the enum[0m
 1357 | { "@ind_num_desc",      sort_down_index_number, AINDEX|AINUM|ADESC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~~
[0m[1marray.c:1358:44: [0m[0;1;35mwarning: [0m[1mThe value '162' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1358 | { "@val_str_desc",      sort_down_value_string, AVALUE|AVSTR|ADESC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1358:44: [0m[0;1;36mnote: [0mThe value '162' provided to the cast expression is not in the valid range of values for the enum[0m
 1358 | { "@val_str_desc",      sort_down_value_string, AVALUE|AVSTR|ADESC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~~
[0m[1marray.c:1359:44: [0m[0;1;35mwarning: [0m[1mThe value '146' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1359 | { "@val_num_desc",      sort_down_value_number, AVALUE|AVNUM|ADESC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1359:44: [0m[0;1;36mnote: [0mThe value '146' provided to the cast expression is not in the valid range of values for the enum[0m
 1359 | { "@val_num_desc",      sort_down_value_number, AVALUE|AVNUM|ADESC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~~~~~~~
[0m[1marray.c:1360:40: [0m[0;1;35mwarning: [0m[1mThe value '66' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1360 | { "@val_type_asc",      sort_up_value_type,     AVALUE|AASC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1360:40: [0m[0;1;36mnote: [0mThe value '66' provided to the cast expression is not in the valid range of values for the enum[0m
 1360 | { "@val_type_asc",      sort_up_value_type,     AVALUE|AASC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~
[0m[1marray.c:1361:43: [0m[0;1;35mwarning: [0m[1mThe value '130' provided to the cast expression is not in the valid range of values for the enum [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1361 | { "@val_type_desc",     sort_down_value_type,   AVALUE|ADESC },[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:1407:9: [0m[0;1;36mnote: [0menum declared here[0m
 1407 | typedef enum {[0m
      | [0;1;32m        ^~~~~~
[0m 1408 |         ANONE   = 0x00,         /* "unused" value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1409 |         AINDEX  = 0x001,        /* list of indices */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1410 |         AVALUE  = 0x002,        /* list of values */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1411 |         AINUM   = 0x004,        /* numeric index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1412 |         AISTR   = 0x008,        /* string index */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1413 |         AVNUM   = 0x010,        /* numeric scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1414 |         AVSTR   = 0x020,        /* string scalar value */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1415 |         AASC    = 0x040,        /* ascending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1416 |         ADESC   = 0x080,        /* descending order */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1417 |         ADELETE = 0x100         /* need a single index; for use in do_delete_loop */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1418 | } assoc_kind_t;[0m
      | [0;1;32m~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1361:43: [0m[0;1;36mnote: [0mThe value '130' provided to the cast expression is not in the valid range of values for the enum[0m
 1361 | { "@val_type_desc",     sort_down_value_type,   AVALUE|ADESC },[0m
      | [0;1;32m                                                ^~~~~~~~~~~~
[0m[1marray.c:1383:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1384 |                         break;[0m
      | [0;1;32m                              
[0m[1marray.c:1391:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1392 |                         assoc_kind &= ~(AASC|ADESC);[0m
      | [0;1;32m                                                    
[0m[1marray.c:1405:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1405 |                 for (sp = sort_str; *sp != '\0' && ! isspace((unsigned char) *sp); sp++)[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m 1406 |                         continue;[0m
      | [0;1;32m                                 
[0m[1marray.c:1409:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1409 |                 if (sp == sort_str || *sp != '\0')[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 1410 |                         fatal(_("`%s' is invalid as a function name"), sort_str);[0m
      | [0;1;32m                                                                                 
[0m[1marray.c:1413:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1413 |                 if (f == NULL || f->type != Node_func)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1414 |                         fatal(_("sort comparison function `%s' is not defined"), sort_str);[0m
      | [0;1;32m                                                                                           
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '11' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 11 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '11' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '19' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 19 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '19' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '35' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 35 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '35' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '7' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 7 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '7' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '71' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 71 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '71' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '75' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 75 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '75' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '83' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 83 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '83' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;35mwarning: [0m[1mThe value '99' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1marray.c:1005:9: [0m[0;1;36mnote: [0mCalling 'asort_actual'[0m
 1005 |         return asort_actual(nargs, ASORTI);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'ctxt' is not equal to ASORT[0m
  829 |         const char *name = (ctxt == ASORT ? "asort" : "asorti");        // D.R.Y.[0m
      | [0;1;32m                            ^~~~
[0m[1marray.c:829:22: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1marray.c:831:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:831:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  831 |         if (nargs == 3)  /* 3rd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:840:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1marray.c:840:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  840 |         if (s->stlen == 0) {            /* default sorting */[0m
      | [0;1;32m        ^
[0m[1marray.c:847:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is < 2[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1marray.c:847:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  847 |         if (nargs >= 2) {  /* 2nd optional arg */[0m
      | [0;1;32m        ^
[0m[1marray.c:857:13: [0m[0;1;36mnote: [0mField 'type' is equal to Node_var_array[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m                   ^
[0m[1marray.c:857:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  857 |         if (array->type != Node_var_array) {[0m
      | [0;1;32m        ^
[0m[1marray.c:860:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'symbol_table'[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:860:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  860 |         else if (array == symbol_table && dest == NULL)[0m
      | [0;1;32m                                       ^
[0m[1marray.c:862:11: [0m[0;1;36mnote: [0mAssuming 'array' is not equal to 'func_table'[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1marray.c:862:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  862 |         else if (array == func_table && dest == NULL)[0m
      | [0;1;32m                                     ^
[0m[1marray.c:865:6: [0m[0;1;36mnote: [0m'dest' is equal to NULL[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m            ^~~~
[0m[1marray.c:865:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  865 |         if (dest != NULL) {[0m
      | [0;1;32m        ^
[0m[1marray.c:886:9: [0m[0;1;36mnote: [0mCalling 'assoc_list'[0m
  886 |         list = assoc_list(array, sort_str, ctxt);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1382:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1382 |         for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1383:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1383 |                 if (strcmp(sort_funcs[qi].name, sort_str) == 0)[0m
      | [0;1;32m                ^
[0m[1marray.c:1384:4: [0m[0;1;36mnote: [0m Execution continues on line 1387[0m
 1384 |                         break;[0m
      | [0;1;32m                        ^
[0m[1marray.c:1387:6: [0m[0;1;36mnote: [0m'qi' is < 'j'[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m            ^~
[0m[1marray.c:1387:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1387 |         if (qi < j) {[0m
      | [0;1;32m        ^
[0m[1marray.c:1391:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1391:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1391 |                 if (symbol->array_funcs != & cint_array_func)[0m
      | [0;1;32m                ^
[0m[1marray.c:1394:7: [0m[0;1;36mnote: [0m'sort_ctxt' is not equal to SORTED_IN[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1marray.c:1394:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1394 |                 if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {[0m
      | [0;1;32m                                           ^
[0m[1marray.c:1397:4: [0m[0;1;36mnote: [0mThe value 99 is assigned to 'assoc_kind'[0m
 1397 |                         assoc_kind |= (AINDEX|AVALUE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1441:16: [0m[0;1;36mnote: [0mThe value '99' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
 1441 |         akind.flags = (unsigned int) assoc_kind;        /* kludge */[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1marray.c:1453:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1453 |                         for (j = 1; j < num_elems; j++)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1454 |                                 list[j] = list[2 * j];[0m
      | [0;1;32m                                                      
[0m163 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[48/54][236.2s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmp3ht4bqi7.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/eval.c
[1meval.c:213:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  213 |         if (loaded || do_traditional)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  214 |                 return;[0m
      | [0;1;32m                       
[0m[1meval.c:221:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  221 |                 if (isalpha(i) && islower(i) && i != toupper(i))[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  222 |                         casetable[i] = toupper(i);[0m
  223 |                 else[0m
      | [0;32m                } 
[0m[1meval.c:223:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  223 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  224 |                         casetable[i] = i;[0m
      | [0;1;32m                                         
[0m[1meval.c:402:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  402 |         if (type >= Node_illegal && type <= Node_final)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  403 |                 return nodetypes[(int) type];[0m
      | [0;1;32m                                             
[0m[1meval.c:405:2: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  405 |         sprintf(buf, _("unknown nodetype %d"), (int) type);[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:405:2: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  405 |         sprintf(buf, _("unknown nodetype %d"), (int) type);[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:414:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  414 |         if (op >= Op_illegal && op < Op_final)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  415 |                 return optypes[(int) op].desc;[0m
      | [0;1;32m                                              
[0m[1meval.c:426:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  426 |                 if (optypes[(int) op].operator != NULL)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  427 |                         return optypes[(int) op].operator;[0m
  428 |                 else[0m
      | [0;32m                } 
[0m[1meval.c:428:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  428 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  429 |                         fatal(_("opcode %s not an operator or keyword"),[0m
  430 |                                         optypes[(int) op].desc);[0m
      | [0;1;32m                                                                
[0m[1meval.c:431:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  431 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  432 |                 fatal(_("unknown opcode %d"), (int) op);[0m
      | [0;1;32m                                                        
[0m[1meval.c:487:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  487 |                         if (space_left <= space_needed)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  488 |                                 fatal(_("buffer overflow in genflags2str"));[0m
      | [0;1;32m                                                                            
[0m[1meval.c:494:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  494 |                         strcpy(sp, tab[i].name);[0m
      | [0;1;32m                        ^~~~~~
[0m[1meval.c:494:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  494 |                         strcpy(sp, tab[i].name);[0m
      | [0;1;32m                        ^~~~~~
[0m[1meval.c:529:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  529 |                         if (ret != 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  530 |                                 break;[0m
      | [0;1;32m                                      
[0m[1meval.c:537:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  537 |                                 if (p2 != s2->stptr + s2->stlen + 1)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  538 |                                         ret = -1;[0m
      | [0;1;32m                                                 
[0m[1meval.c:564:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  564 |                         if (ret != 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  565 |                                 break;[0m
      | [0;1;32m                                      
[0m[1meval.c:572:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  572 |                                 if (p2 != s2->wstptr + s2->wstlen + 1)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  573 |                                         ret = -1;[0m
      | [0;1;32m                                                 
[0m[1meval.c:596:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  596 |         if (t1 == t2)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  597 |                 return 0;[0m
      | [0;1;32m                         
[0m[1meval.c:602:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  602 |         if ((t1->flags & NUMBER) != 0 && (t2->flags & NUMBER) != 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  603 |                 return cmp_numbers(t1, t2);[0m
      | [0;1;32m                                           
[0m[1meval.c:610:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  610 |         if (len1 == 0 || len2 == 0)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  611 |                 return ldiff;[0m
      | [0;1;32m                             
[0m[1meval.c:613:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  613 |         if (do_posix && ! use_strcmp)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  614 |                 return posix_compare(t1, t2);[0m
      | [0;1;32m                                             
[0m[1meval.c:632:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  632 |                         for (ret = 0; l-- > 0 && ret == 0; cp1++, cp2++)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m  633 |                                 ret = casetable[*cp1] - casetable[*cp2];[0m
      | [0;1;32m                                                                        
[0m[1meval.c:635:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  635 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  636 |                 ret = memcmp(t1->stptr, t2->stptr, l);[0m
      | [0;1;32m                                                      
[0m[1meval.c:660:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  660 |         if (fcall_count > 1)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  661 |                 memmove(fcall_list + 2, fcall_list + 1, (fcall_count - 1) * sizeof(NODE *));[0m
      | [0;1;32m                                                                                            
[0m[1meval.c:661:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  661 |                 memmove(fcall_list + 2, fcall_list + 1, (fcall_count - 1) * sizeof(NODE *));[0m
      | [0;1;32m                ^~~~~~~
[0m[1meval.c:661:3: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  661 |                 memmove(fcall_list + 2, fcall_list + 1, (fcall_count - 1) * sizeof(NODE *));[0m
      | [0;1;32m                ^~~~~~~
[0m[1meval.c:671:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  671 |         if (fcall_count > 1)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  672 |                 memmove(fcall_list + 1, fcall_list + 2, (fcall_count - 1) * sizeof(NODE *));[0m
      | [0;1;32m                                                                                            
[0m[1meval.c:672:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  672 |                 memmove(fcall_list + 1, fcall_list + 2, (fcall_count - 1) * sizeof(NODE *));[0m
      | [0;1;32m                ^~~~~~~
[0m[1meval.c:672:3: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  672 |                 memmove(fcall_list + 1, fcall_list + 2, (fcall_count - 1) * sizeof(NODE *));[0m
      | [0;1;32m                ^~~~~~~
[0m[1meval.c:675:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  675 |         if (do_debug)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  676 |                 frame_popped();[0m
      | [0;1;32m                               
[0m[1meval.c:688:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  688 |         if (fcall_count == 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  689 |                 return;[0m
      | [0;1;32m                       
[0m[1meval.c:690:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  690 |         fprintf(fp, _("\n\t# Function Call Stack:\n\n"));[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:690:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  690 |         fprintf(fp, _("\n\t# Function Call Stack:\n\n"));[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:694:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  694 |         fprintf(fp, "\t# %3ld. %s\n", k++, func->vname);[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:694:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  694 |         fprintf(fp, "\t# %3ld. %s\n", k++, func->vname);[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:700:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  700 |                 fprintf(fp, "\t# %3ld. %s\n", k++, func->vname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1meval.c:700:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  700 |                 fprintf(fp, "\t# %3ld. %s\n", k++, func->vname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1meval.c:703:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  703 |         fprintf(fp, "\t# %3ld. -- main --\n", k);[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:703:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  703 |         fprintf(fp, "\t# %3ld. -- main --\n", k);[0m
      | [0;1;32m        ^~~~~~~
[0m[1meval.c:719:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  719 |         if (do_traditional)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  720 |                 IGNORECASE = false;[0m
  721 |         else[0m
      | [0;32m        } 
[0m[1meval.c:721:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  721 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  722 |                 IGNORECASE = boolval(IGNORECASE_node->var_value);[0m
      | [0;1;32m                                                                 
[0m[1meval.c:739:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  739 |         if (do_traditional)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  740 |                 BINMODE = TEXT_TRANSLATE;[0m
  741 |         else if ((v->flags & NUMBER) != 0) {[0m
      | [0;32m        } 
[0m[1meval.c:744:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  744 |                 if (BINMODE < TEXT_TRANSLATE)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  745 |                         BINMODE = TEXT_TRANSLATE;[0m
  746 |                 else if (BINMODE > BINMODE_BOTH)[0m
      | [0;32m                } 
[0m[1meval.c:746:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  746 |                 else if (BINMODE > BINMODE_BOTH)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  747 |                         BINMODE = BINMODE_BOTH;[0m
      | [0;1;32m                                               
[0m[1meval.c:759:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  759 |                         switch (p[0]) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1meval.c:765:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  765 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1meval.c:767:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  767 |                                 BINMODE = BINMODE_INPUT;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  768 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1meval.c:770:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  770 |                                 BINMODE = BINMODE_OUTPUT;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  771 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1meval.c:773:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  773 |                                 BINMODE = BINMODE_BOTH;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  774 |                                 goto bad_value;[0m
  775 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1meval.c:779:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  779 |                         switch (p[0]) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  780 |                         case 'r':[0m
  781 |                                 BINMODE = BINMODE_BOTH;[0m
  782 |                                 if (p[1] != 'w')[0m
  783 |                                         goto bad_value;[0m
  784 |                                 break;[0m
  785 |                         case 'w':[0m
  786 |                                 BINMODE = BINMODE_BOTH;[0m
  787 |                                 if (p[1] != 'r')[0m
  788 |                                         goto bad_value;[0m
  789 |                                 break;[0m
  790 |                         }[0m
  791 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:781:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  781 |                                 BINMODE = BINMODE_BOTH;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  782 |                                 if (p[1] != 'w')[0m
  783 |                                         goto bad_value;[0m
  784 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1meval.c:782:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  782 |                                 if (p[1] != 'w')[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  783 |                                         goto bad_value;[0m
      | [0;1;32m                                                       
[0m[1meval.c:786:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  786 |                                 BINMODE = BINMODE_BOTH;[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m  787 |                                 if (p[1] != 'r')[0m
  788 |                                         goto bad_value;[0m
  789 |                                 break;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1meval.c:787:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  787 |                                 if (p[1] != 'r')[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  788 |                                         goto bad_value;[0m
      | [0;1;32m                                                       
[0m[1meval.c:793:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  793 |         bad_value:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m  794 |                         lintwarn(_("BINMODE value `%s' is invalid, treated as 3"), p);[0m
  795 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:797:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  797 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  798 |                 BINMODE = 3;            /* shouldn't happen */[0m
      | [0;1;32m                                                              
[0m[1meval.c:809:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  809 |         if (first)      /* true when called from init_vars() in main() */[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  810 |                 first = false;[0m
  811 |         else {[0m
      | [0;32m        } 
[0m[1meval.c:828:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  828 |         if (OFS == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  829 |                 emalloc(OFS, char *, new_ofs_len + 1, "set_OFS");[0m
  830 |         else if (OFSlen < new_ofs_len)[0m
      | [0;32m        } 
[0m[1meval.c:830:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  830 |         else if (OFSlen < new_ofs_len)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  831 |                 erealloc(OFS, char *, new_ofs_len + 1, "set_OFS");[0m
      | [0;1;32m                                                                  
[0m[1meval.c:833:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  833 |         memcpy(OFS, OFS_node->var_value->stptr, OFS_node->var_value->stlen);[0m
      | [0;1;32m        ^~~~~~
[0m[1meval.c:833:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  833 |         memcpy(OFS, OFS_node->var_value->stptr, OFS_node->var_value->stlen);[0m
      | [0;1;32m        ^~~~~~
[0m[1meval.c:873:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  873 |         if (*p++ != '%')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  874 |                 return 0;[0m
      | [0;1;32m                         
[0m[1meval.c:875:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  875 |         while (*p && strchr(flags, *p) != NULL) /* flags */[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  876 |                 p++;[0m
      | [0;1;32m                    
[0m[1meval.c:877:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  877 |         while (*p && isdigit((unsigned char) *p))       /* width - %*.*g is NOT allowed */[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  878 |                 p++;[0m
      | [0;1;32m                    
[0m[1meval.c:879:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  879 |         if (*p == '\0' || (*p != '.' && ! isdigit((unsigned char) *p)))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  880 |                 return 0;[0m
      | [0;1;32m                         
[0m[1meval.c:881:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  881 |         if (*p == '.')[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  882 |                 p++;[0m
      | [0;1;32m                    
[0m[1meval.c:883:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  883 |         while (*p && isdigit((unsigned char) *p))       /* precision */[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  884 |                 p++;[0m
      | [0;1;32m                    
[0m[1meval.c:885:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  885 |         if (*p == '\0' || strchr(float_formats, *p) == NULL)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  886 |                 return 0;[0m
      | [0;1;32m                         
[0m[1meval.c:887:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  887 |         if (*++p != '\0')[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  888 |                 return 0;[0m
      | [0;1;32m                         
[0m[1meval.c:902:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  902 |         if (fmt_list == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  903 |                 emalloc(fmt_list, NODE **, fmt_num*sizeof(*fmt_list), "fmt_index");[0m
      | [0;1;32m                                                                                   
[0m[1meval.c:910:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  910 |                 if (cmp_nodes(fmt_list[ix], n, true) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  911 |                         return ix;[0m
      | [0;1;32m                                  
[0m[1meval.c:916:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  916 |         if (do_lint && ! fmt_ok(n))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  917 |                 lintwarn(_("bad `%sFMT' specification `%s'"),[0m
  918 |                             n == CONVFMT_node->var_value ? "CONV"[0m
  919 |                           : n == OFMT_node->var_value ? "O"[0m
  920 |                           : "", n->stptr);[0m
      | [0;1;32m                                          
[0m[1meval.c:970:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  970 |                         if (lintlen == 7 && strncmp(lintval, "invalid", 7) == 0)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m  971 |                                 do_flags |= DO_LINT_INVALID;[0m
  972 |                         else if (lintlen == 6 && strncmp(lintval, "no-ext", 6) == 0)[0m
      | [0;32m                        } 
[0m[1meval.c:972:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  972 |                         else if (lintlen == 6 && strncmp(lintval, "no-ext", 6) == 0)[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m  973 |                                 do_flags &= ~DO_LINT_EXTENSIONS;[0m
  974 |                         else {[0m
      | [0;32m                        } 
[0m[1meval.c:976:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  976 |                                 if (lintlen == 5 && strncmp(lintval, "fatal", 5) == 0)[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m  977 |                                         lintfunc = r_fatal;[0m
      | [0;1;32m                                                           
[0m[1meval.c:981:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  981 |                 if (! is_zero(n))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  982 |                         do_flags |= DO_LINT_ALL;[0m
      | [0;1;32m                                                
[0m[1meval.c:986:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  986 |         if (old_lint != do_lint && old_lint && ! do_lint)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  987 |                 warning(_("turning off `--lint' due to assignment to `LINT'"));[0m
      | [0;1;32m                                                                               
[0m[1meval.c:1020:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1020 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1021 |                 cp = "";[0m
      | [0;1;32m                        
[0m[1meval.c:1087:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1087 |                 if (NF == -1)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1088 |                         (void) get_field(UNLIMITED - 1, NULL); /* parse record */[0m
      | [0;1;32m                                                                                 
[0m[1meval.c:1156:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1156 |                 fatal(_("attempt to use array `%s' in a scalar context"),[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1157 |                                 array_vname(n));[0m
 1158 |                 return NULL;    // silence compiler warnings[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1m./awk.h:1388:16: [0m[0;1;36mnote: [0mexpanded from macro 'fatal'[0m
 1388 | #define fatal           (*(set_loc(__FILE__, __LINE__), r_fatal))[0m
      | [0;1;32m                        ^
[0m[1meval.c:1160:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1160 |                 if (n->orig_array->type == Node_var_array)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1161 |                         fatal(_("attempt to use array `%s' in a scalar context"),[0m
 1162 |                                         array_vname(n));[0m
 1163 |                 if (n->orig_array->type != Node_var) {[0m
 1164 |                         n->orig_array->type = Node_var;[0m
 1165 |                         n->orig_array->var_value = dupnode(Nnull_string);[0m
 1166 |                 }[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1meval.c:1160:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1160 |                 if (n->orig_array->type == Node_var_array)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1161 |                         fatal(_("attempt to use array `%s' in a scalar context"),[0m
 1162 |                                         array_vname(n));[0m
      | [0;1;32m                                                        
[0m[1meval.c:1169:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1169 |                 n->type = Node_var;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1170 |                 n->var_value = dupnode(Nnull_string);[0m
 1171 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1174:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1174 |                 efree(n->stptr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1175 |                 n->stptr = NULL;[0m
 1176 |                 n->stlen = 0;[0m
 1177 |                 n->type = Node_var;[0m
 1178 |                 n->var_value = dupnode(Nnull_string);[0m
 1179 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1m./awk.h:1386:18: [0m[0;1;36mnote: [0mexpanded from macro 'efree'[0m
 1386 | #define efree(p)        free(p)[0m
      | [0;1;32m                        ^
[0m[1m./custom.h:133:14: [0m[0;1;36mnote: [0mexpanded from macro 'free'[0m
  133 | #define free    pma_free[0m
      | [0;1;32m                ^
[0m[1meval.c:1182:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1182 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1meval.c:1185:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1185 |                 cant_happen("unexpected variable type %s", nodetype2str(n->type));[0m
      | [0;1;32m                ^                                                                
[0m      | [0;32m                {                                                                ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1meval.c:1188:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1188 |         if (do_lint && reference && var_uninitialized(n))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1189 |                 lintwarn((isparam ?[0m
 1190 |                         _("reference to uninitialized argument `%s'") :[0m
 1191 |                         _("reference to uninitialized variable `%s'")),[0m
 1192 |                                 n->vname);[0m
      | [0;1;32m                                          
[0m[1meval.c:1205:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1205 |         if (assign)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 1206 |                 *assign = NULL;[0m
      | [0;1;32m                               
[0m[1meval.c:1210:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1210 |                         if (n->stlen == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1211 |                                 lintwarn(_("attempt to field reference from null string"));[0m
      | [0;1;32m                                                                                           
[0m[1meval.c:1218:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1218 |         if (field_num < 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1219 |                 fatal(_("attempt to access field %ld"), field_num);[0m
      | [0;1;32m                                                                   
[0m[1meval.c:1223:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1223 |                 if (assign)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1224 |                         *assign = reset_record;[0m
      | [0;1;32m                                               
[0m[1meval.c:1225:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1225 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1226 |                 lhs = get_field(field_num, assign);[0m
      | [0;1;32m                                                   
[0m[1meval.c:1227:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1227 |         if (do_lint && reference && ((*lhs)->flags & NULL_FIELD) != 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1228 |                 lintwarn(_("reference to uninitialized field `$%ld'"),[0m
 1229 |                               field_num);[0m
      | [0;1;32m                                         
[0m[1meval.c:1245:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1245 |                 if ((n % 2) == 1)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1246 |                         mult *= x;[0m
      | [0;1;32m                                  
[0m[1meval.c:1261:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1261 |                 if (lx == 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1262 |                         return 1;[0m
      | [0;1;32m                                 
[0m[1meval.c:1296:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1296 |                         if (r->type == Node_val)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1297 |                                 DEREF(r);[0m
      | [0;1;32m                                         
[0m[1meval.c:1303:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1303 |                 memset(r, 0, sizeof(NODE));[0m
      | [0;1;32m                ^~~~~~
[0m[1meval.c:1303:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1303 |                 memset(r, 0, sizeof(NODE));[0m
      | [0;1;32m                ^~~~~~
[0m[1meval.c:1315:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1315 |                 if (m->type == Node_param_list)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1316 |                         m = GET_PARAM(m->param_cnt);[0m
      | [0;1;32m                                                    
[0m[1meval.c:1329:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1329 |                         r->orig_array = r->prev_array = m;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1330 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1333:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1333 |                         r->type = Node_array_ref;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1334 |                         r->orig_array = m->orig_array;[0m
 1335 |                         r->prev_array = m;[0m
 1336 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1343:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1343 |                         r->type = Node_var;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1344 |                         r->var_value = dupnode(Nnull_string);[0m
 1345 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1348:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1348 |                         r->type = Node_var;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1349 |                         r->var_value = m;[0m
 1350 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1356:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1356 |                         r->var_value = make_string(m->vname, strlen(m->vname));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1357 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1360:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1360 |                         cant_happen("unexpected parameter type %s", nodetype2str(m->type));[0m
      | [0;1;32m                        ^                                                                 
[0m      | [0;32m                        {                                                                 ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1meval.c:1374:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1374 |         if (do_profile || do_debug)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1375 |                 push_frame(frame_ptr);[0m
      | [0;1;32m                                      
[0m[1meval.c:1410:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1410 |                 if (r->type == Node_var)     /* local variable */[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1411 |                         DEREF(r->var_value);[0m
 1412 |                 else if (r->type == Node_var_array)     /* local array */[0m
      | [0;32m                } 
[0m[1meval.c:1412:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1412 |                 else if (r->type == Node_var_array)     /* local array */[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1413 |                         assoc_clear(r);[0m
      | [0;1;32m                                       
[0m[1meval.c:1417:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1417 |         if (frame_ptr->stack != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1418 |                 efree(frame_ptr->stack);[0m
      | [0;1;32m                                        
[0m[1meval.c:1423:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1423 |         if (do_profile || do_debug)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1424 |                 pop_frame();[0m
      | [0;1;32m                            
[0m[1meval.c:1467:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1467 |         if (stack_empty())[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1468 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1meval.c:1472:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1472 |         if (stack_ptr < sp)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1473 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1meval.c:1478:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1478 |                         cp = restore_frame(r);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1479 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1481:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1481 |                         free_arrayfor(r);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1482 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1484:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1484 |                         DEREF(r);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1485 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1487:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1487 |                         freenode(r);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1488 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1m./awk.h:1367:21: [0m[0;1;36mnote: [0mexpanded from macro 'freenode'[0m
 1367 | #define freenode(n)     freeblock(n, BLOCK_NODE)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1361:27: [0m[0;1;36mnote: [0mexpanded from macro 'freeblock'[0m
 1361 | #define freeblock(p, id)         (void) (((struct block_item *) p)->freep = nextfree[id].freep, \[0m
      | [0;1;32m                                 ^
[0m[1meval.c:1496:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1496 |                         if (in_main_context() && ! exiting)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1497 |                                 fatal(_("unwind_stack: unexpected type `%s'"),[0m
 1498 |                                                 nodetype2str(r->type));[0m
 1499 |                         /* else[0m
 1500 |                                 * Node_var_array,[0m
 1501 |                                 * Node_param_list,[0m
 1502 |                                 * Node_var (e.g: trying to use scalar for array)[0m
 1503 |                                 * Node_regex/Node_dynregex[0m
 1504 |                                 * ?[0m
 1505 |                          */[0m
 1506 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1496:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1496 |                         if (in_main_context() && ! exiting)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1497 |                                 fatal(_("unwind_stack: unexpected type `%s'"),[0m
 1498 |                                                 nodetype2str(r->type));[0m
      | [0;1;32m                                                                       
[0m[1meval.c:1509:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1509 |                 if (stack_ptr < sp)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1510 |                         break;[0m
      | [0;1;32m                              
[0m[1meval.c:1526:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1526 |         if (t == node_Boolean[false])[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1527 |                 return false;[0m
      | [0;1;32m                             
[0m[1meval.c:1529:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1529 |         if (t == node_Boolean[true])[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1530 |                 return true;[0m
      | [0;1;32m                            
[0m[1meval.c:1564:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1564 |                         ret = (di == 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1565 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1567:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1567 |                         ret = (di != 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1568 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1570:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1570 |                         ret = (di < 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1571 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1573:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1573 |                         ret = (di <= 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1574 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1576:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1576 |                         ret = (di > 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1577 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1579:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1579 |                         ret = (di >= 0);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1580 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1meval.c:1614:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1614 |         if ((t1_nan || t2_nan) && comparison_type != SCALAR_NEQ)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 1615 |                 return false;[0m
      | [0;1;32m                             
[0m[1meval.c:1619:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1619 |                 ret = (t1->numbr == t2->numbr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1620 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1622:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1622 |                 ret = (t1->numbr != t2->numbr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1623 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1625:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1625 |                 ret = (t1->numbr < t2->numbr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1626 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1628:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1628 |                 ret = (t1->numbr <= t2->numbr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1629 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1631:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1631 |                 ret = (t1->numbr > t2->numbr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1632 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1634:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1634 |                 ret = (t1->numbr >= t2->numbr);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1635 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1661:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1661 |                 x = x1 + x2;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1662 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1664:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1664 |                 x = x1 - x2;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1665 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1667:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1667 |                 x = x1 * x2;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1668 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1670:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1670 |                 if (x2 == (AWKNUM) 0) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1671 |                         decr_sp();[0m
 1672 |                         fatal(_("division by zero attempted in `/='"));[0m
 1673 |                 }[0m
 1674 |                 x = x1 / x2;[0m
 1675 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1677:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1677 |                 if (x2 == (AWKNUM) 0) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1678 |                         decr_sp();[0m
 1679 |                         fatal(_("division by zero attempted in `%%='"));[0m
 1680 |                 }[0m
 1681 | #ifdef HAVE_FMOD[0m
 1682 |                 x = fmod(x1, x2);[0m
 1683 | #else   /* ! HAVE_FMOD */[0m
 1684 |                 (void) modf(x1 / x2, &x);[0m
 1685 |                 x = x1 - x2 * x;[0m
 1686 | #endif  /* ! HAVE_FMOD */[0m
 1687 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1689:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1689 |                 x = calc_exp((double) x1, (double) x2);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1690 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1meval.c:1692:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1692 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1meval.c:1788:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1788 |         if (es == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1789 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1meval.c:1791:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1791 |         if (rule != NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1792 |                 *rule = es->rule;[0m
      | [0;1;32m                                 
[0m[1meval.c:1793:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1793 |         if (src != NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1794 |                 *src = (char *) es->source;[0m
      | [0;1;32m                                           
[0m[1meval.c:1795:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1795 |         if (sz != NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1796 |                 *sz = es->stack_size;[0m
      | [0;1;32m                                     
[0m[1meval.c:1815:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1815 |         if (! preh || (post_execute && posth))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1816 |                 return false;[0m
      | [0;1;32m                             
[0m[1meval.c:1818:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1818 |         if (num_exec_hook == MAX_EXEC_HOOKS)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1819 |                 return false;[0m
      | [0;1;32m                             
[0m[1meval.c:1827:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1827 |                 if (num_exec_hook > pos)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1828 |                         memmove(pre_execute + pos + 1, pre_execute + pos,[0m
 1829 |                                         (num_exec_hook - pos) * sizeof (preh));[0m
      | [0;1;32m                                                                               
[0m[1meval.c:1828:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1828 |                         memmove(pre_execute + pos + 1, pre_execute + pos,[0m
      | [0;1;32m                        ^~~~~~~
[0m[1meval.c:1828:4: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
 1828 |                         memmove(pre_execute + pos + 1, pre_execute + pos,[0m
      | [0;1;32m                        ^~~~~~~
[0m[1meval.c:1834:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1834 |         if (posth)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1835 |                 post_execute = posth;[0m
      | [0;1;32m                                     
[0m[1meval.c:1857:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1857 |         if ((newval = getenv_long("GAWK_STACKSIZE")) > 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1858 |                 STACK_SIZE = newval;[0m
      | [0;1;32m                                    
[0m[1meval.c:1885:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1885 |         if (num_exec_hook > 0)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1886 |                 interpret = h_interpret;[0m
 1887 |         else[0m
      | [0;32m        } 
[0m[1meval.c:1887:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1887 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1888 |                 interpret = r_interpret;[0m
      | [0;1;32m                                        
[0m[1meval.c:1896:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1896 |         if (n->type != Node_elem_new)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1897 |                 return n;[0m
      | [0;1;32m                         
[0m[1meval.c:1918:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1918 |         if (isnan(left) && signbit(left))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1919 |                 return copysign(result, -1.0);[0m
 1920 |         else if (isnan(right) && signbit(right))[0m
      | [0;32m        } 
[0m[1meval.c:1920:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1920 |         else if (isnan(right) && signbit(right))[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1921 |                 return copysign(result, -1.0);[0m
 1922 |         else[0m
      | [0;32m        } 
[0m[1meval.c:1922:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1922 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1923 |                 return result;[0m
      | [0;1;32m                              
[0m520 warnings generated.
Suppressed 373 warnings (373 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[49/54][262.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpk718yab8.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/cint_array.c
[1mcint_array.c:175:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  175 |                 if ((newval = getenv_long("NHAT")) > 1 && newval < INT32_BIT)[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m  176 |                         NHAT = newval;[0m
      | [0;1;32m                                      
[0m[1mcint_array.c:178:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  178 |                 if (NHAT > nelems - 2)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  179 |                         NHAT = nelems - 2;[0m
      | [0;1;32m                                          
[0m[1mcint_array.c:181:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  181 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  182 |                 null_array(symbol);[0m
      | [0;1;32m                                   
[0m[1mcint_array.c:193:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  193 |         if (is_integer(symbol, subs) != NULL && subs->numbr >= 0)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  194 |                 return & success_node;[0m
      | [0;1;32m                                      
[0m[1mcint_array.c:214:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  214 |                 if ((lhs = cint_find(symbol, k, h1)) != NULL)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  215 |                         return lhs;[0m
      | [0;1;32m                                   
[0m[1mcint_array.c:218:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  218 |         if (xn != NULL && (lhs = xn->aexists(xn, subs)) != NULL)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  219 |                 return lhs;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:223:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  223 |         if (k < 0)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  224 |                 goto xinstall;[0m
      | [0;1;32m                              
[0m[1mcint_array.c:241:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  241 |         if ((capacity - cint_size) > THRESHOLD)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  242 |                 goto xinstall;[0m
      | [0;1;32m                              
[0m[1mcint_array.c:260:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  260 |         if (m < NHAT)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  261 |                 return tree_lookup(symbol, tn, k, NHAT, 0);[0m
      | [0;1;32m                                                           
[0m[1mcint_array.c:276:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  276 |                 if (is_integer(xn, subs))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  277 |                         xn->array_funcs = & int_array_func;[0m
  278 |                 else[0m
      | [0;32m                } 
[0m[1mcint_array.c:278:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  278 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  279 |                         xn->array_funcs = & str_array_func;[0m
      | [0;1;32m                                                           
[0m[1mcint_array.c:296:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  296 |                 if ((lhs = cint_find(symbol, k, cint_hash(k))) != NULL)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  297 |                         return lhs;[0m
      | [0;1;32m                                   
[0m[1mcint_array.c:299:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  299 |         if ((xn = symbol->xarray) == NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  300 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:345:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  345 |         if (symbol->table_size == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  346 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:348:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  348 |         if (! ISUINT(symbol, subs))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  349 |                 goto xremove;[0m
      | [0;1;32m                             
[0m[1mcint_array.c:356:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  356 |         if (tn == NULL || ! tree_remove(symbol, tn, k))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  357 |                 goto xremove;[0m
      | [0;1;32m                             
[0m[1mcint_array.c:383:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  383 |         if (xn == NULL || xn->aremove(xn, subs) == NULL)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  384 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:411:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  411 |                 if (old[i] == NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  412 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:424:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  424 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  425 |                 newsymb->xarray = NULL;[0m
      | [0;1;32m                                       
[0m[1mcint_array.c:449:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  449 |         if (num_elems == 0)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  450 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:452:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  452 |         if ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  453 |                 num_elems = 1;[0m
      | [0;1;32m                              
[0m[1mcint_array.c:455:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  455 |         if ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  456 |                 elem_size = 2;[0m
      | [0;1;32m                              
[0m[1mcint_array.c:465:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  465 |                 if (num_elems == 1 || num_elems == xn->table_size)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  466 |                         return list;[0m
      | [0;1;32m                                    
[0m[1mcint_array.c:469:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  469 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  470 |                 emalloc(list, NODE **, list_size * sizeof(NODE *), "cint_list");[0m
      | [0;1;32m                                                                                
[0m[1mcint_array.c:483:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  483 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  484 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:486:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  486 |                 if (k >= list_size)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  487 |                         return list;[0m
      | [0;1;32m                                    
[0m[1mcint_array.c:514:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  514 |         if ((symbol->flags & XARRAY) == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  515 |                 fprintf(output_fp, "%s `%s'\n",[0m
  516 |                         (symbol->parent_array == NULL) ? "array" : "sub-array",[0m
  517 |                         array_vname(symbol));[0m
      | [0;1;32m                                             
[0m[1mcint_array.c:515:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  515 |                 fprintf(output_fp, "%s `%s'\n",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:515:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  515 |                 fprintf(output_fp, "%s `%s'\n",[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:520:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  520 |         fprintf(output_fp, "array_func: cint_array_func\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:520:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  520 |         fprintf(output_fp, "array_func: cint_array_func\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:523:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  523 |                 fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:523:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  523 |                 fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:526:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  526 |         fprintf(output_fp, "NHAT: %d\n", NHAT);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:526:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  526 |         fprintf(output_fp, "NHAT: %d\n", NHAT);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:528:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  528 |         fprintf(output_fp, "THRESHOLD: %ld\n", THRESHOLD);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:528:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  528 |         fprintf(output_fp, "THRESHOLD: %ld\n", THRESHOLD);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:530:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  530 |         fprintf(output_fp, "table_size: %lu (total), %ld (cint), %ld (int + str)\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:530:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  530 |         fprintf(output_fp, "table_size: %lu (total), %ld (cint), %ld (int + str)\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:533:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  533 |         fprintf(output_fp, "array_capacity: %lu\n", (unsigned long) symbol->array_capacity);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:533:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  533 |         fprintf(output_fp, "array_capacity: %lu\n", (unsigned long) symbol->array_capacity);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:535:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  535 |         fprintf(output_fp, "Load Factor: %.2g\n", (AWKNUM) cint_size / symbol->array_capacity);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:535:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  535 |         fprintf(output_fp, "Load Factor: %.2g\n", (AWKNUM) cint_size / symbol->array_capacity);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:539:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  539 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  540 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:547:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  547 |                 if (xn->array_funcs == & int_array_func)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  548 |                         kb += int_kilobytes(xn);[0m
  549 |                 else[0m
      | [0;32m                } 
[0m[1mcint_array.c:549:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  549 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  550 |                         kb += str_kilobytes(xn);[0m
      | [0;1;32m                                                
[0m[1mcint_array.c:554:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  554 |         fprintf(output_fp, "memory: %.2g kB (total)\n", kb);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:554:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  554 |         fprintf(output_fp, "memory: %.2g kB (total)\n", kb);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mcint_array.c:561:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  561 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:561:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  561 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:565:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  565 |                         if (tn != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  566 |                                 tree_info(tn, ndump, aname);[0m
      | [0;1;32m                                                            
[0m[1mcint_array.c:571:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  571 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:571:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  571 |                 fprintf(output_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mcint_array.c:592:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  592 |         if (k == 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  593 |                 return NHAT;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:635:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  635 |         if (r < NHAT)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  636 |                 return NHAT;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:649:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  649 |         if (symbol->nodes == NULL || (tn = symbol->nodes[h1]) == NULL)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  650 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:732:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  732 |         memset(n, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1mcint_array.c:732:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  732 |         memset(n, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1mcint_array.c:767:22: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  767 |                 tree->table_size = 0;   /* # of elements in the array */[0m
      | [0;1;32m                                   ^
[0m[1m./awk.h:360:9: [0m[0;1;36mnote: [0menum declared here[0m
  360 |                         enum reflagvals {[0m
      | [0;1;32m                        ~~~~~^~~~~~~~~~~~
[0m  361 |                                 CONSTANT = 1,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  362 |                                 FS_DFLT  = 2,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  363 |                         } reflags;[0m
      | [0;1;32m                        ~
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:24: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:24: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                          ^
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:54: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                                                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:23: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                         ^
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mAssuming field 'fltnum' is >= 0[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:134:40: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  134 |                                     && (s)->numbr >= 0)[0m
      | [0;1;32m                                       ^~~~~~~~~~~~~~~
[0m[1mcint_array.c:211:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:214:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  214 |                 if ((lhs = cint_find(symbol, k, h1)) != NULL)[0m
      | [0;1;32m                ^
[0m[1mcint_array.c:218:6: [0m[0;1;36mnote: [0mAssuming 'xn' is equal to NULL[0m
  218 |         if (xn != NULL && (lhs = xn->aexists(xn, subs)) != NULL)[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mcint_array.c:218:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  218 |         if (xn != NULL && (lhs = xn->aexists(xn, subs)) != NULL)[0m
      | [0;1;32m                       ^
[0m[1mcint_array.c:223:6: [0m[0;1;36mnote: [0mAssuming 'k' is >= 0[0m
  223 |         if (k < 0)[0m
      | [0;1;32m            ^~~~~
[0m[1mcint_array.c:223:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  223 |         if (k < 0)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:231:7: [0m[0;1;36mnote: [0mAssuming 'm' is <= 'NHAT'[0m
  231 |         li = m > NHAT ? m : NHAT;[0m
      | [0;1;32m             ^~~~~~~~
[0m[1mcint_array.c:231:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mcint_array.c:232:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  232 |         while (li >= NHAT) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:232:9: [0m[0;1;36mnote: [0mAssuming 'li' is < 'NHAT'[0m
  232 |         while (li >= NHAT) {[0m
      | [0;1;32m               ^~~~~~~~~~
[0m[1mcint_array.c:232:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 236[0m
  232 |         while (li >= NHAT) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:238:15: [0m[0;1;36mnote: [0m'xn' is equal to NULL[0m
  238 |         cint_size = (xn == NULL) ? symbol->table_size[0m
      | [0;1;32m                     ^~
[0m[1mcint_array.c:238:14: [0m[0;1;36mnote: [0m'?' condition is true[0m
  238 |         cint_size = (xn == NULL) ? symbol->table_size[0m
      | [0;1;32m                    ^
[0m[1mcint_array.c:241:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  241 |         if ((capacity - cint_size) > THRESHOLD)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:241:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  241 |         if ((capacity - cint_size) > THRESHOLD)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:244:14: [0m[0;1;36mnote: [0mField 'av' is not equal to NULL[0m
  244 |         if (symbol->nodes == NULL) {[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:544:28: [0m[0;1;36mnote: [0mexpanded from macro 'nodes'[0m
  544 | #define nodes           sub.nodep.r.av[0m
      | [0;1;32m                                    ^
[0m[1mcint_array.c:244:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  244 |         if (symbol->nodes == NULL) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:255:6: [0m[0;1;36mnote: [0mAssuming 'tn' is not equal to NULL[0m
  255 |         if (tn == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mcint_array.c:255:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  255 |         if (tn == NULL) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:260:6: [0m[0;1;36mnote: [0m'm' is >= 'NHAT'[0m
  260 |         if (m < NHAT)[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:260:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  260 |         if (m < NHAT)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:262:9: [0m[0;1;36mnote: [0mCalling 'tree_lookup'[0m
  262 |         return tree_lookup(symbol, tn, k, m, power_two_table[m]);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:757:6: [0m[0;1;36mnote: [0mAssuming field 'reflags' is equal to 0[0m
  757 |         if (tree->table_size == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:757:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  757 |         if (tree->table_size == 0) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:767:22: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals'[0m
  767 |                 tree->table_size = 0;   /* # of elements in the array */[0m
      | [0;1;32m                                   ^
[0m[1mcint_array.c:775:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  775 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  776 |                 size = tree->array_size;[0m
      | [0;1;32m                                        
[0m[1mcint_array.c:782:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  782 |         if ((lhs = tree_find(tree, k, i)) != NULL)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  783 |                 return lhs;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:791:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  791 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  792 |                         tn = tree->nodes[i] = make_node(Node_array_tree);[0m
      | [0;1;32m                                                                         
[0m[1mcint_array.c:795:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  795 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  796 |                         tn = tree->nodes[i] = make_node(Node_array_leaf);[0m
      | [0;1;32m                                                                         
[0m[1mcint_array.c:813:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  813 |         if (tn == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  814 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mcint_array.c:815:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  815 |         if (tn->type == Node_array_tree)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  816 |                 return tree_exists(tn, k);[0m
      | [0;1;32m                                          
[0m[1mcint_array.c:829:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  829 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  830 |                 hsize /= 2;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:834:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  834 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  835 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:836:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  836 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  837 |                         tree_clear(tn);[0m
  838 |                 else[0m
      | [0;32m                } 
[0m[1mcint_array.c:838:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  838 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  839 |                         leaf_clear(tn);[0m
      | [0;1;32m                                       
[0m[1mcint_array.c:844:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  844 |         memset(tree, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1mcint_array.c:844:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  844 |         memset(tree, '\0', sizeof(NODE));[0m
      | [0;1;32m        ^~~~~~
[0m[1mcint_array.c:860:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  860 |         if (tn == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  861 |                 return false;[0m
      | [0;1;32m                             
[0m[1mcint_array.c:864:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  864 |                         && ! tree_remove(symbol, tn, k))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  865 |                 return false;[0m
  866 |         else if (tn->type == Node_array_leaf[0m
      | [0;32m        } 
[0m[1mcint_array.c:867:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  867 |                         && ! leaf_remove(symbol, tn, k))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  868 |                 return false;[0m
      | [0;1;32m                             
[0m[1mcint_array.c:878:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  878 |                 memset(tree, '\0', sizeof(NODE));[0m
      | [0;1;32m                ^~~~~~
[0m[1mcint_array.c:878:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  878 |                 memset(tree, '\0', sizeof(NODE));[0m
      | [0;1;32m                ^~~~~~
[0m[1mcint_array.c:895:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  895 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  896 |                         return tree_exists(tn, k);[0m
      | [0;1;32m                                                  
[0m[1mcint_array.c:915:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  915 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  916 |                 hsize /= 2;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:921:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  921 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  922 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:923:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  923 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  924 |                         k += tree_list(tn, list + k, assoc_kind);[0m
  925 |                 else[0m
      | [0;32m                } 
[0m[1mcint_array.c:925:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  925 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  926 |                         k += leaf_list(tn, list + k, assoc_kind);[0m
      | [0;1;32m                                                                 
[0m[1mcint_array.c:927:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  927 |                 if ((assoc_kind & ADELETE) != 0 && k >= 1)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  928 |                         return k;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:943:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  943 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  944 |                 hsize /= 2;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:955:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  955 |                 if (old[j] == NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  956 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:977:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  977 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  978 |                 hsize /= 2;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:982:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  982 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  983 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:984:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  984 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  985 |                         tree_info(tn, ndump, aname);[0m
  986 |                 else[0m
      | [0;32m                } 
[0m[1mcint_array.c:986:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  986 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  987 |                         leaf_info(tn, ndump, aname);[0m
      | [0;1;32m                                                    
[0m[1mcint_array.c:1002:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1002 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1003 |                 hsize /= 2;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:1006:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1006 |                 if (tn == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1007 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1009:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1009 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1010 |                         sz += tree_kilobytes(tn);[0m
      | [0;1;32m                                                 
[0m[1mcint_array.c:1061:23: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1061 |                 array->table_size = 0;  /* sanity */[0m
      | [0;1;32m                                    ^
[0m[1m./awk.h:360:9: [0m[0;1;36mnote: [0menum declared here[0m
  360 |                         enum reflagvals {[0m
      | [0;1;32m                        ~~~~~^~~~~~~~~~~~
[0m  361 |                                 CONSTANT = 1,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  362 |                                 FS_DFLT  = 2,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  363 |                         } reflags;[0m
      | [0;1;32m                        ~
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:24: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:24: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                          ^
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:54: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                                                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:133:23: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  133 | #define ISUINT(a, s)    ((((s)->flags & NUMINT) != 0 || is_integer(a, s) != NULL) \[0m
      | [0;1;32m                         ^
[0m[1mcint_array.c:211:6: [0m[0;1;36mnote: [0mAssuming field 'fltnum' is >= 0[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:134:40: [0m[0;1;36mnote: [0mexpanded from macro 'ISUINT'[0m
  134 |                                     && (s)->numbr >= 0)[0m
      | [0;1;32m                                       ^~~~~~~~~~~~~~~
[0m[1mcint_array.c:211:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  211 |         if (ISUINT(symbol, subs)) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:214:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  214 |                 if ((lhs = cint_find(symbol, k, h1)) != NULL)[0m
      | [0;1;32m                ^
[0m[1mcint_array.c:218:6: [0m[0;1;36mnote: [0mAssuming 'xn' is equal to NULL[0m
  218 |         if (xn != NULL && (lhs = xn->aexists(xn, subs)) != NULL)[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mcint_array.c:218:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  218 |         if (xn != NULL && (lhs = xn->aexists(xn, subs)) != NULL)[0m
      | [0;1;32m                       ^
[0m[1mcint_array.c:223:6: [0m[0;1;36mnote: [0mAssuming 'k' is >= 0[0m
  223 |         if (k < 0)[0m
      | [0;1;32m            ^~~~~
[0m[1mcint_array.c:223:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  223 |         if (k < 0)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:231:7: [0m[0;1;36mnote: [0mAssuming 'm' is <= 'NHAT'[0m
  231 |         li = m > NHAT ? m : NHAT;[0m
      | [0;1;32m             ^~~~~~~~
[0m[1mcint_array.c:231:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mcint_array.c:232:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  232 |         while (li >= NHAT) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:232:9: [0m[0;1;36mnote: [0mAssuming 'li' is < 'NHAT'[0m
  232 |         while (li >= NHAT) {[0m
      | [0;1;32m               ^~~~~~~~~~
[0m[1mcint_array.c:232:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 236[0m
  232 |         while (li >= NHAT) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:238:15: [0m[0;1;36mnote: [0m'xn' is equal to NULL[0m
  238 |         cint_size = (xn == NULL) ? symbol->table_size[0m
      | [0;1;32m                     ^~
[0m[1mcint_array.c:238:14: [0m[0;1;36mnote: [0m'?' condition is true[0m
  238 |         cint_size = (xn == NULL) ? symbol->table_size[0m
      | [0;1;32m                    ^
[0m[1mcint_array.c:241:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  241 |         if ((capacity - cint_size) > THRESHOLD)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:241:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  241 |         if ((capacity - cint_size) > THRESHOLD)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:244:14: [0m[0;1;36mnote: [0mField 'av' is not equal to NULL[0m
  244 |         if (symbol->nodes == NULL) {[0m
      | [0;1;32m                    ^
[0m[1m./awk.h:544:28: [0m[0;1;36mnote: [0mexpanded from macro 'nodes'[0m
  544 | #define nodes           sub.nodep.r.av[0m
      | [0;1;32m                                    ^
[0m[1mcint_array.c:244:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  244 |         if (symbol->nodes == NULL) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:255:6: [0m[0;1;36mnote: [0mAssuming 'tn' is not equal to NULL[0m
  255 |         if (tn == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mcint_array.c:255:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  255 |         if (tn == NULL) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:260:6: [0m[0;1;36mnote: [0m'm' is >= 'NHAT'[0m
  260 |         if (m < NHAT)[0m
      | [0;1;32m            ^
[0m[1mcint_array.c:260:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  260 |         if (m < NHAT)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:262:9: [0m[0;1;36mnote: [0mCalling 'tree_lookup'[0m
  262 |         return tree_lookup(symbol, tn, k, m, power_two_table[m]);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:757:6: [0m[0;1;36mnote: [0mAssuming field 'reflags' is not equal to 0[0m
  757 |         if (tree->table_size == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:757:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  757 |         if (tree->table_size == 0) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:782:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  782 |         if ((lhs = tree_find(tree, k, i)) != NULL)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:790:6: [0m[0;1;36mnote: [0mAssuming 'n' is <= 'NHAT'[0m
  790 |         if (n > NHAT) {[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mcint_array.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (n > NHAT) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:795:7: [0m[0;1;36mnote: [0mAssuming 'tn' is not equal to NULL[0m
  795 |                 if (tn == NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mcint_array.c:795:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  795 |                 if (tn == NULL)[0m
      | [0;1;32m                ^
[0m[1mcint_array.c:797:10: [0m[0;1;36mnote: [0mCalling 'leaf_lookup'[0m
  797 |                 return leaf_lookup(symbol, tn, k, size, base);[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:1060:6: [0m[0;1;36mnote: [0mAssuming field 'av' is equal to NULL[0m
 1060 |         if (array->nodes == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:1060:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1060 |         if (array->nodes == NULL) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:1061:23: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals'[0m
 1061 |                 array->table_size = 0;  /* sanity */[0m
      | [0;1;32m                                    ^
[0m[1mcint_array.c:1098:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1098 |                 if (r == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1099 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1104:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1104 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1105 |                         unref(r);[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1109:42: [0m[0;1;35mwarning: [0m[1mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
 1109 |         array->array_size = array->table_size = 0;[0m
      | [0;1;32m                                                ^
[0m[1m./awk.h:360:9: [0m[0;1;36mnote: [0menum declared here[0m
  360 |                         enum reflagvals {[0m
      | [0;1;32m                        ~~~~~^~~~~~~~~~~~
[0m  361 |                                 CONSTANT = 1,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  362 |                                 FS_DFLT  = 2,[0m
      | [0;1;32m                                ~~~~~~~~~~~~~
[0m  363 |                         } reflags;[0m
      | [0;1;32m                        ~
[0m[1mcint_array.c:315:6: [0m[0;1;36mnote: [0mAssuming field 'rn' is equal to NULL[0m
  315 |         if (symbol->xarray != NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:315:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  315 |         if (symbol->xarray != NULL) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:322:17: [0m[0;1;36mnote: [0mAssuming 'i' is < INT32_BIT[0m
  322 |         for (i = NHAT; i < INT32_BIT; i++) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~
[0m[1mcint_array.c:322:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  322 |         for (i = NHAT; i < INT32_BIT; i++) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:324:7: [0m[0;1;36mnote: [0mAssuming 'tn' is not equal to NULL[0m
  324 |                 if (tn != NULL) {[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mcint_array.c:324:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  324 |                 if (tn != NULL) {[0m
      | [0;1;32m                ^
[0m[1mcint_array.c:325:4: [0m[0;1;36mnote: [0mCalling 'tree_clear'[0m
  325 |                         tree_clear(tn);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~
[0m[1mcint_array.c:829:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  829 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:829:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  829 |         if ((tree->flags & HALFHAT) != 0)[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:832:14: [0m[0;1;36mnote: [0mAssuming 'j' is < 'hsize'[0m
  832 |         for (j = 0; j < hsize; j++) {[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1mcint_array.c:832:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  832 |         for (j = 0; j < hsize; j++) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:834:7: [0m[0;1;36mnote: [0mAssuming 'tn' is not equal to NULL[0m
  834 |                 if (tn == NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mcint_array.c:834:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  834 |                 if (tn == NULL)[0m
      | [0;1;32m                ^
[0m[1mcint_array.c:836:7: [0m[0;1;36mnote: [0mAssuming field 'type' is not equal to Node_array_tree[0m
  836 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mcint_array.c:836:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  836 |                 if (tn->type == Node_array_tree)[0m
      | [0;1;32m                ^
[0m[1mcint_array.c:839:4: [0m[0;1;36mnote: [0mCalling 'leaf_clear'[0m
  839 |                         leaf_clear(tn);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~
[0m[1mcint_array.c:1096:14: [0m[0;1;36mnote: [0mAssuming 'i' is >= 'size'[0m
 1096 |         for (i = 0; i < size; i++) {[0m
      | [0;1;32m                    ^~~~~~~~
[0m[1mcint_array.c:1096:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1107[0m
 1096 |         for (i = 0; i < size; i++) {[0m
      | [0;1;32m        ^
[0m[1mcint_array.c:1109:42: [0m[0;1;36mnote: [0mThe value '0' provided to the cast expression is not in the valid range of values for 'reflagvals'[0m
 1109 |         array->array_size = array->table_size = 0;[0m
      | [0;1;32m                                                ^
[0m[1mcint_array.c:1121:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1121 |         if (*lhs == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1122 |                 return false;[0m
      | [0;1;32m                             
[0m[1mcint_array.c:1152:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1152 |                 if (old[i] == NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1153 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1154:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1154 |                 if (old[i]->type == Node_val)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1155 |                         new[i] = dupnode(old[i]);[0m
 1156 |                 else {[0m
      | [0;32m                } 
[0m[1mcint_array.c:1180:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1180 |                 if (r == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1181 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1186:4: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1186 |                         sprintf(buf, "%ld", num);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mcint_array.c:1186:4: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1186 |                         sprintf(buf, "%ld", num);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mcint_array.c:1199:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1199 |                                 if ((assoc_kind & AVNUM) != 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1200 |                                         (void) force_number(r);[0m
 1201 |                                 else if ((assoc_kind & AVSTR) != 0)[0m
      | [0;32m                                } 
[0m[1mcint_array.c:1201:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1201 |                                 else if ((assoc_kind & AVSTR) != 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 1202 |                                         r = force_string(r);[0m
      | [0;1;32m                                                            
[0m[1mcint_array.c:1206:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1206 |                 if ((assoc_kind & ADELETE) != 0 && k >= 1)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1207 |                         return k;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1228:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1228 |                 if (val == NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1229 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1263:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1263 |         if (newval->stlen == 0) // empty strings in ARGV are OK[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1264 |                 return val;[0m
      | [0;1;32m                           
[0m[1mcint_array.c:1267:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1267 |                 if (! in_array(argv_shadow_array, newval))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1268 |                         fatal(_("cannot add a new file (%.*s) to ARGV in sandbox mode"),[0m
 1269 |                                 (int) newval->stlen, newval->stptr);[0m
      | [0;1;32m                                                                    
[0m[1mcint_array.c:1278:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1278 |                 if (! is_letter((unsigned char) arg[0]))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1279 |                         badvar = true;[0m
 1280 |                 else[0m
      | [0;32m                } 
[0m[1mcint_array.c:1280:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1280 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1281 |                         for (cp2 = arg+1; *cp2; cp2++)[0m
 1282 |                                 if (! is_identchar((unsigned char) *cp2) && *cp2 != ':') {[0m
 1283 |                                         badvar = true;[0m
 1284 |                                         break;[0m
 1285 |                                 }[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1281:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1281 |                         for (cp2 = arg+1; *cp2; cp2++)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1282 |                                 if (! is_identchar((unsigned char) *cp2) && *cp2 != ':') {[0m
 1283 |                                         badvar = true;[0m
 1284 |                                         break;[0m
 1285 |                                 }[0m
      | [0;1;32m                                 
[0m[1mcint_array.c:1290:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1290 |                         if (cp && (cp[1] != ':' || strchr(cp + 2, ':') != NULL))[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1291 |                                 badvar = true;[0m
      | [0;1;32m                                              
[0m[1mcint_array.c:1295:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1295 |                 if (badvar && ! in_array(argv_shadow_array, newval))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1296 |                         fatal(_("cannot add a new file (%.*s) to ARGV in sandbox mode"),[0m
 1297 |                                 (int) newval->stlen, newval->stptr);[0m
      | [0;1;32m                                                                    
[0m[1mcint_array.c:1310:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1310 |         if (! do_sandbox)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1311 |                 return;[0m
      | [0;1;32m                       
[0m128 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[50/54][280.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpsak25vst.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/field.c
[1mfield.c:109:22: [0m[0;1;35mwarning: [0m[1mThe value '16390' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  109 |         Null_field->flags = (STRCUR|STRING|NULL_FIELD); /* do not set MALLOC */[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mfield.c:109:22: [0m[0;1;36mnote: [0mThe value '16390' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  109 |         Null_field->flags = (STRCUR|STRING|NULL_FIELD); /* do not set MALLOC */[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfield.c:142:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  142 |         if (num > nf_high_water)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  143 |                 grow_fields_arr(num);[0m
      | [0;1;32m                                     
[0m[1mfield.c:147:13: [0m[0;1;35mwarning: [0m[1mThe value '38' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  147 |         n->flags = (STRCUR|STRING|USER_INPUT);  /* do not set MALLOC */[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mfield.c:142:6: [0m[0;1;36mnote: [0mAssuming 'num' is <= 'nf_high_water'[0m
  142 |         if (num > nf_high_water)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mfield.c:142:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  142 |         if (num > nf_high_water)[0m
      | [0;1;32m        ^
[0m[1mfield.c:147:13: [0m[0;1;36mnote: [0mThe value '38' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  147 |         n->flags = (STRCUR|STRING|USER_INPUT);  /* do not set MALLOC */[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfield.c:175:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  175 |         if ((long) tlen < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  176 |                 tlen = 0;[0m
      | [0;1;32m                         
[0m[1mfield.c:184:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  184 |                 if (tmp->stlen == 1)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  185 |                         *cops++ = tmp->stptr[0];[0m
  186 |                 else if (tmp->stlen != 0) {[0m
      | [0;32m                } 
[0m[1mfield.c:187:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  187 |                         memcpy(cops, tmp->stptr, tmp->stlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mfield.c:187:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  187 |                         memcpy(cops, tmp->stptr, tmp->stlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mfield.c:192:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  192 |                         if (OFSlen == 1)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  193 |                                 *cops++ = *OFS;[0m
  194 |                         else if (OFSlen != 0) {[0m
      | [0;32m                        } 
[0m[1mfield.c:195:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  195 |                                 memcpy(cops, OFS, OFSlen);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mfield.c:195:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  195 |                                 memcpy(cops, OFS, OFSlen);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mfield.c:227:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  227 |                                 memcpy(r->stptr, cops, r->stlen);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mfield.c:227:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  227 |                                 memcpy(r->stptr, cops, r->stlen);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mfield.c:286:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  286 |                         if (databuf_size > MAX_SIZE/2)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  287 |                                 fatal(_("input record too large"));[0m
      | [0;1;32m                                                                   
[0m[1mfield.c:291:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  291 |                 memset(databuf, '\0', databuf_size);[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:291:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  291 |                 memset(databuf, '\0', databuf_size);[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:295:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  295 |                 memcpy(databuf, buf, cnt);[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:295:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  295 |                 memcpy(databuf, buf, cnt);[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:319:13: [0m[0;1;35mwarning: [0m[1mThe value '38' provided to the cast expression is not in the valid range of values for 'flagvals' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  319 |         n->flags = (STRING|STRCUR|USER_INPUT);  /* do not set MALLOC */[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:387:7: [0m[0;1;36mnote: [0menum declared here[0m
  387 |         enum flagvals {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~
[0m  388 |         /* type = Node_val */[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~
[0m  389 |                 /*[0m
      | [0;1;32m                ~~
[0m  390 |                  * STRING and NUMBER are mutually exclusive, except for the special[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  391 |                  * case of an uninitialized value, represented internally by[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  392 |                  * Nnull_string. They represent the type of a value as assigned.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  393 |                  * Nnull_string has both STRING and NUMBER attributes, but all other[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  394 |                  * scalar values should have precisely one of these bits set.[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  395 |                  *[0m
      | [0;1;32m                 ~
[0m  396 |                  * STRCUR and NUMCUR are not mutually exclusive. They represent that[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  397 |                  * the particular type of value is up to date.  For example,[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  398 |                  *[0m
      | [0;1;32m                 ~
[0m  399 |                  *      a = 5           # NUMBER | NUMCUR[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  400 |                  *      b = a ""        # Adds STRCUR to a, since a string value[0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  401 |                  *                      # is now available. But the type hasn't changed![0m
      | [0;1;32m                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  402 |                  *[0m
      | [0;1;32m                 ~
[0m[1mfield.c:275:6: [0m[0;1;36mnote: [0m'databuf_size' is equal to 0[0m
  275 |         if (databuf_size == 0) {        /* first time */[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mfield.c:275:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  275 |         if (databuf_size == 0) {        /* first time */[0m
      | [0;1;32m        ^
[0m[1mfield.c:284:6: [0m[0;1;36mnote: [0mAssuming 'cnt' is < 'databuf_size'[0m
  284 |         if (cnt >= databuf_size) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mfield.c:284:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  284 |         if (cnt >= databuf_size) {[0m
      | [0;1;32m        ^
[0m[1mfield.c:294:6: [0m[0;1;36mnote: [0mAssuming 'cnt' is equal to 0[0m
  294 |         if (cnt != 0) {[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mfield.c:294:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  294 |         if (cnt != 0) {[0m
      | [0;1;32m        ^
[0m[1mfield.c:310:10: [0m[0;1;36mnote: [0mAssuming 'n' is null[0m
  310 |         getnode(n);[0m
      | [0;1;32m                ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mfield.c:310:2: [0m[0;1;36mnote: [0m'?' condition is false[0m
  310 |         getnode(n);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mfield.c:319:13: [0m[0;1;36mnote: [0mThe value '38' provided to the cast expression is not in the valid range of values for 'flagvals'[0m
  319 |         n->flags = (STRING|STRCUR|USER_INPUT);  /* do not set MALLOC */[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mfield.c:371:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  371 |                         memcpy(r->stptr, save, r->stlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mfield.c:371:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  371 |                         memcpy(r->stptr, save, r->stlen);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mfield.c:407:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  407 |         if (nf < 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  408 |                 fatal(_("NF set to negative value"));[0m
      | [0;1;32m                                                     
[0m[1mfield.c:418:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  418 |         if (NF > nf_high_water)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  419 |                 grow_fields_arr(NF);[0m
      | [0;1;32m                                    
[0m[1mfield.c:467:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  467 |         memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mfield.c:467:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  467 |         memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mfield.c:469:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  469 |         if (in_middle)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  470 |                 regex_flags |= RE_NO_BOL;[0m
      | [0;1;32m                                         
[0m[1mfield.c:472:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  472 |         if (up_to == UNLIMITED)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  473 |                 nf = 0;[0m
      | [0;1;32m                       
[0m[1mfield.c:474:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  474 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  475 |                 return nf;[0m
      | [0;1;32m                          
[0m[1mfield.c:481:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  481 |                 while (scan < end && (*scan == ' ' || *scan == '\t' || *scan == '\n'))[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m  482 |                         scan++;[0m
      | [0;1;32m                               
[0m[1mfield.c:483:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  483 |                 if (sep_arr != NULL && sep < scan)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  484 |                         set_element(nf, sep, (long)(scan - sep), sep_arr);[0m
      | [0;1;32m                                                                          
[0m[1mfield.c:487:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  487 |         if (rp == NULL) /* use FS */[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  488 |                 rp = FS_regexp;[0m
      | [0;1;32m                               
[0m[1mfield.c:504:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  504 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  505 |                                 scan++;[0m
      | [0;1;32m                                       
[0m[1mfield.c:515:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  515 |                 if (sep_arr != NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  516 |                         set_element(nf, scan + RESTART(rp, scan),[0m
  517 |                                 (long) (REEND(rp, scan) - RESTART(rp, scan)), sep_arr);[0m
      | [0;1;32m                                                                                       
[0m[1mfield.c:520:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  520 |                 if (scan == end && ! default_field_splitting)   /* FS at end of record */[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  521 |                         (*set)(++nf, field, 0L, n);[0m
      | [0;1;32m                                                   
[0m[1mfield.c:557:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  557 |         if (up_to == UNLIMITED)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  558 |                 nf = 0;[0m
      | [0;1;32m                       
[0m[1mfield.c:559:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  559 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  560 |                 return nf;[0m
      | [0;1;32m                          
[0m[1mfield.c:582:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  582 |                 while (scan < end && (*scan == ' ' || *scan == '\t' || *scan == '\n'))[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m  583 |                         scan++;[0m
      | [0;1;32m                               
[0m[1mfield.c:585:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  585 |                 if (sep_arr != NULL && scan > sep)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  586 |                         set_element(nf, sep, (long) (scan - sep), sep_arr);[0m
      | [0;1;32m                                                                           
[0m[1mfield.c:588:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  588 |                 if (scan >= end)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  589 |                         break;[0m
      | [0;1;32m                              
[0m[1mfield.c:593:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  593 |                 while (*scan != ' ' && *scan != '\t' && *scan != '\n')[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  594 |                         scan++;[0m
      | [0;1;32m                               
[0m[1mfield.c:598:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  598 |                 if (scan == end)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  599 |                         break;[0m
      | [0;1;32m                              
[0m[1mfield.c:632:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  632 |         if (up_to == UNLIMITED)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  633 |                 nf = 0;[0m
      | [0;1;32m                       
[0m[1mfield.c:634:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  634 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  635 |                 return nf;[0m
      | [0;1;32m                          
[0m[1mfield.c:639:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  639 |                 memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:639:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  639 |                 memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:647:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  647 |                         if (sep_arr != NULL && nf > 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  648 |                                 set_element(nf, scan, 0L, sep_arr);[0m
      | [0;1;32m                                                                   
[0m[1mfield.c:654:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  654 |                         if (sep_arr != NULL && nf > 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  655 |                                 set_element(nf, scan, 0L, sep_arr);[0m
      | [0;1;32m                                                                   
[0m[1mfield.c:691:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  691 |         memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mfield.c:691:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  691 |         memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mfield.c:693:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  693 |         if (up_to == UNLIMITED)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  694 |                 nf = 0;[0m
      | [0;1;32m                       
[0m[1mfield.c:695:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  695 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  696 |                 return nf;[0m
      | [0;1;32m                          
[0m[1mfield.c:698:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  698 |         if (RS_is_null && fs->stlen == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  699 |                 fschar = '\n';[0m
  700 |         else[0m
      | [0;32m        } 
[0m[1mfield.c:700:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  700 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  701 |                 fschar = fs->stptr[0];[0m
      | [0;1;32m                                      
[0m[1mfield.c:721:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  721 |                         while (*scan != fschar)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  722 |                                 scan++;[0m
      | [0;1;32m                                       
[0m[1mfield.c:725:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  725 |                 if (scan == end)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  726 |                         break;[0m
      | [0;1;32m                              
[0m[1mfield.c:727:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  727 |                 if (sep_arr != NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  728 |                         set_element(nf, scan, 1L, sep_arr);[0m
      | [0;1;32m                                                           
[0m[1mfield.c:757:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  757 |                 if (!(mbclen > 0 && mbclen <= (size_t)(end - mbscan)))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  758 |                         /*[0m
  759 |                          * We treat it as a singlebyte character. This should[0m
  760 |                          * catch error codes 0, (size_t) -1, and (size_t) -2.[0m
  761 |                          */[0m
  762 |                         mbclen = 1;[0m
      | [0;1;32m                                   
[0m[1mfield.c:795:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  795 |         if (up_to == UNLIMITED)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  796 |                 nf = 0;[0m
      | [0;1;32m                       
[0m[1mfield.c:797:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  797 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  798 |                 return nf;[0m
      | [0;1;32m                          
[0m[1mfield.c:806:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  806 |                 memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:806:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  806 |                 memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mfield.c:824:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  824 |                         if (skiplen > end - scan)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  825 |                                 skiplen = end - scan;[0m
      | [0;1;32m                                                     
[0m[1mfield.c:828:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  828 |                         if (flen > end - scan)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  829 |                                 flen = end - scan;[0m
      | [0;1;32m                                                  
[0m[1mfield.c:891:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  891 |                 if (assign != NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  892 |                         *assign = reset_record;[0m
      | [0;1;32m                                               
[0m[1mfield.c:910:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  910 |         if (assign != NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  911 |                 *assign = invalidate_field0;    /* $0 needs reconstruction */[0m
      | [0;1;32m                                                                             
[0m[1mfield.c:914:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  914 |         if (requested <= parse_high_water)      /* already parsed this field */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  915 |                 return &fields_arr[requested];[0m
      | [0;1;32m                                              
[0m[1mfield.c:922:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  922 |                 if (parse_high_water == 0)      /* starting at the beginning */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  923 |                         parse_extent = fields_arr[0]->stptr;[0m
  924 |                 else[0m
      | [0;32m                } 
[0m[1mfield.c:924:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  924 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  925 |                         in_middle = true;[0m
      | [0;1;32m                                         
[0m[1mfield.c:938:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  938 |                 if (parse_extent == fields_arr[0]->stptr + fields_arr[0]->stlen)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m  939 |                         NF = parse_high_water;[0m
      | [0;1;32m                                              
[0m[1mfield.c:940:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  940 |                 if (requested == UNLIMITED - 1) /* UNLIMITED-1 means set NF */[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  941 |                         requested = parse_high_water;[0m
      | [0;1;32m                                                     
[0m[1mfield.c:945:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  945 |                         if (requested > nf_high_water)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  946 |                                 grow_fields_arr(requested);[0m
      | [0;1;32m                                                           
[0m[1mfield.c:950:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  950 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  951 |                         return &Null_field;[0m
      | [0;1;32m                                           
[0m[1mfield.c:991:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  991 |                 if (sep_arr->type != Node_var_array)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  992 |                         fatal(_("split: fourth argument is not an array"));[0m
      | [0;1;32m                                                                           
[0m[1mfield.c:1003:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1003 |         if (arr->type != Node_var_array)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1004 |                 fatal(_("split: second argument is not an array"));[0m
      | [0;1;32m                                                                   
[0m[1mfield.c:1009:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1009 |                 if (sep_arr == arr)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1010 |                         fatal(_("split: cannot use the same array for second and fourth args"));[0m
      | [0;1;32m                                                                                                
[0m[1mfield.c:1013:74: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1013 |                 for (tmp = sep_arr->parent_array; tmp != NULL; tmp = tmp->parent_array)[0m
      | [0;1;32m                                                                                       ^
[0m      | [0;32m                                                                                        {
[0m 1014 |                         if (tmp == arr)[0m
 1015 |                                 fatal(_("split: cannot use a subarray of second arg for fourth arg"));[0m
      | [0;1;32m                                                                                                      
[0m[1mfield.c:1014:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1014 |                         if (tmp == arr)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1015 |                                 fatal(_("split: cannot use a subarray of second arg for fourth arg"));[0m
      | [0;1;32m                                                                                                      
[0m[1mfield.c:1016:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1016 |                 for (tmp = arr->parent_array; tmp != NULL; tmp = tmp->parent_array)[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m 1017 |                         if (tmp == sep_arr)[0m
 1018 |                                 fatal(_("split: cannot use a subarray of fourth arg for second arg"));[0m
      | [0;1;32m                                                                                                      
[0m[1mfield.c:1017:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1017 |                         if (tmp == sep_arr)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1018 |                                 fatal(_("split: cannot use a subarray of fourth arg for second arg"));[0m
      | [0;1;32m                                                                                                      
[0m[1mfield.c:1033:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1033 |         if ((sep->flags & REGEX) != 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1034 |                 sep = sep->typed_re;[0m
      | [0;1;32m                                    
[0m[1mfield.c:1057:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1057 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1058 |                                 parseit = sc_parse_field;[0m
      | [0;1;32m                                                         
[0m[1mfield.c:1090:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1090 |                 if (sep_arr->type != Node_var_array)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1091 |                         fatal(_("patsplit: fourth argument is not an array"));[0m
      | [0;1;32m                                                                              
[0m[1mfield.c:1097:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1097 |         if (arr->type != Node_var_array)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1098 |                 fatal(_("patsplit: second argument is not an array"));[0m
      | [0;1;32m                                                                      
[0m[1mfield.c:1104:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1104 |         if ((sep->flags & REGEX) != 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1105 |                 sep = sep->typed_re;[0m
      | [0;1;32m                                    
[0m[1mfield.c:1108:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1108 |         if (fpat->stlen == 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1109 |                 fatal(_("patsplit: third argument must be non-null"));[0m
      | [0;1;32m                                                                      
[0m[1mfield.c:1112:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1112 |                 if (sep_arr == arr)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1113 |                         fatal(_("patsplit: cannot use the same array for second and fourth args"));[0m
      | [0;1;32m                                                                                                   
[0m[1mfield.c:1116:74: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1116 |                 for (tmp = sep_arr->parent_array; tmp != NULL; tmp = tmp->parent_array)[0m
      | [0;1;32m                                                                                       ^
[0m      | [0;32m                                                                                        {
[0m 1117 |                         if (tmp == arr)[0m
 1118 |                                 fatal(_("patsplit: cannot use a subarray of second arg for fourth arg"));[0m
      | [0;1;32m                                                                                                         
[0m[1mfield.c:1117:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1117 |                         if (tmp == arr)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1118 |                                 fatal(_("patsplit: cannot use a subarray of second arg for fourth arg"));[0m
      | [0;1;32m                                                                                                         
[0m[1mfield.c:1119:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1119 |                 for (tmp = arr->parent_array; tmp != NULL; tmp = tmp->parent_array)[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m 1120 |                         if (tmp == sep_arr)[0m
 1121 |                                 fatal(_("patsplit: cannot use a subarray of fourth arg for second arg"));[0m
      | [0;1;32m                                                                                                         
[0m[1mfield.c:1120:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1120 |                         if (tmp == sep_arr)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1121 |                                 fatal(_("patsplit: cannot use a subarray of fourth arg for second arg"));[0m
      | [0;1;32m                                                                                                         
[0m[1mfield.c:1173:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1173 |         if (do_traditional)     /* quick and dirty, does the trick */[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1174 |                 return;[0m
      | [0;1;32m                       
[0m[1mfield.c:1180:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1180 |         if (fields_arr != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1181 |                 (void) get_field(UNLIMITED - 1, 0);[0m
      | [0;1;32m                                                   
[0m[1mfield.c:1207:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1207 |                 if (*scan == '\0')[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1208 |                         break;[0m
      | [0;1;32m                              
[0m[1mfield.c:1228:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1228 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1229 |                         FIELDWIDTHS->fields[i].skip = 0;[0m
      | [0;1;32m                                                        
[0m[1mfield.c:1236:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1236 |                                 for (scan++; is_blank(*scan); scan++)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1237 |                                         continue;[0m
      | [0;1;32m                                                 
[0m[1mfield.c:1239:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1239 |                                 if (*scan != '\0')[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 1240 |                                         fatal(_("`*' must be the last designator in FIELDWIDTHS"));[0m
      | [0;1;32m                                                                                                   
[0m[1mfield.c:1245:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1245 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1246 |                                 fatal_error = true;[0m
      | [0;1;32m                                                   
[0m[1mfield.c:1256:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1256 |                 if (*scan == '\0')[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1257 |                         break;[0m
      | [0;1;32m                              
[0m[1mfield.c:1260:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1260 |         if (fatal_error)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1261 |                 fatal(_("invalid FIELDWIDTHS value, for field %d, near `%s'"),[0m
 1262 |                               i + 1, scan);[0m
      | [0;1;32m                                           
[0m[1mfield.c:1280:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1280 |         if (fields_arr != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1281 |                 (void) get_field(UNLIMITED - 1, 0);[0m
      | [0;1;32m                                                   
[0m[1mfield.c:1294:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1294 |                 if (FS_regexp != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1295 |                         FS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);[0m
      | [0;1;32m                                                                                  
[0m[1mfield.c:1337:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1337 |                 if (do_lint_old)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1338 |                         lintwarn(_("old awk does not support regexps as value of `FS'"));[0m
      | [0;1;32m                                                                                         
[0m[1mfield.c:1354:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1354 |                                 sprintf(buf, "[%c\n]", fs->stptr[0]);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mfield.c:1354:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1354 |                                 sprintf(buf, "[%c\n]", fs->stptr[0]);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mfield.c:1361:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1361 |                         if (fs->stptr[0] == ' ')[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1362 |                                 default_FS = true;[0m
 1363 |                         else if (fs->stptr[0] == '\\')[0m
      | [0;32m                        } 
[0m[1mfield.c:1363:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1363 |                         else if (fs->stptr[0] == '\\')[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1364 |                                 /* same special case */[0m
 1365 |                                 strcpy(buf, "[\\\\]");[0m
 1366 |                         else[0m
      | [0;32m                        } 
[0m[1mfield.c:1366:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1366 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1367 |                                 set_parser(sc_parse_field);[0m
      | [0;1;32m                                                           
[0m[1mfield.c:1384:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1384 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1385 |                         FS_re_yes_case = FS_re_no_case = FS_regexp = NULL;[0m
      | [0;1;32m                                                                          
[0m[1mfield.c:1393:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1393 |         if (fs->stlen == 1 && parse_field == re_parse_field)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1394 |                 FS_regexp = FS_re_yes_case;[0m
      | [0;1;32m                                           
[0m[1mfield.c:1402:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1402 |         if (api_parser_override)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1403 |                 return Using_API;[0m
 1404 |         else if (parse_field == fw_parse_field)[0m
      | [0;32m        } 
[0m[1mfield.c:1404:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1404 |         else if (parse_field == fw_parse_field)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1405 |                 return Using_FIELDWIDTHS;[0m
 1406 |         else if (parse_field == fpat_parse_field)[0m
      | [0;32m        } 
[0m[1mfield.c:1406:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1406 |         else if (parse_field == fpat_parse_field)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1407 |                 return Using_FPAT;[0m
 1408 |         else[0m
      | [0;32m        } 
[0m[1mfield.c:1408:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1408 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1409 |                 return Using_FS;[0m
      | [0;1;32m                                
[0m[1mfield.c:1417:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1417 |         if (api_parser_override)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1418 |                 return "API";[0m
 1419 |         else if (parse_field == fw_parse_field)[0m
      | [0;32m        } 
[0m[1mfield.c:1419:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1419 |         else if (parse_field == fw_parse_field)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1420 |                 return "FIELDWIDTHS";[0m
 1421 |         else if (parse_field == fpat_parse_field)[0m
      | [0;32m        } 
[0m[1mfield.c:1421:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1421 |         else if (parse_field == fpat_parse_field)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1422 |                 return "FPAT";[0m
 1423 |         else[0m
      | [0;32m        } 
[0m[1mfield.c:1423:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1423 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1424 |                 return "FS";[0m
      | [0;1;32m                            
[0m[1mfield.c:1434:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1434 |         if (PROCINFO_node == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1435 |                 return;[0m
      | [0;1;32m                       
[0m[1mfield.c:1447:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1447 |         if (PROCINFO_node == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1448 |                 return;[0m
      | [0;1;32m                       
[0m[1mfield.c:1466:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1466 |         if (do_traditional)     /* quick and dirty, does the trick */[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1467 |                 return;[0m
      | [0;1;32m                       
[0m[1mfield.c:1473:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1473 |         if (fields_arr != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1474 |                 (void) get_field(UNLIMITED - 1, 0);[0m
      | [0;1;32m                                                   
[0m[1mfield.c:1484:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1484 |                 if (FPAT_regexp != NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1485 |                         FPAT_regexp = (IGNORECASE ? FPAT_re_no_case : FPAT_re_yes_case);[0m
      | [0;1;32m                                                                                        
[0m[1mfield.c:1541:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1541 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1542 |                 (*scanp)++;[0m
      | [0;1;32m                           
[0m[1mfield.c:1633:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1633 |         memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mfield.c:1633:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1633 |         memset(&mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mfield.c:1635:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1635 |         if (up_to == UNLIMITED)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1636 |                 nf = 0;[0m
      | [0;1;32m                       
[0m[1mfield.c:1638:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1638 |         if (len == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1639 |                 return nf;[0m
      | [0;1;32m                          
[0m[1mfield.c:1641:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1641 |         if (rp == NULL) /* use FPAT */[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1642 |                 rp = FPAT_regexp;[0m
      | [0;1;32m                                 
[0m[1mfield.c:1660:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1660 |                                 if (field_start == start) /* match at front */[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1661 |                                         set_element(nf, start, 0L, sep_arr);[0m
 1662 |                                 else[0m
      | [0;32m                                } 
[0m[1mfield.c:1662:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1662 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1663 |                                         set_element(nf,[0m
 1664 |                                                 start,[0m
 1665 |                                                 (long) (field_start - start),[0m
 1666 |                                                 sep_arr);[0m
      | [0;1;32m                                                         
[0m[1mfield.c:1680:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1680 |                         if (sep_arr != NULL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1681 |                                 set_element(nf, start, (long) (end - start), sep_arr);[0m
      | [0;1;32m                                                                                      
[0m[1mfield.c:1690:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1690 |         if (sep_arr != NULL && scan == end && field_found)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1691 |                 set_element(nf, scan, 0L, sep_arr);[0m
      | [0;1;32m                                                   
[0m149 warnings generated.
Suppressed 30 warnings (30 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[51/54][284.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpzllo6ujw.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/support/dfa.c
[1mdfa.c:650:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  650 |       memset (&d->mbs, 0, sizeof d->mbs);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:650:7: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  650 |       memset (&d->mbs, 0, sizeof d->mbs);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:749:3: [0m[0;1;35mwarning: [0m[1mOut of bound access to memory after the end of 'ccl.w' [clang-analyzer-security.ArrayBound][0m
  749 |   c->w[b / CHARCLASS_WORD_BITS] |= one << b % CHARCLASS_WORD_BITS;[0m
      | [0;1;32m  ^
[0m[1mdfa.c:959:17: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  959 |   bool invert = c == '^';[0m
      | [0;1;32m                ^~~~~~~~
[0m[1mdfa.c:960:7: [0m[0;1;36mnote: [0m'invert' is false[0m
  960 |   if (invert)[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:960:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  960 |   if (invert)[0m
      | [0;1;32m  ^
[0m[1mdfa.c:968:26: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  968 |   colon_warning_state = (c == ':');[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mdfa.c:978:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  978 |       if (c == '[')[0m
      | [0;1;32m          ^~~~~~~~
[0m[1mdfa.c:978:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  978 |       if (c == '[')[0m
      | [0;1;32m      ^
[0m[1mdfa.c:1042:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1042 |       if (c == '\\'[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mdfa.c:1042:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mdfa.c:1043:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1043 |           && (dfa->syntax.syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:1042:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1042 |       if (c == '\\'[0m
      | [0;1;32m      ^
[0m[1mdfa.c:1049:11: [0m[0;1;36mnote: [0m'c1' is equal to NOTCHAR[0m
 1049 |       if (c1 == NOTCHAR)[0m
      | [0;1;32m          ^~
[0m[1mdfa.c:1049:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1049 |       if (c1 == NOTCHAR)[0m
      | [0;1;32m      ^
[0m[1mdfa.c:1055:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 1055 |       if (c1 == '-')[0m
      | [0;1;32m      ^
[0m[1mdfa.c:1110:30: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1110 |       colon_warning_state |= (c == ':') ? 2 : 4;[0m
      | [0;1;32m                             ^
[0m[1mdfa.c:1112:11: [0m[0;1;36mnote: [0mAssuming field 'multibyte' is false[0m
 1112 |       if (!dfa->localeinfo.multibyte)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:1112:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1112 |       if (!dfa->localeinfo.multibyte)[0m
      | [0;1;32m      ^
[0m[1mdfa.c:1114:15: [0m[0;1;36mnote: [0mAssuming field 'case_fold' is false[0m
 1114 |           if (dfa->syntax.case_fold && isalpha (c))[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:1114:37: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1114 |           if (dfa->syntax.case_fold && isalpha (c))[0m
      | [0;1;32m                                    ^
[0m[1mdfa.c:1117:13: [0m[0;1;36mnote: [0mCalling 'setbit'[0m
 1117 |             setbit (c, &ccl);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~
[0m[1mdfa.c:749:3: [0m[0;1;36mnote: [0mAccess of 'ccl.w' at index 67108863, while it holds only 4 'unsigned long' elements[0m
  749 |   c->w[b / CHARCLASS_WORD_BITS] |= one << b % CHARCLASS_WORD_BITS;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:762:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  762 |   memset (s, 0, sizeof *s);[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:762:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  762 |   memset (s, 0, sizeof *s);[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:768:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  768 |   for (int i = 0; i < CHARCLASS_WORDS; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  769 |     s->w[i] = CHARCLASS_WORD_MASK;[0m
      | [0;1;32m                                  
[0m[1mdfa.c:775:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  775 |   for (int i = 0; i < CHARCLASS_WORDS; ++i)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  776 |     s->w[i] = CHARCLASS_WORD_MASK & ~s->w[i];[0m
      | [0;1;32m                                             
[0m[1mdfa.c:783:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  783 |   for (int i = 0; i < CHARCLASS_WORDS; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  784 |     w |= s1->w[i] ^ s2->w[i];[0m
      | [0;1;32m                             
[0m[1mdfa.c:792:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  792 |   for (int i = 0; i < CHARCLASS_WORDS; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  793 |     w |= s->w[i];[0m
      | [0;1;32m                 
[0m[1mdfa.c:810:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  810 |   if (i < *nitems)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  811 |     return pa;[0m
      | [0;1;32m              
[0m[1mdfa.c:821:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  821 |   for (i = 0; i < d->cindex; ++i)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  822 |     if (equal (s, &d->charclasses[i]))[0m
  823 |       return i;[0m
      | [0;1;32m               
[0m[1mdfa.c:822:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  822 |     if (equal (s, &d->charclasses[i]))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  823 |       return i;[0m
      | [0;1;32m               
[0m[1mdfa.c:840:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  840 |   if (c == dfa->syntax.eolbyte && !(dfa->syntax.dfaopts & DFA_ANCHOR))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  841 |     return CTX_NEWLINE;[0m
      | [0;1;32m                       
[0m[1mdfa.c:842:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  842 |   if (unibyte_word_constituent (dfa, c))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  843 |     return CTX_LETTER;[0m
      | [0;1;32m                      
[0m[1mdfa.c:856:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  856 |   if (b < 0)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  857 |     return false;[0m
      | [0;1;32m                 
[0m[1mdfa.c:869:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  869 |   for (int i = 0; i < NOTCHAR; i++)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  870 |     if (toupper (i) == ub)[0m
  871 |       setbit (i, c);[0m
      | [0;1;32m                    
[0m[1mdfa.c:870:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  870 |     if (toupper (i) == ub)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  871 |       setbit (i, c);[0m
      | [0;1;32m                    
[0m[1mdfa.c:896:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  896 |   if (! dfa->lex.left)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  897 |     dfaerror (_("unbalanced ["));[0m
      | [0;1;32m                                 
[0m[1mdfa.c:933:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  933 |   for (int i = 0; prednames[i].name; i++)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  934 |     if (str_eq (str, prednames[i].name))[0m
  935 |       return &prednames[i];[0m
      | [0;1;32m                           
[0m[1mdfa.c:934:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  934 |     if (str_eq (str, prednames[i].name))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  935 |       return &prednames[i];[0m
      | [0;1;32m                           
[0m[1mdfa.c:993:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  993 |                       || (c == c1 && dfa->lex.ptr[0] == ']'))[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  994 |                     break;[0m
      | [0;1;32m                          
[0m[1mdfa.c:995:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  995 |                   if (len < MAX_BRACKET_STRING_LEN)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  996 |                     str[len++] = c;[0m
  997 |                   else[0m
      | [0;32m                  } 
[0m[1mdfa.c:997:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  997 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  998 |                     /* This is in any case an invalid class name.  */[0m
  999 |                     str[0] = '\0';[0m
      | [0;1;32m                                  
[0m[1mdfa.c:1004:15: [0m[0;1;35mwarning: [0m[1mValue stored to 'c' is never read [clang-analyzer-deadcode.DeadStores][0m
 1004 |               c = bracket_fetch_wc (dfa);[0m
      | [0;1;32m              ^   ~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:1004:15: [0m[0;1;36mnote: [0mValue stored to 'c' is never read[0m
 1004 |               c = bracket_fetch_wc (dfa);[0m
      | [0;1;32m              ^   ~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:1005:15: [0m[0;1;35mwarning: [0m[1mValue stored to 'wc' is never read [clang-analyzer-deadcode.DeadStores][0m
 1005 |               wc = dfa->lex.wctok;[0m
      | [0;1;32m              ^    ~~~~~~~~~~~~~~
[0m[1mdfa.c:1005:15: [0m[0;1;36mnote: [0mValue stored to 'wc' is never read[0m
 1005 |               wc = dfa->lex.wctok;[0m
      | [0;1;32m              ^    ~~~~~~~~~~~~~~
[0m[1mdfa.c:1017:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1017 |                   if (!pred)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1018 |                     dfaerror (_("invalid character class"));[0m
      | [0;1;32m                                                            
[0m[1mdfa.c:1020:76: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1020 |                   if (dfa->localeinfo.multibyte && !pred->single_byte_only)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 1021 |                     known_bracket_exp = false;[0m
 1022 |                   else[0m
      | [0;32m                  } 
[0m[1mdfa.c:1022:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1022 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1023 |                     for (int c2 = 0; c2 < NOTCHAR; ++c2)[0m
 1024 |                       if (pred->func (c2))[0m
 1025 |                         setbit (c2, &ccl);[0m
      | [0;1;32m                                          
[0m[1mdfa.c:1023:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1023 |                     for (int c2 = 0; c2 < NOTCHAR; ++c2)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1024 |                       if (pred->func (c2))[0m
 1025 |                         setbit (c2, &ccl);[0m
      | [0;1;32m                                          
[0m[1mdfa.c:1024:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1024 |                       if (pred->func (c2))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1025 |                         setbit (c2, &ccl);[0m
      | [0;1;32m                                          
[0m[1mdfa.c:1027:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1027 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1028 |                 known_bracket_exp = false;[0m
      | [0;1;32m                                          
[0m[1mdfa.c:1096:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1096 |                       for (int ci = c; ci <= c2; ci++)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1097 |                         if (dfa->syntax.case_fold && isalpha (ci))[0m
 1098 |                           setbit_case_fold_c (ci, &ccl);[0m
 1099 |                         else[0m
 1100 |                           setbit (ci, &ccl);[0m
      | [0;1;32m                                            
[0m[1mdfa.c:1097:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1097 |                         if (dfa->syntax.case_fold && isalpha (ci))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 1098 |                           setbit_case_fold_c (ci, &ccl);[0m
 1099 |                         else[0m
      | [0;32m                        } 
[0m[1mdfa.c:1099:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1099 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1100 |                           setbit (ci, &ccl);[0m
      | [0;1;32m                                            
[0m[1mdfa.c:1102:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1102 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1103 |                     known_bracket_exp = false;[0m
      | [0;1;32m                                              
[0m[1mdfa.c:1114:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1114 |           if (dfa->syntax.case_fold && isalpha (c))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1115 |             setbit_case_fold_c (c, &ccl);[0m
 1116 |           else[0m
      | [0;32m          } 
[0m[1mdfa.c:1116:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1116 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1117 |             setbit (c, &ccl);[0m
      | [0;1;32m                             
[0m[1mdfa.c:1121:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1121 |       if (wc == WEOF)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1122 |         known_bracket_exp = false;[0m
 1123 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:1130:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1130 |           for (int i = 0; i < n; i++)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1131 |             if (!setbit_wc (folded[i], &ccl))[0m
 1132 |               {[0m
 1133 |                 dfa->lex.brack.chars[0m
 1134 |                   = maybe_realloc (dfa->lex.brack.chars, dfa->lex.brack.nchars,[0m
 1135 |                                    &dfa->lex.brack.nchars_alloc, -1,[0m
 1136 |                                    sizeof *dfa->lex.brack.chars);[0m
 1137 |                 dfa->lex.brack.chars[dfa->lex.brack.nchars++] = folded[i];[0m
 1138 |               }[0m
      | [0;1;32m               
[0m[1mdfa.c:1147:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1147 |       if (dfa->syntax.dfaopts & DFA_CONFUSING_BRACKETS_ERROR)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1148 |         dfaerror (msg);[0m
 1149 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:1149:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1149 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1150 |         dfawarn (msg);[0m
      | [0;1;32m                      
[0m[1mdfa.c:1153:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1153 |   if (! known_bracket_exp)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1154 |     return BACKREF;[0m
      | [0;1;32m                   
[0m[1mdfa.c:1166:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1166 |       if (dfa->syntax.syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1167 |         clrbit ('\n', &ccl);[0m
      | [0;1;32m                            
[0m[1mdfa.c:1209:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1209 |       if (2 <= i)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1210 |         abort ();[0m
      | [0;1;32m                 
[0m[1mdfa.c:1212:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1212 |       if (! dfa->lex.left)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1213 |         return dfa->lex.lasttok = END;[0m
      | [0;1;32m                                      
[0m[1mdfa.c:1219:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1219 |           if (backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1220 |             goto normal_char;[0m
 1221 |           if (dfa->lex.left == 0)[0m
 1222 |             dfaerror (_("unfinished \\ escape"));[0m
 1223 |           backslash = true;[0m
 1224 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:1219:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1219 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1220 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1221:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1221 |           if (dfa->lex.left == 0)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1222 |             dfaerror (_("unfinished \\ escape"));[0m
      | [0;1;32m                                                 
[0m[1mdfa.c:1227:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1227 |           if (backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1228 |             goto normal_char;[0m
 1229 |           if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS[0m
 1230 |               || dfa->lex.lasttok == END || dfa->lex.lasttok == LPAREN[0m
 1231 |               || dfa->lex.lasttok == OR)[0m
 1232 |             return dfa->lex.lasttok = BEGLINE;[0m
 1233 |           goto normal_char;[0m
      | [0;1;32m                          
[0m      | [0;32m                          ;} 
[0m[1mdfa.c:1227:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1227 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1228 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1231:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1231 |               || dfa->lex.lasttok == OR)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1232 |             return dfa->lex.lasttok = BEGLINE;[0m
      | [0;1;32m                                              
[0m[1mdfa.c:1236:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1236 |           if (backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:1236:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1236 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1237 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1251:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1251 |                   && dfa->lex.left > 0 && dfa->lex.ptr[0] == '\n'))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 1252 |             return dfa->lex.lasttok = ENDLINE;[0m
      | [0;1;32m                                              
[0m[1mdfa.c:1264:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1264 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1265 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1266:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1266 |           if (dfa->syntax.syntax_bits & RE_NO_BK_REFS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1267 |             goto stray_backslash;[0m
 1268 | [0m
 1269 |           dfa->lex.laststart = false;[0m
 1270 |           return dfa->lex.lasttok = BACKREF;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mdfa.c:1266:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1266 |           if (dfa->syntax.syntax_bits & RE_NO_BK_REFS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1267 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1273:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1273 |           if (!backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1274 |             goto normal_char;[0m
 1275 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
 1276 |             goto stray_backslash;[0m
 1277 | [0m
 1278 |           /* FIXME: should be beginning of string */[0m
 1279 |           return dfa->lex.lasttok = BEGLINE;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mdfa.c:1273:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1273 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1274 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1275:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1275 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1276 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1282:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1282 |           if (!backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1283 |             goto normal_char;[0m
 1284 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
 1285 |             goto stray_backslash;[0m
 1286 | [0m
 1287 |           /* FIXME: should be end of string */[0m
 1288 |           return dfa->lex.lasttok = ENDLINE;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mdfa.c:1282:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1282 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1283 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1284:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1284 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1285 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1291:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1291 |           if (!backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1292 |             goto normal_char;[0m
 1293 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
 1294 |             goto stray_backslash;[0m
 1295 | [0m
 1296 |           return dfa->lex.lasttok = BEGWORD;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mdfa.c:1291:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1291 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1292 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1293:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1293 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1294 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1299:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1299 |           if (!backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1300 |             goto normal_char;[0m
 1301 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
 1302 |             goto stray_backslash;[0m
 1303 | [0m
 1304 |           return dfa->lex.lasttok = ENDWORD;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mdfa.c:1299:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1299 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1300 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1301:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1301 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1302 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1307:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1307 |           if (!backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1308 |             goto normal_char;[0m
 1309 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
 1310 |             goto stray_backslash;[0m
 1311 | [0m
 1312 |           return dfa->lex.lasttok = LIMWORD;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mdfa.c:1307:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1307 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1308 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1309:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1309 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1310 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1315:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1315 |           if (!backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1316 |             goto normal_char;[0m
 1317 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
 1318 |             goto stray_backslash;[0m
 1319 | [0m
 1320 |           return dfa->lex.lasttok = NOTLIMWORD;[0m
      | [0;1;32m                                              
[0m      | [0;32m                                              ;} 
[0m[1mdfa.c:1315:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1315 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1316 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1317:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1317 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1318 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1323:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1323 |           if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1324 |             goto default_case;[0m
 1325 |           if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))[0m
 1326 |             goto normal_char;[0m
 1327 |           if (dfa->lex.laststart)[0m
 1328 |             {[0m
 1329 |               if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
 1330 |                 goto default_case;[0m
 1331 |               if (dfa->syntax.dfaopts & DFA_PLUS_WARN)[0m
 1332 |                 dfawarn (_("? at start of expression"));[0m
 1333 |             }[0m
 1334 |           return dfa->lex.lasttok = QMARK;[0m
      | [0;1;32m                                         
[0m      | [0;32m                                         ;} 
[0m[1mdfa.c:1323:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1323 |           if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1324 |             goto default_case;[0m
      | [0;1;32m                              
[0m[1mdfa.c:1325:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1325 |           if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 1326 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1329:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1329 |               if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1330 |                 goto default_case;[0m
      | [0;1;32m                                  
[0m[1mdfa.c:1331:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1331 |               if (dfa->syntax.dfaopts & DFA_PLUS_WARN)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1332 |                 dfawarn (_("? at start of expression"));[0m
      | [0;1;32m                                                        
[0m[1mdfa.c:1337:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1337 |           if (backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1338 |             goto normal_char;[0m
 1339 |           if (dfa->lex.laststart)[0m
 1340 |             {[0m
 1341 |               if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
 1342 |                 goto default_case;[0m
 1343 |               if (dfa->syntax.dfaopts & DFA_STAR_WARN)[0m
 1344 |                 dfawarn (_("* at start of expression"));[0m
 1345 |             }[0m
 1346 |           return dfa->lex.lasttok = STAR;[0m
      | [0;1;32m                                        
[0m      | [0;32m                                        ;} 
[0m[1mdfa.c:1337:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1337 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1338 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1341:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1341 |               if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1342 |                 goto default_case;[0m
      | [0;1;32m                                  
[0m[1mdfa.c:1343:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1343 |               if (dfa->syntax.dfaopts & DFA_STAR_WARN)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1344 |                 dfawarn (_("* at start of expression"));[0m
      | [0;1;32m                                                        
[0m[1mdfa.c:1349:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1349 |           if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1350 |             goto default_case;[0m
 1351 |           if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))[0m
 1352 |             goto normal_char;[0m
 1353 |           if (dfa->lex.laststart)[0m
 1354 |             {[0m
 1355 |               if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
 1356 |                 goto default_case;[0m
 1357 |               if (dfa->syntax.dfaopts & DFA_PLUS_WARN)[0m
 1358 |                 dfawarn (_("+ at start of expression"));[0m
 1359 |             }[0m
 1360 |           return dfa->lex.lasttok = PLUS;[0m
      | [0;1;32m                                        
[0m      | [0;32m                                        ;} 
[0m[1mdfa.c:1349:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1349 |           if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1350 |             goto default_case;[0m
      | [0;1;32m                              
[0m[1mdfa.c:1351:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1351 |           if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 1352 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1355:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1355 |               if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1356 |                 goto default_case;[0m
      | [0;1;32m                                  
[0m[1mdfa.c:1357:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1357 |               if (dfa->syntax.dfaopts & DFA_PLUS_WARN)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1358 |                 dfawarn (_("+ at start of expression"));[0m
      | [0;1;32m                                                        
[0m[1mdfa.c:1363:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1363 |           if (!(dfa->syntax.syntax_bits & RE_INTERVALS))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:1363:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1363 |           if (!(dfa->syntax.syntax_bits & RE_INTERVALS))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1364 |             goto default_case;[0m
      | [0;1;32m                              
[0m[1mdfa.c:1365:79: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1365 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_BRACES) == 0))[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1366 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1378:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1378 |             for (; p != lim && c_isdigit (*p); p++)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1379 |               dfa->lex.minrep = (dfa->lex.minrep < 0[0m
 1380 |                                  ? *p - '0'[0m
 1381 |                                  : MIN (RE_DUP_MAX + 1,[0m
 1382 |                                         dfa->lex.minrep * 10 + *p - '0'));[0m
      | [0;1;32m                                                                          
[0m[1mdfa.c:1385:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1385 |                 if (*p != ',')[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1386 |                   dfa->lex.maxrep = dfa->lex.minrep;[0m
 1387 |                 else[0m
      | [0;32m                } 
[0m[1mdfa.c:1389:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1389 |                     if (dfa->lex.minrep < 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1390 |                       dfa->lex.minrep = 0;[0m
      | [0;1;32m                                          
[0m[1mdfa.c:1391:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1391 |                     while (++p != lim && c_isdigit (*p))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1392 |                       dfa->lex.maxrep[0m
 1393 |                         = (dfa->lex.maxrep < 0[0m
 1394 |                            ? *p - '0'[0m
 1395 |                            : MIN (RE_DUP_MAX + 1,[0m
 1396 |                                   dfa->lex.maxrep * 10 + *p - '0'));[0m
      | [0;1;32m                                                                    
[0m[1mdfa.c:1406:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1406 |                 && (dfa->syntax.syntax_bits & RE_INVALID_INTERVAL_ORD))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 1407 |               goto normal_char;[0m
      | [0;1;32m                               
[0m[1mdfa.c:1410:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1410 |                 if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1411 |                   goto default_case;[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1412:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1412 |                 if (dfa->syntax.dfaopts & DFA_PLUS_WARN)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1413 |                   dfawarn (_("{...} at start of expression"));[0m
      | [0;1;32m                                                              
[0m[1mdfa.c:1415:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1415 |             if (invalid_content)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1416 |               dfaerror (_("invalid content of \\{\\}"));[0m
      | [0;1;32m                                                        
[0m[1mdfa.c:1417:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1417 |             if (RE_DUP_MAX < dfa->lex.maxrep)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1418 |               dfaerror (_("regular expression too big"));[0m
      | [0;1;32m                                                         
[0m[1mdfa.c:1426:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1426 |           if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1427 |             goto default_case;[0m
 1428 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_VBAR) == 0))[0m
 1429 |             goto normal_char;[0m
 1430 |           dfa->lex.laststart = true;[0m
 1431 |           return dfa->lex.lasttok = OR;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mdfa.c:1426:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1426 |           if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1427 |             goto default_case;[0m
      | [0;1;32m                              
[0m[1mdfa.c:1428:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1428 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_VBAR) == 0))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 1429 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1434:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1434 |           if (!(dfa->syntax.syntax_bits & RE_NEWLINE_ALT))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1435 |             goto default_case;[0m
 1436 |           if (backslash)[0m
 1437 |             goto normal_char;[0m
 1438 |           dfa->lex.laststart = true;[0m
 1439 |           return dfa->lex.lasttok = OR;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mdfa.c:1434:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1434 |           if (!(dfa->syntax.syntax_bits & RE_NEWLINE_ALT))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1435 |             goto default_case;[0m
      | [0;1;32m                              
[0m[1mdfa.c:1436:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1436 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1437 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1442:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1442 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1443 |             goto normal_char;[0m
 1444 |           dfa->lex.parens++;[0m
 1445 |           dfa->lex.laststart = true;[0m
 1446 |           return dfa->lex.lasttok = LPAREN;[0m
      | [0;1;32m                                          
[0m      | [0;32m                                          ;} 
[0m[1mdfa.c:1442:79: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1442 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1443 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1449:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1449 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1450 |             goto normal_char;[0m
 1451 |           if (dfa->lex.parens == 0[0m
 1452 |               && dfa->syntax.syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)[0m
 1453 |             goto normal_char;[0m
 1454 |           dfa->lex.parens--;[0m
 1455 |           dfa->lex.laststart = false;[0m
 1456 |           return dfa->lex.lasttok = RPAREN;[0m
      | [0;1;32m                                          
[0m      | [0;32m                                          ;} 
[0m[1mdfa.c:1449:79: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1449 |           if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1450 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1452:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1452 |               && dfa->syntax.syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 1453 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1459:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1459 |           if (backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:1459:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1459 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1460 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1465:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1465 |               if (!(dfa->syntax.syntax_bits & RE_DOT_NEWLINE))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1466 |                 clrbit ('\n', &ccl);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1467:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1467 |               if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1468 |                 clrbit ('\0', &ccl);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1469:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1469 |               if (dfa->localeinfo.multibyte)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1470 |                 for (int c2 = 0; c2 < NOTCHAR; c2++)[0m
 1471 |                   if (dfa->localeinfo.sbctowc[c2] == WEOF)[0m
 1472 |                     clrbit (c2, &ccl);[0m
      | [0;1;32m                                      
[0m[1mdfa.c:1470:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1470 |                 for (int c2 = 0; c2 < NOTCHAR; c2++)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1471 |                   if (dfa->localeinfo.sbctowc[c2] == WEOF)[0m
 1472 |                     clrbit (c2, &ccl);[0m
      | [0;1;32m                                      
[0m[1mdfa.c:1471:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1471 |                   if (dfa->localeinfo.sbctowc[c2] == WEOF)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1472 |                     clrbit (c2, &ccl);[0m
      | [0;1;32m                                      
[0m[1mdfa.c:1482:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1482 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1483 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1484:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1484 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:1484:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1484 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1485 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1491:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1491 |               for (int c2 = 0; c2 < NOTCHAR; ++c2)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 1492 |                 if (isspace (c2))[0m
 1493 |                   setbit (c2, &ccl);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1492:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1492 |                 if (isspace (c2))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1493 |                   setbit (c2, &ccl);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1494:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1494 |               if (c == 'S')[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1495 |                 notset (&ccl);[0m
      | [0;1;32m                              
[0m[1mdfa.c:1518:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1518 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1519 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1520:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1520 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:1520:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1520 |           if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1521 |             goto stray_backslash;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:1527:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1527 |               for (int c2 = 0; c2 < NOTCHAR; ++c2)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 1528 |                 if (dfa->syntax.sbit[c2] == CTX_LETTER)[0m
 1529 |                   setbit (c2, &ccl);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1528:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1528 |                 if (dfa->syntax.sbit[c2] == CTX_LETTER)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1529 |                   setbit (c2, &ccl);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:1530:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1530 |               if (c == 'W')[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1531 |                 notset (&ccl);[0m
      | [0;1;32m                              
[0m[1mdfa.c:1553:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1553 |           if (backslash)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1554 |             goto normal_char;[0m
 1555 |           dfa->lex.laststart = false;[0m
 1556 |           return dfa->lex.lasttok = parse_bracket_exp (dfa);[0m
      | [0;1;32m                                                           
[0m      | [0;32m                                                           ;} 
[0m[1mdfa.c:1553:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1553 |           if (backslash)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1554 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1559:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1559 |         default_case:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mdfa.c:1560:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1560 |           if (!backslash)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1561 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mdfa.c:1567:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1567 |               if (!iswprint (dfa->lex.wctok))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1568 |                 msg = _("stray \\ before unprintable character");[0m
 1569 |               else if (iswspace (dfa->lex.wctok))[0m
      | [0;32m              } 
[0m[1mdfa.c:1569:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1569 |               else if (iswspace (dfa->lex.wctok))[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1570 |                 msg = _("stray \\ before white space");[0m
 1571 |               else[0m
      | [0;32m              } 
[0m[1mdfa.c:1573:27: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1573 |                   int n = snprintf (msgbuf, sizeof msgbuf,[0m
      | [0;1;32m                          ^~~~~~~~
[0m[1mdfa.c:1573:27: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 1573 |                   int n = snprintf (msgbuf, sizeof msgbuf,[0m
      | [0;1;32m                          ^~~~~~~~
[0m[1mdfa.c:1585:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1585 |           if (dfa->localeinfo.multibyte)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1586 |             return dfa->lex.lasttok = WCHAR;[0m
 1587 | [0m
 1588 |           if (dfa->syntax.case_fold && isalpha (c))[0m
 1589 |             {[0m
 1590 |               charclass ccl;[0m
 1591 |               zeroset (&ccl);[0m
 1592 |               setbit_case_fold_c (c, &ccl);[0m
 1593 |               return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);[0m
 1594 |             }[0m
 1595 | [0m
 1596 |           return dfa->lex.lasttok = c;[0m
      | [0;1;32m                                     
[0m      | [0;32m                                     ;} 
[0m[1mdfa.c:1585:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1585 |           if (dfa->localeinfo.multibyte)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1586 |             return dfa->lex.lasttok = WCHAR;[0m
      | [0;1;32m                                            
[0m[1mdfa.c:1608:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1608 |       if (dfa->localeinfo.multibyte)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1609 |         dfa->multibyte_prop = xreallocarray (dfa->multibyte_prop, dfa->talloc,[0m
 1610 |                                              sizeof *dfa->multibyte_prop);[0m
      | [0;1;32m                                                                          
[0m[1mdfa.c:1612:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1612 |   if (dfa->localeinfo.multibyte)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1613 |     dfa->multibyte_prop[dfa->tindex] = mbprop;[0m
      | [0;1;32m                                              
[0m[1mdfa.c:1626:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1626 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mdfa.c:1629:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1629 |       dfa->epsilon = true;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1630 |       goto increment_depth;[0m
      | [0;1;32m                          
[0m      | [0;32m                          ;} 
[0m[1mdfa.c:1633:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1633 |       dfa->fast = false;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1634 |       goto increment_nleaves;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mdfa.c:1643:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1643 |       FALLTHROUGH;[0m
      | [0;1;32m      ^           
[0m      | [0;32m      {           ;} 
[0m[1mdfa.c:74:23: [0m[0;1;36mnote: [0mexpanded from macro 'FALLTHROUGH'[0m
   74 | #  define FALLTHROUGH __attribute__ ((__fallthrough__))[0m
      | [0;1;32m                      ^
[0m[1mdfa.c:1645:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1645 |     increment_nleaves:[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1646 |       dfa->nleaves++;[0m
 1647 |     increment_depth:[0m
 1648 |       dfa->parse.depth++;[0m
 1649 |       if (dfa->depth < dfa->parse.depth)[0m
 1650 |         dfa->depth = dfa->parse.depth;[0m
 1651 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mdfa.c:1649:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1649 |       if (dfa->depth < dfa->parse.depth)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1650 |         dfa->depth = dfa->parse.depth;[0m
      | [0;1;32m                                      
[0m[1mdfa.c:1671:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1671 |           if (need_or)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1672 |             addtok (dfa, OR);[0m
      | [0;1;32m                             
[0m[1mdfa.c:1682:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1682 |           if (need_or)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1683 |             addtok (dfa, OR);[0m
      | [0;1;32m                             
[0m[1mdfa.c:1706:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1706 |   if (stored_bytes != (size_t) -1)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1707 |     buflen = stored_bytes;[0m
 1708 |   else[0m
      | [0;32m  } 
[0m[1mdfa.c:1794:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1794 |       if (! (dfa->syntax.syntax_bits & RE_DOT_NEWLINE))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1795 |         clrbit ('\n', &c);[0m
      | [0;1;32m                          
[0m[1mdfa.c:1796:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1796 |       if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1797 |         clrbit ('\0', &c);[0m
      | [0;1;32m                          
[0m[1mdfa.c:1800:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1800 |       for (int i = 1; i < sizeof utf8_classes / sizeof *utf8_classes; i++)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 1801 |         dfa->utf8_anychar_classes[i][0m
 1802 |           = CSET + charclass_index (dfa, &utf8_classes[i]);[0m
      | [0;1;32m                                                           
[0m[1mdfa.c:1894:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1894 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1895 |         addtok (dfa, dfa->parse.tok);[0m
      | [0;1;32m                                     
[0m[1mdfa.c:1900:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1900 |       if (dfa->lex.wctok == WEOF)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1901 |         addtok (dfa, BACKREF);[0m
 1902 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:1924:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1924 |       if (dfa->parse.tok != RPAREN)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1925 |         dfaerror (_("unbalanced ("));[0m
      | [0;1;32m                                     
[0m[1mdfa.c:1928:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1928 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1929 |     addtok (dfa, EMPTY);[0m
      | [0;1;32m                        
[0m[1mdfa.c:1939:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1939 |       return 1;[0m
      | [0;1;32m      ^       
[0m      | [0;32m      {       ;} 
[0m[1mdfa.c:1957:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1957 |   if (dfa->localeinfo.multibyte)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1958 |     for (idx_t i = 0; i < ntokens; i++)[0m
 1959 |       addtok_mb (dfa, dfa->tokens[tindex + i],[0m
 1960 |                  dfa->multibyte_prop[tindex + i]);[0m
 1961 |   else[0m
      | [0;32m  } 
[0m[1mdfa.c:1958:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1958 |     for (idx_t i = 0; i < ntokens; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1959 |       addtok_mb (dfa, dfa->tokens[tindex + i],[0m
 1960 |                  dfa->multibyte_prop[tindex + i]);[0m
      | [0;1;32m                                                  
[0m[1mdfa.c:1961:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1961 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1962 |     for (idx_t i = 0; i < ntokens; i++)[0m
 1963 |       addtok_mb (dfa, dfa->tokens[tindex + i], 3);[0m
      | [0;1;32m                                                  
[0m[1mdfa.c:1962:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1962 |     for (idx_t i = 0; i < ntokens; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1963 |       addtok_mb (dfa, dfa->tokens[tindex + i], 3);[0m
      | [0;1;32m                                                  
[0m[1mdfa.c:1971:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1971 |          || dfa->parse.tok == PLUS || dfa->parse.tok == REPMN)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m[1mdfa.c:1976:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1976 |         if (dfa->lex.maxrep < 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1977 |           addtok (dfa, PLUS);[0m
      | [0;1;32m                             
[0m[1mdfa.c:1978:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1978 |         if (dfa->lex.minrep == 0)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1979 |           addtok (dfa, QMARK);[0m
      | [0;1;32m                              
[0m[1mdfa.c:2041:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2041 |   if (!d->syntax.syntax_bits_set)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2042 |     dfaerror (_("no syntax specified"));[0m
      | [0;1;32m                                        
[0m[1mdfa.c:2044:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2044 |   if (!d->nregexps)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 2045 |     addtok (d, BEG);[0m
      | [0;1;32m                    
[0m[1mdfa.c:2052:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2052 |   if (d->parse.tok != END)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2053 |     dfaerror (_("unbalanced )"));[0m
      | [0;1;32m                                 
[0m[1mdfa.c:2058:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2058 |   if (d->nregexps)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2059 |     addtok (d, OR);[0m
      | [0;1;32m                   
[0m[1mdfa.c:2077:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2077 |   if (src->nelem != 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2078 |     memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);[0m
      | [0;1;32m                                                                     
[0m[1mdfa.c:2078:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2078 |     memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);[0m
      | [0;1;32m    ^~~~~~
[0m[1mdfa.c:2078:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2078 |     memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);[0m
      | [0;1;32m    ^~~~~~
[0m[1mdfa.c:2101:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2101 |       if (s->elems[mid].index < p.index)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2102 |         lo = mid + 1;[0m
 2103 |       else if (s->elems[mid].index == p.index)[0m
      | [0;32m      } 
[0m[1mdfa.c:2108:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2108 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2109 |         hi = mid;[0m
      | [0;1;32m                 
[0m[1mdfa.c:2113:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2113 |   for (idx_t i = count; i > lo; i--)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2114 |     s->elems[i] = s->elems[i - 1];[0m
      | [0;1;32m                                  
[0m[1mdfa.c:2143:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2143 |   while (i < s1->nelem || j < s2->nelem)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m[1mdfa.c:2180:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2180 |       for (idx_t i = 0; i < src->nelem; i++)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2181 |         insert (src->elems[i], dst);[0m
      | [0;1;32m                                    
[0m[1mdfa.c:2200:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2200 |       if (s->elems[mid].index < del)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2201 |         lo = mid + 1;[0m
 2202 |       else if (s->elems[mid].index == del)[0m
      | [0;32m      } 
[0m[1mdfa.c:2206:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2206 |           for (i = mid; i + 1 < count; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2207 |             s->elems[i] = s->elems[i + 1];[0m
      | [0;1;32m                                          
[0m[1mdfa.c:2211:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2211 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2212 |         hi = mid;[0m
      | [0;1;32m                 
[0m[1mdfa.c:2251:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2251 |           || context != d->states[i].context)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2252 |         continue;[0m
      | [0;1;32m                 
[0m[1mdfa.c:2254:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2254 |       for (j = 0; j < s->nelem; ++j)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2255 |         if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint[0m
 2256 |             || s->elems[j].index != d->states[i].elems.elems[j].index)[0m
 2257 |           break;[0m
      | [0;1;32m                
[0m[1mdfa.c:2256:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2256 |             || s->elems[j].index != d->states[i].elems.elems[j].index)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2257 |           break;[0m
      | [0;1;32m                
[0m[1mdfa.c:2258:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2258 |       if (j == s->nelem)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2259 |         return i;[0m
      | [0;1;32m                 
[0m[1mdfa.c:2290:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2290 |           if (succeeds_in_context (c, context, CTX_ANY))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2291 |             constraint |= c;[0m
      | [0;1;32m                            
[0m[1mdfa.c:2293:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2293 |       else if (d->tokens[s->elems[j].index] == BACKREF)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2294 |         constraint = NO_CONSTRAINT;[0m
      | [0;1;32m                                   
[0m[1mdfa.c:2326:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2326 |   for (idx_t i = 0; i < d->tindex; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m[1mdfa.c:2333:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2333 |             continue;[0m
      | [0;1;32m            ^       
[0m      | [0;32m            {       ;} 
[0m[1mdfa.c:2336:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2336 |             constraint = BEGLINE_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2337 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2339:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2339 |             constraint = ENDLINE_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2340 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2342:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2342 |             constraint = BEGWORD_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2343 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2345:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2345 |             constraint = ENDWORD_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2346 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2348:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2348 |             constraint = LIMWORD_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2349 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2351:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2351 |             constraint = NOTLIMWORD_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2352 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2354:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2354 |             constraint = NO_CONSTRAINT;[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2355 |             break;[0m
      | [0;1;32m                 
[0m      | [0;32m                 ;} 
[0m[1mdfa.c:2360:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2360 |         for (idx_t j = 0; j < backward[i].nelem; j++)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2361 |           replace (&d->follows[backward[i].elems[j].index], i, &d->follows[i],[0m
 2362 |                    constraint, &tmp);[0m
      | [0;1;32m                                     
[0m[1mdfa.c:2363:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2363 |         for (idx_t j = 0; j < d->follows[i].nelem; j++)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2364 |           replace (&backward[d->follows[i].elems[j].index], i, &backward[i],[0m
 2365 |                    NO_CONSTRAINT, &tmp);[0m
      | [0;1;32m                                        
[0m[1mdfa.c:2380:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2380 |       if (c->w[j] & dfa->syntax.newline.w[j])[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2381 |         context |= CTX_NEWLINE;[0m
      | [0;1;32m                               
[0m[1mdfa.c:2382:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2382 |       if (c->w[j] & dfa->syntax.letters.w[j])[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2383 |         context |= CTX_LETTER;[0m
      | [0;1;32m                              
[0m[1mdfa.c:2384:76: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2384 |       if (c->w[j] & ~(dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j]))[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 2385 |         context |= CTX_NONE;[0m
      | [0;1;32m                            
[0m[1mdfa.c:2402:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2402 |   for (idx_t j = 0; j < s->nelem; j++)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2403 |     separate_contexts |= d->separates[s->elems[j].index];[0m
      | [0;1;32m                                                         
[0m[1mdfa.c:2441:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2441 |       if (iconstraint == 0)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2442 |         continue;[0m
      | [0;1;32m                 
[0m[1mdfa.c:2458:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2458 |               if (dindex == tindex)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2459 |                 continue;[0m
      | [0;1;32m                         
[0m[1mdfa.c:2461:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2461 |               if (follows[tindex].elems[j].constraint != iconstraint)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 2462 |                 continue;[0m
      | [0;1;32m                         
[0m[1mdfa.c:2464:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2464 |               if (flags[dindex] & (OPT_LPAREN | OPT_RPAREN))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 2465 |                 continue;[0m
      | [0;1;32m                         
[0m[1mdfa.c:2467:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2467 |               if (d->tokens[sindex] != d->tokens[dindex])[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 2468 |                 continue;[0m
      | [0;1;32m                         
[0m[1mdfa.c:2470:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2470 |               if ((flags[sindex] ^ flags[dindex]) & OPT_REPEAT)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 2471 |                 continue;[0m
      | [0;1;32m                         
[0m[1mdfa.c:2473:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2473 |               if (flags[sindex] & OPT_REPEAT)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2474 |                 delete (sindex, &follows[sindex]);[0m
      | [0;1;32m                                                  
[0m[1mdfa.c:2481:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2481 |           if (j < nelem)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2482 |             continue;[0m
      | [0;1;32m                     
[0m[1mdfa.c:2505:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2505 |   for (idx_t i = 1; i < d->tindex; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2506 |     map[i] = -1;[0m
      | [0;1;32m                
[0m[1mdfa.c:2529:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2529 |       if (multibyte_prop != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2530 |         multibyte_prop[map[i]] = d->multibyte_prop[i];[0m
      | [0;1;32m                                                      
[0m[1mdfa.c:2534:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2534 |           if (map[d->follows[i].elems[j].index] == -1)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 2535 |             map[d->follows[i].elems[j].index] = nleaves++;[0m
      | [0;1;32m                                                          
[0m[1mdfa.c:2550:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2550 |       if (multibyte_prop != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2551 |         d->multibyte_prop[i] = multibyte_prop[i];[0m
      | [0;1;32m                                                 
[0m[1mdfa.c:2572:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2572 |           if (d->follows[i].elems[j].index == i)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 2573 |             flags[d->follows[i].elems[j].index] |= OPT_REPEAT;[0m
 2574 |           else if (d->follows[i].elems[j].index < i)[0m
      | [0;32m          } 
[0m[1mdfa.c:2574:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2574 |           else if (d->follows[i].elems[j].index < i)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2575 |             flags[d->follows[i].elems[j].index] |= OPT_LPAREN;[0m
 2576 |           else if (flags[d->follows[i].elems[j].index] &= OPT_WALKED)[0m
      | [0;32m          } 
[0m[1mdfa.c:2576:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2576 |           else if (flags[d->follows[i].elems[j].index] &= OPT_WALKED)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 2577 |             flags[d->follows[i].elems[j].index] |= OPT_RPAREN;[0m
 2578 |           else[0m
      | [0;32m          } 
[0m[1mdfa.c:2578:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2578 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2579 |             flags[d->follows[i].elems[j].index] |= OPT_WALKED;[0m
      | [0;1;32m                                                              
[0m[1mdfa.c:2591:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2591 |   for (idx_t i = 0; i < d->tindex; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2592 |     if (flags[i] & OPT_QUEUED)[0m
 2593 |       merge_nfa_state (d, i, flags, merged);[0m
      | [0;1;32m                                            
[0m[1mdfa.c:2592:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2592 |     if (flags[i] & OPT_QUEUED)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2593 |       merge_nfa_state (d, i, flags, merged);[0m
      | [0;1;32m                                            
[0m[1mdfa.c:2702:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2702 |           stk->nullable = true;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2703 | [0m
 2704 |           /* The firstpos and lastpos of the empty leaf are both empty.  */[0m
 2705 |           stk->nfirstpos = stk->nlastpos = 0;[0m
 2706 |           stk++;[0m
 2707 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:2718:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2718 |                    p < firstpos; p++)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2719 |                 merge2 (&backward[p->index], &tmp, &merged);[0m
      | [0;1;32m                                                            
[0m[1mdfa.c:2724:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2724 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2725 |             tmp.elems = firstpos - stk[-1].nfirstpos;[0m
 2726 |             tmp.nelem = stk[-1].nfirstpos;[0m
 2727 |             for (position *p = lastpos - stk[-1].nlastpos; p < lastpos; p++)[0m
 2728 |               merge2 (&d->follows[p->index], &tmp, &merged);[0m
 2729 |           }[0m
 2730 |           FALLTHROUGH;[0m
      | [0;1;32m                      
[0m      | [0;32m                      ;} 
[0m[1mdfa.c:2727:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2727 |             for (position *p = lastpos - stk[-1].nlastpos; p < lastpos; p++)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 2728 |               merge2 (&d->follows[p->index], &tmp, &merged);[0m
      | [0;1;32m                                                            
[0m[1mdfa.c:2733:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2733 |           if (d->tokens[i] != PLUS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2734 |             stk[-1].nullable = true;[0m
 2735 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:2733:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2733 |           if (d->tokens[i] != PLUS)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2734 |             stk[-1].nullable = true;[0m
      | [0;1;32m                                    
[0m[1mdfa.c:2741:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2741 |           if (backward)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:2746:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2746 |                    p < firstpos; p++)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2747 |                 merge2 (&backward[p->index], &tmp, &merged);[0m
      | [0;1;32m                                                            
[0m[1mdfa.c:2757:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2757 |                  p < plim; p++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2758 |               merge2 (&d->follows[p->index], &tmp, &merged);[0m
      | [0;1;32m                                                            
[0m[1mdfa.c:2763:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2763 |           if (stk[-2].nullable)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2764 |             stk[-2].nfirstpos += stk[-1].nfirstpos;[0m
 2765 |           else[0m
      | [0;32m          } 
[0m[1mdfa.c:2765:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2765 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2766 |             firstpos -= stk[-1].nfirstpos;[0m
      | [0;1;32m                                          
[0m[1mdfa.c:2770:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2770 |           if (stk[-1].nullable)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2771 |             stk[-2].nlastpos += stk[-1].nlastpos;[0m
 2772 |           else[0m
      | [0;32m          } 
[0m[1mdfa.c:2775:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2775 |               for (idx_t j = 0; j < stk[-1].nlastpos; j++)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2776 |                 p[j] = p[j + stk[-2].nlastpos];[0m
      | [0;1;32m                                               
[0m[1mdfa.c:2788:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2788 |           stk[-2].nfirstpos += stk[-1].nfirstpos;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2789 | [0m
 2790 |           /* The lastpos is the union of the lastpos of each argument.  */[0m
 2791 |           stk[-2].nlastpos += stk[-1].nlastpos;[0m
 2792 | [0m
 2793 |           /* An OR node is nullable if either argument is nullable.  */[0m
 2794 |           stk[-2].nullable |= stk[-1].nullable;[0m
 2795 |           stk--;[0m
 2796 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:2804:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2804 |           stk->nullable = d->tokens[i] == BACKREF;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2805 | [0m
 2806 |           /* This position is in its own firstpos and lastpos.  */[0m
 2807 |           stk->nfirstpos = stk->nlastpos = 1;[0m
 2808 |           stk++;[0m
 2809 | [0m
 2810 |           firstpos->index = lastpos->index = i;[0m
 2811 |           firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;[0m
 2812 |           firstpos++, lastpos++;[0m
 2813 | [0m
 2814 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:2845:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2845 |       for (idx_t i = 0; i < tindex; i++)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2846 |         free (backward[i].elems);[0m
      | [0;1;32m                                 
[0m[1mdfa.c:2881:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2881 |       if (prev_newline_dependent (d->constraints[i]))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2882 |         d->separates[i] |= CTX_NEWLINE;[0m
      | [0;1;32m                                       
[0m[1mdfa.c:2883:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2883 |       if (prev_letter_dependent (d->constraints[i]))[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2884 |         d->separates[i] |= CTX_LETTER;[0m
      | [0;1;32m                                      
[0m[1mdfa.c:2888:74: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2888 |           if (prev_newline_dependent (d->follows[i].elems[j].constraint))[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 2889 |             d->separates[i] |= CTX_NEWLINE;[0m
      | [0;1;32m                                           
[0m[1mdfa.c:2890:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2890 |           if (prev_letter_dependent (d->follows[i].elems[j].constraint))[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 2891 |             d->separates[i] |= CTX_LETTER;[0m
      | [0;1;32m                                          
[0m[1mdfa.c:2899:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2899 |   if (separate_contexts & CTX_NEWLINE)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2900 |     state_index (d, &tmp, CTX_NEWLINE);[0m
      | [0;1;32m                                       
[0m[1mdfa.c:2903:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2903 |   if (separate_contexts & CTX_LETTER)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2904 |     d->min_trcount = state_index (d, &tmp, CTX_LETTER);[0m
      | [0;1;32m                                                       
[0m[1mdfa.c:2935:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2935 |           if (oldalloc == 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2936 |             realtrans[0] = realtrans[1] = NULL;[0m
      | [0;1;32m                                               
[0m[1mdfa.c:2943:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2943 |           if (d->localeinfo.multibyte)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2944 |             d->mb_trans[oldalloc] = NULL;[0m
      | [0;1;32m                                         
[0m[1mdfa.c:3023:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3023 |       for (int i = 0; i < NOTCHAR; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3024 |         trans[i] = -2;[0m
      | [0;1;32m                      
[0m[1mdfa.c:3029:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3029 |   if (accepts_in_context (d->states[s].context, CTX_NEWLINE, s, d))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 3030 |     d->success[s] |= CTX_NEWLINE;[0m
      | [0;1;32m                                 
[0m[1mdfa.c:3031:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3031 |   if (accepts_in_context (d->states[s].context, CTX_LETTER, s, d))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3032 |     d->success[s] |= CTX_LETTER;[0m
      | [0;1;32m                                
[0m[1mdfa.c:3033:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3033 |   if (accepts_in_context (d->states[s].context, CTX_NONE, s, d))[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 3034 |     d->success[s] |= CTX_NONE;[0m
      | [0;1;32m                              
[0m[1mdfa.c:3040:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3040 |   for (idx_t j = 0; j < d->states[s].elems.nelem; j++)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3041 |     for (idx_t k = 0;[0m
 3042 |          k < d->follows[d->states[s].elems.elems[j].index].nelem; ++k)[0m
 3043 |       insert (d->follows[d->states[s].elems.elems[j].index].elems[k],[0m
 3044 |               &follows);[0m
      | [0;1;32m                        
[0m[1mdfa.c:3042:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3042 |          k < d->follows[d->states[s].elems.elems[j].index].nelem; ++k)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 3043 |       insert (d->follows[d->states[s].elems.elems[j].index].elems[k],[0m
 3044 |               &follows);[0m
      | [0;1;32m                        
[0m[1mdfa.c:3062:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3062 |           if (d->tokens[pos.index] == uc)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 3063 |             matched = true;[0m
      | [0;1;32m                           
[0m[1mdfa.c:3068:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3068 |           if (tstbit (uc, &matches))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3069 |             matched = true;[0m
      | [0;1;32m                           
[0m[1mdfa.c:3074:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3074 |           if (tstbit (uc, &matches))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3075 |             matched = true;[0m
      | [0;1;32m                           
[0m[1mdfa.c:3086:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3086 |               if (d->states[s].mbps.nelem == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 3087 |                 alloc_position_set (&d->states[s].mbps, 1);[0m
      | [0;1;32m                                                           
[0m[1mdfa.c:3091:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3091 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 3092 |         continue;[0m
      | [0;1;32m                 
[0m[1mdfa.c:3099:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3099 |                                     d->states[s].context, CTX_NEWLINE))[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 3100 |             for (int j = 0; j < CHARCLASS_WORDS; j++)[0m
 3101 |               matches.w[j] &= ~d->syntax.newline.w[j];[0m
      | [0;1;32m                                                      
[0m[1mdfa.c:3100:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3100 |             for (int j = 0; j < CHARCLASS_WORDS; j++)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 3101 |               matches.w[j] &= ~d->syntax.newline.w[j];[0m
      | [0;1;32m                                                      
[0m[1mdfa.c:3103:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3103 |                                     d->states[s].context, CTX_LETTER))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 3104 |             for (int j = 0; j < CHARCLASS_WORDS; ++j)[0m
 3105 |               matches.w[j] &= ~d->syntax.letters.w[j];[0m
      | [0;1;32m                                                      
[0m[1mdfa.c:3104:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3104 |             for (int j = 0; j < CHARCLASS_WORDS; ++j)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 3105 |               matches.w[j] &= ~d->syntax.letters.w[j];[0m
      | [0;1;32m                                                      
[0m[1mdfa.c:3107:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3107 |                                     d->states[s].context, CTX_NONE))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 3108 |             for (int j = 0; j < CHARCLASS_WORDS; ++j)[0m
 3109 |               matches.w[j] &= d->syntax.letters.w[j] | d->syntax.newline.w[j];[0m
      | [0;1;32m                                                                              
[0m[1mdfa.c:3108:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3108 |             for (int j = 0; j < CHARCLASS_WORDS; ++j)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 3109 |               matches.w[j] &= d->syntax.letters.w[j] | d->syntax.newline.w[j];[0m
      | [0;1;32m                                                                              
[0m[1mdfa.c:3112:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3112 |           if (emptyset (&matches))[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3113 |             continue;[0m
      | [0;1;32m                     
[0m[1mdfa.c:3118:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3118 |           if (!tstbit (uc, &matches))[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3119 |             matched = false;[0m
      | [0;1;32m                            
[0m[1mdfa.c:3134:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3134 |           for (int k = 0; k < CHARCLASS_WORDS; ++k)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3135 |             label.w[k] &= matches.w[k];[0m
      | [0;1;32m                                       
[0m[1mdfa.c:3140:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3140 |           for (int k = 0; k < CHARCLASS_WORDS; ++k)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3141 |             label.w[k] &= ~matches.w[k];[0m
      | [0;1;32m                                        
[0m[1mdfa.c:3174:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3174 |               for (idx_t j = 0; mergeit && j < group.nelem; j++)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 3175 |                 mergeit &= d->multibyte_prop[group.elems[j].index];[0m
      | [0;1;32m                                                                   
[0m[1mdfa.c:3177:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3177 |           if (mergeit)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3178 |             merge2 (&group, &d->states[0].elems, &tmp);[0m
      | [0;1;32m                                                       
[0m[1mdfa.c:3188:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3188 |       if (possible_contexts & ~separate_contexts)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 3189 |         state = state_index (d, &group, separate_contexts ^ CTX_ANY);[0m
 3190 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:3190:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3190 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 3191 |         state = -1;[0m
      | [0;1;32m                   
[0m[1mdfa.c:3192:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3192 |       if (separate_contexts & possible_contexts & CTX_NEWLINE)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 3193 |         state_newline = state_index (d, &group, CTX_NEWLINE);[0m
 3194 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:3194:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3194 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 3195 |         state_newline = state;[0m
      | [0;1;32m                              
[0m[1mdfa.c:3196:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3196 |       if (separate_contexts & possible_contexts & CTX_LETTER)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3197 |         state_letter = state_index (d, &group, CTX_LETTER);[0m
 3198 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:3198:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3198 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 3199 |         state_letter = state;[0m
      | [0;1;32m                             
[0m[1mdfa.c:3222:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3222 |   for (int i = 0; i < NOTCHAR; i++)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3223 |     if (tstbit (i, &label))[0m
 3224 |       switch (d->syntax.sbit[i])[0m
 3225 |         {[0m
 3226 |         case CTX_NEWLINE:[0m
 3227 |           trans[i] = state_newline;[0m
 3228 |           break;[0m
 3229 |         case CTX_LETTER:[0m
 3230 |           trans[i] = state_letter;[0m
 3231 |           break;[0m
 3232 |         default:[0m
 3233 |           trans[i] = state;[0m
 3234 |           break;[0m
 3235 |         }[0m
      | [0;1;32m         
[0m[1mdfa.c:3223:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3223 |     if (tstbit (i, &label))[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 3224 |       switch (d->syntax.sbit[i])[0m
 3225 |         {[0m
 3226 |         case CTX_NEWLINE:[0m
 3227 |           trans[i] = state_newline;[0m
 3228 |           break;[0m
 3229 |         case CTX_LETTER:[0m
 3230 |           trans[i] = state_letter;[0m
 3231 |           break;[0m
 3232 |         default:[0m
 3233 |           trans[i] = state;[0m
 3234 |           break;[0m
 3235 |         }[0m
      | [0;1;32m         
[0m[1mdfa.c:3227:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3227 |           trans[i] = state_newline;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3228 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:3230:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3230 |           trans[i] = state_letter;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3231 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:3233:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3233 |           trans[i] = state;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3234 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:3274:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3274 |   if (d->trans[s])[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 3275 |     t = d->trans[s];[0m
 3276 |   else if (d->fails[s])[0m
      | [0;32m  } 
[0m[1mdfa.c:3276:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3276 |   else if (d->fails[s])[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 3277 |     t = d->fails[s];[0m
 3278 |   else[0m
      | [0;32m  } 
[0m[1mdfa.c:3281:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3281 |       if (d->trans[s])[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3282 |         t = d->trans[s];[0m
 3283 |       else[0m
      | [0;32m      } 
[0m[1mdfa.c:3290:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3290 |   if (t[**pp] == -2)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3291 |     build_state (s, d, **pp);[0m
      | [0;1;32m                             
[0m[1mdfa.c:3314:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3314 |   for (mbci = 0; mbci < mbclen && (mbci == 0 || d->min_trcount <= s); mbci++)[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m 3315 |     s = transit_state_singlebyte (d, s, pp);[0m
      | [0;1;32m                                            
[0m[1mdfa.c:3338:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3338 |           for (state_num i = 0; i < d->sindex; i++)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3339 |             d->states[i].mb_trindex = -1;[0m
      | [0;1;32m                                         
[0m[1mdfa.c:3350:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3350 |       for (int i = 0; i < MAX_TRCOUNT; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 3351 |         d->mb_trans[s][i] = -1;[0m
      | [0;1;32m                               
[0m[1mdfa.c:3353:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3353 |   else if (d->mb_trans[s][d->states[s1].mb_trindex] >= 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3354 |     return d->mb_trans[s][d->states[s1].mb_trindex];[0m
      | [0;1;32m                                                    
[0m[1mdfa.c:3356:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3356 |   if (s == -1)[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 3357 |     copy (&d->states[s1].mbps, &d->mb_follows);[0m
 3358 |   else[0m
      | [0;32m  } 
[0m[1mdfa.c:3358:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3358 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 3359 |     merge (&d->states[s1].mbps, &d->states[s].elems, &d->mb_follows);[0m
      | [0;1;32m                                                                     
[0m[1mdfa.c:3389:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3389 |   if (d->syntax.never_trail[*p])[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3390 |     return p;[0m
      | [0;1;32m             
[0m[1mdfa.c:3451:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3451 |           for (state_num s = 0; s < d->min_trcount; s++)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 3452 |             d->states[s].mb_trindex = -1;[0m
      | [0;1;32m                                         
[0m[1mdfa.c:3457:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3457 |   if (!d->tralloc)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 3458 |     realloc_trans_if_necessary (d);[0m
      | [0;1;32m                                   
[0m[1mdfa.c:3475:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3475 |       memset (&d->mbs, 0, sizeof d->mbs);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:3475:7: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3475 |       memset (&d->mbs, 0, sizeof d->mbs);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:3476:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3476 |       if (d->mb_follows.alloc == 0)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3477 |         alloc_position_set (&d->mb_follows, d->nleaves);[0m
      | [0;1;32m                                                        
[0m[1mdfa.c:3484:19: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'trans') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 3484 |       while ((t = trans[s]) != NULL)[0m
      | [0;1;32m                  ^
[0m[1mdfa.c:3614:10: [0m[0;1;36mnote: [0mCalling 'dfaexec_main'[0m
 3614 |   return dfaexec_main (d, begin, end, allow_nl, count, false);[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:3424:7: [0m[0;1;36mnote: [0mAssuming MAX_TRCOUNT is <= field 'sindex'[0m
 3424 |   if (MAX_TRCOUNT <= d->sindex)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:3424:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3424 |   if (MAX_TRCOUNT <= d->sindex)[0m
      | [0;1;32m  ^
[0m[1mdfa.c:3426:42: [0m[0;1;36mnote: [0mAssuming 's' is >= field 'sindex'[0m
 3426 |       for (state_num s = d->min_trcount; s < d->sindex; s++)[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~
[0m[1mdfa.c:3426:7: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3431[0m
 3426 |       for (state_num s = d->min_trcount; s < d->sindex; s++)[0m
      | [0;1;32m      ^
[0m[1mdfa.c:3433:11: [0m[0;1;36mnote: [0mAssuming pointer value is null[0m
 3433 |       if (d->trans)[0m
      | [0;1;32m          ^~~~~~~~
[0m[1mdfa.c:3433:11: [0m[0;1;36mnote: [0mAssuming field 'trans' is null[0m
 3433 |       if (d->trans)[0m
      | [0;1;32m          ^~~~~~~~
[0m[1mdfa.c:3433:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3433 |       if (d->trans)[0m
      | [0;1;32m      ^
[0m[1mdfa.c:3444:11: [0m[0;1;36mnote: [0mAssuming field 'multibyte' is false[0m
 3444 |       if (d->localeinfo.multibyte && d->mb_trans)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdfa.c:3444:35: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3444 |       if (d->localeinfo.multibyte && d->mb_trans)[0m
      | [0;1;32m                                  ^
[0m[1mdfa.c:3457:7: [0m[0;1;36mnote: [0mAssuming field 'tralloc' is not equal to 0[0m
 3457 |   if (!d->tralloc)[0m
      | [0;1;32m      ^~~~~~~~~~~
[0m[1mdfa.c:3457:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3457 |   if (!d->tralloc)[0m
      | [0;1;32m  ^
[0m[1mdfa.c:3468:3: [0m[0;1;36mnote: [0m'trans' initialized to a null pointer value[0m
 3468 |   state_num **trans = d->trans;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~
[0m[1mdfa.c:3473:7: [0m[0;1;36mnote: [0m'multibyte' is false[0m
 3473 |   if (multibyte)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mdfa.c:3473:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3473 |   if (multibyte)[0m
      | [0;1;32m  ^
[0m[1mdfa.c:3481:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3481 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mdfa.c:3484:19: [0m[0;1;36mnote: [0mArray access (from variable 'trans') results in a null pointer dereference[0m
 3484 |       while ((t = trans[s]) != NULL)[0m
      | [0;1;32m                  ^~~~~
[0m[1mdfa.c:3490:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3490 |                   while (t[*p] == s)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3491 |                     p++;[0m
      | [0;1;32m                        
[0m[1mdfa.c:3493:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3493 |               if (multibyte)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3494 |                 p = mbp = skip_remains_mb (d, p, mbp, end);[0m
      | [0;1;32m                                                           
[0m[1mdfa.c:3528:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3528 |                   while (t[*p] == s1)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3529 |                     p++;[0m
      | [0;1;32m                        
[0m[1mdfa.c:3565:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3565 |                                          d)))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3566 |             goto done;[0m
      | [0;1;32m                      
[0m[1mdfa.c:3568:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3568 |           if (multibyte && s < d->min_trcount)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 3569 |             p = mbp = skip_remains_mb (d, p, mbp, end);[0m
      | [0;1;32m                                                       
[0m[1mdfa.c:3594:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3594 |   if (count)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 3595 |     *count += nlcount;[0m
      | [0;1;32m                      
[0m[1mdfa.c:3660:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3660 |       for (s = -1; s < d->tralloc; s++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3661 |         free (d->mb_trans[s]);[0m
      | [0;1;32m                              
[0m[1mdfa.c:3678:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3678 |           if (!d->localeinfo.multibyte)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3679 |             continue;[0m
      | [0;1;32m                     
[0m[1mdfa.c:3680:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3680 |           FALLTHROUGH;[0m
      | [0;1;32m          ^           
[0m      | [0;32m          {           ;} 
[0m[1mdfa.c:74:23: [0m[0;1;36mnote: [0mexpanded from macro 'FALLTHROUGH'[0m
   74 | #  define FALLTHROUGH __attribute__ ((__fallthrough__))[0m
      | [0;1;32m                      ^
[0m[1mdfa.c:3694:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3694 |   if (!d->localeinfo.using_utf8)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3695 |     return;[0m
      | [0;1;32m           
[0m[1mdfa.c:3704:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3704 |           abort ();[0m
      | [0;1;32m          ^       
[0m      | [0;32m          {       ;} 
[0m[1mdfa.c:3706:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3706 |           have_backref = true;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3707 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:3710:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3710 |           return;[0m
      | [0;1;32m          ^     
[0m      | [0;32m          {     ;} 
[0m[1mdfa.c:3712:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3712 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mdfa.c:3754:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3754 |       memcpy (sup->charclasses, d->charclasses,[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:3754:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 3754 |       memcpy (sup->charclasses, d->charclasses,[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:3777:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3777 |                 || d->tokens[i + 1] == PLUS)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 3778 |               i++;[0m
      | [0;1;32m                  
[0m[1mdfa.c:3781:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3781 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mdfa.c:3793:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3793 |           FALLTHROUGH;[0m
      | [0;1;32m          ^           
[0m      | [0;32m          {           ;} 
[0m[1mdfa.c:74:23: [0m[0;1;36mnote: [0mexpanded from macro 'FALLTHROUGH'[0m
   74 | #  define FALLTHROUGH __attribute__ ((__fallthrough__))[0m
      | [0;1;32m                      ^
[0m[1mdfa.c:3795:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3795 |           sup->tokens[j++] = d->tokens[i];[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3796 |           if ((0 <= d->tokens[i] && d->tokens[i] < NOTCHAR)[0m
 3797 |               || d->tokens[i] >= CSET)[0m
 3798 |             have_nchar = true;[0m
 3799 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:3797:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3797 |               || d->tokens[i] >= CSET)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3798 |             have_nchar = true;[0m
      | [0;1;32m                              
[0m[1mdfa.c:3804:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3804 |   if (have_nchar && (have_achar || d->localeinfo.multibyte))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 3805 |     d->superset = sup;[0m
 3806 |   else[0m
      | [0;32m  } 
[0m[1mdfa.c:3819:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3819 |   if (s != NULL)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 3820 |     dfaparse (s, len, d);[0m
      | [0;1;32m                         
[0m[1mdfa.c:3848:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3848 |   if (d->localeinfo.multibyte)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3849 |     free_mbdata (d);[0m
      | [0;1;32m                    
[0m[1mdfa.c:3863:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3863 |       for (idx_t i = 0; i < d->tindex; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 3864 |         free (d->follows[i].elems);[0m
      | [0;1;32m                                   
[0m[1mdfa.c:3975:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3975 |   if (newsize == 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 3976 |     return old;[0m
      | [0;1;32m               
[0m[1mdfa.c:3979:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3979 |   memcpy (result + oldsize, new, newsize + 1);[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:3979:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 3979 |   memcpy (result + oldsize, new, newsize + 1);[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:3986:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3986 |   while (*cpp)[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 3987 |     free (*cpp++);[0m
      | [0;1;32m                  
[0m[1mdfa.c:3995:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3995 |   for (i = 0; cpp[i] != NULL; i++)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3996 |     if (strstr (cpp[i], new) != NULL)[0m
 3997 |       {[0m
 3998 |         free (new);[0m
 3999 |         return cpp;[0m
 4000 |       }[0m
      | [0;1;32m       
[0m[1mdfa.c:4002:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4002 |   for (idx_t j = 0; cpp[j] != NULL; )[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 4003 |     if (strstr (new, cpp[j]) == NULL)[0m
 4004 |       ++j;[0m
 4005 |     else[0m
 4006 |       {[0m
 4007 |         free (cpp[j]);[0m
 4008 |         if (--i == j)[0m
 4009 |           break;[0m
 4010 |         cpp[j] = cpp[i];[0m
 4011 |         cpp[i] = NULL;[0m
 4012 |       }[0m
      | [0;1;32m       
[0m[1mdfa.c:4003:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4003 |     if (strstr (new, cpp[j]) == NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 4004 |       ++j;[0m
 4005 |     else[0m
      | [0;32m    } 
[0m[1mdfa.c:4008:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4008 |         if (--i == j)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 4009 |           break;[0m
      | [0;1;32m                
[0m[1mdfa.c:4040:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4040 |           for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 4041 |             continue;[0m
      | [0;1;32m                     
[0m[1mdfa.c:4042:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4042 |           if (i > len)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4043 |             len = i;[0m
      | [0;1;32m                    
[0m[1mdfa.c:4046:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4046 |       if (len != 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 4047 |         cpp = enlist (cpp, lcp, len);[0m
      | [0;1;32m                                     
[0m[1mdfa.c:4055:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4055 |   for (; *new; new++)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 4056 |     old = enlistnew (old, xstrdup (*new));[0m
      | [0;1;32m                                          
[0m[1mdfa.c:4146:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4146 |           mp = allocmust (mp, 2);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4147 |           mp->begline = true;[0m
 4148 |           need_begline = true;[0m
 4149 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:4151:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4151 |           mp = allocmust (mp, 2);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4152 |           mp->endline = true;[0m
 4153 |           need_endline = true;[0m
 4154 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:4168:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4168 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mdfa.c:4173:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4173 |           resetmust (mp);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4174 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:4177:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4177 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:4199:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4199 |             while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 4200 |               ++i;[0m
      | [0;1;32m                  
[0m[1mdfa.c:4206:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4206 |             if (n > rn)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 4207 |               n = rn;[0m
      | [0;1;32m                     
[0m[1mdfa.c:4208:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4208 |             for (i = 0; i < n; ++i)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4209 |               if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])[0m
 4210 |                 break;[0m
      | [0;1;32m                      
[0m[1mdfa.c:4209:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4209 |               if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 4210 |                 break;[0m
      | [0;1;32m                      
[0m[1mdfa.c:4211:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4211 |             for (j = 0; j < i; ++j)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4212 |               lmp->right[j] = lmp->right[(ln - i) + j];[0m
      | [0;1;32m                                                       
[0m[1mdfa.c:4223:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4223 |           assume_nonnull (mp);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4224 |           mp->is[0] = '\0';[0m
 4225 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:44:27: [0m[0;1;36mnote: [0mexpanded from macro 'assume_nonnull'[0m
   44 | #define assume_nonnull(x) assume ((x) != NULL)[0m
      | [0;1;32m                          ^
[0m[1m./verify.h:357:20: [0m[0;1;36mnote: [0mexpanded from macro 'assume'[0m
  357 | # define assume(R) ((R) ? (void) 0 : __builtin_unreachable ())[0m
      | [0;1;32m                   ^
[0m[1mdfa.c:4228:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4228 |           assume_nonnull (mp);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4229 |           assert (!mp->prev);[0m
 4230 |           for (idx_t i = 0; mp->in[i] != NULL; i++)[0m
 4231 |             if (strlen (mp->in[i]) > strlen (result))[0m
 4232 |               result = mp->in[i];[0m
 4233 |           if (str_eq (result, mp->is))[0m
 4234 |             {[0m
 4235 |               if ((!need_begline || mp->begline) && (!need_endline[0m
 4236 |                                                      || mp->endline))[0m
 4237 |                 exact = true;[0m
 4238 |               begline = mp->begline;[0m
 4239 |               endline = mp->endline;[0m
 4240 |             }[0m
 4241 |           goto done;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mdfa.c:44:27: [0m[0;1;36mnote: [0mexpanded from macro 'assume_nonnull'[0m
   44 | #define assume_nonnull(x) assume ((x) != NULL)[0m
      | [0;1;32m                          ^
[0m[1m./verify.h:357:20: [0m[0;1;36mnote: [0mexpanded from macro 'assume'[0m
  357 | # define assume(R) ((R) ? (void) 0 : __builtin_unreachable ())[0m
      | [0;1;32m                   ^
[0m[1mdfa.c:4230:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4230 |           for (idx_t i = 0; mp->in[i] != NULL; i++)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 4231 |             if (strlen (mp->in[i]) > strlen (result))[0m
 4232 |               result = mp->in[i];[0m
      | [0;1;32m                                 
[0m[1mdfa.c:4231:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4231 |             if (strlen (mp->in[i]) > strlen (result))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 4232 |               result = mp->in[i];[0m
      | [0;1;32m                                 
[0m[1mdfa.c:4236:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4236 |                                                      || mp->endline))[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 4237 |                 exact = true;[0m
      | [0;1;32m                             
[0m[1mdfa.c:4244:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4244 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:4259:17: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4259 |                 memcpy (tp + lrlen, rmp->left, rllen + 1);[0m
      | [0;1;32m                ^~~~~~
[0m[1mdfa.c:4259:17: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4259 |                 memcpy (tp + lrlen, rmp->left, rllen + 1);[0m
      | [0;1;32m                ^~~~~~
[0m[1mdfa.c:4260:17: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4260 |                 memcpy (tp, lmp->right, lrlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mdfa.c:4260:17: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4260 |                 memcpy (tp, lmp->right, lrlen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mdfa.c:4264:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4264 |             if (lmp->is[0] != '\0')[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4265 |               lmp->left = icatalloc (lmp->left, rmp->left);[0m
      | [0;1;32m                                                           
[0m[1mdfa.c:4267:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4267 |             if (rmp->is[0] == '\0')[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4268 |               lmp->right[0] = '\0';[0m
      | [0;1;32m                                   
[0m[1mdfa.c:4289:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4289 |           goto done;[0m
      | [0;1;32m          ^        
[0m      | [0;32m          {        ;} 
[0m[1mdfa.c:4292:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4292 |           if (CSET <= t)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mdfa.c:4300:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4300 |               for (j = 0; j < NOTCHAR; j++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 4301 |                 if (tstbit (j, ccl))[0m
 4302 |                   break;[0m
      | [0;1;32m                        
[0m[1mdfa.c:4301:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4301 |                 if (tstbit (j, ccl))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 4302 |                   break;[0m
      | [0;1;32m                        
[0m[1mdfa.c:4309:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4309 |               while (++j < NOTCHAR)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4310 |                 if (tstbit (j, ccl)[0m
 4311 |                     && ! (case_fold_unibyte[0m
 4312 |                           && toupper (j) == toupper (t)))[0m
 4313 |                   break;[0m
      | [0;1;32m                        
[0m[1mdfa.c:4312:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4312 |                           && toupper (j) == toupper (t)))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 4313 |                   break;[0m
      | [0;1;32m                        
[0m[1mdfa.c:4328:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4328 |                       || d->tokens[rj + 1] != CAT)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 4329 |                     break;[0m
      | [0;1;32m                          
[0m[1mdfa.c:4358:7: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 4358 |       strcpy (dm->must, result);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:4358:7: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 4358 |       strcpy (dm->must, result);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdfa.c:4388:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4388 |   memset (dfa, 0, offsetof (struct dfa, dfaexec));[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:4388:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 4388 |   memset (dfa, 0, offsetof (struct dfa, dfaexec));[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:4409:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4409 |           setbit (uc, &dfa->syntax.letters);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4410 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:4412:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4412 |           setbit (uc, &dfa->syntax.newline);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4413 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mdfa.c:4428:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4428 |   memset (to, 0, offsetof (struct dfa, syntax));[0m
      | [0;1;32m  ^~~~~~
[0m[1mdfa.c:4428:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 4428 |   memset (to, 0, offsetof (struct dfa, syntax));[0m
      | [0;1;32m  ^~~~~~
[0m385 warnings generated.
Suppressed 27 warnings (27 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[52/54][287.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpkm7mta07.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/io.c
[1mio.c:339:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  339 |         if (PROCINFO_node != NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  340 |                 read_can_timeout = true;[0m
      | [0;1;32m                                        
[0m[1mio.c:447:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  447 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  448 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mio.c:456:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  456 |                 if (arg == NULL || arg->stlen == 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  457 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mio.c:486:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  486 |                         if (! do_traditional)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  487 |                                 update_ERRNO_int(errno);[0m
      | [0;1;32m                                                        
[0m[1mio.c:490:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  490 |                         if (iop->public.fd == INVALID_HANDLE)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  491 |                                 iop->errcode = errcode;[0m
  492 |                         else if (iop->valid)[0m
      | [0;32m                        } 
[0m[1mio.c:492:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  492 |                         else if (iop->valid)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  493 |                                 iop->errcode = 0;[0m
      | [0;1;32m                                                 
[0m[1mio.c:495:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  495 |                         if (! do_traditional && iop->errcode != 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  496 |                                 update_ERRNO_int(iop->errcode);[0m
      | [0;1;32m                                                               
[0m[1mio.c:507:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  507 |                 if (! do_traditional)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  508 |                         update_ERRNO_int(errno);[0m
      | [0;1;32m                                                
[0m[1mio.c:572:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  572 |         if (at_eof(iop) && no_data_left(iop))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  573 |                 retval = false;[0m
  574 |         else if ((iop->flag & IOP_CLOSED) != 0)[0m
      | [0;32m        } 
[0m[1mio.c:574:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  574 |         else if ((iop->flag & IOP_CLOSED) != 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  575 |                 retval = false;[0m
  576 |         else[0m
      | [0;32m        } 
[0m[1mio.c:576:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  576 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  577 |                 /* Note that get_a_record may return -2 when I/O would block */[0m
  578 |                 retval = (get_a_record(& begin, & cnt, iop, errcode, & field_width) == 0);[0m
      | [0;1;32m                                                                                          
[0m[1mio.c:584:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  584 |                 if (*errcode > 0)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  585 |                         retval = false;[0m
      | [0;1;32m                                       
[0m[1mio.c:604:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  604 |         if (newfd == INVALID_HANDLE)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  605 |                 newfd = open("/dev/null", O_RDWR);[0m
      | [0;1;32m                                                  
[0m[1mio.c:611:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  611 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  612 |                 ret = 0;[0m
      | [0;1;32m                        
[0m[1mio.c:624:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  624 |         if (iop == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  625 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mio.c:637:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  637 |         if (iop->public.close_func != NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  638 |                 iop->public.close_func(&iop->public);[0m
      | [0;1;32m                                                     
[0m[1mio.c:643:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  643 |                     || iop->public.fd == fileno(stderr))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  644 |                         ret = remap_std_file(iop->public.fd);[0m
  645 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:645:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  645 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  646 |                         ret = closemaybesocket(iop->public.fd);[0m
      | [0;1;32m                                                               
[0m[1mio.c:649:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  649 |         if (ret == -1)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  650 |                 warning(_("close of fd %d (`%s') failed: %s"), iop->public.fd,[0m
  651 |                                 iop->public.name, strerror(errno));[0m
      | [0;1;32m                                                                   
[0m[1mio.c:703:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  703 |         if (flags == RED_NONE)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  704 |                 return "RED_NONE";[0m
      | [0;1;32m                                  
[0m[1mio.c:727:15: [0m[0;1;35mwarning: [0m[1mThe value '5' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  727 |                 { RED_NONE, (RED_FILE|RED_READ), (RED_PIPE|RED_WRITE),[0m
      | [0;1;32m                            ^
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is not equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^
[0m[1mio.c:828:35: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                         ^~~~~~~~~~~~
[0m[1mio.c:828:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m        ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:833:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m        ^
[0m[1mio.c:842:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:849:22: [0m[0;1;36mnote: [0mAssuming 'rp' is not equal to NULL[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mio.c:849:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m        ^
[0m[1mio.c:859:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:859:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                                              ^
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mio.c:872:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  872 |                     && memcmp(rp->value, str, explen) == 0) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                ^
[0m[1mio.c:873:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  873 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:874:5: [0m[0;1;36mnote: [0mCalling 'check_duplicated_redirections'[0m
  874 |                                 check_duplicated_redirections(rp->value, explen,[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  875 |                                                 (redirect_flags_t) rp->flag, (redirect_flags_t) tflag);[0m
      | [0;1;32m                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:727:15: [0m[0;1;36mnote: [0mThe value '5' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  727 |                 { RED_NONE, (RED_FILE|RED_READ), (RED_PIPE|RED_WRITE),[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~
[0m[1mio.c:727:36: [0m[0;1;35mwarning: [0m[1mThe value '10' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  727 |                 { RED_NONE, (RED_FILE|RED_READ), (RED_PIPE|RED_WRITE),[0m
      | [0;1;32m                                                 ^
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is not equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^
[0m[1mio.c:828:35: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                         ^~~~~~~~~~~~
[0m[1mio.c:828:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m        ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:833:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m        ^
[0m[1mio.c:842:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:849:22: [0m[0;1;36mnote: [0mAssuming 'rp' is not equal to NULL[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mio.c:849:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m        ^
[0m[1mio.c:859:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:859:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                                              ^
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mio.c:872:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  872 |                     && memcmp(rp->value, str, explen) == 0) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                ^
[0m[1mio.c:873:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  873 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:874:5: [0m[0;1;36mnote: [0mCalling 'check_duplicated_redirections'[0m
  874 |                                 check_duplicated_redirections(rp->value, explen,[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  875 |                                                 (redirect_flags_t) rp->flag, (redirect_flags_t) tflag);[0m
      | [0;1;32m                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:727:36: [0m[0;1;36mnote: [0mThe value '10' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  727 |                 { RED_NONE, (RED_FILE|RED_READ), (RED_PIPE|RED_WRITE),[0m
      | [0;1;32m                                                 ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:729:5: [0m[0;1;35mwarning: [0m[1mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  729 |                 { (RED_FILE|RED_WRITE), (RED_FILE|RED_WRITE), RED_APPEND,[0m
      | [0;1;32m                  ^
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is not equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^
[0m[1mio.c:828:35: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                         ^~~~~~~~~~~~
[0m[1mio.c:828:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m        ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:833:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m        ^
[0m[1mio.c:842:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:849:22: [0m[0;1;36mnote: [0mAssuming 'rp' is not equal to NULL[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mio.c:849:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m        ^
[0m[1mio.c:859:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:859:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                                              ^
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mio.c:872:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  872 |                     && memcmp(rp->value, str, explen) == 0) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                ^
[0m[1mio.c:873:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  873 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:874:5: [0m[0;1;36mnote: [0mCalling 'check_duplicated_redirections'[0m
  874 |                                 check_duplicated_redirections(rp->value, explen,[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  875 |                                                 (redirect_flags_t) rp->flag, (redirect_flags_t) tflag);[0m
      | [0;1;32m                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:729:5: [0m[0;1;36mnote: [0mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  729 |                 { (RED_FILE|RED_WRITE), (RED_FILE|RED_WRITE), RED_APPEND,[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:729:27: [0m[0;1;35mwarning: [0m[1mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  729 |                 { (RED_FILE|RED_WRITE), (RED_FILE|RED_WRITE), RED_APPEND,[0m
      | [0;1;32m                                        ^
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is not equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^
[0m[1mio.c:828:35: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                         ^~~~~~~~~~~~
[0m[1mio.c:828:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m        ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:833:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m        ^
[0m[1mio.c:842:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:849:22: [0m[0;1;36mnote: [0mAssuming 'rp' is not equal to NULL[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mio.c:849:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m        ^
[0m[1mio.c:859:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:859:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                                              ^
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mio.c:872:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  872 |                     && memcmp(rp->value, str, explen) == 0) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                ^
[0m[1mio.c:873:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  873 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:874:5: [0m[0;1;36mnote: [0mCalling 'check_duplicated_redirections'[0m
  874 |                                 check_duplicated_redirections(rp->value, explen,[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  875 |                                                 (redirect_flags_t) rp->flag, (redirect_flags_t) tflag);[0m
      | [0;1;32m                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:729:27: [0m[0;1;36mnote: [0mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  729 |                 { (RED_FILE|RED_WRITE), (RED_FILE|RED_WRITE), RED_APPEND,[0m
      | [0;1;32m                                        ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:731:15: [0m[0;1;35mwarning: [0m[1mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  731 |                 { RED_NONE, (RED_FILE|RED_WRITE), (RED_PIPE|RED_READ),[0m
      | [0;1;32m                            ^
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is not equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^
[0m[1mio.c:828:35: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                         ^~~~~~~~~~~~
[0m[1mio.c:828:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m        ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:833:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m        ^
[0m[1mio.c:842:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:849:22: [0m[0;1;36mnote: [0mAssuming 'rp' is not equal to NULL[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mio.c:849:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m        ^
[0m[1mio.c:859:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:859:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                                              ^
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mio.c:872:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  872 |                     && memcmp(rp->value, str, explen) == 0) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                ^
[0m[1mio.c:873:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  873 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:874:5: [0m[0;1;36mnote: [0mCalling 'check_duplicated_redirections'[0m
  874 |                                 check_duplicated_redirections(rp->value, explen,[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  875 |                                                 (redirect_flags_t) rp->flag, (redirect_flags_t) tflag);[0m
      | [0;1;32m                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:731:15: [0m[0;1;36mnote: [0mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  731 |                 { RED_NONE, (RED_FILE|RED_WRITE), (RED_PIPE|RED_READ),[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:731:37: [0m[0;1;35mwarning: [0m[1mThe value '6' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  731 |                 { RED_NONE, (RED_FILE|RED_WRITE), (RED_PIPE|RED_READ),[0m
      | [0;1;32m                                                  ^
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is not equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^
[0m[1mio.c:828:35: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                         ^~~~~~~~~~~~
[0m[1mio.c:828:2: [0m[0;1;36mnote: [0mTaking true branch[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m        ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:833:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m        ^
[0m[1mio.c:842:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:849:22: [0m[0;1;36mnote: [0mAssuming 'rp' is not equal to NULL[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m                            ^~~~~~~~~~
[0m[1mio.c:849:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  849 |         for (rp = red_head; rp != NULL; rp = rp->next) {[0m
      | [0;1;32m        ^
[0m[1mio.c:859:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:859:33: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  859 |                 if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {[0m
      | [0;1;32m                                              ^
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mio.c:872:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  872 |                     && memcmp(rp->value, str, explen) == 0) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:871:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  871 |                 if (strlen(rp->value) == explen[0m
      | [0;1;32m                ^
[0m[1mio.c:873:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  873 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:874:5: [0m[0;1;36mnote: [0mCalling 'check_duplicated_redirections'[0m
  874 |                                 check_duplicated_redirections(rp->value, explen,[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  875 |                                                 (redirect_flags_t) rp->flag, (redirect_flags_t) tflag);[0m
      | [0;1;32m                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:731:37: [0m[0;1;36mnote: [0mThe value '6' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  731 |                 { RED_NONE, (RED_FILE|RED_WRITE), (RED_PIPE|RED_READ),[0m
      | [0;1;32m                                                  ^~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  791 |                 fatal(_("redirection not allowed in sandbox mode"));[0m
      | [0;1;32m                                                                    
[0m[1mio.c:795:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  795 |                 tflag = RED_APPEND;[0m
      | [0;1;32m                ^                 
[0m      | [0;32m                {                 ;} 
[0m[1mio.c:798:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  798 |                 outflag = (RED_FILE|RED_WRITE);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  799 |                 tflag |= outflag;[0m
  800 |                 if (redirtype == redirect_output)[0m
  801 |                         what = ">";[0m
  802 |                 else[0m
  803 |                         what = ">>";[0m
  804 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:798:13: [0m[0;1;35mwarning: [0m[1mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  798 |                 outflag = (RED_FILE|RED_WRITE);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to 'case redirect_output:'  at line 797[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:798:13: [0m[0;1;36mnote: [0mThe value '9' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  798 |                 outflag = (RED_FILE|RED_WRITE);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:800:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  800 |                 if (redirtype == redirect_output)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  801 |                         what = ">";[0m
  802 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:802:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  802 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  803 |                         what = ">>";[0m
      | [0;1;32m                                    
[0m[1mio.c:806:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  806 |                 tflag = (RED_PIPE|RED_WRITE);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  807 |                 what = "|";[0m
  808 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:806:11: [0m[0;1;35mwarning: [0m[1mThe value '10' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  806 |                 tflag = (RED_PIPE|RED_WRITE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to 'case redirect_pipe:'  at line 805[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:806:11: [0m[0;1;36mnote: [0mThe value '10' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  806 |                 tflag = (RED_PIPE|RED_WRITE);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:810:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  810 |                 tflag = (RED_PIPE|RED_READ);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  811 |                 what = "|";[0m
  812 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:810:11: [0m[0;1;35mwarning: [0m[1mThe value '6' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  810 |                 tflag = (RED_PIPE|RED_READ);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to 'case redirect_pipein:'  at line 809[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:810:11: [0m[0;1;36mnote: [0mThe value '6' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  810 |                 tflag = (RED_PIPE|RED_READ);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~
[0m[1mio.c:814:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  814 |                 tflag = (RED_FILE|RED_READ);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  815 |                 what = "<";[0m
  816 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:814:11: [0m[0;1;35mwarning: [0m[1mThe value '5' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  814 |                 tflag = (RED_FILE|RED_READ);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to 'case redirect_input:'  at line 813[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:814:11: [0m[0;1;36mnote: [0mThe value '5' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  814 |                 tflag = (RED_FILE|RED_READ);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~
[0m[1mio.c:818:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  818 |                 tflag = (RED_READ|RED_WRITE|RED_TWOWAY);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  819 |                 what = "|&";[0m
  820 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:818:11: [0m[0;1;35mwarning: [0m[1mThe value '268' provided to the cast expression is not in the valid range of values for 'redirect_flags' [clang-analyzer-optin.core.EnumCastOutOfRange][0m
  818 |                 tflag = (RED_READ|RED_WRITE|RED_TWOWAY);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m./awk.h:969:7: [0m[0;1;36mnote: [0menum declared here[0m
  969 |         enum redirect_flags {[0m
      | [0;1;32m        ~~~~~^~~~~~~~~~~~~~~~
[0m  970 |                 RED_NONE        = 0,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  971 |                 RED_FILE        = 1,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  972 |                 RED_PIPE        = 2,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  973 |                 RED_READ        = 4,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  974 |                 RED_WRITE       = 8,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~
[0m  975 |                 RED_APPEND      = 16,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  976 |                 RED_FLUSH       = 32,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~
[0m  977 |                 RED_USED        = 64,   /* closed temporarily to reuse fd */[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  978 |                 RED_EOF         = 128,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  979 |                 RED_TWOWAY      = 256,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  980 |                 RED_PTY         = 512,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~
[0m  981 |                 RED_SOCKET      = 1024,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  982 |                 RED_TCP         = 2048,[0m
      | [0;1;32m                ~~~~~~~~~~~~~~~~~~~~~~~
[0m  983 |         } flag;[0m
      | [0;1;32m        ~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to 'case redirect_twoway:'  at line 817[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:818:11: [0m[0;1;36mnote: [0mThe value '268' provided to the cast expression is not in the valid range of values for 'redirect_flags'[0m
  818 |                 tflag = (RED_READ|RED_WRITE|RED_TWOWAY);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:822:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  822 |                 cant_happen("invalid redirection type %d", (int) redirtype);[0m
      | [0;1;32m                ^                                                          
[0m      | [0;32m                {                                                          ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mio.c:824:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  825 |                 lintwarn(_("expression in `%s' redirection is a number"),[0m
  826 |                         what);[0m
      | [0;1;32m                              
[0m[1mio.c:828:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  829 |                 fatal(_("expression for `%s' redirection has null string value"),[0m
  830 |                         what);[0m
      | [0;1;32m                              
[0m[1mio.c:832:18: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^       ~~~
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:32: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                      ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:29: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                            ^
[0m[1mio.c:832:18: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                        ^       ~~~
[0m[1mio.c:833:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  833 |                         || strncmp(str, "1", explen) == 0))[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  834 |                 lintwarn(_("filename `%.*s' for `%s' redirection may be result of logical expression"),[0m
  835 |                                 (int) explen, str, what);[0m
      | [0;1;32m                                                         
[0m[1mio.c:844:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  844 |                 if (isi.protocol == SOCK_STREAM)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  845 |                         tflag |= RED_TCP;       /* use shutdown when closing */[0m
      | [0;1;32m                                                                               
[0m[1mio.c:860:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  860 |                         if (rp->pid != -1)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  861 | #ifdef __MINGW32__[0m
  862 |                                 /* MinGW cannot wait for any process.  */[0m
  863 |                                 wait_any(rp->pid);[0m
  864 | #else[0m
  865 |                                 wait_any(0);[0m
      | [0;1;32m                                            
[0m[1mio.c:892:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  892 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  893 |                         emalloc(rp, struct redirect *, sizeof(struct redirect), "redirect");[0m
      | [0;1;32m                                                                                            
[0m[1mio.c:895:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  895 |                 memcpy(newstr, str, explen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:895:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  895 |                 memcpy(newstr, str, explen);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:905:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  905 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  906 |                 str = rp->value;        /* get \0 terminated string */[0m
      | [0;1;32m                                                                      
[0m[1mio.c:922:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  922 |                         mode = binmode("w");[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  923 |                         if ((rp->flag & RED_USED) != 0)[0m
  924 |                                 mode = (rp->mode[1] == 'b') ? "ab" : "a";[0m
  925 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mio.c:923:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  923 |                         if ((rp->flag & RED_USED) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  924 |                                 mode = (rp->mode[1] == 'b') ? "ab" : "a";[0m
      | [0;1;32m                                                                         
[0m[1mio.c:927:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  927 |                         mode = binmode("a");[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  928 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mio.c:930:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  930 |                         if (extfd >= 0) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mio.c:945:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  945 |                         if ((rp->output.fp = popen(str, binmode("w"))) == NULL)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m  946 |                                 fatal(_("cannot open pipe `%s' for output: %s"),[0m
  947 |                                                 str, strerror(errno));[0m
      | [0;1;32m                                                                      
[0m[1mio.c:955:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  955 |                         if (extfd >= 0) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  956 |                                 warning(_("get_file cannot create pipe `%s' with fd %d"), str, extfd);[0m
  957 |                                 return NULL;[0m
  958 |                         }[0m
  959 |                         direction = "from";[0m
  960 |                         if (gawk_popen(str, rp) == NULL)[0m
  961 |                                 fatal(_("cannot open pipe `%s' for input: %s"),[0m
  962 |                                         str, strerror(errno));[0m
  963 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mio.c:960:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  960 |                         if (gawk_popen(str, rp) == NULL)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  961 |                                 fatal(_("cannot open pipe `%s' for input: %s"),[0m
  962 |                                         str, strerror(errno));[0m
      | [0;1;32m                                                              
[0m[1mio.c:965:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  965 |                         direction = "from";[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mio.c:976:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  976 |                                 if (! do_traditional && rp->iop->errcode != 0)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  977 |                                         update_ERRNO_int(rp->iop->errcode);[0m
      | [0;1;32m                                                                           
[0m[1mio.c:989:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  989 |                         direction = "to/from";[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  990 |                         if (! two_way_open(str, rp, extfd)) {[0m
  991 |                                 if (! failure_fatal || is_non_fatal_redirect(str, explen)) {[0m
  992 |                                         *errflg = errno;[0m
  993 |                                         /* do not free rp, saving it for reuse (save_rp = rp) */[0m
  994 |                                         return NULL;[0m
  995 |                                 } else[0m
  996 |                                         fatal(_("cannot open two way pipe `%s' for input/output: %s"),[0m
  997 |                                                         str, strerror(errno));[0m
  998 |                         }[0m
  999 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mio.c:995:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  995 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  996 |                                         fatal(_("cannot open two way pipe `%s' for input/output: %s"),[0m
  997 |                                                         str, strerror(errno));[0m
      | [0;1;32m                                                                              
[0m[1mio.c:1001:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1001 |                         cant_happen("invalid redirection type %d", (int) redirtype);[0m
      | [0;1;32m                        ^                                                          
[0m      | [0;32m                        {                                                          ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mio.c:1010:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1010 |                                 if (fd == fileno(stdin))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1011 |                                         rp->output.fp = stdin;[0m
 1012 |                                 else if (fd == fileno(stdout))[0m
      | [0;32m                                } 
[0m[1mio.c:1012:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1012 |                                 else if (fd == fileno(stdout))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1013 |                                         rp->output.fp = stdout;[0m
 1014 |                                 else if (fd == fileno(stderr))[0m
      | [0;32m                                } 
[0m[1mio.c:1014:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1014 |                                 else if (fd == fileno(stderr))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1015 |                                         rp->output.fp = stderr;[0m
 1016 |                                 else {[0m
      | [0;32m                                } 
[0m[1mio.c:1022:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1022 |                                         if (fd_flags != -1 && (fd_flags & O_APPEND) == O_APPEND)[0m
      | [0;1;32m                                                                                                ^
[0m      | [0;32m                                                                                                 {
[0m 1023 |                                                 omode = binmode("a");[0m
      | [0;1;32m                                                                     
[0m[1mio.c:1029:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1029 |                                         if (rp->output.fp == NULL)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 1030 |                                                 close(fd);[0m
      | [0;1;32m                                                          
[0m[1mio.c:1032:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1032 |                                 if (rp->output.fp != NULL && os_isatty(fd))[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 1033 |                                         rp->flag |= RED_FLUSH;[0m
      | [0;1;32m                                                              
[0m[1mio.c:1037:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1037 |                                         if ((rp->prev->next = rp->next) != NULL)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1038 |                                                 rp->next->prev = rp->prev;[0m
      | [0;1;32m                                                                          
[0m[1mio.c:1050:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1050 |                         if (errno == EMFILE || errno == ENFILE)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1051 |                                 close_one();[0m
 1052 | #ifdef VMS[0m
 1053 |                         /* Alpha/VMS V7.1+ C RTL is returning these instead[0m
 1054 |                            of EMFILE (haven't tried other post-V6.2 systems) */[0m
 1055 |                         else if ((errno == EIO || errno == EVMSERR) &&[0m
 1056 |                                  (vaxc$errno == SS$_EXQUOTA ||[0m
 1057 |                                   vaxc$errno == SS$_EXBYTLM ||[0m
 1058 |                                   vaxc$errno == RMS$_ACC ||[0m
 1059 |                                   vaxc$errno == RMS$_SYN)) {[0m
 1060 |                                 close_one();[0m
 1061 |                                 close_one();[0m
 1062 |                         }[0m
 1063 | #endif[0m
 1064 |                         else {[0m
      | [0;32m                        } 
[0m[1mio.c:1076:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1076 |                                 if (errflg != NULL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1077 |                                         *errflg = errno;[0m
      | [0;1;32m                                                        
[0m[1mio.c:1082:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1082 |                                         if (*direction == 'f')[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1083 |                                                 fatal(_("cannot redirect from `%s': %s"),[0m
 1084 |                                                         str, strerror(errno));[0m
 1085 |                                         else[0m
      | [0;32m                                        } 
[0m[1mio.c:1085:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1085 |                                         else[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1086 |                                                 fatal(_("cannot redirect to `%s': %s"),[0m
 1087 |                                                         str, strerror(errno));[0m
      | [0;1;32m                                                                              
[0m[1mio.c:1101:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1101 |                 if (red_head != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1102 |                         red_head->prev = rp;[0m
      | [0;1;32m                                            
[0m[1mio.c:1130:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1130 |         for (rp = red_head; rp != NULL; rp = rp->next)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1131 |                 if (strlen(rp->value) == len && memcmp(rp->value, str, len) == 0)[0m
 1132 |                         return rp;[0m
      | [0;1;32m                                  
[0m[1mio.c:1131:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1131 |                 if (strlen(rp->value) == len && memcmp(rp->value, str, len) == 0)[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m 1132 |                         return rp;[0m
      | [0;1;32m                                  
[0m[1mio.c:1142:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1142 |         if (in_PROCINFO(nonfatal, NULL, NULL))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1143 |                 return true;[0m
      | [0;1;32m                            
[0m[1mio.c:1192:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1192 |         for (rp = red_head; rp != NULL; rp = rp->next)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1193 |                 rplast = rp;[0m
      | [0;1;32m                            
[0m[1mio.c:1197:83: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1197 |                 if (rp->output.fp == NULL || rp->output.fp == stderr || rp->output.fp == stdout)[0m
      | [0;1;32m                                                                                                ^
[0m      | [0;32m                                                                                                 {
[0m 1198 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mio.c:1203:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1203 |                         if (rp->output.gawk_fclose(rp->output.fp, rp->output.opaque) != 0)[0m
      | [0;1;32m                                                                                          ^
[0m      | [0;32m                                                                                           {
[0m 1204 |                                 warning(_("close of `%s' failed: %s"),[0m
 1205 |                                         rp->value, strerror(errno));[0m
      | [0;1;32m                                                                    
[0m[1mio.c:1210:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1210 |         if (rp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1211 |                 /* surely this is the only reason ??? */[0m
 1212 |                 fatal(_("too many pipes or input files open"));[0m
      | [0;1;32m                                                               
[0m[1mio.c:1232:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1232 |                 if (strcasecmp(tmp2->stptr, "to") == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1233 |                         how = CLOSE_TO;[0m
 1234 |                 else if (strcasecmp(tmp2->stptr, "from") == 0)[0m
      | [0;32m                } 
[0m[1mio.c:1234:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1234 |                 else if (strcasecmp(tmp2->stptr, "from") == 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1235 |                         how = CLOSE_FROM;[0m
 1236 |                 else {[0m
      | [0;32m                } 
[0m[1mio.c:1248:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1248 |                     && memcmp(rp->value, tmp->stptr, tmp->stlen) == 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1249 |                         break;[0m
      | [0;1;32m                              
[0m[1mio.c:1255:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1255 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1256 |                         lintwarn(_("close: `%.*s' is not an open file, pipe or co-process"),[0m
 1257 |                                 (int) tmp->stlen, tmp->stptr);[0m
      | [0;1;32m                                                              
[0m[1mio.c:1298:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1298 |                         if ((rp->flag & RED_TCP) != 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1299 |                                 (void) shutdown(fileno(rp->output.fp), SHUT_WR);[0m
      | [0;1;32m                                                                                
[0m[1mio.c:1314:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1314 |                                 if ((rp->flag & RED_TCP) != 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1315 |                                         (void) shutdown(rp->iop->public.fd, SHUT_RD);[0m
      | [0;1;32m                                                                                     
[0m[1mio.c:1318:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1318 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1319 |                                 /* status already sanitized */[0m
 1320 |                                 status = gawk_pclose(rp);[0m
      | [0;1;32m                                                         
[0m[1mio.c:1327:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1327 |                 if ((BINMODE & BINMODE_INPUT) != 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1328 |                         os_setbinmode(fileno(stdin), O_BINARY);[0m
      | [0;1;32m                                                               
[0m[1mio.c:1335:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1335 |                 if ((rp->flag & RED_PIPE) != 0)         /* read from pipe */[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1336 |                         status = gawk_pclose(rp);[0m
 1337 |                         /* gawk_pclose sets rp->iop to null */[0m
 1338 |                 else {                                  /* read from file */[0m
      | [0;32m                } 
[0m[1mio.c:1354:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1354 |         if (rp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1355 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mio.c:1356:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1356 |         if ((rp->flag & RED_WRITE) && rp->output.fp)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1357 |                 /* flush before closing to leverage special error handling */[0m
 1358 |                 efflush(rp->output.fp, "flush", rp);[0m
      | [0;1;32m                                                    
[0m[1mio.c:1359:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1359 |         if (rp->output.fp == stdout || rp->output.fp == stderr)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1360 |                 goto checkwarn;         /* bypass closing, remove from list */[0m
      | [0;1;32m                                                                              
[0m[1mio.c:1362:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1362 |         if (do_lint && (rp->flag & RED_TWOWAY) == 0 && how != CLOSE_ALL)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 1363 |                 lintwarn(_("close: redirection `%s' not opened with `|&', second argument ignored"),[0m
 1364 |                                 rp->value);[0m
      | [0;1;32m                                           
[0m[1mio.c:1379:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1379 |                         if ((rp->flag & RED_PIPE) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1380 |                                 lintwarn(_("failure status (%d) on pipe close of `%s': %s"),[0m
 1381 |                                          status, rp->value, s);[0m
 1382 |                         else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;32m                        } 
[0m[1mio.c:1382:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1382 |                         else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1383 |                                 lintwarn(_("failure status (%d) on two-way pipe close of `%s': %s"),[0m
 1384 |                                          status, rp->value, s);[0m
 1385 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:1385:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1385 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1386 |                                 lintwarn(_("failure status (%d) on file close of `%s': %s"),[0m
 1387 |                                          status, rp->value, s);[0m
      | [0;1;32m                                                               
[0m[1mio.c:1405:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1405 |                 if ((rp->flag & RED_SOCKET) != 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1406 |                         warning(_("no explicit close of socket `%s' provided"),[0m
 1407 |                                 rp->value);[0m
 1408 |                 else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;32m                } 
[0m[1mio.c:1408:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1408 |                 else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1409 |                         warning(_("no explicit close of co-process `%s' provided"),[0m
 1410 |                                 rp->value);[0m
 1411 |                 else if ((rp->flag & RED_PIPE) != 0)[0m
      | [0;32m                } 
[0m[1mio.c:1411:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1411 |                 else if ((rp->flag & RED_PIPE) != 0)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1412 |                         warning(_("no explicit close of pipe `%s' provided"),[0m
 1413 |                                 rp->value);[0m
 1414 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:1414:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1414 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1415 |                         warning(_("no explicit close of file `%s' provided"),[0m
 1416 |                                 rp->value);[0m
      | [0;1;32m                                           
[0m[1mio.c:1421:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1421 |                 if (rp->next != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1422 |                         rp->next->prev = rp->prev;[0m
      | [0;1;32m                                                  
[0m[1mio.c:1423:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1423 |                 if (rp->prev != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1424 |                         rp->prev->next = rp->next;[0m
 1425 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:1425:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1425 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1426 |                         red_head = rp->next;[0m
      | [0;1;32m                                            
[0m[1mio.c:1446:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1446 |                         if (errno == EPIPE)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1447 |                                 die_via_sigpipe();[0m
 1448 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:1448:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1448 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1449 |                                 fatal(fp == stdout[0m
 1450 |                                         ? _("fflush: cannot flush standard output: %s")[0m
 1451 |                                         : _("fflush: cannot flush standard error: %s"),[0m
 1452 |                                                 strerror(errno));[0m
      | [0;1;32m                                                                 
[0m[1mio.c:1475:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1475 |         if (! non_fatal_flush_std_file(stdout)) // ERRNO updated[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1476 |                 status++;[0m
      | [0;1;32m                         
[0m[1mio.c:1479:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1479 |         if (! non_fatal_flush_std_file(stderr)) // ERRNO updated[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1480 |                 status++;[0m
      | [0;1;32m                         
[0m[1mio.c:1492:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1492 |                                 if (is_non_fatal_redirect(rp->value, strlen(rp->value)))[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m 1493 |                                         messagefunc = r_warning;[0m
      | [0;1;32m                                                                
[0m[1mio.c:1495:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1495 |                                 if ((rp->flag & RED_PIPE) != 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1496 |                                         messagefunc(_("pipe flush of `%s' failed: %s"),[0m
 1497 |                                                 rp->value, strerror(errno));[0m
 1498 |                                 else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;32m                                } 
[0m[1mio.c:1498:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1498 |                                 else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1499 |                                         messagefunc(_("co-process flush of pipe to `%s' failed: %s"),[0m
 1500 |                                                 rp->value, strerror(errno));[0m
 1501 |                                 else[0m
      | [0;32m                                } 
[0m[1mio.c:1501:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1501 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1502 |                                         messagefunc(_("file flush of `%s' failed: %s"),[0m
 1503 |                                                 rp->value, strerror(errno));[0m
      | [0;1;32m                                                                            
[0m[1mio.c:1508:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1508 |         if (status != 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1509 |                 status = -1;    /* canonicalize it */[0m
      | [0;1;32m                                                     
[0m[1mio.c:1530:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1530 |                 if (close_redir(rp, do_lint, CLOSE_ALL))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1531 |                         status++;[0m
      | [0;1;32m                                 
[0m[1mio.c:1544:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1544 |                 if (errno != EPIPE)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1545 |                         warning(_("error writing standard output: %s"), strerror(errno));[0m
 1546 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:1546:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1546 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1547 |                         *got_EPIPE = true;[0m
      | [0;1;32m                                          
[0m[1mio.c:1555:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1555 |                 if (errno != EPIPE)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1556 |                         warning(_("error writing standard error: %s"), strerror(errno));[0m
 1557 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:1557:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1557 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1558 |                         *got_EPIPE = true;[0m
      | [0;1;32m                                          
[0m[1mio.c:1574:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1574 |         if (*second == 'b')[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1575 |                 second++;[0m
      | [0;1;32m                         
[0m[1mio.c:1579:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1579 |                 ret = O_RDONLY;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1580 |                 if (*second == '+' || *second == 'w')[0m
 1581 |                         ret = O_RDWR;[0m
 1582 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:1580:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1580 |                 if (*second == '+' || *second == 'w')[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1581 |                         ret = O_RDWR;[0m
      | [0;1;32m                                     
[0m[1mio.c:1585:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1585 |                 ret = O_WRONLY|O_CREAT|O_TRUNC;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1586 |                 if (*second == '+' || *second == 'r')[0m
 1587 |                         ret = O_RDWR|O_CREAT|O_TRUNC;[0m
 1588 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:1586:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1586 |                 if (*second == '+' || *second == 'r')[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1587 |                         ret = O_RDWR|O_CREAT|O_TRUNC;[0m
      | [0;1;32m                                                     
[0m[1mio.c:1591:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1591 |                 ret = O_WRONLY|O_APPEND|O_CREAT;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1592 |                 if (*second == '+')[0m
 1593 |                         ret = O_RDWR|O_APPEND|O_CREAT;[0m
 1594 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:1592:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1592 |                 if (*second == '+')[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1593 |                         ret = O_RDWR|O_APPEND|O_CREAT;[0m
      | [0;1;32m                                                      
[0m[1mio.c:1597:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1597 |                 ret = 0;                /* lint */[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1598 |                 cant_happen("invalid open mode \"%s\"", mode);[0m
      | [0;1;32m                                                             
[0m      | [0;32m                                                             ;} 
[0m[1mio.c:1600:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1600 |         if (strchr(mode, 'b') != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1601 |                 ret |= O_BINARY;[0m
      | [0;1;32m                                
[0m[1mio.c:1623:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1623 |         memset(& lhints, '\0', sizeof (lhints));[0m
      | [0;1;32m        ^~~~~~
[0m[1mio.c:1623:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1623 |         memset(& lhints, '\0', sizeof (lhints));[0m
      | [0;1;32m        ^~~~~~
[0m[1mio.c:1638:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1638 |         if (lhints.ai_family == AF_UNSPEC)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1639 |                 lhints.ai_flags |= AI_ADDRCONFIG;[0m
      | [0;1;32m                                                 
[0m[1mio.c:1655:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1655 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1656 |                 lres0 = lres;[0m
      | [0;1;32m                             
[0m[1mio.c:1659:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1659 |                 memset (& rhints, '\0', sizeof (rhints));[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:1659:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1659 |                 memset (& rhints, '\0', sizeof (rhints));[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:1668:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1668 |                         if (lres0 != NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1669 |                                 freeaddrinfo(lres0);[0m
      | [0;1;32m                                                    
[0m[1mio.c:1684:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1684 |                         if (socket_fd < 0 || socket_fd == INVALID_HANDLE)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 1685 |                                 goto nextrres;[0m
      | [0;1;32m                                              
[0m[1mio.c:1691:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1691 |                                 memset(& linger, '\0', sizeof(linger));[0m
      | [0;1;32m                                ^~~~~~
[0m[1mio.c:1691:5: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1691 |                                 memset(& linger, '\0', sizeof(linger));[0m
      | [0;1;32m                                ^~~~~~
[0m[1mio.c:1703:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1703 |                         if (bind(socket_fd, lres->ai_addr, lres->ai_addrlen) != 0)[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 1704 |                                 goto nextrres;[0m
      | [0;1;32m                                              
[0m[1mio.c:1707:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1707 |                                 if (connect(socket_fd, rres->ai_addr, rres->ai_addrlen) == 0)[0m
      | [0;1;32m                                                                                             ^
[0m      | [0;32m                                                                                              {
[0m 1708 |                                         break;[0m
      | [0;1;32m                                              
[0m[1mio.c:1736:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1736 |                                                                 read_len) == 0)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 1737 |                                                         break;[0m
      | [0;1;32m                                                              
[0m[1mio.c:1743:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1743 |                         if (socket_fd != INVALID_HANDLE)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1744 |                                 closemaybesocket(socket_fd);[0m
      | [0;1;32m                                                            
[0m[1mio.c:1749:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1749 |                 if (socket_fd != INVALID_HANDLE)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1750 |                         break;[0m
      | [0;1;32m                              
[0m[1mio.c:1753:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1753 |         if (lres0)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1754 |                 freeaddrinfo(lres0);[0m
      | [0;1;32m                                    
[0m[1mio.c:1783:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1783 |                 if (mode[0] == 'r')[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1784 |                         return fileno(stdin);[0m
 1785 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:1785:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1785 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1786 |                         return fileno(stdout);[0m
      | [0;1;32m                                              
[0m[1mio.c:1792:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1792 |         if (do_posix)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1793 |                 goto done;[0m
      | [0;1;32m                          
[0m[1mio.c:1803:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1803 |                 if (strcmp(cp, "stdin") == 0 && (flag & O_ACCMODE) == O_RDONLY)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 1804 |                         openfd = fileno(stdin);[0m
 1805 |                 else if (strcmp(cp, "stdout") == 0 && (flag & O_ACCMODE) == O_WRONLY)[0m
      | [0;32m                } 
[0m[1mio.c:1805:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1805 |                 else if (strcmp(cp, "stdout") == 0 && (flag & O_ACCMODE) == O_WRONLY)[0m
      | [0;1;32m                                                                                     ^
[0m      | [0;32m                                                                                      {
[0m 1806 |                         openfd = fileno(stdout);[0m
 1807 |                 else if (strcmp(cp, "stderr") == 0 && (flag & O_ACCMODE) == O_WRONLY)[0m
      | [0;32m                } 
[0m[1mio.c:1807:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1807 |                 else if (strcmp(cp, "stderr") == 0 && (flag & O_ACCMODE) == O_WRONLY)[0m
      | [0;1;32m                                                                                     ^
[0m      | [0;32m                                                                                      {
[0m 1808 |                         openfd = fileno(stderr);[0m
 1809 |                 else if (do_traditional)[0m
      | [0;32m                } 
[0m[1mio.c:1809:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1809 |                 else if (do_traditional)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1810 |                         goto done;[0m
 1811 |                 else if (strncmp(cp, "fd/", 3) == 0) {[0m
      | [0;32m                } 
[0m[1mio.c:1817:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1817 |                             || fstat(openfd, & sbuf) < 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1818 |                                 openfd = INVALID_HANDLE;[0m
      | [0;1;32m                                                        
[0m[1mio.c:1823:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1823 |         if (try_real_open)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1824 |                 openfd = open(name, flag, 0666);[0m
      | [0;1;32m                                                
[0m[1mio.c:1845:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1845 |         if (openfd != INVALID_HANDLE)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1846 |                 return openfd;[0m
      | [0;1;32m                              
[0m[1mio.c:1878:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1878 |                                 if (end != cp && count > 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1879 |                                         def_retries = count;[0m
      | [0;1;32m                                                            
[0m[1mio.c:1889:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1889 |                                 if (end == ms2 || msleep < 0)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1890 |                                         msleep = 1000;[0m
 1891 |                                 else[0m
      | [0;32m                                } 
[0m[1mio.c:1891:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1891 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1892 |                                         msleep *= 1000;[0m
      | [0;1;32m                                                       
[0m[1mio.c:1928:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1928 |                 if (openfd == INVALID_HANDLE && errno == ENOENT && save_errno)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1929 |                         errno = save_errno;[0m
      | [0;1;32m                                           
[0m[1mio.c:1943:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1943 |                 if (openfd > fileno(stderr))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1944 |                         os_close_on_exec(openfd, name, "file", "");[0m
      | [0;1;32m                                                                   
[0m[1mio.c:2097:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2097 |                 setsid();[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mio.c:2103:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2103 |                 if (close(master) == -1)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2104 |                         fatal(_("close of master pty failed: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                    
[0m[1mio.c:2105:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2105 |                 if (close(1) == -1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2106 |                         fatal(_("close of stdout in child failed: %s"),[0m
 2107 |                                 strerror(errno));[0m
      | [0;1;32m                                                 
[0m[1mio.c:2108:7: [0m[0;1;35mwarning: [0m[1mThe 1st argument to 'dup' is -1 but should be >= 0 [clang-analyzer-unix.StdCLibraryFunctions][0m
 2108 |                 if (dup(slave) != 1)[0m
      | [0;1;32m                    ^
[0m[1mio.c:2156:6: [0m[0;1;36mnote: [0mAssuming 'extfd' is < 0[0m
 2156 |         if (extfd >= 0 || inetfile(str, strlen(str), NULL)) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:2156:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:2156:20: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 2156 |         if (extfd >= 0 || inetfile(str, strlen(str), NULL)) {[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:2156:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2156 |         if (extfd >= 0 || inetfile(str, strlen(str), NULL)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:2196:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2196 |         if (find_two_way_processor(str, rp))[0m
      | [0;1;32m        ^
[0m[1mio.c:2201:8: [0m[0;1;36mnote: [0m'no_ptys' is false[0m
 2201 |         if (! no_ptys && pty_vs_pipe(str)) {[0m
      | [0;1;32m              ^~~~~~~
[0m[1mio.c:2201:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 2201 |         if (! no_ptys && pty_vs_pipe(str)) {[0m
      | [0;1;32m            ^
[0m[1mio.c:2201:19: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 2201 |         if (! no_ptys && pty_vs_pipe(str)) {[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~
[0m[1mio.c:2201:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 2201 |         if (! no_ptys && pty_vs_pipe(str)) {[0m
      | [0;1;32m        ^
[0m[1mio.c:2216:9: [0m[0;1;36mnote: [0m'initialized' is false[0m
 2216 |                 if (! initialized) {[0m
      | [0;1;32m                      ^~~~~~~~~~~
[0m[1mio.c:2216:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 2216 |                 if (! initialized) {[0m
      | [0;1;32m                ^
[0m[1mio.c:2225:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 2225 |                                 if (stat(slavenam, & statb) >= 0) {[0m
      | [0;1;32m                                ^
[0m[1mio.c:2227:6: [0m[0;1;36mnote: [0m Execution continues on line 2235[0m
 2227 |                                         break;[0m
      | [0;1;32m                                        ^
[0m[1mio.c:2240:8: [0m[0;1;36mnote: [0mAssuming 'master' is >= 0[0m
 2240 |                         if (master >= 0) {[0m
      | [0;1;32m                            ^~~~~~~~~~~
[0m[1mio.c:2240:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 2240 |                         if (master >= 0) {[0m
      | [0;1;32m                        ^
[0m[1mio.c:2246:9: [0m[0;1;36mnote: [0mAssuming 'tem' is not equal to NULL[0m
 2246 |                                 if (tem != NULL) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~
[0m[1mio.c:2246:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 2246 |                                 if (tem != NULL) {[0m
      | [0;1;32m                                ^
[0m[1mio.c:2248:6: [0m[0;1;36mnote: [0mControl jumps to line 2299[0m
 2248 |                                         goto got_the_pty;[0m
      | [0;1;32m                                        ^
[0m[1mio.c:2299:9: [0m[0;1;36mnote: [0mCalling 'fork_and_open_slave_pty'[0m
 2299 |                 if (! fork_and_open_slave_pty(slavenam, master, str, & pid))[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:2085:15: [0m[0;1;36mnote: [0mAssuming that 'open' fails[0m
 2085 |         if ((slave = open(slavenam, O_RDWR)) < 0) {[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:2085:7: [0m[0;1;36mnote: [0mValue assigned to 'slave'[0m
 2085 |         if ((slave = open(slavenam, O_RDWR)) < 0) {[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:2085:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 2085 |         if ((slave = open(slavenam, O_RDWR)) < 0) {[0m
      | [0;1;32m        ^
[0m[1mio.c:2094:2: [0m[0;1;36mnote: [0mControl jumps to 'case 0:'  at line 2095[0m
 2094 |         switch (*pid = fork()) {[0m
      | [0;1;32m        ^
[0m[1mio.c:2103:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 2103 |                 if (close(master) == -1)[0m
      | [0;1;32m                ^
[0m[1mio.c:2105:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 2105 |                 if (close(1) == -1)[0m
      | [0;1;32m                ^
[0m[1mio.c:2108:7: [0m[0;1;36mnote: [0mThe 1st argument to 'dup' is -1 but should be >= 0[0m
 2108 |                 if (dup(slave) != 1)[0m
      | [0;1;32m                    ^   ~~~~~
[0m[1mio.c:2108:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2108 |                 if (dup(slave) != 1)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2109 |                         fatal(_("moving slave pty to stdout in child failed (dup: %s)"), strerror(errno));[0m
      | [0;1;32m                                                                                                          
[0m[1mio.c:2110:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2110 |                 if (close(0) == -1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2111 |                         fatal(_("close of stdin in child failed: %s"),[0m
 2112 |                                 strerror(errno));[0m
      | [0;1;32m                                                 
[0m[1mio.c:2113:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2113 |                 if (dup(slave) != 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2114 |                         fatal(_("moving slave pty to stdin in child failed (dup: %s)"), strerror(errno));[0m
      | [0;1;32m                                                                                                         
[0m[1mio.c:2115:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2115 |                 if (close(slave))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2116 |                         fatal(_("close of slave pty failed: %s"), strerror(errno));[0m
      | [0;1;32m                                                                                   
[0m[1mio.c:2126:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2126 |                 save_errno = errno;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 2127 |                 close(master);[0m
 2128 |                 close(slave);[0m
 2129 |                 errno = save_errno;[0m
 2130 |                 return false;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mio.c:2160:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2160 |                 if (fd == INVALID_HANDLE)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2161 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mio.c:2162:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2162 |                 if ((BINMODE & BINMODE_OUTPUT) != 0)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2163 |                         os_setbinmode(fd, O_BINARY);[0m
      | [0;1;32m                                                    
[0m[1mio.c:2174:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2174 |                 if ((BINMODE & BINMODE_INPUT) != 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2175 |                         os_setbinmode(newfd, O_BINARY);[0m
      | [0;1;32m                                                       
[0m[1mio.c:2183:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2183 |                         if (! do_traditional && rp->iop->errcode != 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2184 |                                 update_ERRNO_int(rp->iop->errcode);[0m
      | [0;1;32m                                                                   
[0m[1mio.c:2196:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2196 |         if (find_two_way_processor(str, rp))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2197 |                 return true;[0m
      | [0;1;32m                            
[0m[1mio.c:2224:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2224 |                                 sprintf(slavenam, "/dev/pty%c0", c);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mio.c:2224:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 2224 |                                 sprintf(slavenam, "/dev/pty%c0", c);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mio.c:2247:6: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 2247 |                                         strcpy(slavenam, tem);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mio.c:2247:6: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 2247 |                                         strcpy(slavenam, tem);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mio.c:2269:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2269 |                                         sprintf(slavenam, "/dev/pty%c%x", c, i);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mio.c:2269:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 2269 |                                         sprintf(slavenam, "/dev/pty%c%x", c, i);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mio.c:2277:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2277 |                                                 if (access(slavenam, R_OK | W_OK) == 0)[0m
      | [0;1;32m                                                                                       ^
[0m      | [0;32m                                                                                        {
[0m 2278 |                                                         goto got_the_pty;[0m
      | [0;1;32m                                                                         
[0m[1mio.c:2284:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2284 |                                 if (cp[1] != '\0')[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 2285 |                                         cp++;[0m
 2286 |                                 else[0m
      | [0;32m                                } 
[0m[1mio.c:2286:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2286 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2287 |                                         cp = pty_chars;[0m
      | [0;1;32m                                                       
[0m[1mio.c:2290:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2290 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2291 |                         no_ptys = true;[0m
      | [0;1;32m                                       
[0m[1mio.c:2299:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2299 |                 if (! fork_and_open_slave_pty(slavenam, master, str, & pid))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 2300 |                         fatal(_("could not create child process or open pty"));[0m
      | [0;1;32m                                                                               
[0m[1mio.c:2307:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2307 |                         if (! do_traditional && rp->iop->errcode != 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2308 |                                 update_ERRNO_int(rp->iop->errcode);[0m
      | [0;1;32m                                                                   
[0m[1mio.c:2327:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2327 |                         if (dup_master > 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2328 |                                 (void) close(dup_master);[0m
      | [0;1;32m                                                         
[0m[1mio.c:2330:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2330 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2331 |                         find_output_wrapper(& rp->output);[0m
      | [0;1;32m                                                          
[0m[1mio.c:2352:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2352 |         if (pipe(ptoc) < 0)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2353 |                 return false;   /* errno set, diagnostic from caller */[0m
      | [0;1;32m                                                                       
[0m[1mio.c:2446:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2446 |                 if (close(1) == -1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2447 |                         fatal(_("close of stdout in child failed: %s"),[0m
 2448 |                                 strerror(errno));[0m
      | [0;1;32m                                                 
[0m[1mio.c:2449:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2449 |                 if (dup(ctop[1]) != 1)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2450 |                         fatal(_("moving pipe to stdout in child failed (dup: %s)"), strerror(errno));[0m
      | [0;1;32m                                                                                                     
[0m[1mio.c:2451:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2451 |                 if (close(0) == -1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2452 |                         fatal(_("close of stdin in child failed: %s"),[0m
 2453 |                                 strerror(errno));[0m
      | [0;1;32m                                                 
[0m[1mio.c:2454:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2454 |                 if (dup(ptoc[0]) != 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2455 |                         fatal(_("moving pipe to stdin in child failed (dup: %s)"), strerror(errno));[0m
      | [0;1;32m                                                                                                    
[0m[1mio.c:2457:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2457 |                     || close(ctop[0]) == -1 || close(ctop[1]) == -1)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 2458 |                         fatal(_("close of pipe failed: %s"), strerror(errno));[0m
      | [0;1;32m                                                                              
[0m[1mio.c:2467:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2467 |         if ((BINMODE & BINMODE_INPUT) != 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2468 |                 os_setbinmode(ctop[0], O_BINARY);[0m
      | [0;1;32m                                                 
[0m[1mio.c:2469:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2469 |         if ((BINMODE & BINMODE_OUTPUT) != 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2470 |                 os_setbinmode(ptoc[1], O_BINARY);[0m
      | [0;1;32m                                                 
[0m[1mio.c:2476:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2476 |                 if (! do_traditional && rp->iop->errcode != 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2477 |                         update_ERRNO_int(rp->iop->errcode);[0m
      | [0;1;32m                                                           
[0m[1mio.c:2501:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2501 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2502 |                 find_output_wrapper(& rp->output);[0m
      | [0;1;32m                                                  
[0m[1mio.c:2590:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2590 |                 if ((pid = waitpid(-1, & status, (interesting ? 0 : WNOHANG))) == 0)[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m 2591 |                         /* No children have exited */[0m
 2592 |                         break;[0m
      | [0;1;32m                              
[0m[1mio.c:2601:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2601 |                         for (redp = red_head; redp != NULL; redp = redp->next)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 2602 |                                 if (pid == redp->pid) {[0m
 2603 |                                         redp->pid = -1;[0m
 2604 |                                         redp->status = sanitize_exit_status(status);[0m
 2605 |                                         break;[0m
 2606 |                                 }[0m
      | [0;1;32m                                 
[0m[1mio.c:2608:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2608 |                 if (pid == -1 && errno == ECHILD)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2609 |                         break;[0m
      | [0;1;32m                              
[0m[1mio.c:2644:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2644 |         if (pipe(p) < 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2645 |                 fatal(_("cannot open pipe `%s': %s"), cmd, strerror(errno));[0m
      | [0;1;32m                                                                            
[0m[1mio.c:2684:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2684 |                 if (close(1) == -1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2685 |                         fatal(_("close of stdout in child failed: %s"),[0m
 2686 |                                 strerror(errno));[0m
      | [0;1;32m                                                 
[0m[1mio.c:2687:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2687 |                 if (dup(p[1]) != 1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2688 |                         fatal(_("moving pipe to stdout in child failed (dup: %s)"), strerror(errno));[0m
      | [0;1;32m                                                                                                     
[0m[1mio.c:2689:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2689 |                 if (close(p[0]) == -1 || close(p[1]) == -1)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2690 |                         fatal(_("close of pipe failed: %s"), strerror(errno));[0m
      | [0;1;32m                                                                              
[0m[1mio.c:2709:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2709 |         if ((BINMODE & BINMODE_INPUT) != 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2710 |                 os_setbinmode(p[0], O_BINARY);[0m
      | [0;1;32m                                              
[0m[1mio.c:2715:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2715 |                 if (! do_traditional && rp->iop->errcode != 0)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2716 |                         update_ERRNO_int(rp->iop->errcode);[0m
      | [0;1;32m                                                           
[0m[1mio.c:2729:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2729 |         if (rp->iop != NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2730 |                 (void) iop_close(rp->iop);[0m
      | [0;1;32m                                          
[0m[1mio.c:2734:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2734 |         if (rp->pid == -1)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2735 |                 return rp->status;[0m
      | [0;1;32m                                  
[0m[1mio.c:2818:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2818 |         if (into_variable)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2819 |                 lhs = POP_ADDRESS();[0m
      | [0;1;32m                                    
[0m[1mio.c:2828:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2828 |                         if (! do_traditional)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2829 |                                 update_ERRNO_int(redir_error);[0m
      | [0;1;32m                                                              
[0m[1mio.c:2841:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2841 |         if (iop == NULL)                /* end of input */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2842 |                 return make_number((AWKNUM) 0.0);[0m
      | [0;1;32m                                                 
[0m[1mio.c:2847:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2847 |                 if (! do_traditional && (errcode != -1))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2848 |                         update_ERRNO_int(errcode);[0m
      | [0;1;32m                                                  
[0m[1mio.c:2866:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2866 |         if (lhs == NULL)        /* no optional var. */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2867 |                 set_record(s, cnt, field_width);[0m
 2868 |         else {                  /* assignment to variable */[0m
      | [0;32m        } 
[0m[1mio.c:2891:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2891 |                 if (into_variable)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2892 |                         (void) POP_ADDRESS();[0m
      | [0;1;32m                                             
[0m[1mio.c:2899:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2899 |                 if (! do_traditional && (errcode != -1))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2900 |                         update_ERRNO_int(errcode);[0m
      | [0;1;32m                                                  
[0m[1mio.c:2901:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2901 |                 if (into_variable)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2902 |                         (void) POP_ADDRESS();[0m
      | [0;1;32m                                             
[0m[1mio.c:2906:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2906 |         if (retval == EOF)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2907 |                 return NULL;    /* try next file */[0m
      | [0;1;32m                                                   
[0m[1mio.c:2911:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2911 |         if (! into_variable)    /* no optional var. */[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2912 |                 set_record(s, cnt, field_width);[0m
 2913 |         else {                  /* assignment to variable */[0m
      | [0;32m        } 
[0m[1mio.c:2954:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2954 |         if ((path = getenv(pi->envname)) == NULL || *path == '\0')[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 2955 |                 path = pi->dfltp[0];[0m
      | [0;1;32m                                    
[0m[1mio.c:2958:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2958 |         for (max_path = 0, p = (char *) path; *p; p++)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 2959 |                 if (*p == envsep)[0m
 2960 |                         max_path++;[0m
      | [0;1;32m                                   
[0m[1mio.c:2959:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2959 |                 if (*p == envsep)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2960 |                         max_path++;[0m
      | [0;1;32m                                   
[0m[1mio.c:2977:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2977 |                                 if (pi->max_pathlen == 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 2978 |                                         pi->max_pathlen = 1;[0m
      | [0;1;32m                                                            
[0m[1mio.c:2982:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2982 |                                 if (pi->max_pathlen == 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 2983 |                                         pi->max_pathlen = 1;[0m
      | [0;1;32m                                                            
[0m[1mio.c:2985:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2985 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2986 |                                 start++;[0m
      | [0;1;32m                                        
[0m[1mio.c:2988:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2988 |                         for (end = start; *end && *end != envsep; end++)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 2989 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mio.c:2994:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2994 |                                 memcpy(p, start, len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mio.c:2994:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2994 |                                 memcpy(p, start, len);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mio.c:2997:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2997 |                                 if (! isdirpunct(end[-1]))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2998 |                                         p[len++] = '/';[0m
      | [0;1;32m                                                       
[0m[1mio.c:3001:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3001 |                                 if (len > pi->max_pathlen)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3002 |                                         pi->max_pathlen = len;[0m
      | [0;1;32m                                                              
[0m[1mio.c:3005:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3005 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3006 |                                 start++;[0m
      | [0;1;32m                                        
[0m[1mio.c:3026:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 3026 |                 strcpy(path, src);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3026:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 3026 |                 strcpy(path, src);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3027:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3027 |                 if (stat(path, stb) == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 3028 |                         return path;[0m
      | [0;1;32m                                    
[0m[1mio.c:3034:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3034 |         if (pi->awkpath == NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3035 |                 init_awkpath(pi);[0m
      | [0;1;32m                                 
[0m[1mio.c:3039:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3039 |                 if (strcmp(pi->awkpath[i], "./") == 0 || strcmp(pi->awkpath[i], ".") == 0)[0m
      | [0;1;32m                                                                                          ^
[0m      | [0;32m                                                                                           {
[0m 3040 |                         *path = '\0';[0m
 3041 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:3041:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3041 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3042 |                         strcpy(path, pi->awkpath[i]);[0m
      | [0;1;32m                                                     
[0m[1mio.c:3042:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 3042 |                         strcpy(path, pi->awkpath[i]);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mio.c:3042:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 3042 |                         strcpy(path, pi->awkpath[i]);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mio.c:3043:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 3043 |                 strcat(path, src);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3043:3: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
 3043 |                 strcat(path, src);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3044:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3044 |                 if (stat(path, stb) == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 3045 |                         return path;[0m
      | [0;1;32m                                    
[0m[1mio.c:3063:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3063 |         if (src == NULL || *src == '\0')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3064 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mio.c:3078:88: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3078 |                 if (src_len >= suffix_len && strcmp(& src[src_len - suffix_len], EXTLIB_SUFFIX) == 0)[0m
      | [0;1;32m                                                                                                     ^
[0m      | [0;32m                                                                                                      {
[0m 3079 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mio.c:3084:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3084 |                 sprintf(file_ext, "%s%s", src, EXTLIB_SUFFIX);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:3084:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 3084 |                 sprintf(file_ext, "%s%s", src, EXTLIB_SUFFIX);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:3087:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3087 |                 if (path == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3088 |                         errno = save_errno;[0m
      | [0;1;32m                                           
[0m[1mio.c:3112:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3112 |                 sprintf(file_awk, "%s%s", src, DEFAULT_FILETYPE);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:3112:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 3112 |                 sprintf(file_awk, "%s%s", src, DEFAULT_FILETYPE);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:3135:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3135 |         if (s->stype == SRC_STDIN)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3136 |                 fd = fileno(stdin);[0m
 3137 |         else if (s->stype == SRC_FILE || s->stype == SRC_INC)[0m
      | [0;32m        } 
[0m[1mio.c:3137:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3137 |         else if (s->stype == SRC_FILE || s->stype == SRC_INC)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3138 |                 fd = devopen(s->fullpath, "r");[0m
      | [0;1;32m                                               
[0m[1mio.c:3141:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3141 |         if (fd != INVALID_HANDLE)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3142 |                 os_setbinmode(fd, O_BINARY);[0m
      | [0;1;32m                                            
[0m[1mio.c:3161:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3161 |         if (input_parser == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3162 |                 fatal(_("register_input_parser: received NULL pointer"));[0m
      | [0;1;32m                                                                         
[0m[1mio.c:3164:21: [0m[0;1;35mwarning: [0m[1mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'input_parser') [clang-analyzer-core.NullDereference][0m
 3164 |         input_parser->next = NULL;      /* force it */[0m
      | [0;1;32m        ~~~~~~~~~~~~       ^
[0m[1mio.c:3161:6: [0m[0;1;36mnote: [0mAssuming 'input_parser' is equal to NULL[0m
 3161 |         if (input_parser == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:3161:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3161 |         if (input_parser == NULL)[0m
      | [0;1;32m        ^
[0m[1mio.c:3164:21: [0m[0;1;36mnote: [0mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'input_parser')[0m
 3164 |         input_parser->next = NULL;      /* force it */[0m
      | [0;1;32m        ~~~~~~~~~~~~       ^
[0m[1mio.c:3181:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3181 |         if (iop->public.get_record != NULL || iop->public.read_func != read)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 3182 |                 return;[0m
      | [0;1;32m                       
[0m[1mio.c:3187:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3187 |                         if (ip == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3188 |                                 ip = ip2;       /* found first one */[0m
 3189 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:3189:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3189 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3190 |                                 fatal(_("input parser `%s' conflicts with previously installed input parser `%s'"),[0m
 3191 |                                                 ip2->name, ip->name);[0m
      | [0;1;32m                                                                     
[0m[1mio.c:3196:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3196 |                 if (! ip->take_control_of(& iop->public))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3197 |                         warning(_("input parser `%s' failed to open `%s'"),[0m
 3198 |                                         ip->name, iop->public.name);[0m
 3199 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:3199:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3199 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3200 |                         iop->valid = true;[0m
      | [0;1;32m                                          
[0m[1mio.c:3216:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3216 |         if (wrapper == NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3217 |                 fatal(_("register_output_wrapper: received NULL pointer"));[0m
      | [0;1;32m                                                                           
[0m[1mio.c:3219:16: [0m[0;1;35mwarning: [0m[1mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'wrapper') [clang-analyzer-core.NullDereference][0m
 3219 |         wrapper->next = NULL;   /* force it */[0m
      | [0;1;32m        ~~~~~~~       ^
[0m[1mio.c:3216:6: [0m[0;1;36mnote: [0mAssuming 'wrapper' is equal to NULL[0m
 3216 |         if (wrapper == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mio.c:3216:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3216 |         if (wrapper == NULL)[0m
      | [0;1;32m        ^
[0m[1mio.c:3219:16: [0m[0;1;36mnote: [0mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'wrapper')[0m
 3219 |         wrapper->next = NULL;   /* force it */[0m
      | [0;1;32m        ~~~~~~~       ^
[0m[1mio.c:3236:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3236 |         if (outbuf->redirected)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3237 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:3242:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3242 |                         if (op == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3243 |                                 op = op2;       /* found first one */[0m
 3244 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:3244:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3244 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3245 |                                 fatal(_("output wrapper `%s' conflicts with previously installed output wrapper `%s'"),[0m
 3246 |                                                 op2->name, op->name);[0m
      | [0;1;32m                                                                     
[0m[1mio.c:3272:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3272 |         if (processor == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3273 |                 fatal(_("register_output_processor: received NULL pointer"));[0m
      | [0;1;32m                                                                             
[0m[1mio.c:3275:18: [0m[0;1;35mwarning: [0m[1mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'processor') [clang-analyzer-core.NullDereference][0m
 3275 |         processor->next = NULL; /* force it */[0m
      | [0;1;32m        ~~~~~~~~~       ^
[0m[1mio.c:3272:6: [0m[0;1;36mnote: [0mAssuming 'processor' is equal to NULL[0m
 3272 |         if (processor == NULL)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~
[0m[1mio.c:3272:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3272 |         if (processor == NULL)[0m
      | [0;1;32m        ^
[0m[1mio.c:3275:18: [0m[0;1;36mnote: [0mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'processor')[0m
 3275 |         processor->next = NULL; /* force it */[0m
      | [0;1;32m        ~~~~~~~~~       ^
[0m[1mio.c:3293:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3293 |             || rp->output.fp != NULL)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3294 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:3299:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3299 |                         if (tw == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3300 |                                 tw = tw2;       /* found first one */[0m
 3301 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:3301:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3301 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3302 |                                 fatal(_("two-way processor `%s' conflicts with previously installed two-way processor `%s'"),[0m
 3303 |                                                 tw2->name, tw->name);[0m
      | [0;1;32m                                                                     
[0m[1mio.c:3308:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3308 |                 if (rp->iop == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3309 |                         rp->iop = iop_alloc(INVALID_HANDLE, name, 0);[0m
      | [0;1;32m                                                                     
[0m[1mio.c:3378:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3378 |         if (fd != INVALID_HANDLE)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3379 |                 fstat(fd, & iop->public.sbuf);[0m
 3380 |         else {[0m
      | [0;32m        } 
[0m[1mio.c:3390:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3390 |                 if (statf(name, & iop->public.sbuf) < 0)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 3391 |                         memset(& iop->public.sbuf, 0, sizeof(struct stat));[0m
      | [0;1;32m                                                                           
[0m[1mio.c:3391:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3391 |                         memset(& iop->public.sbuf, 0, sizeof(struct stat));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mio.c:3391:4: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3391 |                         memset(& iop->public.sbuf, 0, sizeof(struct stat));[0m
      | [0;1;32m                        ^~~~~~
[0m[1mio.c:3405:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3405 |                 if (os_isreadable(& iop->public, & isdir))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3406 |                         iop->valid = true;[0m
 3407 |                 else {[0m
      | [0;32m                } 
[0m[1mio.c:3408:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3408 |                         if (isdir)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3409 |                                 iop->errcode = EISDIR;[0m
 3410 |                         else {[0m
      | [0;32m                        } 
[0m[1mio.c:3422:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3422 |                                 if (fcntl(iop->public.fd, F_GETFL) >= 0)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 3423 | #endif[0m
 3424 |                                         (void) close(iop->public.fd);[0m
      | [0;1;32m                                                                     
[0m[1mio.c:3434:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3434 |         if (! iop->valid || iop->public.fd == INVALID_HANDLE)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3435 |                 return iop;[0m
      | [0;1;32m                           
[0m[1mio.c:3437:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3437 |         if (os_isatty(iop->public.fd))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3438 |                 iop->flag |= IOP_IS_TTY;[0m
      | [0;1;32m                                        
[0m[1mio.c:3441:84: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3441 |         if (do_lint && S_ISREG(iop->public.sbuf.st_mode) && iop->public.sbuf.st_size == 0)[0m
      | [0;1;32m                                                                                          ^
[0m      | [0;32m                                                                                           {
[0m 3442 |                 lintwarn(_("data file `%s' is empty"), iop->public.name);[0m
      | [0;1;32m                                                                         
[0m[1mio.c:3483:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3483 |         if (newsize <= iop->size)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3484 |                 fatal(_("could not allocate more input memory"));[0m
      | [0;1;32m                                                                 
[0m[1mio.c:3487:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3487 |         if (newsize - valid < iop->readsize)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 3488 |                 newsize += iop->readsize + 1;[0m
      | [0;1;32m                                             
[0m[1mio.c:3491:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3491 |         if (newsize <= iop->size)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3492 |                 fatal(_("could not allocate more input memory"));[0m
      | [0;1;32m                                                                 
[0m[1mio.c:3511:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3511 |         memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m        ^~~~~~
[0m[1mio.c:3511:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3511 |         memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m        ^~~~~~
[0m[1mio.c:3517:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3517 |         if (*state == INDATA)   /* skip over data we've already seen */[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 3518 |                 bp += iop->scanoff;[0m
      | [0;1;32m                                   
[0m[1mio.c:3578:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3578 |                 memset(& mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3578:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3578 |                 memset(& mbs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3580:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3580 |                         if (*bp == rs)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3581 |                                 found = true;[0m
      | [0;1;32m                                             
[0m[1mio.c:3582:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3582 |                         if (is_valid_character(*bp))[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 3583 |                                 mbclen = 1;[0m
 3584 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:3584:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3584 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3585 |                                 mbclen = mbrlen(bp, len, & mbs);[0m
      | [0;1;32m                                                                
[0m[1mio.c:3617:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3617 |         while (*bp != rs)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 3618 |                 bp++;[0m
      | [0;1;32m                     
[0m[1mio.c:3645:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3645 |         memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m        ^~~~~~
[0m[1mio.c:3645:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3645 |         memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m        ^~~~~~
[0m[1mio.c:3649:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3649 |         if (*state == INDATA)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 3650 |                 bp += iop->scanoff;[0m
      | [0;1;32m                                   
[0m[1mio.c:3652:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3652 |         if ((iop->flag & IOP_AT_START) == 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 3653 |                 regex_flags |= RE_NO_BOL;[0m
      | [0;1;32m                                         
[0m[1mio.c:3702:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3702 |                 if (reisstring(RS->stptr, RS->stlen, RSre, iop->off))[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 3703 |                         return REC_OK;[0m
 3704 |                 else[0m
      | [0;32m                } 
[0m[1mio.c:3704:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3704 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3705 |                         return TERMATEND;[0m
      | [0;1;32m                                         
[0m[1mio.c:3735:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3735 |                 if (iop->dataend - matchend < RS->stlen)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 3736 |                         return TERMNEAREND;[0m
      | [0;1;32m                                           
[0m[1mio.c:3749:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3749 |         if (*state == NOSTATE || *state == INLEADER)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 3750 |                 memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m                                                            
[0m[1mio.c:3750:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3750 |                 memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3750:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3750 |                 memset(recm, '\0', sizeof(struct recmatch));[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:3755:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3755 |         if (*state != NOSTATE)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3756 |                 bp += iop->scanoff;[0m
      | [0;1;32m                                   
[0m[1mio.c:3761:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3761 |         if (*state == INTERM)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 3762 |                 goto find_longest_terminator;[0m
 3763 |         else if (*state == INDATA)[0m
      | [0;32m        } 
[0m[1mio.c:3763:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3763 |         else if (*state == INDATA)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3764 |                 goto scan_data;[0m
      | [0;1;32m                               
[0m[1mio.c:3771:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3771 |         while (*bp == '\n' && bp < iop->dataend)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3772 |                 bp++;[0m
      | [0;1;32m                     
[0m[1mio.c:3782:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3782 |         while (*bp++ != '\n')[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 3783 |                 continue;[0m
      | [0;1;32m                         
[0m[1mio.c:3796:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3796 |         if (*bp != '\n')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 3797 |                 goto scan_data;[0m
      | [0;1;32m                               
[0m[1mio.c:3806:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3806 |         while (*bp == '\n' && bp < iop->dataend)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3807 |                 bp++;[0m
      | [0;1;32m                     
[0m[1mio.c:3812:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3812 |         if (bp >= iop->dataend)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3813 |                 return TERMATEND;[0m
      | [0;1;32m                                 
[0m[1mio.c:3848:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3848 |                 return 0;[0m
      | [0;1;32m                ^       
[0m      | [0;32m                {       ;} 
[0m[1mio.c:3873:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3873 |         if (at_eof(iop) && no_data_left(iop))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3874 |                 return EOF;[0m
      | [0;1;32m                           
[0m[1mio.c:3876:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3876 |         if (read_can_timeout)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 3877 |                 read_timeout = get_read_timeout(iop);[0m
      | [0;1;32m                                                     
[0m[1mio.c:3885:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3885 |                 if (rc == EOF)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3886 |                         iop->flag |= IOP_AT_EOF;[0m
 3887 |                 else {[0m
      | [0;32m                } 
[0m[1mio.c:3891:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3891 |                         if (rt_len != 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3892 |                                 set_RT(rt_start, rt_len);[0m
 3893 |                         else[0m
      | [0;32m                        } 
[0m[1mio.c:3893:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3893 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3894 |                                 set_RT_to_null();[0m
      | [0;1;32m                                                 
[0m[1mio.c:3907:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3907 |                         if (errno_io_retry() && retryable(iop))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3908 |                                 return -2;[0m
      | [0;1;32m                                          
[0m[1mio.c:3927:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3927 |                 if (ret == REC_OK)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3928 |                         break;[0m
      | [0;1;32m                              
[0m[1mio.c:3935:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3935 |                 if (ret == TERMNEAREND && buffer_has_all_data(iop))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 3936 |                         break;[0m
      | [0;1;32m                              
[0m[1mio.c:3941:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3941 |                 memmove(iop->buf, iop->off, dataend_off);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:3941:3: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
 3941 |                 memmove(iop->buf, iop->off, dataend_off);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:3947:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3947 |                 if (recm.rt_start != NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 3948 |                         recm.rt_start = iop->off + recm.len;[0m
      | [0;1;32m                                                            
[0m[1mio.c:3962:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3962 |                         if (recm.rt_start != NULL)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 3963 |                                 recm.rt_start = iop->off + recm.len;[0m
      | [0;1;32m                                                                    
[0m[1mio.c:3969:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3969 |                 while (amt_to_read + iop->readsize < room_left)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3970 |                         amt_to_read += iop->readsize;[0m
      | [0;1;32m                                                     
[0m[1mio.c:3983:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3983 |                         if (errno_io_retry() && retryable(iop))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3984 |                                 return -2;[0m
      | [0;1;32m                                          
[0m[1mio.c:3995:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3995 |                         if (ret != TERMNEAREND)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 3996 |                                 iop->flag |= IOP_AT_EOF;[0m
      | [0;1;32m                                                        
[0m[1mio.c:3998:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3998 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3999 |                         iop->dataend += iop->count;[0m
      | [0;1;32m                                                   
[0m[1mio.c:4034:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4034 |                         if (rtval->stlen != 1 || rtval->stptr[0] != recm.rt_start[0])[0m
      | [0;1;32m                                                                                     ^
[0m      | [0;32m                                                                                      {
[0m 4035 |                                 set_RT(recm.rt_start, recm.rt_len);[0m
      | [0;1;32m                                                                   
[0m[1mio.c:4042:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4042 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 4043 |                                 set_RT(recm.rt_start, recm.rt_len);[0m
      | [0;1;32m                                                                   
[0m[1mio.c:4044:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4044 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4045 |                         set_RT(recm.rt_start, recm.rt_len);[0m
      | [0;1;32m                                                           
[0m[1mio.c:4059:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4059 |         if (recm.len == 0 && recm.rt_len == 0 && at_eof(iop))[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 4060 |                 return EOF;[0m
 4061 |         else[0m
      | [0;32m        } 
[0m[1mio.c:4061:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4061 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 4062 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mio.c:4116:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4116 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4117 |                 matchrec = rs1scan;[0m
      | [0;1;32m                                   
[0m[1mio.c:4119:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4119 |         if (current_field_sep() == Using_FS)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 4120 |                 set_FS();[0m
      | [0;1;32m                         
[0m[1mio.c:4141:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4141 |         if (val)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 4142 |                 return boolval(val);[0m
      | [0;1;32m                                    
[0m[1mio.c:4185:17: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 4185 |         if (len < 5 || memcmp(cp, "/inet", 5) != 0)[0m
      | [0;1;32m                       ^
[0m[1mio.c:790:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1187:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_sandbox'[0m
 1187 | #define do_sandbox          (do_flags & DO_SANDBOX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:790:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  790 |         if (do_sandbox)[0m
      | [0;1;32m        ^
[0m[1mio.c:793:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 821[0m
  793 |         switch (redirtype) {[0m
      | [0;1;32m        ^
[0m[1mio.c:824:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:824:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  824 |         if (do_lint && not_string)[0m
      | [0;1;32m                    ^
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mAssuming 'explen' is >= 1[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mio.c:828:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:828:20: [0m[0;1;36mnote: [0mAssuming 'str' is equal to NULL[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                          ^~~~~~~~~~~
[0m[1mio.c:828:32: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
  828 |         if (explen < 1 || str == NULL || *str == '\0')[0m
      | [0;1;32m                                      ^
[0m[1mio.c:832:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:832:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  832 |         if (do_lint && (strncmp(str, "0", explen) == 0[0m
      | [0;1;32m                    ^
[0m[1mio.c:842:15: [0m[0;1;36mnote: [0mPassing null pointer value via 1st parameter 'str'[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m                     ^~~
[0m[1mio.c:842:6: [0m[0;1;36mnote: [0mCalling 'inetfile'[0m
  842 |         if (inetfile(str, explen, & isi)) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mio.c:4180:2: [0m[0;1;36mnote: [0m'cp' initialized to a null pointer value[0m
 4180 |         const char *cp = str;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~
[0m[1mio.c:4185:6: [0m[0;1;36mnote: [0mAssuming 'len' is >= 5[0m
 4185 |         if (len < 5 || memcmp(cp, "/inet", 5) != 0)[0m
      | [0;1;32m            ^~~~~~~
[0m[1mio.c:4185:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mio.c:4185:17: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 4185 |         if (len < 5 || memcmp(cp, "/inet", 5) != 0)[0m
      | [0;1;32m                       ^      ~~
[0m[1mio.c:4185:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4185 |         if (len < 5 || memcmp(cp, "/inet", 5) != 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 4186 |                 /* quick exit */[0m
 4187 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4188:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4188 |         if (! isi)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 4189 |                 isi = & buf;[0m
      | [0;1;32m                            
[0m[1mio.c:4191:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4191 |         if (cpend - cp < 2)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 4192 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4195:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4195 |                 isi->family = AF_UNSPEC;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4196 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:4198:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4198 |                 if (*++cp != '/')[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4199 |                         return false;[0m
 4200 |                 isi->family = AF_INET;[0m
 4201 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:4198:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4198 |                 if (*++cp != '/')[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4199 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mio.c:4203:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4203 |                 if (*++cp != '/')[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4204 |                         return false;[0m
 4205 |                 isi->family = AF_INET6;[0m
 4206 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mio.c:4203:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4203 |                 if (*++cp != '/')[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4204 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mio.c:4208:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4208 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mio.c:4213:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4213 |         if (cpend - cp < 5)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 4214 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4215:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4215 |         if (memcmp(cp, "tcp/", 4) == 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 4216 |                 isi->protocol = SOCK_STREAM;[0m
 4217 |         else if (memcmp(cp, "udp/", 4) == 0)[0m
      | [0;32m        } 
[0m[1mio.c:4217:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4217 |         else if (memcmp(cp, "udp/", 4) == 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 4218 |                 isi->protocol = SOCK_DGRAM;[0m
 4219 |         else[0m
      | [0;32m        } 
[0m[1mio.c:4219:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4219 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 4220 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4226:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4226 |                 if (++cp >= cpend)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 4227 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mio.c:4233:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4233 |         if ((isi->localport.len = (cp-str)-isi->localport.offset) == 0)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 4234 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4237:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4237 |         if (cpend - cp < 2)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 4238 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4242:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4242 |                 if (++cp >= cpend)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 4243 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mio.c:4245:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4245 |         if ((isi->remotehost.len = (cp-str)-isi->remotehost.offset) == 0)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 4246 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4249:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4249 |         if (cpend - cp < 2)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 4250 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4259:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4259 |         while (*cp != '/' && cp < cpend)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 4260 |                 cp++;[0m
      | [0;1;32m                     
[0m[1mio.c:4261:84: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4261 |         if (cp != cpend || ((isi->remoteport.len = (cp-str)-isi->remoteport.offset) == 0))[0m
      | [0;1;32m                                                                                          ^
[0m      | [0;32m                                                                                           {
[0m 4262 |                 return false;[0m
      | [0;1;32m                             
[0m[1mio.c:4286:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4286 |         if (PROCINFO_node == NULL || (pidx1 == NULL && pidx2 == NULL))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 4287 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mio.c:4291:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4291 |         if (full_idx)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 4292 |                 sub = *full_idx;[0m
      | [0;1;32m                                
[0m[1mio.c:4294:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4294 |         if (pidx1 != NULL && pidx2 == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 4295 |                 str_len = strlen(pidx1);[0m
 4296 |         else if (pidx1 == NULL && pidx2 != NULL)[0m
      | [0;32m        } 
[0m[1mio.c:4296:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4296 |         else if (pidx1 == NULL && pidx2 != NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 4297 |                 str_len = strlen(pidx2);[0m
 4298 |         else[0m
      | [0;32m        } 
[0m[1mio.c:4298:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4298 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 4299 |                 str_len = strlen(pidx1) + subsep->stlen + strlen(pidx2);[0m
      | [0;1;32m                                                                        
[0m[1mio.c:4304:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4304 |                 if (full_idx)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 4305 |                         *full_idx = sub;[0m
      | [0;1;32m                                        
[0m[1mio.c:4314:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4314 |         if (pidx1 != NULL && pidx2 == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 4315 |                 strcpy(sub->stptr, pidx1);[0m
 4316 |         else if (pidx1 == NULL && pidx2 != NULL)[0m
      | [0;32m        } 
[0m[1mio.c:4315:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 4315 |                 strcpy(sub->stptr, pidx1);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:4315:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 4315 |                 strcpy(sub->stptr, pidx1);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:4316:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4316 |         else if (pidx1 == NULL && pidx2 != NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 4317 |                 strcpy(sub->stptr, pidx2);[0m
 4318 |         else[0m
      | [0;32m        } 
[0m[1mio.c:4317:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 4317 |                 strcpy(sub->stptr, pidx2);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:4317:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 4317 |                 strcpy(sub->stptr, pidx2);[0m
      | [0;1;32m                ^~~~~~
[0m[1mio.c:4318:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4318 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 4319 |                 sprintf(sub->stptr, "%s%.*s%s", pidx1, (int)subsep->stlen,[0m
 4320 |                                 subsep->stptr, pidx2);[0m
      | [0;1;32m                                                      
[0m[1mio.c:4319:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4319 |                 sprintf(sub->stptr, "%s%.*s%s", pidx1, (int)subsep->stlen,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:4319:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 4319 |                 sprintf(sub->stptr, "%s%.*s%s", pidx1, (int)subsep->stlen,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mio.c:4323:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4323 |         if (! full_idx)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 4324 |                 unref(sub);[0m
      | [0;1;32m                           
[0m[1mio.c:4348:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4348 |                         if (last_name != NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 4349 |                                 efree((void *) last_name);[0m
      | [0;1;32m                                                          
[0m[1mio.c:4351:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4351 |                 } else  /* use cached full index */[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4352 |                         val = in_array(PROCINFO_node, full_idx);[0m
      | [0;1;32m                                                                
[0m[1mio.c:4358:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4358 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4359 |                 tmout = read_default_timeout;   /* initialized from env. variable in init_io() */[0m
      | [0;1;32m                                                                                                 
[0m[1mio.c:4362:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4362 |         if ((iop->public.read_func == ( ssize_t(*)() ) read) && tmout > 0)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 4363 |                 iop->public.read_func = read_with_timeout;[0m
      | [0;1;32m                                                          
[0m[1mio.c:4404:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4404 |         if (select(fd + 1, & readfds, NULL, NULL, & tv) < 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 4405 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mio.c:4407:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4407 |         if (FD_ISSET(s, & readfds))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4408 |                 return read(fd, buf, size);[0m
      | [0;1;32m                                           
[0m388 warnings generated.
Suppressed 32 warnings (32 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[53/54][314.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpj0ws2hm2.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/debug.c
[1mdebug.c:387:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  387 |         if (input_from_tty && prompt && *prompt)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  388 |                 fprintf(out_fp, "%s", prompt);[0m
      | [0;1;32m                                              
[0m[1mdebug.c:388:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  388 |                 fprintf(out_fp, "%s", prompt);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:388:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  388 |                 fprintf(out_fp, "%s", prompt);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:395:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  395 |                         if (p > line && p[-1] == '\r')[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  396 |                                 p--;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:405:8: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  405 |                 *p++ = buf[0];[0m
      | [0;1;32m                ~~~~~^~~~~~~~
[0m[1mdebug.c:387:6: [0m[0;1;36mnote: [0mAssuming 'input_from_tty' is false[0m
  387 |         if (input_from_tty && prompt && *prompt)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~
[0m[1mdebug.c:387:21: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  387 |         if (input_from_tty && prompt && *prompt)[0m
      | [0;1;32m                           ^
[0m[1mdebug.c:393:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  393 |         while ((n = read(input_fd, buf, 1)) > 0) {[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:393:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  393 |         while ((n = read(input_fd, buf, 1)) > 0) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:394:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  394 |                 if (buf[0] == '\n') {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~
[0m[1mdebug.c:394:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  394 |                 if (buf[0] == '\n') {[0m
      | [0;1;32m                ^
[0m[1mdebug.c:399:7: [0m[0;1;36mnote: [0m'p' is equal to 'end'[0m
  399 |                 if (p == end) {[0m
      | [0;1;32m                    ^
[0m[1mdebug.c:399:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  399 |                 if (p == end) {[0m
      | [0;1;32m                ^
[0m[1mdebug.c:405:4: [0m[0;1;36mnote: [0mNull pointer value stored to 'p'[0m
  405 |                 *p++ = buf[0];[0m
      | [0;1;32m                 ^~~
[0m[1mdebug.c:405:8: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  405 |                 *p++ = buf[0];[0m
      | [0;1;32m                ~~~~~^~~~~~~~
[0m[1mdebug.c:423:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  423 |         fprintf(out_fp, _("error: "));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:423:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  423 |         fprintf(out_fp, _("error: "));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:425:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  425 |         fprintf(out_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:425:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  425 |         fprintf(out_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:460:12: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  460 |                                 *++pos = ofs + (p - buf);[0m
      | [0;1;32m                                       ^
[0m[1mdebug.c:3620:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3620 |         if (! in_main_context())[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3620:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3620 |         if (! in_main_context())[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3628:6: [0m[0;1;36mnote: [0mAssuming 'do_trace' is 0[0m
 3628 |         if (do_trace[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mdebug.c:3629:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3629 |                 && cur_pc->opcode != Op_breakpoint[0m
      | [0;1;32m                ^
[0m[1mdebug.c:3640:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 3676[0m
 3640 |         switch (cur_pc->opcode) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3677:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is > 0[0m
 3677 |                 if (cur_pc->source_line <= 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3677:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3677 |                 if (cur_pc->source_line <= 0)[0m
      | [0;1;32m                ^
[0m[1mdebug.c:3679:3: [0m[0;1;36mnote: [0m Execution continues on line 3682[0m
 3679 |                 break;[0m
      | [0;1;32m                ^
[0m[1mdebug.c:3682:6: [0m[0;1;36mnote: [0m'cant_stop' is false[0m
 3682 |         if (cant_stop)[0m
      | [0;1;32m            ^~~~~~~~~
[0m[1mdebug.c:3682:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3682 |         if (cant_stop)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3694:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3694 |         if (check_watchpoint()) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3700:13: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 3700 |         } else if (check_breakpoint(pi)[0m
      | [0;1;32m                   ^
[0m[1mdebug.c:3701:8: [0m[0;1;36mnote: [0mAssuming field 'check_func' is non-null[0m
 3701 |                         || (stop.check_func && stop.check_func(pi))) {[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~
[0m[1mdebug.c:3701:8: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mdebug.c:3701:27: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3701 |                         || (stop.check_func && stop.check_func(pi))) {[0m
      | [0;1;32m                                               ^~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3700:9: [0m[0;1;36mnote: [0mTaking true branch[0m
 3700 |         } else if (check_breakpoint(pi)[0m
      | [0;1;32m               ^
[0m[1mdebug.c:3702:3: [0m[0;1;36mnote: [0mCalling 'next_command'[0m
 3702 |                 next_command(); /* return to debugger interface */[0m
      | [0;1;32m                ^~~~~~~~~~~~~~
[0m[1mdebug.c:3479:6: [0m[0;1;36mnote: [0mAssuming 'source' is not equal to NULL[0m
 3479 |         if (source == NULL) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~
[0m[1mdebug.c:3479:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3479 |         if (source == NULL) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3485:6: [0m[0;1;36mnote: [0mAssuming field 'break_point' is 0[0m
 3485 |         if (stop.break_point) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~
[0m[1mdebug.c:3485:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3485 |         if (stop.break_point) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3490:13: [0m[0;1;36mnote: [0mAssuming field 'watch_point' is 0[0m
 3490 |         } else if (stop.watch_point) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~
[0m[1mdebug.c:3490:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 3490 |         } else if (stop.watch_point) {[0m
      | [0;1;32m               ^
[0m[1mdebug.c:3496:6: [0m[0;1;36mnote: [0mAssuming 'cur_rule' is equal to 'last_rule'[0m
 3496 |         if (cur_rule != last_rule) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3496:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3496 |         if (cur_rule != last_rule) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3501:6: [0m[0;1;36mnote: [0m'b' is equal to NULL[0m
 3501 |         if (b != NULL)[0m
      | [0;1;32m            ^
[0m[1mdebug.c:3501:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3501 |         if (b != NULL)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3503:11: [0m[0;1;36mnote: [0m'w' is equal to NULL[0m
 3503 |         else if (w != NULL) {[0m
      | [0;1;32m                 ^
[0m[1mdebug.c:3503:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3503 |         else if (w != NULL) {[0m
      | [0;1;32m             ^
[0m[1mdebug.c:3509:6: [0m[0;1;36mnote: [0mAssuming field 'print_frame' is false[0m
 3509 |         if (stop.print_frame) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~
[0m[1mdebug.c:3509:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3509 |         if (stop.print_frame) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3515:9: [0m[0;1;36mnote: [0mCalling 'print_lines'[0m
 3515 |         (void) print_lines(source, sourceline, 1);[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:542:6: [0m[0;1;36mnote: [0m's' is not equal to NULL[0m
  542 |         if (s == NULL)[0m
      | [0;1;32m            ^
[0m[1mdebug.c:542:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  542 |         if (s == NULL)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:544:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  544 |         if (s->fd <= INVALID_HANDLE && (s->fd = srcopen(s)) <= INVALID_HANDLE) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:544:30: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  544 |         if (s->fd <= INVALID_HANDLE && (s->fd = srcopen(s)) <= INVALID_HANDLE) {[0m
      | [0;1;32m                                    ^
[0m[1mdebug.c:550:31: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
  550 |         if (fstat(s->fd, &sbuf) == 0 && s->mtime < sbuf.st_mtime) {[0m
      | [0;1;32m                                     ^
[0m[1mdebug.c:570:6: [0m[0;1;36mnote: [0mAssuming field 'line_offset' is equal to NULL[0m
  570 |         if (s->line_offset == NULL && find_lines(s) != 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:570:6: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mdebug.c:570:32: [0m[0;1;36mnote: [0mCalling 'find_lines'[0m
  570 |         if (s->line_offset == NULL && find_lines(s) != 0)[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~
[0m[1mdebug.c:449:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  449 |         while ((n = read(s->fd, buf, s->bufsize)) > 0) {[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:449:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  449 |         while ((n = read(s->fd, buf, s->bufsize)) > 0) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:453:10: [0m[0;1;36mnote: [0m'p' is < 'end'[0m
  453 |                 while (p < end) {[0m
      | [0;1;32m                       ^
[0m[1mdebug.c:453:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  453 |                 while (p < end) {[0m
      | [0;1;32m                ^
[0m[1mdebug.c:454:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  454 |                         if (*p++ == '\n') {[0m
      | [0;1;32m                            ^~~~~~~~~~~~
[0m[1mdebug.c:454:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  454 |                         if (*p++ == '\n') {[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:455:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  455 |                                 if (++numlines > pos_size) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:455:5: [0m[0;1;36mnote: [0mTaking true branch[0m
  455 |                                 if (++numlines > pos_size) {[0m
      | [0;1;32m                                ^
[0m[1mdebug.c:460:6: [0m[0;1;36mnote: [0mNull pointer value stored to 'pos'[0m
  460 |                                 *++pos = ofs + (p - buf);[0m
      | [0;1;32m                                 ^~~~~
[0m[1mdebug.c:460:12: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  460 |                                 *++pos = ofs + (p - buf);[0m
      | [0;1;32m                                ~~~~~~~^~~~~~~~~~~~~~~~~
[0m[1mdebug.c:461:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  461 |                                 if ((pos[0] - pos[-1]) > maxlen)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  462 |                                         maxlen = pos[0] - pos[-1];      /* length including NEWLINE */[0m
      | [0;1;32m                                                                                                      
[0m[1mdebug.c:475:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  475 |                 fprintf(out_fp, _("source file `%s' is empty.\n"), s->src);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:475:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  475 |                 fprintf(out_fp, _("source file `%s' is empty.\n"), s->src);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:483:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  483 |                 if ((pos[0] - pos[-1]) > maxlen)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  484 |                         maxlen = pos[0] - pos[-1];[0m
      | [0;1;32m                                                  
[0m[1mdebug.c:506:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  506 |         if (cur_srcfile->src == src)  /* strcmp(cur_srcfile->src, src) == 0 */[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  507 |                 return cur_srcfile;[0m
      | [0;1;32m                                   
[0m[1mdebug.c:511:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  511 |                                 && strcmp(s->src, src) == 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  512 |                         return s;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:542:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  542 |         if (s == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  543 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mdebug.c:551:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  551 |                 fprintf(out_fp, _("warning: source file `%s' modified since program compilation.\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:551:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  551 |                 fprintf(out_fp, _("warning: source file `%s' modified since program compilation.\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:570:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  570 |         if (s->line_offset == NULL && find_lines(s) != 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  571 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mdebug.c:579:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  579 |         if ((start_line + nlines - 1) > s->srclines)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m  580 |                 nlines = s->srclines - start_line + 1;[0m
      | [0;1;32m                                                      
[0m[1mdebug.c:600:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  600 |                 sprintf(linebuf, "%-8d", i);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:600:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  600 |                 sprintf(linebuf, "%-8d", i);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:615:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  615 |                                 if (has_bpt)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  616 |                                         sprintf(linebuf, "%-4d:b=>", i);[0m
  617 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:616:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  616 |                                         sprintf(linebuf, "%-4d:b=>", i);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:616:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  616 |                                         sprintf(linebuf, "%-4d:b=>", i);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:617:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  617 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  618 |                                         sprintf(linebuf, "%-4d  =>", i);[0m
      | [0;1;32m                                                                        
[0m[1mdebug.c:618:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  618 |                                         sprintf(linebuf, "%-4d  =>", i);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:618:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  618 |                                         sprintf(linebuf, "%-4d  =>", i);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:619:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  619 |                         } else if (has_bpt)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  620 |                                 sprintf(linebuf, "%-4d:b  ", i);[0m
      | [0;1;32m                                                                
[0m[1mdebug.c:620:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  620 |                                 sprintf(linebuf, "%-4d:b  ", i);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:620:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  620 |                                 sprintf(linebuf, "%-4d:b  ", i);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:628:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  628 |                         d_error(_("cannot read source file `%s': %s"),[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  629 |                                                 src, strerror(errno));[0m
  630 |                         return -1;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mdebug.c:633:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  633 |                         d_error(_("unexpected eof while reading file `%s', line %d"),[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  634 |                                                 src, i);[0m
  635 |                         return -1;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mdebug.c:638:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  638 |                         if (i == s->srclines && p[len - 1] != '\n')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  639 |                                 p[len++] = '\n';[0m
  640 | #if 0[0m
  641 |                         if (len != supposed_len || p[len - 1] != '\n') {[0m
  642 |                                 d_error(_("source file `%s' modified since start of program execution"),[0m
  643 |                                                 src);[0m
  644 |                                 return -1;[0m
  645 |                         }[0m
  646 | #endif[0m
  647 |                         len += (p - linebuf);[0m
  648 |                         if (fwrite(linebuf, sizeof(char), len, out_fp) != len)[0m
  649 |                                 return -1;[0m
      | [0;1;32m                                         
[0m      | [0;32m                                         ;} 
[0m[1mdebug.c:638:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  638 |                         if (i == s->srclines && p[len - 1] != '\n')[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  639 |                                 p[len++] = '\n';[0m
      | [0;1;32m                                                
[0m[1mdebug.c:648:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  648 |                         if (fwrite(linebuf, sizeof(char), len, out_fp) != len)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  649 |                                 return -1;[0m
      | [0;1;32m                                          
[0m[1mdebug.c:674:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  674 |         if (arg == NULL)        /* list or list + */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  675 |                 goto list;[0m
      | [0;1;32m                          
[0m[1mdebug.c:679:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  679 |                 if (arg->a_int < 0) {           /* list - */[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  680 |                         line_first = last_printed_line - last_print_count - list_size + 1;[0m
  681 |                         if (line_first < 1) {[0m
  682 |                                 if (last_printed_line != last_print_count)[0m
  683 |                                         line_first = 1;[0m
  684 |                                 else[0m
  685 |                                         return false;[0m
  686 |                         }[0m
  687 |                 } else {[0m
  688 | line:[0m
  689 |                         line_first = arg->a_int - list_size / 2;[0m
  690 |                         if (line_first < 1)[0m
  691 |                                 line_first = 1;[0m
  692 |                 }[0m
  693 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:682:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  682 |                                 if (last_printed_line != last_print_count)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m  683 |                                         line_first = 1;[0m
  684 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:684:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  684 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  685 |                                         return false;[0m
      | [0;1;32m                                                     
[0m[1mdebug.c:690:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  690 |                         if (line_first < 1)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  691 |                                 line_first = 1;[0m
      | [0;1;32m                                               
[0m[1mdebug.c:696:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  696 | range:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m  697 |                 line_first = arg->a_int;[0m
  698 |                 arg = arg->next;[0m
  699 |                 assert(arg != NULL);[0m
  700 |                 assert(arg->type == D_int);[0m
  701 |                 count = arg->a_int - line_first + 1;[0m
  702 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:705:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  705 |                 src = arg->a_string;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  706 |                 if (arg->next != NULL) {[0m
  707 |                         arg = arg->next;[0m
  708 |                         if (arg->type == D_int) /* list file:n */[0m
  709 |                                 goto line;[0m
  710 |                         else if (arg->type == D_range)  /* list file:m-n */[0m
  711 |                                 goto range;[0m
  712 |                         else if (arg->type == D_func)   /* list file:function */[0m
  713 |                                 goto func;[0m
  714 |                         else[0m
  715 |                                 line_first = 1;[0m
  716 |                 } else[0m
  717 |                         line_first = 1;[0m
  718 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:708:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  708 |                         if (arg->type == D_int) /* list file:n */[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  709 |                                 goto line;[0m
  710 |                         else if (arg->type == D_range)  /* list file:m-n */[0m
      | [0;32m                        } 
[0m[1mdebug.c:710:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  710 |                         else if (arg->type == D_range)  /* list file:m-n */[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  711 |                                 goto range;[0m
  712 |                         else if (arg->type == D_func)   /* list file:function */[0m
      | [0;32m                        } 
[0m[1mdebug.c:712:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  712 |                         else if (arg->type == D_func)   /* list file:function */[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  713 |                                 goto func;[0m
  714 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:714:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  714 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  715 |                                 line_first = 1;[0m
      | [0;1;32m                                               
[0m[1mdebug.c:716:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  716 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  717 |                         line_first = 1;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:721:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  721 | func:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m  722 |                 rp = arg->a_node->code_ptr;[0m
  723 |                 src = rp->source_file;[0m
  724 |                 line_first = rp->source_line - list_size / 2;[0m
  725 |                 if (line_first < 1)[0m
  726 |                         line_first = 1;[0m
  727 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:725:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  725 |                 if (line_first < 1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  726 |                         line_first = 1;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:730:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  730 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:749:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  749 |         if (arg == NULL || arg->type != D_argument)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  750 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:754:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  754 |                 fprintf(out_fp, _("Current source file: %s\n"), cur_srcfile->src);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:754:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  754 |                 fprintf(out_fp, _("Current source file: %s\n"), cur_srcfile->src);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:754:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  754 |                 fprintf(out_fp, _("Current source file: %s\n"), cur_srcfile->src);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  755 |                 fprintf(out_fp, _("Number of lines: %d\n"), cur_srcfile->srclines);[0m
  756 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:755:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  755 |                 fprintf(out_fp, _("Number of lines: %d\n"), cur_srcfile->srclines);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:755:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  755 |                 fprintf(out_fp, _("Number of lines: %d\n"), cur_srcfile->srclines);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:759:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  759 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m  760 |                 SRCFILE *s;[0m
  761 |                 for (s = srcfiles->next; s != srcfiles; s = s->next) {[0m
  762 |                         fprintf(out_fp, _("Source file (lines): %s (%d)\n"),[0m
  763 |                                         (s->stype == SRC_FILE || s->stype == SRC_INC) ? s->src[0m
  764 |                                                                               : "cmd. line",[0m
  765 |                                         s->srclines);[0m
  766 |                 }[0m
  767 |         }[0m
  768 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:762:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  762 |                         fprintf(out_fp, _("Source file (lines): %s (%d)\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:762:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  762 |                         fprintf(out_fp, _("Source file (lines): %s (%d)\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:771:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  771 |                 initialize_pager(out_fp);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:779:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  779 |                                 if ((b->flags & BP_ENABLE_ONCE) != 0)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  780 |                                         disp = "dis";[0m
  781 |                                 else if ((b->flags & BP_TEMP) != 0)[0m
      | [0;32m                                } 
[0m[1mdebug.c:781:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  781 |                                 else if ((b->flags & BP_TEMP) != 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  782 |                                         disp = "del";[0m
      | [0;1;32m                                                     
[0m[1mdebug.c:786:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  786 |                                 if (b->hit_count > 0)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  787 |                                         gprintf(out_fp, _("\tnumber of hits = %ld\n"), b->hit_count);[0m
      | [0;1;32m                                                                                                     
[0m[1mdebug.c:788:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  788 |                                 if ((b->flags & BP_IGNORE) != 0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  789 |                                         gprintf(out_fp, _("\tignore next %ld hit(s)\n"), b->ignore_count);[0m
      | [0;1;32m                                                                                                          
[0m[1mdebug.c:790:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  790 |                                 if (b->cndn.code != NULL)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  791 |                                         gprintf(out_fp, _("\tstop condition: %s\n"), b->cndn.expr);[0m
      | [0;1;32m                                                                                                   
[0m[1mdebug.c:792:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  792 |                                 if (b->commands.next != &b->commands)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  793 |                                         gprintf(out_fp, _("\tcommands:\n"));[0m
      | [0;1;32m                                                                            
[0m[1mdebug.c:801:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  801 |                                                 if (start == NULL || end == NULL)[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m  802 |                                                         continue;[0m
      | [0;1;32m                                                                 
[0m[1mdebug.c:814:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  814 |                 CHECK_PROG_RUNNING();[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  815 |                 fprintf(out_fp, _("Current frame: "));[0m
  816 |                 print_numbered_frame(cur_frame);[0m
  817 |                 if (cur_frame < fcall_count) {[0m
  818 |                         fprintf(out_fp, _("Called by frame: "));[0m
  819 |                         print_numbered_frame(cur_frame + 1);[0m
  820 |                 }[0m
  821 |                 if (cur_frame > 0) {[0m
  822 |                         fprintf(out_fp, _("Caller of frame: "));[0m
  823 |                         print_numbered_frame(cur_frame - 1);[0m
  824 |                 }[0m
  825 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:356:2: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_PROG_RUNNING'[0m
  356 |         do { \[0m
      | [0;1;32m        ^
[0m[1mdebug.c:815:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  815 |                 fprintf(out_fp, _("Current frame: "));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:815:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  815 |                 fprintf(out_fp, _("Current frame: "));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:818:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  818 |                         fprintf(out_fp, _("Called by frame: "));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:818:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  818 |                         fprintf(out_fp, _("Called by frame: "));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:822:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  822 |                         fprintf(out_fp, _("Caller of frame: "));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:822:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  822 |                         fprintf(out_fp, _("Caller of frame: "));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:840:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  840 |                         fprintf(out_fp, _("None in main().\n"));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:840:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  840 |                         fprintf(out_fp, _("None in main().\n"));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:849:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  849 |                 if (arg_count > pcount)                /* extra args */[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  850 |                         arg_count = pcount;[0m
      | [0;1;32m                                           
[0m[1mdebug.c:862:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  862 |                         if (r->type == Node_array_ref)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  863 |                                 r = r->orig_array;[0m
      | [0;1;32m                                                  
[0m[1mdebug.c:864:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  864 |                         fprintf(out_fp, "%s = ", func->fparms[i].param);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:864:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  864 |                         fprintf(out_fp, "%s = ", func->fparms[i].param);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:867:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  867 |                 if (to < from)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  868 |                         fprintf(out_fp, "%s",[0m
  869 |                                 arg->a_argument == A_ARGS ?[0m
  870 |                                         _("No arguments.\n") :[0m
  871 |                                         _("No locals.\n"));[0m
      | [0;1;32m                                                           
[0m[1mdebug.c:868:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  868 |                         fprintf(out_fp, "%s",[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:868:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  868 |                         fprintf(out_fp, "%s",[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:873:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  873 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:876:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  876 |                 table = variable_list();[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  877 |                 initialize_pager(out_fp);[0m
  878 |                 if (setjmp(pager_quit_tag) == 0) {[0m
  879 |                         gprintf(out_fp, _("All defined variables:\n\n"));[0m
  880 |                         print_vars(table, gprintf, out_fp);[0m
  881 |                 }[0m
  882 |                 efree(table);[0m
  883 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:886:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  886 |                 table = function_list(true);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  887 |                 initialize_pager(out_fp);[0m
  888 |                 if (setjmp(pager_quit_tag) == 0) {[0m
  889 |                         gprintf(out_fp, _("All defined functions:\n\n"));[0m
  890 |                         pf_data.print_func = gprintf;[0m
  891 |                         pf_data.fp = out_fp;[0m
  892 |                         pf_data.defn = true;[0m
  893 |                         (void) foreach_func(table,[0m
  894 |                                     (int (*)(INSTRUCTION *, void *)) print_function,[0m
  895 |                                     &pf_data);[0m
  896 |                 }[0m
  897 |                 efree(table);[0m
  898 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:903:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  903 |                 if (setjmp(pager_quit_tag) == 0) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:926:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  926 |                                 } else if (IS_FIELD(d))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  927 |                                         gprintf(out_fp, "%d:\t$%ld\n", d->number, get_number_si(symbol));[0m
  928 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:928:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  928 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  929 |                                         gprintf(out_fp, "%d:\t%s\n", d->number, d->sname);[0m
      | [0;1;32m                                                                                          
[0m[1mdebug.c:930:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  930 |                                 if (d->cndn.code != NULL)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  931 |                                         gprintf(out_fp, _("\tstop condition: %s\n"), d->cndn.expr);[0m
      | [0;1;32m                                                                                                   
[0m[1mdebug.c:932:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  932 |                                 if (d->commands.next != &d->commands)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  933 |                                         gprintf(out_fp, _("\tcommands:\n"));[0m
      | [0;1;32m                                                                            
[0m[1mdebug.c:941:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  941 |                                                 if (start == NULL || end == NULL)[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m  942 |                                                         continue;[0m
      | [0;1;32m                                                                 
[0m[1mdebug.c:955:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  955 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:968:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  968 |                 fprintf(out_fp, "untyped variable\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:968:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  968 |                 fprintf(out_fp, "untyped variable\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:968:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  968 |                 fprintf(out_fp, "untyped variable\n");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  969 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:971:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  971 |                 fprintf(out_fp, "untyped element\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:971:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  971 |                 fprintf(out_fp, "untyped element\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:971:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  971 |                 fprintf(out_fp, "untyped element\n");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  972 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:974:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  974 |                 if (! isparam && r->var_update)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  975 |                         r->var_update();[0m
  976 |                 valinfo(r->var_value, fprintf, out_fp);[0m
  977 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:974:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  974 |                 if (! isparam && r->var_update)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  975 |                         r->var_update();[0m
      | [0;1;32m                                        
[0m[1mdebug.c:979:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  979 |                 fprintf(out_fp, "array, %ld elements\n", (long) assoc_length(r));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:979:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  979 |                 fprintf(out_fp, "array, %ld elements\n", (long) assoc_length(r));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:979:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  979 |                 fprintf(out_fp, "array, %ld elements\n", (long) assoc_length(r));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  980 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:982:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  982 |                 fprintf(out_fp, "`function'\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:982:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  982 |                 fprintf(out_fp, "`function'\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:982:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  982 |                 fprintf(out_fp, "`function'\n");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m  983 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:985:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  985 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:995:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  995 |         if (num == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  996 |                 return frame_ptr;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:1013:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1013 |         if (pname)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1014 |                 *pname = NULL;[0m
      | [0;1;32m                              
[0m[1mdebug.c:1016:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1016 |         if (num < 0 || num > fcall_count || name == NULL)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1017 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:1029:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1029 |                                 if (r->type == Node_array_ref)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1030 |                                         r = r->orig_array;[0m
      | [0;1;32m                                                          
[0m[1mdebug.c:1031:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1031 |                                 if (pname)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1032 |                                         *pname = fparam;[0m
      | [0;1;32m                                                        
[0m[1mdebug.c:1047:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1047 |         if (pname)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1048 |                 *pname = NULL;[0m
      | [0;1;32m                              
[0m[1mdebug.c:1049:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1049 |         if (prog_running)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1050 |                 r = find_param(name, cur_frame, pname);[0m
      | [0;1;32m                                                       
[0m[1mdebug.c:1051:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1051 |         if (r == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1052 |                 r = lookup(name); // for now, require fully qualified name[0m
      | [0;1;32m                                                                          
[0m[1mdebug.c:1053:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1053 |         if (r == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1054 |                 fprintf(out_fp, _("no symbol `%s' in current context\n"), name);[0m
      | [0;1;32m                                                                                
[0m[1mdebug.c:1054:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1054 |                 fprintf(out_fp, _("no symbol `%s' in current context\n"), name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1054:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1054 |                 fprintf(out_fp, _("no symbol `%s' in current context\n"), name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1066:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1066 |                 fprintf(out_fp, _("`%s' is not an array\n"), name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1066:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1066 |                 fprintf(out_fp, _("`%s' is not an array\n"), name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1079:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1079 |         if (*lhs == Null_field || *lhs == Nnull_string)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1080 |                 fprintf(out_fp, _("$%ld = uninitialized field\n"), field_num);[0m
 1081 |         else {[0m
      | [0;32m        } 
[0m[1mdebug.c:1080:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1080 |                 fprintf(out_fp, _("$%ld = uninitialized field\n"), field_num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1080:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1080 |                 fprintf(out_fp, _("$%ld = uninitialized field\n"), field_num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1082:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1082 |                 fprintf(out_fp, "$%ld = ", field_num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1082:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1082 |                 fprintf(out_fp, "$%ld = ", field_num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1110:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1110 |         PUSH_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:349:2: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_BINDING'[0m
  349 |         memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:1110:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1110 |         PUSH_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:349:2: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_BINDING'[0m
  349 |         memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:1115:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1115 |                         if (r->type == Node_var_array)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1116 |                                 ret = print_array(r, r->vname);[0m
 1117 |                         else {[0m
      | [0;32m                        } 
[0m[1mdebug.c:1122:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1122 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1123 |                 ret = 1;[0m
      | [0;1;32m                        
[0m[1mdebug.c:1125:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1125 |         POP_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:352:2: [0m[0;1;36mnote: [0mexpanded from macro 'POP_BINDING'[0m
  352 |         memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:1125:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1125 |         POP_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:352:2: [0m[0;1;36mnote: [0mexpanded from macro 'POP_BINDING'[0m
  352 |         memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:1127:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1127 |         for (i = 0; i < num_elems; i++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1128 |                 unref(list[i]);[0m
      | [0;1;32m                               
[0m[1mdebug.c:1143:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1143 |         if (r == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1144 |                 fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"), (int) subs->stlen, subs->stptr, arr_name);[0m
 1145 |         else if (r->type == Node_var_array) {[0m
      | [0;32m        } 
[0m[1mdebug.c:1144:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1144 |                 fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"), (int) subs->stlen, subs->stptr, arr_name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1144:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1144 |                 fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"), (int) subs->stlen, subs->stptr, arr_name);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1146:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1146 |                 if (count > 1)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1147 |                         print_subscript(r, r->vname, a->next, count - 1);[0m
 1148 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:1150:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1150 |                         fprintf(out_fp, "%s = ", r->vname);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1150:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1150 |                         fprintf(out_fp, "%s = ", r->vname);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1154:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1154 |                 fprintf(out_fp, "%s[\"%.*s\"] = ", arr_name, (int) subs->stlen, subs->stptr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1154:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1154 |                 fprintf(out_fp, "%s[\"%.*s\"] = ", arr_name, (int) subs->stlen, subs->stptr);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1171:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1171 |                         name = a->a_string;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1172 |                         if ((r = find_symbol(name, &pname)) != NULL) {[0m
 1173 |                                 fprintf(out_fp, "%s = ", name);[0m
 1174 |                                 print_symbol(r, (pname != NULL));[0m
 1175 |                         }[0m
 1176 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:1173:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1173 |                                 fprintf(out_fp, "%s = ", name);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1173:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1173 |                                 fprintf(out_fp, "%s = ", name);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1182:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1182 |                         if (r != NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1183 |                                 print_subscript(r, name, a->next, a->a_count);[0m
      | [0;1;32m                                                                              
[0m[1mdebug.c:1187:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1187 |                         name = a->a_string;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mdebug.c:1196:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1196 |                                                 fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"),[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mdebug.c:1196:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1196 |                                                 fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"),[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mdebug.c:1200:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1200 |                                                 fprintf(out_fp, _("`%s[\"%.*s\"]' is not an array\n"),[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mdebug.c:1200:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1200 |                                                 fprintf(out_fp, _("`%s[\"%.*s\"]' is not an array\n"),[0m
      | [0;1;32m                                                ^~~~~~~
[0m[1mdebug.c:1216:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1216 |                         print_field(get_number_si(a->a_node));[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1217 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:1221:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1221 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mdebug.c:1238:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1238 |                 name = arg->a_string;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:1242:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1242 |                 if ((r = find_symbol(name, &pname)) == NULL)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1243 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:1249:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1249 |                         r->var_value = dupnode(Nnull_string);[0m
      | [0;1;32m                        ^                                   
[0m      | [0;32m                        {                                   ;} 
[0m[1mdebug.c:1252:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1252 |                         lhs = &r->var_value;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1253 |                         unref(*lhs);[0m
 1254 |                         *lhs = dupnode(val);[0m
 1255 |                         if (pname == NULL && r->var_assign != NULL)[0m
 1256 |                                 r->var_assign();[0m
 1257 |                         fprintf(out_fp, "%s = ", name);[0m
 1258 |                         print_symbol(r, (pname != NULL));[0m
 1259 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:1255:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1255 |                         if (pname == NULL && r->var_assign != NULL)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 1256 |                                 r->var_assign();[0m
      | [0;1;32m                                                
[0m[1mdebug.c:1257:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1257 |                         fprintf(out_fp, "%s = ", name);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1257:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1257 |                         fprintf(out_fp, "%s = ", name);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1262:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1262 |                         d_error(_("`%s' is not a scalar variable"), name);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1263 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:1268:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1268 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mdebug.c:1276:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1276 |                 if (r == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1277 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:1284:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1284 |                                 if (value != NULL && value->type == Node_var_array)[0m
      | [0;1;32m                                                                                   ^
[0m      | [0;32m                                                                                    {
[0m 1285 |                                         d_error(_("attempt to use array `%s[\"%.*s\"]' in a scalar context"),[0m
 1286 |                                                                 name, (int) subs->stlen, subs->stptr);[0m
 1287 |                                 else {[0m
      | [0;32m                                } 
[0m[1mdebug.c:1294:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1294 |                                         fprintf(out_fp, "%s[\"%.*s\"] = ", name, (int) subs->stlen, subs->stptr);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:1294:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1294 |                                         fprintf(out_fp, "%s[\"%.*s\"] = ", name, (int) subs->stlen, subs->stptr);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:1321:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1321 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mdebug.c:1330:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1330 |                 if (assign)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1331 |                         /* call assign to copy fields before unref frees $0 */[0m
 1332 |                         assign();[0m
      | [0;1;32m                                 
[0m[1mdebug.c:1340:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1340 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:1352:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1352 |         if (num <= 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1353 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:1355:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1355 |                 if (d->number == num)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1356 |                         return d;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:1370:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1370 |                 for (i = 0; i < d->num_subs; i++)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1371 |                         unref(d->subs[i]);[0m
      | [0;1;32m                                          
[0m[1mdebug.c:1373:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1373 |         } else if (IS_FIELD(d))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1374 |                 unref(d->symbol);[0m
      | [0;1;32m                                 
[0m[1mdebug.c:1376:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1376 |         if ((d->flags & CUR_IS_ARRAY) == 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1377 |                 unref(d->cur_value);[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1378:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1378 |         if ((d->flags & OLD_IS_ARRAY) == 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1379 |                 unref(d->old_value);[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1388:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1388 |         if (d->cndn.expr != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1389 |                 efree(d->cndn.expr);[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1448:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1448 |                 if ((symbol = find_symbol(name, &pname)) == NULL)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:1448:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1448 |                 if ((symbol = find_symbol(name, &pname)) == NULL)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 1449 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1478:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1478 |                 symbol = dupnode(arg->a_node);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1479 |                 item = add_item(list, D_field, symbol, NULL);[0m
 1480 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:1483:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1483 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:1490:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1490 |                         if (parse_condition(D_watch, item->number, arg->a_string) == 0)[0m
      | [0;1;32m                                                                                       ^
[0m      | [0;32m                                                                                        {
[0m 1491 |                                 arg->a_string = NULL;   /* don't let free_cmdarg free it */[0m
 1492 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:1492:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1492 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1493 |                                 fprintf(out_fp, _("watchpoint %d is unconditional\n"), item->number);[0m
      | [0;1;32m                                                                                                     
[0m[1mdebug.c:1493:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1493 |                                 fprintf(out_fp, _("watchpoint %d is unconditional\n"), item->number);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1493:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1493 |                                 fprintf(out_fp, _("watchpoint %d is unconditional\n"), item->number);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1505:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1505 |                 while (list->next != list)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1506 |                         delete_item(list->next);[0m
      | [0;1;32m                                                
[0m[1mdebug.c:1517:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1517 |                         if (j > list->number)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1518 |                                 j = list->number;[0m
      | [0;1;32m                                                 
[0m[1mdebug.c:1520:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1520 |                                 if ((d = find_item(list, i)) != NULL)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1521 |                                         delete_item(d);[0m
      | [0;1;32m                                                       
[0m[1mdebug.c:1526:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1526 |                                 if (list == &display_list)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1527 |                                         d_error(_("no display item numbered %ld"),[0m
 1528 |                                                 arg->a_int);[0m
 1529 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:1529:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1529 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1530 |                                         d_error(_("no watch item numbered %ld"),[0m
 1531 |                                                 arg->a_int);[0m
      | [0;1;32m                                                            
[0m[1mdebug.c:1532:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1532 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1533 |                                 delete_item(d);[0m
      | [0;1;32m                                               
[0m[1mdebug.c:1546:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1546 |         if (IS_PARAM(d) && (d->fcall_count != (fcall_count - cur_frame)))[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 1547 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:1556:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1556 |                                 fprintf(out_fp, _("%d: subscript \"%.*s\" is not in array `%s'\n"),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1556:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1556 |                                 fprintf(out_fp, _("%d: subscript \"%.*s\" is not in array `%s'\n"),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1562:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1562 |                                 if (i == count - 1)     /* it's a sub-array */[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1563 |                                         goto print_sym;         /* print # of elements in sub-array */[0m
      | [0;1;32m                                                                                                      
[0m[1mdebug.c:1565:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1565 |                                 if (i != count - 1)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1566 |                                         return;         /* FIXME msg and delete item ? */[0m
      | [0;1;32m                                                                                         
[0m[1mdebug.c:1567:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1567 |                                 fprintf(out_fp, "%d: %s[\"%.*s\"] = ", d->number,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1567:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1567 |                                 fprintf(out_fp, "%d: %s[\"%.*s\"] = ", d->number,[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:1574:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1574 |                 fprintf(out_fp, "%d: ", d->number);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1574:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1574 |                 fprintf(out_fp, "%d: ", d->number);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1578:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1578 |                 fprintf(out_fp, "%d: %s = ", d->number, d->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1578:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1578 |                 fprintf(out_fp, "%d: %s = ", d->number, d->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1593:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1593 |                 for (d = display_list.prev; d != &display_list; d = d->prev)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 1594 |                         display(d);[0m
      | [0;1;32m                                   
[0m[1mdebug.c:1598:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1598 |         if ((d = do_add_item(&display_list, arg)) != NULL)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1599 |                 display(d);[0m
      | [0;1;32m                           
[0m[1mdebug.c:1622:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1622 |         if (cndn->code == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1623 |                 return true;[0m
      | [0;1;32m                            
[0m[1mdebug.c:1628:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1628 |         if (r == NULL)      /* fatal error */[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1629 |                 return false;   /* not triggered */[0m
      | [0;1;32m                                                   
[0m[1mdebug.c:1649:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1649 |                 if (r == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1650 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:1651:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1651 |                 if (r->type == Node_var_array)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1652 |                         symbol = r;[0m
 1653 |                 else if (i < count - 1)[0m
      | [0;32m                } 
[0m[1mdebug.c:1653:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1653 |                 else if (i < count - 1)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1654 |                         return -1;[0m
      | [0;1;32m                                  
[0m[1mdebug.c:1656:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1656 |         if (r != NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1657 |                 *ptr = r;[0m
      | [0;1;32m                         
[0m[1mdebug.c:1682:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1682 |                 if (! new)              /* 9 */[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1683 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1684:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1684 |                 if (new->type == Node_val)      /* 7 */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1685 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1688:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1688 |                 if (w->cur_size == size)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1689 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mdebug.c:1693:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1693 |         if (! old && ! new)     /* 3 */[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1694 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:1696:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1696 |                         || (old && ! new))      /* 6 */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1697 |                 return true;[0m
      | [0;1;32m                            
[0m[1mdebug.c:1699:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1699 |         if (new->type == Node_var_array)        /* 5 */[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1700 |                 return true;[0m
      | [0;1;32m                            
[0m[1mdebug.c:1715:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1715 |         if (IS_PARAM(w) && (w->fcall_count != (fcall_count - cur_frame)))[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 1716 |                 return 0; /* parameter with same name in a different function */[0m
      | [0;1;32m                                                                                
[0m[1mdebug.c:1717:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1717 |         if (! condition_triggered(&w->cndn))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1718 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mdebug.c:1722:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1722 |         if (IS_SUBSCRIPT(w))[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1723 |                 (void) find_subscript(w, &t2);[0m
 1724 |         else if (IS_FIELD(w)) {[0m
      | [0;32m        } 
[0m[1mdebug.c:1731:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1731 |                         t2 = symbol->var_value;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1732 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:1734:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1734 |                         t2 = symbol;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1735 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:1740:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1740 |                         cant_happen("unexpected symbol type %s", nodetype2str(symbol->type));[0m
      | [0;1;32m                        ^                                                                   
[0m      | [0;32m                        {                                                                   ;} 
[0m[1m./awk.h:1379:34: [0m[0;1;36mnote: [0mexpanded from macro 'cant_happen'[0m
 1379 | #define cant_happen(format, ...)        r_fatal("internal error: file %s, line %d: " format, \[0m
      | [0;1;32m                                        ^
[0m[1mdebug.c:1744:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1744 |         if (! cmp_val(w, t1, t2))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1745 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mdebug.c:1749:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1749 |         if ((w->flags & OLD_IS_ARRAY) == 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1750 |                 unref(w->old_value);[0m
      | [0;1;32m                                    
[0m[1mdebug.c:1761:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1761 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1762 |                         w->cur_size = (t2->type == Node_var_array) ? assoc_length(t2) : 0;[0m
      | [0;1;32m                                                                                          
[0m[1mdebug.c:1766:7: [0m[0;1;35mwarning: [0m[1mAccess to field 'type' results in a dereference of a null pointer (loaded from variable 't2') [clang-analyzer-core.NullDereference][0m
 1766 |                 if (t2->type == Node_val)[0m
      | [0;1;32m                    ^
[0m[1mdebug.c:3620:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3620 |         if (! in_main_context())[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3620:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3620 |         if (! in_main_context())[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3628:6: [0m[0;1;36mnote: [0mAssuming 'do_trace' is 0[0m
 3628 |         if (do_trace[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mdebug.c:3629:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3629 |                 && cur_pc->opcode != Op_breakpoint[0m
      | [0;1;32m                ^
[0m[1mdebug.c:3640:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 3676[0m
 3640 |         switch (cur_pc->opcode) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3677:7: [0m[0;1;36mnote: [0mAssuming field 'source_line' is > 0[0m
 3677 |                 if (cur_pc->source_line <= 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3677:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3677 |                 if (cur_pc->source_line <= 0)[0m
      | [0;1;32m                ^
[0m[1mdebug.c:3679:3: [0m[0;1;36mnote: [0m Execution continues on line 3682[0m
 3679 |                 break;[0m
      | [0;1;32m                ^
[0m[1mdebug.c:3682:6: [0m[0;1;36mnote: [0m'cant_stop' is false[0m
 3682 |         if (cant_stop)[0m
      | [0;1;32m            ^~~~~~~~~
[0m[1mdebug.c:3682:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3682 |         if (cant_stop)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3694:6: [0m[0;1;36mnote: [0mCalling 'check_watchpoint'[0m
 3694 |         if (check_watchpoint()) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:2880:6: [0m[0;1;36mnote: [0mAssuming field 'command' is not equal to D_return[0m
 2880 |         if (stop.command == D_return)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:2880:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2880 |         if (stop.command == D_return)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2882:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 2882 |         for (w = watch_list.prev; w != &watch_list; w = w->prev) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2883:14: [0m[0;1;36mnote: [0mCalling 'watchpoint_triggered'[0m
 2883 |                 int wnum = watchpoint_triggered(w);[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1715:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1715 |         if (IS_PARAM(w) && (w->fcall_count != (fcall_count - cur_frame)))[0m
      | [0;1;32m            ^
[0m[1mdebug.c:161:22: [0m[0;1;36mnote: [0mexpanded from macro 'IS_PARAM'[0m
  161 | #define IS_PARAM(d)     (((d)->flags & PARAM) != 0)[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1715:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1715 |         if (IS_PARAM(w) && (w->fcall_count != (fcall_count - cur_frame)))[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:1717:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1717 |         if (! condition_triggered(&w->cndn))[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1717:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1717 |         if (! condition_triggered(&w->cndn))[0m
      | [0;1;32m        ^
[0m[1mdebug.c:1721:2: [0m[0;1;36mnote: [0mNull pointer value stored to 't2'[0m
 1721 |         t2 = (NODE *) 0;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~
[0m[1mdebug.c:1722:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1722 |         if (IS_SUBSCRIPT(w))[0m
      | [0;1;32m            ^
[0m[1mdebug.c:162:26: [0m[0;1;36mnote: [0mexpanded from macro 'IS_SUBSCRIPT'[0m
  162 | #define IS_SUBSCRIPT(d) (((d)->flags & SUBSCRIPT) != 0)[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1722:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1722 |         if (IS_SUBSCRIPT(w))[0m
      | [0;1;32m        ^
[0m[1mdebug.c:1724:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1724 |         else if (IS_FIELD(w)) {[0m
      | [0;1;32m                 ^
[0m[1mdebug.c:163:22: [0m[0;1;36mnote: [0mexpanded from macro 'IS_FIELD'[0m
  163 | #define IS_FIELD(d)     (((d)->flags & FIELD_NUM) != 0)[0m
      | [0;1;32m                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1724:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 1724 |         else if (IS_FIELD(w)) {[0m
      | [0;1;32m             ^
[0m[1mdebug.c:1729:3: [0m[0;1;36mnote: [0mControl jumps to 'case Node_var_new:'  at line 1736[0m
 1729 |                 switch (symbol->type) {[0m
      | [0;1;32m                ^
[0m[1mdebug.c:1738:4: [0m[0;1;36mnote: [0m Execution continues on line 1744[0m
 1738 |                         break;[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:1744:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1744 |         if (! cmp_val(w, t1, t2))[0m
      | [0;1;32m        ^
[0m[1mdebug.c:1749:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1749 |         if ((w->flags & OLD_IS_ARRAY) == 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1749:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1749 |         if ((w->flags & OLD_IS_ARRAY) == 0)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:1752:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1752 |         if (WATCHING_ARRAY(w)) {        /* 7, 8, 9 */[0m
      | [0;1;32m            ^
[0m[1mdebug.c:164:28: [0m[0;1;36mnote: [0mexpanded from macro 'WATCHING_ARRAY'[0m
  164 | #define WATCHING_ARRAY(d)       (((d)->flags & CUR_IS_ARRAY) != 0)[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:1752:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1752 |         if (WATCHING_ARRAY(w)) {        /* 7, 8, 9 */[0m
      | [0;1;32m        ^
[0m[1mdebug.c:1763:13: [0m[0;1;36mnote: [0mAssuming 't1' is null[0m
 1763 |         } else if (! t1) { /* 1, 2 */[0m
      | [0;1;32m                   ^~~~
[0m[1mdebug.c:1763:9: [0m[0;1;36mnote: [0mTaking true branch[0m
 1763 |         } else if (! t1) { /* 1, 2 */[0m
      | [0;1;32m               ^
[0m[1mdebug.c:1766:7: [0m[0;1;36mnote: [0mAccess to field 'type' results in a dereference of a null pointer (loaded from variable 't2')[0m
 1766 |                 if (t2->type == Node_val)[0m
      | [0;1;32m                    ^~
[0m[1mdebug.c:1766:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1766 |                 if (t2->type == Node_val)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1767 |                         w->cur_value = dupnode(t2);[0m
 1768 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:1774:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1774 |                 if (! t2)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1775 |                         w->cur_value = 0;[0m
 1776 |                 else if (t2->type == Node_var_array) {[0m
      | [0;32m                } 
[0m[1mdebug.c:1779:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1779 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1780 |                         w->cur_value = dupnode(t2);[0m
      | [0;1;32m                                                   
[0m[1mdebug.c:1800:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1800 |                 if (r == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1801 |                         w->cur_value = (NODE *) 0;[0m
 1802 |                 else if (r->type == Node_var_array) { /* it's a sub-array */[0m
      | [0;32m                } 
[0m[1mdebug.c:1805:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1805 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1806 |                         w->cur_value = dupnode(r);[0m
      | [0;1;32m                                                  
[0m[1mdebug.c:1814:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1814 |                 if (symbol->type == Node_var_new || symbol->type == Node_elem_new)[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 1815 |                         w->cur_value = (NODE *) 0;[0m
 1816 |                 else if (symbol->type == Node_var) {[0m
      | [0;32m                } 
[0m[1mdebug.c:1840:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1840 |         if (w == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1841 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:1848:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1848 |         fprintf(out_fp, "Watchpoint %d: ", w->number);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:1848:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1848 |         fprintf(out_fp, "Watchpoint %d: ", w->number);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:1853:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1853 |                 fprintf(out_fp, "%s", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1853:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1853 |                 fprintf(out_fp, "%s", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1856:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1856 |                         fprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1856:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1856 |                         fprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1858:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1858 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1858:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1858 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1859:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1859 |         } else if (IS_FIELD(w))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1860 |                 fprintf(out_fp, "$%ld\n", get_number_si(symbol));[0m
 1861 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:1860:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1860 |                 fprintf(out_fp, "$%ld\n", get_number_si(symbol));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1860:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1860 |                 fprintf(out_fp, "$%ld\n", get_number_si(symbol));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1861:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1861 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1862 |                 fprintf(out_fp, "%s\n", w->sname);[0m
      | [0;1;32m                                                  
[0m[1mdebug.c:1862:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1862 |                 fprintf(out_fp, "%s\n", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1862:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1862 |                 fprintf(out_fp, "%s\n", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1886:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1886 |                         fprintf(out_fp,[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1886:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1886 |                         fprintf(out_fp,[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1897:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1897 |                         fprintf(out_fp,[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1897:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1897 |                         fprintf(out_fp,[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:1926:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1926 |                 if (i < pcount - 1)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1927 |                         print_func(fp, ", ");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:1930:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1930 |         if (defn)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1931 |                 print_func(fp, _(" in file `%s', line %d\n"),[0m
 1932 |                                 pc->source_file, pc->source_line);[0m
      | [0;1;32m                                                                  
[0m[1mdebug.c:1944:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1944 |         if (func == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1945 |                 fprintf(out_fp, "main()");[0m
 1946 |         else {[0m
      | [0;32m        } 
[0m[1mdebug.c:1945:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1945 |                 fprintf(out_fp, "main()");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1945:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1945 |                 fprintf(out_fp, "main()");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1952:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1952 |         fprintf(out_fp, _(" at `%s':%d"), src, srcline);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:1952:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1952 |         fprintf(out_fp, _(" at `%s':%d"), src, srcline);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:1965:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1965 |                 fprintf(out_fp, "#%ld\t ", num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1965:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1965 |                 fprintf(out_fp, "#%ld\t ", num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1968:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1968 |                 fprintf(out_fp, _("#%ld\tin "), num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1968:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1968 |                 fprintf(out_fp, _("#%ld\tin "), num);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:1972:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1972 |         fprintf(out_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:1972:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1972 |         fprintf(out_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:1991:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1991 |                         if (last > fcall_count)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1992 |                                  last = fcall_count;[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:1996:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1996 |                         if (cur < 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1997 |                                 cur = 0;[0m
      | [0;1;32m                                        
[0m[1mdebug.c:2004:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2004 |         if (cur <= fcall_count)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2005 |                 fprintf(out_fp, _("More stack frames follow ...\n"));[0m
      | [0;1;32m                                                                     
[0m[1mdebug.c:2005:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2005 |                 fprintf(out_fp, _("More stack frames follow ...\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2005:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2005 |                 fprintf(out_fp, _("More stack frames follow ...\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2031:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2031 |         fprintf(out_fp, (cur_frame > 0 ? _("#%ld\tin ") : "#%ld\t "), cur_frame);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2031:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2031 |         fprintf(out_fp, (cur_frame > 0 ? _("#%ld\tin ") : "#%ld\t "), cur_frame);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2033:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2033 |         fprintf(out_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2033:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2033 |         fprintf(out_fp, "\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2036:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2036 |         if (last_printed_line < 0)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2037 |                 last_printed_line = 0;[0m
      | [0;1;32m                                      
[0m[1mdebug.c:2063:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2063 |         if (arg != NULL && arg->type == D_int)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 2064 |                 cur_frame += arg->a_int;[0m
 2065 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:2065:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2065 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2066 |                 cur_frame++;[0m
      | [0;1;32m                            
[0m[1mdebug.c:2067:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2067 |         if (cur_frame < 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2068 |                 cur_frame = 0;[0m
 2069 |         else if (cur_frame > fcall_count)[0m
      | [0;32m        } 
[0m[1mdebug.c:2069:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2069 |         else if (cur_frame > fcall_count)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2070 |                 cur_frame = fcall_count;[0m
      | [0;1;32m                                        
[0m[1mdebug.c:2081:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2081 |         if (arg != NULL && arg->type == D_int)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 2082 |                 cur_frame -= arg->a_int;[0m
 2083 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:2083:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2083 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2084 |                 cur_frame--;[0m
      | [0;1;32m                            
[0m[1mdebug.c:2085:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2085 |         if (cur_frame < 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2086 |                 cur_frame = 0;[0m
 2087 |         else if (cur_frame > fcall_count)[0m
      | [0;32m        } 
[0m[1mdebug.c:2087:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2087 |         else if (cur_frame > fcall_count)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2088 |                 cur_frame = fcall_count;[0m
      | [0;1;32m                                        
[0m[1mdebug.c:2109:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2109 |                         if ((rp - 1)->source_file == src && (rp - 1)->source_line > 0)[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m 2110 |                                 return (rp - 1);[0m
      | [0;1;32m                                                
[0m[1mdebug.c:2116:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2116 |                                         && lineno <= (rp + 1)->last_line)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 2117 |                                 return (rp - 1);[0m
      | [0;1;32m                                                
[0m[1mdebug.c:2135:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2135 |         memset(&b->cndn, 0, sizeof(struct condition));[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:2135:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 2135 |         memset(&b->cndn, 0, sizeof(struct condition));[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:2182:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2182 |         if (b->cndn.expr != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2183 |                 efree(b->cndn.expr);[0m
      | [0;1;32m                                    
[0m[1mdebug.c:2198:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2198 |         if (num <= 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2199 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:2202:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2202 |                 if (b->number == num)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2203 |                         return b;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:2229:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2229 |                                 if ((b->flags & BP_IGNORE) != 0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 2230 |                                         fprintf(out_fp,[0m
 2231 |                         _("Note: breakpoint %d (enabled, ignore next %ld hits), also set at %s:%d"),[0m
 2232 |                                                 b->number,[0m
 2233 |                                                 b->ignore_count,[0m
 2234 |                                                 b->src,[0m
 2235 |                                                 lineno);[0m
 2236 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:2230:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2230 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2230:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2230 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2236:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2236 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2237 |                                         fprintf(out_fp,[0m
 2238 |                         _("Note: breakpoint %d (enabled), also set at %s:%d"),[0m
 2239 |                                                 b->number,[0m
 2240 |                                                 b->src,[0m
 2241 |                                                 lineno);[0m
      | [0;1;32m                                                        
[0m[1mdebug.c:2237:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2237 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2237:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2237 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2243:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2243 |                                 if ((b->flags & BP_IGNORE) != 0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 2244 |                                         fprintf(out_fp,[0m
 2245 |                         _("Note: breakpoint %d (disabled, ignore next %ld hits), also set at %s:%d"),[0m
 2246 |                                                 b->number,[0m
 2247 |                                                 b->ignore_count,[0m
 2248 |                                                 b->src,[0m
 2249 |                                                 lineno);[0m
 2250 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:2244:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2244 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2244:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2244 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2250:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2250 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2251 |                                         fprintf(out_fp,[0m
 2252 |                         _("Note: breakpoint %d (disabled), also set at %s:%d"),[0m
 2253 |                                                 b->number,[0m
 2254 |                                                 b->src,[0m
 2255 |                                                 lineno);[0m
      | [0;1;32m                                                        
[0m[1mdebug.c:2251:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2251 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2251:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2251 |                                         fprintf(out_fp,[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2268:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2268 |         if (! silent)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2269 |                 fprintf(out_fp, _("Breakpoint %d set at file `%s', line %d\n"),[0m
 2270 |                                                 b->number, src, lineno);[0m
      | [0;1;32m                                                                        
[0m[1mdebug.c:2269:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2269 |                 fprintf(out_fp, _("Breakpoint %d set at file `%s', line %d\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2269:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2269 |                 fprintf(out_fp, _("Breakpoint %d set at file `%s', line %d\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2292:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2292 |                                 if (i1->source_line >= lineno)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2293 |                                         return add_breakpoint(i2, i1, rp->source_file, silent);[0m
      | [0;1;32m                                                                                               
[0m[1mdebug.c:2294:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2294 |                                 if (i1 == ip->stmt_end)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2295 |                                         break;[0m
      | [0;1;32m                                              
[0m[1mdebug.c:2299:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2299 |                 if (ip->source_line >= lineno)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 2300 |                         return add_breakpoint(prevp, ip, rp->source_file, silent);[0m
      | [0;1;32m                                                                                  
[0m[1mdebug.c:2301:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2301 |                 if (ip == (rp + 1)->lasti)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 2302 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:2314:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2314 |         if (ip == (rp + 1)->lasti)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2315 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:2317:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2317 |         if (ip->opcode != Op_breakpoint)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2318 |                 ip = ip->nexti;[0m
      | [0;1;32m                               
[0m[1mdebug.c:2320:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2320 |                 if (ip->source_line > 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2321 |                         return add_breakpoint(prevp, ip, rp->source_file, false);[0m
      | [0;1;32m                                                                                 
[0m[1mdebug.c:2322:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2322 |                 if (ip == (rp + 1)->lasti)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 2323 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:2370:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2370 |                 if ((b = set_breakpoint_next(rp, ip)) == NULL)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2371 |                         fprintf(out_fp, _("cannot set breakpoint in file `%s'\n"), src);[0m
 2372 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:2371:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2371 |                         fprintf(out_fp, _("cannot set breakpoint in file `%s'\n"), src);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2371:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2371 |                         fprintf(out_fp, _("cannot set breakpoint in file `%s'\n"), src);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2377:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2377 |                         if (temporary)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2378 |                                 b->flags |= BP_TEMP;[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:2387:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2387 |                 s = source_find(arg->a_string);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:2390:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2390 |                                 || (arg->type != D_int && arg->type != D_func))[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 2391 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mdebug.c:2393:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2393 |                 if (arg->type == D_func) /* break filename:function */[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2394 |                         goto func;[0m
 2395 |                 else[0m
      | [0;32m                } 
[0m[1mdebug.c:2395:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2395 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2396 |                         /* fall through */[0m
 2397 |         case D_int:             /* break lineno */[0m
 2398 |                 lineno = (int) arg->a_int;[0m
      | [0;1;32m                                          
[0m[1mdebug.c:2399:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2399 |                 if (lineno <= 0 || lineno > s->srclines)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2400 |                         d_error(_("line number %d in file `%s' is out of range"), lineno, src);[0m
 2401 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:2403:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2403 |                         if (rp == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2404 |                                 fprintf(out_fp, _("internal error: cannot find rule\n"));[0m
      | [0;1;32m                                                                                         
[0m[1mdebug.c:2404:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2404 |                                 fprintf(out_fp, _("internal error: cannot find rule\n"));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2404:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2404 |                                 fprintf(out_fp, _("internal error: cannot find rule\n"));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2405:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2405 |                         if (rp == NULL || (b = set_breakpoint_at(rp, lineno, false)) == NULL)[0m
      | [0;1;32m                                                                                             ^
[0m      | [0;32m                                                                                              {
[0m 2406 |                                 fprintf(out_fp, _("cannot set breakpoint at `%s':%d\n"),[0m
 2407 |                                                 src, lineno);[0m
      | [0;1;32m                                                             
[0m[1mdebug.c:2406:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2406 |                                 fprintf(out_fp, _("cannot set breakpoint at `%s':%d\n"),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2406:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2406 |                                 fprintf(out_fp, _("cannot set breakpoint at `%s':%d\n"),[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2408:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2408 |                         if (b != NULL && temporary)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2409 |                                 b->flags |= BP_TEMP;[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:2414:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2414 | func:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m 2415 |                 func = arg->a_node;[0m
 2416 |                 rp = func->code_ptr;[0m
 2417 |                 if ((b = set_breakpoint_at(rp, rp->source_line, false)) == NULL)[0m
 2418 |                         fprintf(out_fp, _("cannot set breakpoint in function `%s'\n"),[0m
 2419 |                                                 func->vname);[0m
 2420 |                 else {[0m
 2421 |                         if (temporary)[0m
 2422 |                                 b->flags |= BP_TEMP;[0m
 2423 |                         lineno = b->bpi->source_line;[0m
 2424 |                 }[0m
 2425 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:2417:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2417 |                 if ((b = set_breakpoint_at(rp, rp->source_line, false)) == NULL)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 2418 |                         fprintf(out_fp, _("cannot set breakpoint in function `%s'\n"),[0m
 2419 |                                                 func->vname);[0m
 2420 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:2418:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2418 |                         fprintf(out_fp, _("cannot set breakpoint in function `%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2418:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2418 |                         fprintf(out_fp, _("cannot set breakpoint in function `%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2421:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2421 |                         if (temporary)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2422 |                                 b->flags |= BP_TEMP;[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:2428:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2428 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mdebug.c:2433:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2433 |                 if (parse_condition(D_break, b->number, arg->a_string) == 0)[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 2434 |                         arg->a_string = NULL;   /* don't let free_cmdarg free it */[0m
 2435 |                 else[0m
      | [0;32m                } 
[0m[1mdebug.c:2435:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2435 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2436 |                         fprintf(out_fp, _("breakpoint %d set at file `%s', line %d is unconditional\n"),[0m
 2437 |                                                         b->number, src, lineno);[0m
      | [0;1;32m                                                                                
[0m[1mdebug.c:2436:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2436 |                         fprintf(out_fp, _("breakpoint %d set at file `%s', line %d is unconditional\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2436:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2436 |                         fprintf(out_fp, _("breakpoint %d set at file `%s', line %d is unconditional\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2448:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2448 |         if ((b->flags & BP_ENABLE) == 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2449 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mdebug.c:2451:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2451 |                 if (--b->ignore_count <= 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2452 |                         b->flags &= ~BP_IGNORE;[0m
      | [0;1;32m                                               
[0m[1mdebug.c:2456:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2456 |         if (! condition_triggered(&b->cndn))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2457 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mdebug.c:2512:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2512 |                 s = source_find(arg->a_string);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 2513 |                 arg = arg->next;[0m
 2514 |                 if (s == NULL || arg == NULL ||[0m
 2515 |                                 (arg->type != D_int && arg->type != D_func))[0m
 2516 |                         return false;[0m
 2517 |                 src = s->src;[0m
 2518 |                 if (arg->type == D_func)[0m
 2519 |                         goto func;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mdebug.c:2515:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2515 |                                 (arg->type != D_int && arg->type != D_func))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 2516 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mdebug.c:2518:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2518 |                 if (arg->type == D_func)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2519 |                         goto func;[0m
      | [0;1;32m                                  
[0m[1mdebug.c:2522:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2522 |                 lineno = (int) arg->a_int;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 2523 |                 if (lineno <= 0 || lineno > s->srclines) {[0m
 2524 |                         d_error(_("line number %d in file `%s' out of range"), lineno, src);[0m
 2525 |                         return false;[0m
 2526 |                 }[0m
 2527 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:2530:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2530 | func:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m[1mdebug.c:2534:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2534 |                         if (ip->source_line <= 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2535 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mdebug.c:2536:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2536 |                         if (ip->opcode != Op_breakpoint)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2537 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mdebug.c:2539:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2539 |                         if (++bp_found == 1)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2540 |                                 fprintf(out_fp, _("Deleted breakpoint %d"), b->number);[0m
 2541 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:2540:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2540 |                                 fprintf(out_fp, _("Deleted breakpoint %d"), b->number);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2540:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2540 |                                 fprintf(out_fp, _("Deleted breakpoint %d"), b->number);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2541:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2541 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2542 |                                 fprintf(out_fp, ", %d", b->number);[0m
      | [0;1;32m                                                                   
[0m[1mdebug.c:2542:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2542 |                                 fprintf(out_fp, ", %d", b->number);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2542:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2542 |                                 fprintf(out_fp, ", %d", b->number);[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2545:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2545 |                 if (bp_found == 0)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2546 |                         fprintf(out_fp, _("No breakpoint(s) at entry to function `%s'\n"),[0m
 2547 |                                         func->vname);[0m
 2548 |                 else[0m
      | [0;32m                } 
[0m[1mdebug.c:2546:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2546 |                         fprintf(out_fp, _("No breakpoint(s) at entry to function `%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2546:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2546 |                         fprintf(out_fp, _("No breakpoint(s) at entry to function `%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2548:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2548 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2549 |                         fprintf(out_fp, "\n");[0m
      | [0;1;32m                                              
[0m[1mdebug.c:2549:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2549 |                         fprintf(out_fp, "\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2549:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2549 |                         fprintf(out_fp, "\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2552:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2552 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mdebug.c:2561:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2561 |                                 if (++bp_found == 1)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2562 |                                         fprintf(out_fp, _("Deleted breakpoint %d"), b->number);[0m
 2563 |                                 else[0m
      | [0;32m                                } 
[0m[1mdebug.c:2562:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2562 |                                         fprintf(out_fp, _("Deleted breakpoint %d"), b->number);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2562:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2562 |                                         fprintf(out_fp, _("Deleted breakpoint %d"), b->number);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2563:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2563 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2564 |                                         fprintf(out_fp, ", %d", b->number);[0m
      | [0;1;32m                                                                           
[0m[1mdebug.c:2564:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2564 |                                         fprintf(out_fp, ", %d", b->number);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2564:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2564 |                                         fprintf(out_fp, ", %d", b->number);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:2567:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2567 |                         if (ip == (rp + 1)->lasti)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 2568 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mdebug.c:2572:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2572 |         if (bp_found == 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2573 |                 fprintf(out_fp, _("No breakpoint at file `%s', line #%d\n"),[0m
 2574 |                                         src, (int) lineno);[0m
 2575 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:2573:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2573 |                 fprintf(out_fp, _("No breakpoint at file `%s', line #%d\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2573:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2573 |                 fprintf(out_fp, _("No breakpoint at file `%s', line #%d\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2575:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2575 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2576 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                                      
[0m[1mdebug.c:2576:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2576 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2576:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2576 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2587:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2587 |         if (disp)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 2588 |                 b->flags |= disp;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:2600:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2600 |                 if (arg->a_argument == A_DEL)   /* del */[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 2601 |                         disp = BP_TEMP;[0m
 2602 |                 else                                            /* once */[0m
      | [0;32m                } 
[0m[1mdebug.c:2602:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2602 |                 else                                            /* once */[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2603 |                         disp = BP_ENABLE_ONCE;[0m
      | [0;1;32m                                              
[0m[1mdebug.c:2608:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2608 |                 for (b = breakpoints.next; b != &breakpoints; b = b->next)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 2609 |                         enable_breakpoint(b, disp);[0m
      | [0;1;32m                                                   
[0m[1mdebug.c:2619:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2619 |                         if (j > breakpoints.number)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2620 |                                 j = breakpoints.number;[0m
      | [0;1;32m                                                       
[0m[1mdebug.c:2622:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2622 |                                 if ((b = find_breakpoint(i)) != NULL)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 2623 |                                         enable_breakpoint(b, disp);[0m
      | [0;1;32m                                                                   
[0m[1mdebug.c:2627:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2627 |                         if ((b = find_breakpoint(arg->a_int)) == NULL)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2628 |                                 d_error(_("invalid breakpoint number"));[0m
 2629 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:2629:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2629 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2630 |                                 enable_breakpoint(b, disp);[0m
      | [0;1;32m                                                           
[0m[1mdebug.c:2648:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2648 |                         while (breakpoints.next != &breakpoints)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 2649 |                                 delete_breakpoint(breakpoints.next);[0m
      | [0;1;32m                                                                    
[0m[1mdebug.c:2661:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2661 |                         if (j > breakpoints.number)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2662 |                                 j = breakpoints.number;[0m
      | [0;1;32m                                                       
[0m[1mdebug.c:2664:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2664 |                                 if ((b = find_breakpoint(i)) != NULL)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 2665 |                                         delete_breakpoint(b);[0m
      | [0;1;32m                                                             
[0m[1mdebug.c:2668:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2668 |                         if ((b = find_breakpoint(arg->a_int)) == NULL)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2669 |                                 d_error(_("invalid breakpoint number"));[0m
 2670 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:2670:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2670 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2671 |                                 delete_breakpoint(b);[0m
      | [0;1;32m                                                     
[0m[1mdebug.c:2685:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2685 |                         || arg->next == NULL || arg->next->type != D_int)[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 2686 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:2688:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2688 |         if ((b = find_breakpoint(arg->a_int)) == NULL)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 2689 |                 d_error(_("invalid breakpoint number"));[0m
 2690 |         else {[0m
      | [0;32m        } 
[0m[1mdebug.c:2694:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2694 |                         fprintf(out_fp, _("Will ignore next %ld crossing(s) of breakpoint %d.\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2694:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2694 |                         fprintf(out_fp, _("Will ignore next %ld crossing(s) of breakpoint %d.\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2698:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2698 |                         fprintf(out_fp, _("Will stop next time breakpoint %d is reached.\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2698:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2698 |                         fprintf(out_fp, _("Will stop next time breakpoint %d is reached.\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2714:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2714 |                 for (b = breakpoints.next; b != &breakpoints; b = b->next)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 2715 |                         b->flags &= ~BP_ENABLE;[0m
      | [0;1;32m                                               
[0m[1mdebug.c:2725:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2725 |                         if (j > breakpoints.number)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2726 |                                 j = breakpoints.number;[0m
      | [0;1;32m                                                       
[0m[1mdebug.c:2727:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2727 |                         for (; i <= j; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2728 |                                 if ((b = find_breakpoint(i)) != NULL)[0m
 2729 |                                         b->flags &= ~BP_ENABLE;[0m
      | [0;1;32m                                                               
[0m[1mdebug.c:2728:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2728 |                                 if ((b = find_breakpoint(i)) != NULL)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 2729 |                                         b->flags &= ~BP_ENABLE;[0m
      | [0;1;32m                                                               
[0m[1mdebug.c:2731:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2731 |                         if ((b = find_breakpoint(arg->a_int)) == NULL)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2732 |                                 d_error(_("invalid breakpoint number"));[0m
 2733 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:2733:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2733 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2734 |                                 b->flags &= ~BP_ENABLE;[0m
      | [0;1;32m                                                       
[0m[1mdebug.c:2749:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2749 |         if (! prog_running)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2750 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:2796:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2796 |         if (os_isatty(input_fd))[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 2797 |                 input_from_tty = true;[0m
      | [0;1;32m                                      
[0m[1mdebug.c:2798:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2798 |         if (input_fd == 0 && input_from_tty)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2799 |                 initialize_readline();[0m
      | [0;1;32m                                      
[0m[1mdebug.c:2801:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2801 |         if (! read_a_line)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2802 |                 read_a_line = g_readline;[0m
      | [0;1;32m                                         
[0m[1mdebug.c:2810:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2810 |                         || cur_srcfile->stype == SRC_INC)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 2811 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:2815:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2815 |                 fprintf(out_fp, _("Can only debug programs provided with the `-f' option.\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2815:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2815 |                 fprintf(out_fp, _("Can only debug programs provided with the `-f' option.\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2822:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2822 |         memset(&stop, 0, sizeof(stop));[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:2822:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 2822 |         memset(&stop, 0, sizeof(stop));[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:2835:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2835 |                 fprintf(out_fp, _("Restarting ...\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2835:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2835 |                 fprintf(out_fp, _("Restarting ...\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:2836:7: [0m[0;1;35mwarning: [0m[1muse of invalidated pointer 'run' in a function call [clang-analyzer-security.cert.env.InvalidPtr][0m
 2836 |                 if (strcasecmp(run, "true") == 0)[0m
      | [0;1;32m                    ^          ~~~
[0m[1mdebug.c:2796:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 2796 |         if (os_isatty(input_fd))[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:2796:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2796 |         if (os_isatty(input_fd))[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2798:6: [0m[0;1;36mnote: [0mAssuming 'input_fd' is not equal to 0[0m
 2798 |         if (input_fd == 0 && input_from_tty)[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mdebug.c:2798:20: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 2798 |         if (input_fd == 0 && input_from_tty)[0m
      | [0;1;32m                          ^
[0m[1mdebug.c:2801:6: [0m[0;1;36mnote: [0mAssuming 'read_a_line' is non-null[0m
 2801 |         if (! read_a_line)[0m
      | [0;1;32m            ^~~~~~~~~~~~~
[0m[1mdebug.c:2801:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2801 |         if (! read_a_line)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2807:37: [0m[0;1;36mnote: [0mAssuming 'cur_srcfile' is not equal to 'srcfiles'[0m
 2807 |         for (cur_srcfile = srcfiles->prev; cur_srcfile != srcfiles;[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:2807:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 2807 |         for (cur_srcfile = srcfiles->prev; cur_srcfile != srcfiles;[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2809:7: [0m[0;1;36mnote: [0mAssuming field 'stype' is equal to SRC_FILE[0m
 2809 |                 if (cur_srcfile->stype == SRC_FILE[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:2810:4: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 2810 |                         || cur_srcfile->stype == SRC_INC)[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:2811:4: [0m[0;1;36mnote: [0m Execution continues on line 2814[0m
 2811 |                         break;[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:2814:6: [0m[0;1;36mnote: [0m'cur_srcfile' is not equal to 'srcfiles'[0m
 2814 |         if (cur_srcfile == srcfiles) {[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1mdebug.c:2814:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 2814 |         if (cur_srcfile == srcfiles) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2825:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 2825 |         if ((run = getenv("DGAWK_RESTART")) != NULL) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:2834:3: [0m[0;1;36mnote: [0m'unsetenv' call may invalidate the environment returned by 'getenv'[0m
 2834 |                 unsetenv("DGAWK_RESTART");[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:2836:7: [0m[0;1;36mnote: [0muse of invalidated pointer 'run' in a function call[0m
 2836 |                 if (strcasecmp(run, "true") == 0)[0m
      | [0;1;32m                    ^          ~~~
[0m[1mdebug.c:2836:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2836 |                 if (strcasecmp(run, "true") == 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2837 |                         (void) do_run(NULL, 0);[0m
      | [0;1;32m                                               
[0m[1mdebug.c:2844:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2844 |                         fprintf(stderr, _("cannot open source file `%s' for reading: %s"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2844:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2844 |                         fprintf(stderr, _("cannot open source file `%s' for reading: %s"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2861:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2861 |                 if (fd > INVALID_HANDLE)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2862 |                         push_cmd_src(fd, false, g_readline, close, 0, EXIT_SUCCESS);[0m
      | [0;1;32m                                                                                    
[0m[1mdebug.c:2880:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2880 |         if (stop.command == D_return)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2881 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:2901:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2901 |         if (stop.command == D_return)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2902 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:2940:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2940 |         fprintf(out_fp, _("Failed to restart debugger"));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2940:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2940 |         fprintf(out_fp, _("Failed to restart debugger"));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2950:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2950 |                 if (! input_from_tty)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2951 |                         need_restart = true;    /* handled later */[0m
 2952 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:2958:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2958 |                                 fprintf(out_fp, _("Program not restarted\n"));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2958:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2958 |                                 fprintf(out_fp, _("Program not restarted\n"));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:2968:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2968 |                         fprintf(stderr, _("error: cannot restart, operation not allowed\n"));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2968:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2968 |                         fprintf(stderr, _("error: cannot restart, operation not allowed\n"));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2974:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2974 |                         fprintf(out_fp, _("error (%s): cannot restart, ignoring rest of the commands\n"), cmd_src->str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2974:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2974 |                         fprintf(out_fp, _("error (%s): cannot restart, ignoring rest of the commands\n"), cmd_src->str);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:2982:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2982 |         fprintf(out_fp, _("Starting program:\n"));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2982:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2982 |         fprintf(out_fp, _("Starting program:\n"));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2986:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2986 |         if (setjmp(fatal_tag) == 0)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2987 |                 (void) interpret(code_block);[0m
      | [0;1;32m                                             
[0m[1mdebug.c:2991:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2991 |         fprintf(out_fp, (! exiting && exit_val != EXIT_SUCCESS)[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:2991:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2991 |         fprintf(out_fp, (! exiting && exit_val != EXIT_SUCCESS)[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3005:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3005 |         if (prog_running)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 3006 |                 terminate = prompt_yes_no([0m
 3007 |                             _("The program is running. Exit anyway (y/n)? "),[0m
 3008 |                             _("y")[0], true, out_fp);[0m
      | [0;1;32m                                                     
[0m[1mdebug.c:3017:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3017 |                         if (ret == 0 && history_length > history_size)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 3018 |                                 (void) history_truncate_file(history_file, history_size);[0m
      | [0;1;32m                                                                                         
[0m[1mdebug.c:3021:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3021 |                 if (do_save_options && input_from_tty)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3022 |                         save_options(options_file);[0m
      | [0;1;32m                                                   
[0m[1mdebug.c:3037:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3037 |         if (! arg || arg->type != D_int)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3038 |                 return true;[0m
      | [0;1;32m                            
[0m[1mdebug.c:3042:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3042 |                 fprintf(out_fp, _("Not stopped at any breakpoint; argument ignored.\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3042:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3042 |                 fprintf(out_fp, _("Not stopped at any breakpoint; argument ignored.\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3052:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3052 |         fprintf(out_fp, _("Will ignore next %ld crossings of breakpoint %d.\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3052:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3052 |         fprintf(out_fp, _("Will ignore next %ld crossings of breakpoint %d.\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3063:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3063 |         if (arg != NULL && arg->type == D_int)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 3064 |                 stop.repeat_count = arg->a_int;[0m
 3065 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:3065:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3065 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 3066 |                 stop.repeat_count = 1;[0m
      | [0;1;32m                                      
[0m[1mdebug.c:3128:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3128 |         if (ret)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 3129 |                 stop.check_func = check_stepi;[0m
      | [0;1;32m                                              
[0m[1mdebug.c:3238:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3238 |                 fprintf(out_fp,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3238:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3238 |                 fprintf(out_fp,[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3244:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3244 |         fprintf(out_fp, _("Run until return from "));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3244:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3244 |         fprintf(out_fp, _("Run until return from "));[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3287:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3287 |                 fprintf(out_fp, _("'return' not meaningful in the outermost frame main()\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3287:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3287 |                 fprintf(out_fp, _("'return' not meaningful in the outermost frame main()\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3299:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3299 |         if (arg != NULL && arg->type == D_node) /* optional return value */[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 3300 |                 n = dupnode(arg->a_node);[0m
 3301 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:3301:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3301 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 3302 |                 n = dupnode(Nnull_string);[0m
      | [0;1;32m                                          
[0m[1mdebug.c:3317:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3317 |                 if (stop.pc && *pi == stop.pc)          /* until location */[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 3318 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:3321:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3321 |                                 && sourceline > stop.sourceline)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 3322 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:3369:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3369 |                 s = source_find(arg->a_string);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3370 |                 arg = arg->next;[0m
 3371 |                 if (s == NULL || arg == NULL[0m
 3372 |                                 || (arg->type != D_int && arg->type != D_func))[0m
 3373 |                         return false;[0m
 3374 |                 src = s->src;[0m
 3375 |                 if (arg->type == D_func)[0m
 3376 |                         goto func;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mdebug.c:3372:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3372 |                                 || (arg->type != D_int && arg->type != D_func))[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 3373 |                         return false;[0m
      | [0;1;32m                                     
[0m[1mdebug.c:3375:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3375 |                 if (arg->type == D_func)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3376 |                         goto func;[0m
      | [0;1;32m                                  
[0m[1mdebug.c:3379:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3379 |                 lineno = arg->a_int;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3380 |                 if (lineno <= 0 || lineno > s->srclines) {[0m
 3381 |                         d_error(_("line number %d in file `%s' out of range"),[0m
 3382 |                                                 lineno, src);[0m
 3383 |                         return false;[0m
 3384 |                 }[0m
 3385 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3388:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3388 | func:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m 3389 |                 func = arg->a_node;[0m
 3390 |                 rp = func->code_ptr;[0m
 3391 |                 for (ip = rp->nexti; ip; ip = ip->nexti) {[0m
 3392 |                         if (ip->opcode != Op_breakpoint && ip->source_line > 0) {[0m
 3393 |                                 stop.pc = ip;[0m
 3394 |                                 stop.fcall_count = fcall_count - cur_frame;[0m
 3395 |                                 stop.check_func = check_until;[0m
 3396 |                                 stop.command = (enum argtype) cmd;[0m
 3397 |                                 return true;[0m
 3398 |                         }[0m
 3399 |                 }[0m
 3400 |                 fprintf(out_fp, _("cannot find specified location in function `%s'\n"),[0m
 3401 |                                 func->vname);[0m
      | [0;1;32m                                            
[0m      | [0;32m                                            ;} 
[0m[1mdebug.c:3400:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3400 |                 fprintf(out_fp, _("cannot find specified location in function `%s'\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3400:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3400 |                 fprintf(out_fp, _("cannot find specified location in function `%s'\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3404:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3404 |                 return false;[0m
      | [0;1;32m                ^           
[0m      | [0;32m                {           ;} 
[0m[1mdebug.c:3420:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3420 |                 if (ip == (rp + 1)->lasti)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 3421 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:3423:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3423 |         fprintf(out_fp, _("cannot find specified location %d in file `%s'\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3423:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3423 |         fprintf(out_fp, _("cannot find specified location %d in file `%s'\n"),[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3438:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3438 |                 fprintf(out_fp, "%s", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3438:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3438 |                 fprintf(out_fp, "%s", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3441:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3441 |                         fprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3441:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3441 |                         fprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3443:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3443 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3443:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3443 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3444:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3444 |         } else if (IS_FIELD(w))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3445 |                 fprintf(out_fp, "$%ld\n", get_number_si(symbol));[0m
 3446 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:3445:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3445 |                 fprintf(out_fp, "$%ld\n", get_number_si(symbol));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3445:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3445 |                 fprintf(out_fp, "$%ld\n", get_number_si(symbol));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3446:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3446 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 3447 |                 fprintf(out_fp, "%s\n", w->sname);[0m
      | [0;1;32m                                                  
[0m[1mdebug.c:3447:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3447 |                 fprintf(out_fp, "%s\n", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3447:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3447 |                 fprintf(out_fp, "%s\n", w->sname);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3459:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3459 |         fprintf(out_fp, "  Old value: ");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3459:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3459 |         fprintf(out_fp, "  Old value: ");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3460:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3460 |         print_value((w->flags & OLD_IS_ARRAY) != 0, old_size, old_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3454:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3454 |         fprintf(out_fp, IS_SUBSCRIPT(w) ?                               \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3460:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3460 |         print_value((w->flags & OLD_IS_ARRAY) != 0, old_size, old_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3454:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3454 |         fprintf(out_fp, IS_SUBSCRIPT(w) ?                               \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3460:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3460 |         print_value((w->flags & OLD_IS_ARRAY) != 0, old_size, old_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3452:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3452 |         fprintf(out_fp, "array, %ld elements\n", w->S);                 \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3460:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3460 |         print_value((w->flags & OLD_IS_ARRAY) != 0, old_size, old_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3452:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3452 |         fprintf(out_fp, "array, %ld elements\n", w->S);                 \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3461:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3461 |         fprintf(out_fp, "  New value: ");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3461:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3461 |         fprintf(out_fp, "  New value: ");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3462:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3462 |         print_value((w->flags & CUR_IS_ARRAY) != 0, cur_size, cur_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3454:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3454 |         fprintf(out_fp, IS_SUBSCRIPT(w) ?                               \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3462:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3462 |         print_value((w->flags & CUR_IS_ARRAY) != 0, cur_size, cur_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3454:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3454 |         fprintf(out_fp, IS_SUBSCRIPT(w) ?                               \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3462:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3462 |         print_value((w->flags & CUR_IS_ARRAY) != 0, cur_size, cur_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3452:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3452 |         fprintf(out_fp, "array, %ld elements\n", w->S);                 \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3462:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3462 |         print_value((w->flags & CUR_IS_ARRAY) != 0, cur_size, cur_value);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3452:2: [0m[0;1;36mnote: [0mexpanded from macro 'print_value'[0m
 3452 |         fprintf(out_fp, "array, %ld elements\n", w->S);                 \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mdebug.c:3488:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3488 |                 if (b->silent)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3489 |                         goto no_output;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:3492:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3492 |                 if (w->silent)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3493 |                         goto no_output;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:3497:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3497 |                 fprintf(out_fp, _("Stopping in %s ...\n"), ruletab[cur_rule]);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3497:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3497 |                 fprintf(out_fp, _("Stopping in %s ...\n"), ruletab[cur_rule]);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3501:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3501 |         if (b != NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3502 |                 fprintf(out_fp, "Breakpoint %d, ", b->number);[0m
 3503 |         else if (w != NULL) {[0m
      | [0;32m        } 
[0m[1mdebug.c:3502:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3502 |                 fprintf(out_fp, "Breakpoint %d, ", b->number);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3502:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3502 |                 fprintf(out_fp, "Breakpoint %d, ", b->number);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3504:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3504 |                 fprintf(out_fp, "Watchpoint %d: ", w->number);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3504:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3504 |                 fprintf(out_fp, "Watchpoint %d: ", w->number);[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3511:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3511 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3511:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3511 |                 fprintf(out_fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:3518:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3518 |         for (d = display_list.prev; d != &display_list; d = d->prev)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 3519 |                 display(d);[0m
      | [0;1;32m                           
[0m[1mdebug.c:3527:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3527 |         if (last_printed_line < 0)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3528 |                 last_printed_line = 0;[0m
      | [0;1;32m                                      
[0m[1mdebug.c:3546:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3546 |                 if ((b->flags & BP_TEMP) != 0)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 3547 |                         delete_breakpoint(b);[0m
      | [0;1;32m                                             
[0m[1mdebug.c:3548:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3548 |                 if (ret)        /* resume execution */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 3549 |                         return;[0m
      | [0;1;32m                               
[0m[1mdebug.c:3550:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3550 |         } else if (w != NULL && execute_commands(&w->commands))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3551 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:3561:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3561 |         if (! in_main_context())[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3562 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:3574:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3574 |                         fprintf(out_fp, _("'finish' not meaningful with non-local jump '%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3574:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3574 |                         fprintf(out_fp, _("'finish' not meaningful with non-local jump '%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3581:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3581 |                         fprintf(out_fp, _("'until' not meaningful with non-local jump '%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3581:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3581 |                         fprintf(out_fp, _("'until' not meaningful with non-local jump '%s'\n"),[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3584:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3584 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3587:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3587 |                 if (stop.command == D_finish[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3588 |                                 && fcall_count == stop.fcall_count[0m
 3589 |                                 && stop.print_ret[0m
 3590 |                 ) {[0m
 3591 |                         NODE *r;[0m
 3592 |                         /* print the returned value before it disappears. */[0m
 3593 |                         r = TOP();[0m
 3594 |                         fprintf(out_fp, "Returned value = ");[0m
 3595 |                         valinfo(r, fprintf, out_fp);[0m
 3596 |                         stop.print_ret = false;[0m
 3597 |                 }[0m
 3598 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3594:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3594 |                         fprintf(out_fp, "Returned value = ");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3594:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 3594 |                         fprintf(out_fp, "Returned value = ");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:3605:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3605 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3620:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3620 |         if (! in_main_context())[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3621 |                 return pre_execute_code(pi);[0m
      | [0;1;32m                                            
[0m[1mdebug.c:3631:3: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3631 |         )[0m
      | [0;1;32m         ^
[0m      | [0;32m          {
[0m 3632 |                 print_instruction(cur_pc, fprintf, out_fp, false);[0m
      | [0;1;32m                                                                  
[0m[1mdebug.c:3642:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3642 |                 cant_stop = true;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3643 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3646:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3646 |                 cant_stop = false;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3647 |                 return true; /* may stop at next instruction */[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mdebug.c:3650:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3650 |                 m = cur_pc->memory;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3651 |                 if (m->type == Node_var && m->var_assign)[0m
 3652 |                         cant_stop = true;[0m
 3653 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3651:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3651 |                 if (m->type == Node_var && m->var_assign)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3652 |                         cant_stop = true;[0m
      | [0;1;32m                                         
[0m[1mdebug.c:3656:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3656 |                 m = cur_pc->array_var;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3657 |                 if (m->type == Node_var && m->var_assign)[0m
 3658 |                         cant_stop = true;[0m
 3659 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3657:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3657 |                 if (m->type == Node_var && m->var_assign)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3658 |                         cant_stop = true;[0m
      | [0;1;32m                                         
[0m[1mdebug.c:3662:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3662 |                 cant_stop = false;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3663 |                 return true; /* may stop at next instruction */[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mdebug.c:3666:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3666 |                 cur_rule = cur_pc->in_rule;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3667 |                 return true;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mdebug.c:3674:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3674 |                 break;  /* processed later in check_breakpoint() */[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3677:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3677 |                 if (cur_pc->source_line <= 0)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3678 |                         return true;[0m
 3679 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3677:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3677 |                 if (cur_pc->source_line <= 0)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3678 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:3682:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3682 |         if (cant_stop)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3683 |                 return true;[0m
      | [0;1;32m                            
[0m[1mdebug.c:3696:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3696 |                 if (stop.command == D_return)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3697 |                         *pi = stop.pc;  /* jump to this instruction */[0m
 3698 |                 else if (cur_pc->opcode == Op_breakpoint)[0m
      | [0;32m                } 
[0m[1mdebug.c:3698:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3698 |                 else if (cur_pc->opcode == Op_breakpoint)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 3699 |                         cur_pc = cur_pc->nexti;    /* skip past the breakpoint instruction */[0m
      | [0;1;32m                                                                                             
[0m[1mdebug.c:3703:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3703 |                 if (stop.command == D_return)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3704 |                         *pi = stop.pc;  /* jump to this instruction */[0m
      | [0;1;32m                                                                      
[0m[1mdebug.c:3720:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3720 |                 if (m == Nnull_string)[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:3720:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3720 |                 if (m == Nnull_string)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3721 |                         print_func(fp, "Nnull_string");[0m
 3722 |                 else if ((m->flags & NUMBER) != 0) {[0m
      | [0;32m                } 
[0m[1mdebug.c:3731:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3731 |                 } else if ((m->flags & STRING) != 0)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 3732 |                         pp_string_fp(print_func, fp, m->stptr, m->stlen, '"', false);[0m
 3733 |                 else if ((m->flags & REGEX) != 0) {[0m
      | [0;32m                } 
[0m[1mdebug.c:3736:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3736 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3737 |                         print_func(fp, "-?-");[0m
      | [0;1;32m                                              
[0m[1mdebug.c:3742:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3742 |                 pp_string_fp(print_func, fp, m->re_exp->stptr, m->re_exp->stlen, '/', false);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3743 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3746:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3746 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3750:24: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3750 |                 print_func(fp, "%s", func->fparms[m->param_cnt].param);[0m
      | [0;1;32m                                     ^
[0m[1mdebug.c:3774:2: [0m[0;1;36mnote: [0m'func' initialized to a null pointer value[0m
 3774 |         static NODE *func = NULL;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3777:6: [0m[0;1;36mnote: [0m'noffset' is equal to 0[0m
 3777 |         if (noffset == 0) {[0m
      | [0;1;32m            ^~~~~~~
[0m[1mdebug.c:3777:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3777 |         if (noffset == 0) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3784:6: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_func[0m
 3784 |         if (pc->opcode == Op_func) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3784:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3784 |         if (pc->opcode == Op_func) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3797:13: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_rule[0m
 3797 |         } else if (pc->opcode == Op_rule) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3797:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 3797 |         } else if (pc->opcode == Op_rule) {[0m
      | [0;1;32m               ^
[0m[1mdebug.c:3802:6: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_newfile[0m
 3802 |         if (pc->opcode == Op_newfile)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3802:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3802 |         if (pc->opcode == Op_newfile)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3805:6: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
 3805 |         if (pc->source_line <= 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3805:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3805 |         if (pc->source_line <= 0)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3811:6: [0m[0;1;36mnote: [0mAssuming 'prog_running' is false[0m
 3811 |         if (prog_running && ! in_dump) {[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mdebug.c:3811:19: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3811 |         if (prog_running && ! in_dump) {[0m
      | [0;1;32m                         ^
[0m[1mdebug.c:3817:2: [0m[0;1;36mnote: [0mControl jumps to 'case Op_comment:'  at line 4113[0m
 3817 |         switch (pc->opcode) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:4114:28: [0m[0;1;36mnote: [0mPassing null pointer value via 2nd parameter 'func'[0m
 4114 |                 print_memory(pc->memory, func, print_func, fp);[0m
      | [0;1;32m                                         ^~~~
[0m[1mdebug.c:4114:3: [0m[0;1;36mnote: [0mCalling 'print_memory'[0m
 4114 |                 print_memory(pc->memory, func, print_func, fp);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3718:2: [0m[0;1;36mnote: [0mControl jumps to 'case Node_param_list:'  at line 3748[0m
 3718 |         switch (m->type) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3750:24: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3750 |                 print_func(fp, "%s", func->fparms[m->param_cnt].param);[0m
      | [0;1;32m                                     ^~~~~~~~~~~~
[0m[1mdebug.c:3757:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3757 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3760:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3760 |                 print_func(fp, "element - %p", m);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3761 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3764:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3764 |                 print_func(fp, "?");  /* can't happen */[0m
      | [0;1;32m                ^                  
[0m      | [0;32m                {                  ;} 
[0m[1mdebug.c:3780:13: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3780 |                 noffset = sprintf(buf, "[      :" PTRFMT "] %-20.20s: ", (void *) pc,[0m
      | [0;1;32m                          ^~~~~~~
[0m[1mdebug.c:3780:13: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 3780 |                 noffset = sprintf(buf, "[      :" PTRFMT "] %-20.20s: ", (void *) pc,[0m
      | [0;1;32m                          ^~~~~~~
[0m[1mdebug.c:3792:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3792 |                                 if (j < pcount - 1)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3793 |                                         print_func(fp, ", ");[0m
      | [0;1;32m                                                             
[0m[1mdebug.c:3798:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3798 |                 if (in_dump)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3799 |                         print_func(fp, "\n\t# %s\n\n", ruletab[pc->in_rule]);[0m
      | [0;1;32m                                                                             
[0m[1mdebug.c:3802:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3802 |         if (pc->opcode == Op_newfile)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 3803 |                 print_func(fp, "\n");[0m
      | [0;1;32m                                     
[0m[1mdebug.c:3805:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3805 |         if (pc->source_line <= 0)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3806 |                 print_func(fp, "[      :" PTRFMT "] %-20.20s: ", pc, opcode2str(pc->opcode));[0m
 3807 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:3807:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3807 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 3808 |                 print_func(fp, "[%6d:" PTRFMT "] %-20.20s: ",[0m
 3809 |                                 pc->source_line, pc, opcode2str(pc->opcode));[0m
      | [0;1;32m                                                                             
[0m[1mdebug.c:3819:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3819 |                 print_func(fp, "[branch_if = " PTRFMT "] [branch_else = " PTRFMT "] [branch_else->lasti = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3820 |                                 pc->branch_if, pc->branch_else, pc->branch_else->lasti);[0m
 3821 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3824:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3824 |                 print_func(fp, "[branch_end = " PTRFMT "]\n", pc->branch_end);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3825 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3828:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3828 |                 print_func(fp, "[while_body = " PTRFMT "] [target_break = " PTRFMT "]\n", (pc+1)->while_body, pc->target_break);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3829 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3832:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3832 |                 print_func(fp, "[doloop_cond = " PTRFMT "] [target_break = " PTRFMT "]", (pc+1)->doloop_cond, pc->target_break);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3833 |                 if (pc->comment)[0m
 3834 |                         print_func(fp, " [comment = " PTRFMT "]", pc->comment);[0m
 3835 |                 print_func(fp, "\n");[0m
 3836 |                 if (pc->comment)[0m
 3837 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
 3838 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3833:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3833 |                 if (pc->comment)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3834 |                         print_func(fp, " [comment = " PTRFMT "]", pc->comment);[0m
      | [0;1;32m                                                                               
[0m[1mdebug.c:3836:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3836 |                 if (pc->comment)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3837 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
      | [0;1;32m                                                                                
[0m[1mdebug.c:3841:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3841 |                 print_func(fp, "[forloop_cond = " PTRFMT "] ", (pc+1)->forloop_cond);[0m
      | [0;1;32m                ^                                                                   
[0m      | [0;32m                {                                                                   ;} 
[0m[1mdebug.c:3844:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3844 |                 print_func(fp, "[forloop_body = " PTRFMT "] ", (pc+1)->forloop_body);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3845 |                 print_func(fp, "[target_break = " PTRFMT "] [target_continue = " PTRFMT "]", pc->target_break, pc->target_continue);[0m
 3846 |                 if (pc->comment != NULL) {[0m
 3847 |                         print_func(fp, " [comment = " PTRFMT "]\n", (pc)->comment);[0m
 3848 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
 3849 |                 } else[0m
 3850 |                         print_func(fp, "\n");[0m
 3851 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3849:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3849 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3850 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:3854:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3854 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mdebug.c:3857:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3857 |                 if (pc->comment || (pc+1)->switch_end->comment)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 3858 |                         print_func(fp, "%*s", noffset, "");[0m
      | [0;1;32m                                                           
[0m[1mdebug.c:3867:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3867 |                 if (need_newline)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3868 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:3869:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3869 |                 if (pc->comment)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3870 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
      | [0;1;32m                                                                                
[0m[1mdebug.c:3871:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3871 |                 if ((pc+1)->switch_end->comment)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3872 |                         print_instruction((pc+1)->switch_end->comment, print_func, fp, in_dump);[0m
      | [0;1;32m                                                                                                
[0m[1mdebug.c:3877:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3877 |                 print_func(fp, "[stmt_start = " PTRFMT "] [stmt_end = " PTRFMT "]", pc->stmt_start, pc->stmt_end);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3878 |                 if (pc->comment) {[0m
 3879 |                         print_func(fp, " [comment = " PTRFMT "]\n", pc->comment);[0m
 3880 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
 3881 |                 } else[0m
 3882 |                         print_func(fp, "\n");[0m
 3883 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3881:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3881 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3882 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:3886:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3886 |                 print_func(fp, "[update_%s()]\n", get_spec_varname(pc->update_var));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3887 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3890:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3890 |                 print_func(fp, "[set_%s()]", get_spec_varname(pc->assign_var));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3891 |                 if (pc->assign_ctxt != 0)[0m
 3892 |                         print_func(fp, " [assign_ctxt = %s]", opcode2str((OPCODE) pc->assign_ctxt));[0m
 3893 |                 print_func(fp, "\n");[0m
 3894 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3891:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3891 |                 if (pc->assign_ctxt != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 3892 |                         print_func(fp, " [assign_ctxt = %s]", opcode2str((OPCODE) pc->assign_ctxt));[0m
      | [0;1;32m                                                                                                    
[0m[1mdebug.c:3897:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3897 |                 print_func(fp, "[%s]\n", pc->field_assign == reset_record ?[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3898 |                                         "reset_record()" : "invalidate_field0()");[0m
 3899 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3902:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3902 |                 print_func(fp, "[target_assign = " PTRFMT "] [do_reference = %s]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3903 |                                 pc->target_assign, pc->do_reference ? "true" : "false");[0m
 3904 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3907:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3907 |                 print_func(fp, "[param_cnt = %d] [source_file = %s]", pcount,[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3908 |                                 pc->source_file ? pc->source_file : "cmd. line");[0m
 3909 |                 if (pc[3].nexti != NULL) {[0m
 3910 |                         print_func(fp, "[ns_list = " PTRFMT "]\n", pc[3].nexti);[0m
 3911 |                         print_ns_list(pc[3].nexti, print_func, fp, in_dump);[0m
 3912 |                 } else[0m
 3913 |                         print_func(fp, "\n");[0m
 3914 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3912:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3912 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3913 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:3917:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3917 |                 print_func(fp, "[into_var = %s] [redir_type = \"%s\"]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3918 |                                 pc->into_var ? "true" : "false",[0m
 3919 |                                 redir2str(pc->redir_type));[0m
 3920 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3923:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3923 |                 print_func(fp, "[into_var = %s]\n", pc->into_var ? "true" : "false");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3924 |                 print_func(fp, "%*s[target_beginfile = " PTRFMT "] [target_endfile = " PTRFMT "]\n",[0m
 3925 |                                 noffset, "",[0m
 3926 |                                 (pc + 1)->target_beginfile, (pc + 1)->target_endfile);[0m
 3927 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3930:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3930 |                 print_func(fp, "[redir_type = \"%s\"]\n", redir2str(pc->redir_type));[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3931 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3937:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3937 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3943:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3943 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3946:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3946 |                 print_func(fp, "[target_newfile = " PTRFMT "] [target_endfile = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3947 |                                 pc->target_newfile, pc->target_endfile);[0m
 3948 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3951:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3951 |                 print_func(fp, "[target_jmp = " PTRFMT "] [target_endfile = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3952 |                                 pc->target_jmp, pc->target_endfile);[0m
 3953 |                 print_func(fp, "%*s[target_get_record = " PTRFMT "]\n",[0m
 3954 |                                 noffset, "", (pc + 1)->target_get_record);[0m
 3955 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3958:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3958 |                 print_func(fp, "[target_newfile = " PTRFMT "]\n", pc->target_newfile);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3959 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3971:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3971 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:3974:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3974 |                 print_func(fp, "[target_end = " PTRFMT "] [target_atexit = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3975 |                                                 pc->target_end, pc->target_atexit);[0m
 3976 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3979:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3979 |                 print_func(fp, "[target_jmp = " PTRFMT "] [match_exp = %s]",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3980 |                                                 pc->target_jmp, (pc + 1)->match_exp ? "true" : "false");[0m
 3981 |                 if (pc->comment) {[0m
 3982 |                         print_func(fp, " [comment = " PTRFMT "]\n", pc->comment);[0m
 3983 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
 3984 |                 } else[0m
 3985 |                         print_func(fp, "\n");[0m
 3986 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3984:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3984 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3985 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:3989:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3989 |                 print_func(fp, "[namespace = %s]", pc->ns_name);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3990 |                 if (pc->nexti)[0m
 3991 |                         print_func(fp, "[nexti = " PTRFMT "]", pc->nexti);[0m
 3992 |                 if (pc->comment)[0m
 3993 |                         print_func(fp, "[comment = " PTRFMT "]", pc->comment);[0m
 3994 |                 print_func(fp, "\n");[0m
 3995 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:3990:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3990 |                 if (pc->nexti)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3991 |                         print_func(fp, "[nexti = " PTRFMT "]", pc->nexti);[0m
      | [0;1;32m                                                                          
[0m[1mdebug.c:3992:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3992 |                 if (pc->comment)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3993 |                         print_func(fp, "[comment = " PTRFMT "]", pc->comment);[0m
      | [0;1;32m                                                                              
[0m[1mdebug.c:3998:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3998 |                 print_func(fp, "[array_var = %s] [target_jmp = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 3999 |                                 pc->array_var->type == Node_param_list ?[0m
 4000 |                                    func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,[0m
 4001 |                                 pc->target_jmp);[0m
 4002 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4000:22: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4000 |                                    func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,[0m
      | [0;1;32m                                   ^~~~~~~~~~~~
[0m[1mdebug.c:3774:2: [0m[0;1;36mnote: [0m'func' initialized to a null pointer value[0m
 3774 |         static NODE *func = NULL;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3777:6: [0m[0;1;36mnote: [0m'noffset' is equal to 0[0m
 3777 |         if (noffset == 0) {[0m
      | [0;1;32m            ^~~~~~~
[0m[1mdebug.c:3777:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3777 |         if (noffset == 0) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3784:6: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_func[0m
 3784 |         if (pc->opcode == Op_func) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3784:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3784 |         if (pc->opcode == Op_func) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3797:13: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_rule[0m
 3797 |         } else if (pc->opcode == Op_rule) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3797:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 3797 |         } else if (pc->opcode == Op_rule) {[0m
      | [0;1;32m               ^
[0m[1mdebug.c:3802:6: [0m[0;1;36mnote: [0mAssuming field 'opcode' is not equal to Op_newfile[0m
 3802 |         if (pc->opcode == Op_newfile)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3802:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3802 |         if (pc->opcode == Op_newfile)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3805:6: [0m[0;1;36mnote: [0mAssuming field 'source_line' is <= 0[0m
 3805 |         if (pc->source_line <= 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3805:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3805 |         if (pc->source_line <= 0)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3811:6: [0m[0;1;36mnote: [0mAssuming 'prog_running' is false[0m
 3811 |         if (prog_running && ! in_dump) {[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mdebug.c:3811:19: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3811 |         if (prog_running && ! in_dump) {[0m
      | [0;1;32m                         ^
[0m[1mdebug.c:3817:2: [0m[0;1;36mnote: [0mControl jumps to 'case Op_arrayfor_incr:'  at line 3997[0m
 3817 |         switch (pc->opcode) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:3999:19: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_param_list[0m
 3999 |                                 pc->array_var->type == Node_param_list ?[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:3999:19: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mdebug.c:4000:22: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4000 |                                    func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,[0m
      | [0;1;32m                                   ^~~~~~~~~~~~
[0m[1mdebug.c:4005:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4005 |                 print_func(fp, "[triggered = %ld] [target_jmp = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4006 |                                 pc->triggered, pc->target_jmp);[0m
 4007 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4010:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4010 |                 print_func(fp, "[line_range = " PTRFMT "] [target_jmp = " PTRFMT "]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4011 |                                 pc->line_range, pc->target_jmp);[0m
 4012 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4015:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4015 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mdebug.c:4024:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4024 |                 if ((pc->sub_flags & GSUB) != 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 4025 |                         fname = "gsub";[0m
 4026 |                 else if ((pc->sub_flags & GENSUB) != 0)[0m
      | [0;32m                } 
[0m[1mdebug.c:4026:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4026 |                 else if ((pc->sub_flags & GENSUB) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 4027 |                         fname = "gensub";[0m
      | [0;1;32m                                         
[0m[1mdebug.c:4035:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4035 |                 print_func(fp, "%s [arg_count = %ld]\n", getfname(pc->builtin, false),[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4036 |                                                 pc->expr_count);[0m
 4037 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4040:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4040 |                 print_func(fp, "%s [arg_count = %ld]\n", (pc + 1)->func_name,[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4041 |                                                 pc->expr_count);[0m
 4042 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4047:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4047 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:4050:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4050 |                 print_memory(pc->memory, func, print_func, fp);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4051 |                 print_func(fp, " [sub_count = %ld]\n", pc->expr_count);[0m
 4052 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4055:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4055 |                 print_func(fp, "[sub_count = %ld] [do_reference = %s]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4056 |                                 pc->sub_count,[0m
 4057 |                                 pc->do_reference ? "true" : "false");[0m
 4058 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4063:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4063 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:4067:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4067 |                 print_func(fp, "[expr_count = %ld] [concat_flag = %s]\n",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4068 |                                                 pc->expr_count,[0m
 4069 |                                                 (pc->concat_flag & CSUBSEP) != 0 ? "CSUBSEP" : "0");[0m
 4070 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4073:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4073 |                 print_func(fp, "[in_rule = %s] [source_file = %s]",[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4074 |                                 ruletab[pc->in_rule],[0m
 4075 |                                 pc->source_file ? pc->source_file : "cmd. line");[0m
 4076 |                 if (pc[3].nexti != NULL) {[0m
 4077 |                         print_func(fp, "[ns_list = " PTRFMT "]\n", pc[3].nexti);[0m
 4078 |                         print_ns_list(pc[3].nexti, print_func, fp, in_dump);[0m
 4079 |                 } else[0m
 4080 |                         print_func(fp, "\n");[0m
 4081 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4079:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4079 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4080 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:4084:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4084 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m 4085 |                 static const char *const linttypetab[] = {[0m
 4086 |                         "LINT_illegal",[0m
 4087 |                         "LINT_assign_in_cond",[0m
 4088 |                         "LINT_no_effect"[0m
 4089 |                 };[0m
 4090 |                 print_func(fp, "[lint_type = %s]\n", linttypetab[pc->lint_type]);[0m
 4091 |         }[0m
 4092 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4095:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4095 |                 print_func(fp, "[exec_count = " EXEC_COUNT_FMT "]\n", pc->exec_count);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4096 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4099:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4099 |                 print_memory(pc->memory, func, print_func, fp);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4100 |                 if (pc->initval != NULL) {[0m
 4101 |                         print_func(fp, " = ");[0m
 4102 |                         print_memory(pc->initval, func, print_func, fp);[0m
 4103 |                 }[0m
 4104 |                 print_func(fp, "\n");[0m
 4105 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4108:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4108 |                 print_memory(pc->memory, func, print_func, fp);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4109 |                 print_func(fp, " [do_reference = %s]\n",[0m
 4110 |                                 pc->do_reference ? "true" : "false");[0m
 4111 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4114:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4114 |                 print_memory(pc->memory, func, print_func, fp);[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4115 |                 print_func(fp, " [comment_type = %s]",[0m
 4116 |                         pc->memory->comment_type == EOL_COMMENT ?[0m
 4117 |                                                 "EOL" : "BLOCK");[0m
 4118 |                 if (pc->comment) {[0m
 4119 |                         print_func(fp, " [comment = " PTRFMT "]\n", pc->comment);[0m
 4120 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
 4121 |                 } else[0m
 4122 |                         print_func(fp, "\n");[0m
 4123 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4121:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4121 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4122 |                         print_func(fp, "\n");[0m
      | [0;1;32m                                             
[0m[1mdebug.c:4145:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4145 |                 print_func(fp, "\n");[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4146 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4156:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4156 |                         && arg->a_argument == A_TRACE_ON)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 4157 |                 do_trace = true;[0m
 4158 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:4158:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4158 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 4159 |                 do_trace = false;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:4169:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4169 |         for (; pc != NULL; pc = pc->nexti)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 4170 |                 print_instruction(pc, data->print_func, data->fp, data->defn /* in_dump */);[0m
      | [0;1;32m                                                                                            
[0m[1mdebug.c:4181:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4181 |                 if (pc->comment != NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 4182 |                         print_instruction(pc->comment, print_func, fp, in_dump);[0m
      | [0;1;32m                                                                                
[0m[1mdebug.c:4257:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4257 |                             && strncmp(line, "sa", 2) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 4258 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mdebug.c:4260:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4260 |                         fprintf(fp, "%s\n", line);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:4260:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4260 |                         fprintf(fp, "%s\n", line);[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:4278:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4278 |                         if (opt->str_val != NULL)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 4279 |                                 fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));[0m
 4280 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:4279:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4279 |                                 fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:4279:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4279 |                                 fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:4280:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4280 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 4281 |                                 fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                                                                                         
[0m[1mdebug.c:4281:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4281 |                                 fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:4281:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4281 |                                 fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                                ^~~~~~~
[0m[1mdebug.c:4291:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4291 |                 if (strcmp(name, opt->name) == 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 4292 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:4294:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4294 |         if (! opt->name)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 4295 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:4298:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4298 |                 if (opt->str_val != NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 4299 |                         fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));[0m
 4300 |                 else[0m
      | [0;32m                } 
[0m[1mdebug.c:4299:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4299 |                         fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:4299:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4299 |                         fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:4300:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4300 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 4301 |                         fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                                                                                 
[0m[1mdebug.c:4301:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4301 |                         fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:4301:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4301 |                         fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:4302:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4302 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4303 |                 (*(opt->assign))(value);[0m
      | [0;1;32m                                        
[0m[1mdebug.c:4325:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4325 |                 if (screen_height <= 1)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 4326 |                         screen_height = INT_MAX;[0m
      | [0;1;32m                                                
[0m[1mdebug.c:4327:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4327 |                 if (screen_width <= 1)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 4328 |                         screen_width = INT_MAX;[0m
      | [0;1;32m                                               
[0m[1mdebug.c:4339:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4339 |         if (os_isatty(fileno(fp)) && input_fd == 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 4340 |                 quit_pager = prompt_yes_no([0m
 4341 |                         // TRANSLATORS: don't translate the 'q' inside the brackets.[0m
 4342 |                         _("\t------[Enter] to continue or [q] + [Enter] to quit------"),[0m
 4343 |                         'q', false, fp);[0m
      | [0;1;32m                                        
[0m[1mdebug.c:4344:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4344 |         if (quit_pager)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 4345 |                 longjmp(pager_quit_tag, 1);[0m
      | [0;1;32m                                           
[0m[1mdebug.c:4373:11: [0m[0;1;35mwarning: [0m[1mCall to function 'vsnprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'vsnprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4373 |                 nchar = vsnprintf(buf + bl, buflen - bl, format, args);[0m
      | [0;1;32m                        ^~~~~~~~~
[0m[1mdebug.c:4373:11: [0m[0;1;36mnote: [0mCall to function 'vsnprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'vsnprintf_s' in case of C11[0m
 4373 |                 nchar = vsnprintf(buf + bl, buflen - bl, format, args);[0m
      | [0;1;32m                        ^~~~~~~~~
[0m[1mdebug.c:4375:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4375 |                 if (nchar == 0)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 4376 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:4379:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4379 |                         if (buf[bl-1] != '\n') /* buffer output until see a newline at end */[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 4380 |                                 return nchar;[0m
      | [0;1;32m                                             
[0m[1mdebug.c:4398:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4398 |                         if (cnt < sz && (pager_lines_printed == (screen_height - 2)))[0m
      | [0;1;32m                                                                                     ^
[0m      | [0;32m                                                                                      {
[0m 4399 |                                 prompt_continue(fp);[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:4401:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4401 |                         if (fwrite(p, sizeof(char), cnt, fp) != cnt)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 4402 |                                 return -1;[0m
      | [0;1;32m                                          
[0m[1mdebug.c:4403:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4403 |                         if (cnt == sz)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 4404 |                                 break;[0m
 4405 |                         else {[0m
      | [0;32m                        } 
[0m[1mdebug.c:4406:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4406 |                                 if (++pager_lines_printed == (screen_height - 1))[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m 4407 |                                         prompt_continue(fp);[0m
      | [0;1;32m                                                            
[0m[1mdebug.c:4414:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4414 |                 fprintf(fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:4414:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4414 |                 fprintf(fp, "\n");[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:4415:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4415 |                 if (++pager_lines_printed == (screen_height - 1))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 4416 |                         prompt_continue(fp);[0m
      | [0;1;32m                                            
[0m[1mdebug.c:4429:10: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4429 |         nchar = snprintf(buf, buflen, "%d%c%d%c%s%c%d%c",[0m
      | [0;1;32m                ^~~~~~~~
[0m[1mdebug.c:4429:10: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4429 |         nchar = snprintf(buf, buflen, "%d%c%d%c%s%c%d%c",[0m
      | [0;1;32m                ^~~~~~~~
[0m[1mdebug.c:4432:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4432 |         if (nchar <= 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 4433 |                 return 0;[0m
 4434 |         else if (nchar >= buflen)       /* need larger buffer */[0m
      | [0;32m        } 
[0m[1mdebug.c:4434:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4434 |         else if (nchar >= buflen)       /* need larger buffer */[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4435 |                 return nchar;[0m
      | [0;1;32m                             
[0m[1mdebug.c:4439:11: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4439 |                 nchar = snprintf(buf + bl, buflen - bl, "%lu%c%.*s%c",[0m
      | [0;1;32m                        ^~~~~~~~
[0m[1mdebug.c:4439:11: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4439 |                 nchar = snprintf(buf + bl, buflen - bl, "%lu%c%.*s%c",[0m
      | [0;1;32m                        ^~~~~~~~
[0m[1mdebug.c:4442:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4442 |                 if (nchar <= 0)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 4443 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:4445:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4445 |                 if (bl >= buflen)       /* need larger buffer */[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4446 |                         return bl;[0m
      | [0;1;32m                                  
[0m[1mdebug.c:4478:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4478 |                 end_ptr = (void *) &breakpoints;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4479 |                 ptr = (void *) breakpoints.prev;[0m
 4480 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4482:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4482 |                 end_ptr = (void *) &watch_list;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4483 |                 ptr = (void *) watch_list.prev;[0m
 4484 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4486:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4486 |                 end_ptr = (void *) &display_list;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4487 |                 ptr = (void *) display_list.prev;[0m
 4488 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4490:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4490 |                 hist_list = history_list();[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4491 |                 if (hist_list == NULL) /* empty history list */[0m
 4492 |                         return;[0m
 4493 |                 end_ptr = NULL;[0m
 4494 |                 ptr = (void *) hist_list[0];[0m
 4495 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4491:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4491 |                 if (hist_list == NULL) /* empty history list */[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 4492 |                         return;[0m
      | [0;1;32m                               
[0m[1mdebug.c:4497:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4497 |         {[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m 4498 |                 int n;[0m
 4499 |                 n = sizeof(option_list)/sizeof(option_list[0]);[0m
 4500 |                 end_ptr = (void *) &option_list[n - 1];[0m
 4501 |                 ptr = (void *) option_list;[0m
 4502 |         }[0m
 4503 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:4506:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4506 |                 return;[0m
      | [0;1;32m                ^     
[0m      | [0;32m                {     ;} 
[0m[1mdebug.c:4509:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4509 |         if (type != HISTORY && ptr == end_ptr)          /* empty list */[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 4510 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:4534:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4534 |                         b = (BREAKPOINT *) ptr;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4535 | [0m
 4536 |                         /* src source_line flags ignore_count hit_count number;[0m
 4537 |                          * commands and condition processed later in the end switch[0m
 4538 |                          */[0m
 4539 | [0m
 4540 |                         nchar = snprintf(buf + bl, buflen - bl,[0m
 4541 |                                          "%s%c%d%c%d%c%d%c%d%c%d%c",[0m
 4542 |                                          b->src, FSEP, b->bpi->source_line, FSEP, b->flags, FSEP,[0m
 4543 |                                          (int) b->ignore_count, FSEP,[0m
 4544 |                                          (int) b->hit_count, FSEP, b->number, FSEP);[0m
 4545 |                         cnum = b->number;[0m
 4546 |                         commands = &b->commands;[0m
 4547 |                         cndn = &b->cndn;[0m
 4548 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4540:12: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4540 |                         nchar = snprintf(buf + bl, buflen - bl,[0m
      | [0;1;32m                                ^~~~~~~~
[0m[1mdebug.c:4540:12: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4540 |                         nchar = snprintf(buf + bl, buflen - bl,[0m
      | [0;1;32m                                ^~~~~~~~
[0m[1mdebug.c:4558:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4558 |                         if (IS_PARAM(wd))       /* exclude parameters */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4559 |                                 nchar = 0;[0m
 4560 |                         else if (IS_SUBSCRIPT(wd))[0m
 4561 |                                 nchar = serialize_subscript(buf + bl, buflen - bl, wd);[0m
 4562 |                         else if (IS_FIELD(wd))[0m
 4563 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%d%c",[0m
 4564 |                                             wd->number, FSEP, D_field, FSEP, (int) get_number_si(wd->symbol), FSEP);[0m
 4565 |                         else[0m
 4566 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%s%c",[0m
 4567 |                                             wd->number, FSEP, D_variable, FSEP, wd->sname, FSEP);[0m
 4568 |                         cnum = wd->number;[0m
 4569 |                         commands = &wd->commands;[0m
 4570 |                         cndn = &wd->cndn;[0m
 4571 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4558:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4558 |                         if (IS_PARAM(wd))       /* exclude parameters */[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 4559 |                                 nchar = 0;[0m
 4560 |                         else if (IS_SUBSCRIPT(wd))[0m
      | [0;32m                        } 
[0m[1mdebug.c:4560:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4560 |                         else if (IS_SUBSCRIPT(wd))[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 4561 |                                 nchar = serialize_subscript(buf + bl, buflen - bl, wd);[0m
 4562 |                         else if (IS_FIELD(wd))[0m
      | [0;32m                        } 
[0m[1mdebug.c:4562:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4562 |                         else if (IS_FIELD(wd))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 4563 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%d%c",[0m
 4564 |                                             wd->number, FSEP, D_field, FSEP, (int) get_number_si(wd->symbol), FSEP);[0m
 4565 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:4563:13: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4563 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%d%c",[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4563:13: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4563 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%d%c",[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4565:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4565 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 4566 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%s%c",[0m
 4567 |                                             wd->number, FSEP, D_variable, FSEP, wd->sname, FSEP);[0m
      | [0;1;32m                                                                                                 
[0m[1mdebug.c:4566:13: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4566 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%s%c",[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4566:13: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4566 |                                 nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%s%c",[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4574:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4574 |                         h = (HIST_ENTRY *) ptr;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4575 |                         nchar = strlen(h->line);[0m
 4576 |                         if (nchar >= buflen - bl)[0m
 4577 |                                 goto enlarge_buffer;[0m
 4578 |                         strcpy(buf + bl, h->line);[0m
 4579 | #endif[0m
 4580 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4576:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4576 |                         if (nchar >= buflen - bl)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 4577 |                                 goto enlarge_buffer;[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:4578:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 4578 |                         strcpy(buf + bl, h->line);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mdebug.c:4578:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 4578 |                         strcpy(buf + bl, h->line);[0m
      | [0;1;32m                        ^~~~~~
[0m[1mdebug.c:4582:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4582 |                         opt = (struct dbg_option *) ptr;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4583 |                         if (opt->num_val != NULL)[0m
 4584 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
 4585 |                                                                 "%s%c%d%c", opt->name, FSEP, *(opt->num_val), FSEP);[0m
 4586 |                         else[0m
 4587 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
 4588 |                                                                 "%s%c%s%c", opt->name, FSEP, *(opt->str_val), FSEP);[0m
 4589 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4583:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4583 |                         if (opt->num_val != NULL)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 4584 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
 4585 |                                                                 "%s%c%d%c", opt->name, FSEP, *(opt->num_val), FSEP);[0m
 4586 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:4584:13: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4584 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4584:13: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4584 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4586:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4586 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 4587 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
 4588 |                                                                 "%s%c%s%c", opt->name, FSEP, *(opt->str_val), FSEP);[0m
      | [0;1;32m                                                                                                                    
[0m[1mdebug.c:4587:13: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4587 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4587:13: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 4587 |                                 nchar = snprintf(buf + bl, buflen - bl,[0m
      | [0;1;32m                                        ^~~~~~~~
[0m[1mdebug.c:4591:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4591 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mdebug.c:4594:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4594 |                 if (nchar == 0) /* skip empty history lines etc.*/[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 4595 |                         ;[0m
 4596 |                 else if (nchar > 0 && nchar  < buflen - bl) {[0m
      | [0;32m                } 
[0m[1mdebug.c:4600:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4600 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4601 |                         goto enlarge_buffer;[0m
      | [0;1;32m                                            
[0m[1mdebug.c:4615:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4615 |                         nchar = 0;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mdebug.c:4631:13: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4631 |                                 nchar = sprintf(buf + bl, "commands %d", cnum);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:4631:13: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 4631 |                                 nchar = sprintf(buf + bl, "commands %d", cnum);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mdebug.c:4636:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4636 |                                         memcpy(buf + bl, c->cmd_string, nchar);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mdebug.c:4636:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4636 |                                         memcpy(buf + bl, c->cmd_string, nchar);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mdebug.c:4643:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4643 |                                                 memcpy(buf + bl, a->a_string, nchar);[0m
      | [0;1;32m                                                ^~~~~~
[0m[1mdebug.c:4643:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4643 |                                                 memcpy(buf + bl, a->a_string, nchar);[0m
      | [0;1;32m                                                ^~~~~~
[0m[1mdebug.c:4647:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4647 |                                                 memcpy(buf + bl, "end", nchar);[0m
      | [0;1;32m                                                ^~~~~~
[0m[1mdebug.c:4647:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4647 |                                                 memcpy(buf + bl, "end", nchar);[0m
      | [0;1;32m                                                ^~~~~~
[0m[1mdebug.c:4653:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4653 |                                 memcpy(buf + bl, "end", nchar);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mdebug.c:4653:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4653 |                                 memcpy(buf + bl, "end", nchar);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mdebug.c:4668:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4668 |                                 memcpy(buf + bl, cndn->expr, nchar);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mdebug.c:4668:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4668 |                                 memcpy(buf + bl, cndn->expr, nchar);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mdebug.c:4678:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4678 |                         ptr = (void *) wd->prev;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4679 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4681:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4681 |                         ptr = (void *) hist_list[++hist_index];[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4682 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4684:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4684 |                         ptr = (void *) (++opt);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4685 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4687:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4687 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mdebug.c:4691:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4691 |         if (bl > 0)     /* non-empty list */[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 4692 |                 setenv(env_variable[type], buf, 1);[0m
      | [0;1;32m                                                   
[0m[1mdebug.c:4699:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4699 |         if (str_len <= 0 || str == NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 4700 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:4739:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4739 |                 if (symbol == NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4740 |                         return NULL;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:4770:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4770 |                         if (parse_condition(D_watch, l->number, expr) != 0)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 4771 |                                 efree(expr);[0m
      | [0;1;32m                                            
[0m[1mdebug.c:4773:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4773 |                 if (num > list->number)   /* update list number counter */[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 4774 |                         list->number = num;[0m
      | [0;1;32m                                           
[0m[1mdebug.c:4775:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4775 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4776 |                 list->number = num;[0m
      | [0;1;32m                                   
[0m[1mdebug.c:4797:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4797 |         if (s == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4798 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:4801:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4801 |         if (lineno <= 0 || lineno > s->srclines)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 4802 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:4806:3: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4806 |         )[0m
      | [0;1;32m         ^
[0m      | [0;32m          {
[0m 4807 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:4814:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4814 |         if (field_cnt > 6)      /* unserialize breakpoint `commands' */[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 4815 |                 unserialize_commands(pstr[6], pstr_len[6]);[0m
      | [0;1;32m                                                           
[0m[1mdebug.c:4820:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4820 |                 if (parse_condition(D_break, b->number, expr) != 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 4821 |                         efree(expr);[0m
      | [0;1;32m                                    
[0m[1mdebug.c:4824:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4824 |         if (b->number > watch_list.number)  /* watch and break has same number counter */[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 4825 |                 watch_list.number = b->number;  /* update counter */[0m
      | [0;1;32m                                                                    
[0m[1mdebug.c:4863:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4863 |         if (val == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 4864 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:4881:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4881 |                         if (field_cnt == MAX_FIELD)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 4882 | #ifdef GAWKDEBUG[0m
 4883 |                                 fatal("Increase MAX_FIELD and recompile");[0m
 4884 | #else[0m
 4885 |                                 return;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:4891:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4891 |                         (void) unserialize_breakpoint(pstr, pstr_len, field_cnt);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4892 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4894:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4894 |                         (void) unserialize_list_item(&display_list, pstr, pstr_len, field_cnt);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4895 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4897:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4897 |                         (void) unserialize_list_item(&watch_list, pstr, pstr_len, field_cnt);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4898 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4900:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4900 |                         (void) unserialize_option(pstr, pstr_len, field_cnt);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4901 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:4904:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4904 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mdebug.c:4906:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4906 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mdebug.c:4911:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4911 |         if (type == HISTORY)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 4912 |                 sess_history_base = history_length;[0m
      | [0;1;32m                                                   
[0m[1mdebug.c:4926:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4926 |                 fprintf(fp, "%s", _(mesg));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:4926:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 4926 |                 fprintf(fp, "%s", _(mesg));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:4928:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4928 |                 if (in_str == NULL)     /* EOF */[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4929 |                         exit(EXIT_FAILURE);[0m
      | [0;1;32m                                           
[0m[1mdebug.c:4950:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4950 |                 if (breakpoints.next != &breakpoints)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 4951 |                         b = breakpoints.next;[0m
      | [0;1;32m                                             
[0m[1mdebug.c:4952:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4952 |                 if (watch_list.next != &watch_list)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 4953 |                         w = watch_list.next;[0m
      | [0;1;32m                                            
[0m[1mdebug.c:4955:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4955 |                 if (! b && ! w)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 4956 |                         return 0;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:4978:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4978 |                 if (b->number == *pnum)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 4979 |                         return D_break;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:4982:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4982 |                 if (w->number == *pnum)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 4983 |                         return D_watch;[0m
      | [0;1;32m                                       
[0m[1mdebug.c:5013:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5013 |                 if (arg == NULL)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5014 |                         type = has_break_or_watch_point(&num, true);[0m
 5015 |                 else {[0m
      | [0;32m                } 
[0m[1mdebug.c:5021:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5021 |                 if (type == D_break)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 5022 |                         b = find_breakpoint(num);[0m
 5023 |                 else if (type == D_watch)[0m
      | [0;32m                } 
[0m[1mdebug.c:5023:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5023 |                 else if (type == D_watch)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 5024 |                         w = find_item(&watch_list, num);[0m
      | [0;1;32m                                                        
[0m[1mdebug.c:5029:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'commands') [clang-analyzer-core.NullDereference][0m
 5029 |                 for (c = commands->next; c != commands; c = c->next) {[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mdebug.c:5011:6: [0m[0;1;36mnote: [0mAssuming 'cmd' is equal to D_commands[0m
 5011 |         if (cmd == D_commands) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~
[0m[1mdebug.c:5011:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 5011 |         if (cmd == D_commands) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5013:7: [0m[0;1;36mnote: [0mAssuming 'arg' is equal to NULL[0m
 5013 |                 if (arg == NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~
[0m[1mdebug.c:5013:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 5013 |                 if (arg == NULL)[0m
      | [0;1;32m                ^
[0m[1mdebug.c:5020:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'w'[0m
 5020 |                 w = NULL;[0m
      | [0;1;32m                ^~~~~~~~
[0m[1mdebug.c:5021:7: [0m[0;1;36mnote: [0m'type' is not equal to D_break[0m
 5021 |                 if (type == D_break)[0m
      | [0;1;32m                    ^~~~
[0m[1mdebug.c:5021:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 5021 |                 if (type == D_break)[0m
      | [0;1;32m                ^
[0m[1mdebug.c:5023:12: [0m[0;1;36mnote: [0m'type' is not equal to D_watch[0m
 5023 |                 else if (type == D_watch)[0m
      | [0;1;32m                         ^~~~
[0m[1mdebug.c:5023:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 5023 |                 else if (type == D_watch)[0m
      | [0;1;32m                     ^
[0m[1mdebug.c:5026:15: [0m[0;1;36mnote: [0m'b' is equal to NULL[0m
 5026 |                 commands = (b != NULL) ? &b->commands : &w->commands;[0m
      | [0;1;32m                            ^
[0m[1mdebug.c:5026:14: [0m[0;1;36mnote: [0m'?' condition is false[0m
 5026 |                 commands = (b != NULL) ? &b->commands : &w->commands;[0m
      | [0;1;32m                           ^
[0m[1mdebug.c:5026:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'commands'[0m
 5026 |                 commands = (b != NULL) ? &b->commands : &w->commands;[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:5029:12: [0m[0;1;36mnote: [0mAccess to field 'next' results in a dereference of a null pointer (loaded from variable 'commands')[0m
 5029 |                 for (c = commands->next; c != commands; c = c->next) {[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mdebug.c:5037:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5037 |                 if (read_a_line == read_commands_string) /* unserializig commands */[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 5038 |                         return true;    /* done unserializing, terminate zzparse() */[0m
      | [0;1;32m                                                                                     
[0m[1mdebug.c:5042:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5042 |                 if (b != NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5043 |                         b->silent = true;[0m
 5044 |                 else if (w != NULL)[0m
      | [0;32m                } 
[0m[1mdebug.c:5044:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5044 |                 else if (w != NULL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 5045 |                         w->silent = true;[0m
      | [0;1;32m                                         
[0m[1mdebug.c:5064:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'prev' results in a dereference of a null pointer (loaded from variable 'commands') [clang-analyzer-core.NullDereference][0m
 5064 |         c->prev = commands->prev;[0m
      | [0;1;32m                  ^~~~~~~~
[0m[1mdebug.c:5008:2: [0m[0;1;36mnote: [0m'commands' initialized to a null pointer value[0m
 5008 |         static struct commands_item *commands;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mdebug.c:5011:6: [0m[0;1;36mnote: [0mAssuming 'cmd' is not equal to D_commands[0m
 5011 |         if (cmd == D_commands) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~
[0m[1mdebug.c:5011:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 5011 |         if (cmd == D_commands) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5035:13: [0m[0;1;36mnote: [0mAssuming 'cmd' is not equal to D_end[0m
 5035 |         } else if (cmd == D_end) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~
[0m[1mdebug.c:5035:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 5035 |         } else if (cmd == D_end) {[0m
      | [0;1;32m               ^
[0m[1mdebug.c:5041:13: [0m[0;1;36mnote: [0mAssuming 'cmd' is not equal to D_silent[0m
 5041 |         } else if (cmd == D_silent) {[0m
      | [0;1;32m                   ^~~~~~~~~~~~~~~
[0m[1mdebug.c:5041:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 5041 |         } else if (cmd == D_silent) {[0m
      | [0;1;32m               ^
[0m[1mdebug.c:5064:12: [0m[0;1;36mnote: [0mAccess to field 'prev' results in a dereference of a null pointer (loaded from variable 'commands')[0m
 5064 |         c->prev = commands->prev;[0m
      | [0;1;32m                  ^~~~~~~~
[0m[1mdebug.c:5084:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5084 |                 if (c->cmd == D_silent)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 5085 |                         continue;[0m
      | [0;1;32m                                 
[0m[1mdebug.c:5088:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5088 |                 if (ret)        /* resume execution (continue, next etc.) */[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 5089 |                         break;[0m
      | [0;1;32m                              
[0m[1mdebug.c:5108:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5108 |         for (a = arg; a != NULL ; a = a->next)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 5109 |                 count++;[0m
      | [0;1;32m                        
[0m[1mdebug.c:5115:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5115 |                         name = a->a_string;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 5116 |                         r = find_symbol(name, NULL);[0m
 5117 |                         if (r == NULL)[0m
 5118 |                                 goto done;[0m
 5119 |                         if (r->type == Node_var_new || r->type == Node_elem_new)[0m
 5120 |                                 tmp[i] = Nnull_string;[0m
 5121 |                         else if (r->type != Node_var) {[0m
 5122 |                                 d_error(_("`%s' is not a scalar variable"), name);[0m
 5123 |                                 goto done;[0m
 5124 |                         } else[0m
 5125 |                                 tmp[i] = r->var_value;[0m
 5126 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:5117:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5117 |                         if (r == NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 5118 |                                 goto done;[0m
      | [0;1;32m                                          
[0m[1mdebug.c:5119:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5119 |                         if (r->type == Node_var_new || r->type == Node_elem_new)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 5120 |                                 tmp[i] = Nnull_string;[0m
 5121 |                         else if (r->type != Node_var) {[0m
      | [0;32m                        } 
[0m[1mdebug.c:5124:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5124 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5125 |                                 tmp[i] = r->var_value;[0m
      | [0;1;32m                                                      
[0m[1mdebug.c:5128:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5128 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 5129 |                         long field_num;[0m
 5130 |                         r = a->a_node;[0m
 5131 |                         field_num = get_number_si(r);[0m
 5132 |                         tmp[i] = *get_field(field_num, NULL);[0m
 5133 |                 }[0m
 5134 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:5136:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5136 |                 {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mdebug.c:5140:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5140 |                         if (r == NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 5141 |                                 goto done;[0m
      | [0;1;32m                                          
[0m[1mdebug.c:5146:12: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 5146 |                                 subs = a->a_node;[0m
      | [0;1;32m                                       ^~~~~~~~~
[0m[1mdebug.c:5108:16: [0m[0;1;36mnote: [0mAssuming 'a' is not equal to NULL[0m
 5108 |         for (a = arg; a != NULL ; a = a->next)[0m
      | [0;1;32m                      ^~~~~~~~~
[0m[1mdebug.c:5108:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 5108 |         for (a = arg; a != NULL ; a = a->next)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5108:16: [0m[0;1;36mnote: [0mAssuming 'a' is equal to NULL[0m
 5108 |         for (a = arg; a != NULL ; a = a->next)[0m
      | [0;1;32m                      ^~~~~~~~~
[0m[1mdebug.c:5108:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 5110[0m
 5108 |         for (a = arg; a != NULL ; a = a->next)[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5112:23: [0m[0;1;36mnote: [0m'a' is not equal to NULL[0m
 5112 |         for (i = 0, a = arg; a != NULL ; i++, a = a->next) {[0m
      | [0;1;32m                             ^
[0m[1mdebug.c:5112:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 5112 |         for (i = 0, a = arg; a != NULL ; i++, a = a->next) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5113:3: [0m[0;1;36mnote: [0mControl jumps to 'case D_subscript:'  at line 5135[0m
 5113 |                 switch (a->type) {[0m
      | [0;1;32m                ^
[0m[1mdebug.c:5140:8: [0m[0;1;36mnote: [0m'r' is not equal to NULL[0m
 5140 |                         if (r == NULL)[0m
      | [0;1;32m                            ^
[0m[1mdebug.c:5140:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 5140 |                         if (r == NULL)[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:5143:11: [0m[0;1;36mnote: [0mAssuming 'cnt' is > 0[0m
 5143 |                         for (; cnt > 0; cnt--) {[0m
      | [0;1;32m                               ^~~~~~~
[0m[1mdebug.c:5143:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 5143 |                         for (; cnt > 0; cnt--) {[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:5145:5: [0m[0;1;36mnote: [0mNull pointer value stored to 'a'[0m
 5145 |                                 a = a->next;[0m
      | [0;1;32m                                ^~~~~~~~~~~
[0m[1mdebug.c:5146:12: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 5146 |                                 subs = a->a_node;[0m
      | [0;1;32m                                       ^~~~~~~~~
[0m[1mdebug.c:5149:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5149 |                                         if (value == NULL)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 5150 |                                                 tmp[i] = Nnull_string;          /* FIXME: goto done ? */[0m
 5151 |                                         else if (value->type == Node_var_array) {[0m
      | [0;32m                                        } 
[0m[1mdebug.c:5155:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5155 |                                         } else[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 5156 |                                                 tmp[i] = value;[0m
      | [0;1;32m                                                               
[0m[1mdebug.c:5175:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5175 |                         tmp[i] = a->a_node;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 5176 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mdebug.c:5178:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5178 |                         break;[0m
      | [0;1;32m                        ^    
[0m      | [0;32m                        {    ;} 
[0m[1mdebug.c:5184:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5184 |         PUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:349:2: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_BINDING'[0m
  349 |         memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5184:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 5184 |         PUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:349:2: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_BINDING'[0m
  349 |         memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5185:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5185 |         if (setjmp(fatal_tag) == 0)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 5186 |                 r = format_tree(tmp[0]->stptr, tmp[0]->stlen, tmp, i);[0m
 5187 |         else {[0m
      | [0;32m        } 
[0m[1mdebug.c:5192:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5192 |         POP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:352:2: [0m[0;1;36mnote: [0mexpanded from macro 'POP_BINDING'[0m
  352 |         memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5192:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 5192 |         POP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:352:2: [0m[0;1;36mnote: [0mexpanded from macro 'POP_BINDING'[0m
  352 |         memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5231:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5231 |         if (fd <= INVALID_HANDLE)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 5232 |                 return INVALID_HANDLE;[0m
 5233 |         else if (os_isdir(fd)) {[0m
      | [0;32m        } 
[0m[1mdebug.c:5250:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5250 |                 if (strcmp(p, name) == 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 5251 |                         return idx;[0m
      | [0;1;32m                                   
[0m[1mdebug.c:5263:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5263 |         for (opt = option_list; opt->name; opt++)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 5264 |                 fprintf(out_fp, "\t%-15.15s - %s\n", opt->name, _(opt->help_txt));[0m
      | [0;1;32m                                                                                  
[0m[1mdebug.c:5264:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5264 |                 fprintf(out_fp, "\t%-15.15s - %s\n", opt->name, _(opt->help_txt));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:5264:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 5264 |                 fprintf(out_fp, "\t%-15.15s - %s\n", opt->name, _(opt->help_txt));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:5284:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5284 |                 if (strncmp(name, text, textlen) == 0)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 5285 |                         return estrdup(name, strlen(name));[0m
      | [0;1;32m                                                           
[0m[1mdebug.c:5310:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5310 |         if (file == NULL || file[0] == '\0')[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 5311 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:5316:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5316 |                 if (fp == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 5317 |                         close(fd);[0m
      | [0;1;32m                                  
[0m[1mdebug.c:5322:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5322 |                 if (strcmp(cp, "stdout") == 0)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 5323 |                         return;[0m
      | [0;1;32m                               
[0m[1mdebug.c:5336:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5336 |                                 if (fp == NULL)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 5337 |                                         fd = INVALID_HANDLE;[0m
      | [0;1;32m                                                            
[0m[1mdebug.c:5338:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5338 |                         } else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5339 |                                 fd = INVALID_HANDLE;[0m
      | [0;1;32m                                                    
[0m[1mdebug.c:5347:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5347 |                         if (fp == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 5348 |                                 close(fd);[0m
      | [0;1;32m                                          
[0m[1mdebug.c:5365:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5365 |                 fprintf(out_fp, _("sending output to stdout\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:5365:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 5365 |                 fprintf(out_fp, _("sending output to stdout\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:5385:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5385 |         if (strcmp(value, "on") == 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 5386 |                 return true;[0m
      | [0;1;32m                            
[0m[1mdebug.c:5387:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5387 |         if (strcmp(value, "off") == 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 5388 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:5402:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5402 |         if (errno == 0 && n > 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 5403 |                 *pnum = n;[0m
 5404 |         else[0m
      | [0;32m        } 
[0m[1mdebug.c:5404:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5404 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 5405 |                 d_error(_("invalid number"));[0m
      | [0;1;32m                                             
[0m[1mdebug.c:5459:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5459 |         if (commands_string == NULL)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 5460 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mdebug.c:5488:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5488 |         if (fp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 5489 |                 return;[0m
      | [0;1;32m                       
[0m[1mdebug.c:5492:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5492 |                 if (opt->str_val != NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 5493 |                         fprintf(fp, "option %s = \"%s\"\n", opt->name, *(opt->str_val));[0m
 5494 |                 else[0m
      | [0;32m                } 
[0m[1mdebug.c:5493:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5493 |                         fprintf(fp, "option %s = \"%s\"\n", opt->name, *(opt->str_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:5493:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 5493 |                         fprintf(fp, "option %s = \"%s\"\n", opt->name, *(opt->str_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:5494:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5494 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5495 |                         fprintf(fp, "option %s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                                                                                    
[0m[1mdebug.c:5495:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5495 |                         fprintf(fp, "option %s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:5495:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 5495 |                         fprintf(fp, "option %s = %d\n", opt->name, *(opt->num_val));[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mdebug.c:5542:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5542 |                 *pi = ei->nexti;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 5543 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:5545:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5545 |                 if (ei->nexti != NULL) {        /* not an implicit return */[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 5546 |                         NODE *r;[0m
 5547 |                         d_error(_("`return' not allowed in current context;"[0m
 5548 |                                         " statement ignored"));[0m
 5549 |                         /* throw away return value already pushed onto stack */[0m
 5550 |                         r = POP_SCALAR();[0m
 5551 |                         DEREF(r);[0m
 5552 |                         *pi = ei->nexti;[0m
 5553 |                 }[0m
 5554 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mdebug.c:5556:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5556 |                 break;[0m
      | [0;1;32m                ^    
[0m      | [0;32m                {    ;} 
[0m[1mdebug.c:5579:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5579 |         PUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:349:2: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_BINDING'[0m
  349 |         memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5579:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 5579 |         PUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:349:2: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_BINDING'[0m
  349 |         memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5595:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5595 |                 fprintf(stderr, _("fatal error during eval, need to restart.\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:5595:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 5595 |                 fprintf(stderr, _("fatal error during eval, need to restart.\n"));[0m
      | [0;1;32m                ^~~~~~~
[0m[1mdebug.c:5600:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5600 |         POP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:352:2: [0m[0;1;36mnote: [0mexpanded from macro 'POP_BINDING'[0m
  352 |         memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5600:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 5600 |         POP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);[0m
      | [0;1;32m        ^
[0m[1mdebug.c:352:2: [0m[0;1;36mnote: [0mexpanded from macro 'POP_BINDING'[0m
  352 |         memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))[0m
      | [0;1;32m        ^~~~~~
[0m[1mdebug.c:5678:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5678 |                         if (pcount == 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 5679 |                                 emalloc(this_frame->stack, NODE **, ecount * sizeof(NODE *), "do_eval");[0m
 5680 |                         else[0m
      | [0;32m                        } 
[0m[1mdebug.c:5680:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5680 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5681 |                                 erealloc(this_frame->stack, NODE **, (pcount + ecount) * sizeof(NODE *), "do_eval");[0m
      | [0;1;32m                                                                                                                    
[0m[1mdebug.c:5691:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5691 |                                 memset(r, 0, sizeof(NODE));[0m
      | [0;1;32m                                ^~~~~~
[0m[1mdebug.c:5691:5: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 5691 |                                 memset(r, 0, sizeof(NODE));[0m
      | [0;1;32m                                ^~~~~~
[0m[1mdebug.c:5692:11: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 5692 |                                 *sp++ = r;[0m
      | [0;1;32m                                ~~~~~~^~~
[0m[1mdebug.c:5625:6: [0m[0;1;36mnote: [0mAssuming 'prog_running' is true[0m
 5625 |         if (prog_running) {[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mdebug.c:5625:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 5625 |         if (prog_running) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5639:6: [0m[0;1;36mnote: [0mAssuming 'ret' is equal to 0[0m
 5639 |         if (ret != 0) {[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mdebug.c:5639:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 5639 |         if (ret != 0) {[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5653:6: [0m[0;1;36mnote: [0mAssuming 'this_func' is not equal to NULL[0m
 5653 |         if (this_func == NULL) {        /* in main */[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~
[0m[1mdebug.c:5653:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 5653 |         if (this_func == NULL) {        /* in main */[0m
      | [0;1;32m        ^
[0m[1mdebug.c:5677:7: [0m[0;1;36mnote: [0mAssuming 'ecount' is > 0[0m
 5677 |                 if (ecount > 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mdebug.c:5677:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 5677 |                 if (ecount > 0) {[0m
      | [0;1;32m                ^
[0m[1mdebug.c:5678:8: [0m[0;1;36mnote: [0mAssuming 'pcount' is equal to 0[0m
 5678 |                         if (pcount == 0)[0m
      | [0;1;32m                            ^~~~~~~~~~~
[0m[1mdebug.c:5678:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 5678 |                         if (pcount == 0)[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:5684:16: [0m[0;1;36mnote: [0m'i' is < 'ecount'[0m
 5684 |                         for (i = 0; i < ecount; i++) {[0m
      | [0;1;32m                                    ^
[0m[1mdebug.c:5684:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 5684 |                         for (i = 0; i < ecount; i++) {[0m
      | [0;1;32m                        ^
[0m[1mdebug.c:5690:13: [0m[0;1;36mnote: [0mAssuming 'r' is null[0m
 5690 |                                 getnode(r);[0m
      | [0;1;32m                                        ^
[0m[1m./awk.h:1366:29: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                                 ^
[0m[1m./awk.h:1358:39: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                      ^
[0m[1mdebug.c:5690:5: [0m[0;1;36mnote: [0m'?' condition is false[0m
 5690 |                                 getnode(r);[0m
      | [0;1;32m                                ^
[0m[1m./awk.h:1366:20: [0m[0;1;36mnote: [0mexpanded from macro 'getnode'[0m
 1366 | #define getnode(n)      getblock(n, BLOCK_NODE, NODE *)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:1358:38: [0m[0;1;36mnote: [0mexpanded from macro 'getblock'[0m
 1358 | #define getblock(p, id, ty)  (void) ((p = (ty) nextfree[id].freep) ? \[0m
      | [0;1;32m                                     ^
[0m[1mdebug.c:5692:6: [0m[0;1;36mnote: [0mNull pointer value stored to 'sp'[0m
 5692 |                                 *sp++ = r;[0m
      | [0;1;32m                                 ^~~~
[0m[1mdebug.c:5692:11: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 5692 |                                 *sp++ = r;[0m
      | [0;1;32m                                ~~~~~~^~~
[0m[1mdebug.c:5711:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5711 |         if (ret_val != NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5712 |                 DEREF(ret_val); /* throw away return value */[0m
      | [0;1;32m                                                             
[0m[1mdebug.c:5725:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5725 |                         if (r->type == Node_var)     /* eval local variable */[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 5726 |                                 DEREF(r->var_value);[0m
 5727 |                         else if (r->type == Node_var_array)     /* eval local array */[0m
      | [0;32m                        } 
[0m[1mdebug.c:5727:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5727 |                         else if (r->type == Node_var_array)     /* eval local array */[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 5728 |                                 assoc_clear(r);[0m
      | [0;1;32m                                               
[0m[1mdebug.c:5809:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5809 |                 if (rp != NULL && rp->opcode == Op_func)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 5810 |                         this_func = rp->func_body;[0m
      | [0;1;32m                                                  
[0m[1mdebug.c:5816:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5816 |         if (cndn == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 5817 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mdebug.c:5818:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5818 |         if (expr == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 5819 |                 goto out;       /* delete condition */[0m
      | [0;1;32m                                                      
[0m[1mdebug.c:5862:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5862 |         if (cndn->expr != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 5863 |                 efree(cndn->expr);[0m
      | [0;1;32m                                  
[0m[1mdebug.c:5882:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5882 |         if (! type)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 5883 |                 return false;[0m
      | [0;1;32m                             
[0m[1mdebug.c:5885:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5885 |         if (arg != NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 5886 |                 expr = arg->a_string;[0m
      | [0;1;32m                                     
[0m[1mdebug.c:5887:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5887 |         if (parse_condition(type, num, expr) == 0 && arg != NULL)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 5888 |                 arg->a_string = NULL;   /* don't let free_cmdarg free it */[0m
      | [0;1;32m                                                                           
[0m[1mdebug.c:5899:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5899 |                 if (cs->str != NULL && strcmp(cs->str, filename) == 0)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 5900 |                         return true;[0m
      | [0;1;32m                                    
[0m[1mdebug.c:5908:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5908 |         if (cmd_src == NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5909 |                 return EXIT_FATAL;[0m
      | [0;1;32m                                  
[0m[1mdebug.c:5949:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5949 |         if (cmd_src->next == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 5950 |                 return -1;[0m
      | [0;1;32m                          
[0m[1mdebug.c:5954:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5954 |         if (cs->close_func && cs->fd != INVALID_HANDLE)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 5955 |                 cs->close_func(cs->fd);[0m
      | [0;1;32m                                       
[0m[1mdebug.c:5956:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5956 |         if (cs->str != NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5957 |                 efree(cs->str);[0m
      | [0;1;32m                               
[0m702 warnings generated.
Suppressed 32 warnings (32 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[54/54][339.8s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/tidy-fixes/tmpki2_q0tv.yaml -p=/itch/common/crepos/cu-to-rtu/c/gawk-5.2.2 /itch/common/crepos/cu-to-rtu/c/gawk-5.2.2/builtin.c
[1mbuiltin.c:97:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   97 |         if (nargs != count)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m   98 |                 fatal(_("%s: called with %d arguments"), fname, nargs);[0m
      | [0;1;32m                                                                       
[0m[1mbuiltin.c:104:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  104 |         if (nargs < min || nargs > max)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  105 |                 fatal(_("%s: called with %d arguments"), fname, nargs);[0m
      | [0;1;32m                                                                       
[0m[1mbuiltin.c:123:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  123 |         if (fp == stdout && errno == EPIPE)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  124 |                 die_via_sigpipe();[0m
      | [0;1;32m                                  
[0m[1mbuiltin.c:127:96: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  127 |         if ((rp != NULL) ? is_non_fatal_redirect(rp->value, strlen(rp->value)) : is_non_fatal_std(fp))[0m
      | [0;1;32m                                                                                                      ^
[0m      | [0;32m                                                                                                       {
[0m  128 |                 update_ERRNO_int(errno);[0m
  129 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:129:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  129 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  130 |                 fatal(_("%s to \"%s\" failed: %s"), from,[0m
  131 |                         rp != NULL[0m
  132 |                                 ? rp->value[0m
  133 |                                 : fp == stdout[0m
  134 |                                         ? _("standard output")[0m
  135 |                                         : _("standard error"),[0m
  136 |                         errno ? strerror(errno) : _("reason unknown"));[0m
      | [0;1;32m                                                                       
[0m[1mbuiltin.c:147:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  147 |                 if (rp->output.gawk_ferror(fp, rp->output.opaque))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  148 |                         wrerror(fp, from, rp);[0m
      | [0;1;32m                                              
[0m[1mbuiltin.c:151:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  151 |                 if (ferror(fp))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  152 |                         wrerror(fp, from, rp);[0m
      | [0;1;32m                                              
[0m[1mbuiltin.c:195:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  195 |               || (rp != NULL && (rp->flag & RED_FLUSH) != 0)))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  196 |                 efflush(fp, from, rp);[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:210:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  210 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  211 |                 lintwarn(_("%s: received non-numeric argument"), "exp");[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:216:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  216 |         if (errno == ERANGE)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  217 |                 warning(_("exp: argument %g is out of range"), d);[0m
      | [0;1;32m                                                                  
[0m[1mbuiltin.c:233:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  233 |                 if (strncmp(name, "/dev/stderr", 11) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m  234 |                         return stderr;[0m
  235 |                 else if (strncmp(name, "/dev/stdout", 11) == 0)[0m
      | [0;32m                } 
[0m[1mbuiltin.c:235:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  235 |                 else if (strncmp(name, "/dev/stdout", 11) == 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  236 |                         return stdout;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:280:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  280 |         if (do_lint && (fixtype(tmp)->flags & STRING) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  281 |                 lintwarn(_("%s: received non-string argument"), "fflush");[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:297:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  297 |                         if ((rp->flag & RED_PIPE) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  298 |                                 warning(_("fflush: cannot flush: pipe `%.*s' opened for reading, not writing"),[0m
  299 |                                         len, file);[0m
  300 |                         else[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:300:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  300 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  301 |                                 warning(_("fflush: cannot flush: file `%.*s' opened for reading, not writing"),[0m
  302 |                                         len, file);[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:311:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  311 |                                 if (! is_non_fatal_redirect(tmp->stptr, tmp->stlen))[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m  312 |                                         fatal(_("fflush: cannot flush file `%.*s': %s"),[0m
  313 |                                                 len, file, strerror(errno));[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:316:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  316 |                 } else if ((rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  317 |                                 warning(_("fflush: cannot flush: two-way pipe `%.*s' has closed write end"),[0m
  318 |                                         len, file);[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:338:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  338 |         memset(& mbs1, 0, sizeof(mbs1));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:338:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  338 |         memset(& mbs1, 0, sizeof(mbs1));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:339:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  339 |         memset(& mbs2, 0, sizeof(mbs2));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:339:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  339 |         memset(& mbs2, 0, sizeof(mbs2));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:366:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  366 |                 if ((gap = towlower(wc1) - towlower(wc2)) != 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  367 |                         /* s1 and s2 are not equivalent. */[0m
  368 |                         return gap;[0m
      | [0;1;32m                                   
[0m[1mbuiltin.c:386:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  386 |         memset(& prevs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:386:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  386 |         memset(& prevs, 0, sizeof(mbstate_t));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:424:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  424 |                 memset(& mbs1, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:424:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  424 |                 memset(& mbs1, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:425:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  425 |                 memset(& mbs2, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:425:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  425 |                 memset(& mbs2, 0, sizeof(mbstate_t));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:431:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  431 |                 if ((fixtype(s1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  432 |                         lintwarn(_("%s: received non-string first argument"), "index");[0m
      | [0;1;32m                                                                                       
[0m[1mbuiltin.c:433:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  433 |                 if ((fixtype(s2)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  434 |                         lintwarn(_("%s: received non-string second argument"), "index");[0m
      | [0;1;32m                                                                                        
[0m[1mbuiltin.c:470:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  470 |                         if (l2 > l1)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  471 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:476:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  476 |                                 if (pos == NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  477 |                                         ret = 0;[0m
  478 |                                 else[0m
      | [0;32m                                } 
[0m[1mbuiltin.c:478:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  478 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  479 |                                         ret = pos - s1->wstptr + 1;     /* 1-based */[0m
      | [0;1;32m                                                                                     
[0m[1mbuiltin.c:497:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  497 |                         if (l2 > l1)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  498 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:508:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  508 |                                 if (pos == NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  509 |                                         ret = 0;[0m
  510 |                                 else[0m
      | [0;32m                                } 
[0m[1mbuiltin.c:510:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  510 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  511 |                                         ret = pos - s1->wstptr + 1;     /* 1-based */[0m
      | [0;1;32m                                                                                     
[0m[1mbuiltin.c:530:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  530 |         if (d >= 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  531 |                 d = floor(d);[0m
  532 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:532:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  532 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  533 |                 d = ceil(d);[0m
      | [0;1;32m                            
[0m[1mbuiltin.c:548:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  548 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  549 |                 lintwarn(_("%s: received non-numeric argument"), "int");[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:570:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  570 |                 if (tmp->type == Node_val)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  571 |                         DEREF(tmp);[0m
      | [0;1;32m                                   
[0m[1mbuiltin.c:591:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  591 |                 if (do_posix)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  592 |                         fatal(_("length: received array argument"));[0m
      | [0;1;32m                                                                    
[0m[1mbuiltin.c:617:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  617 |         if (do_lint && (fixtype(tmp)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m  618 |                 lintwarn(_("%s: received non-string argument"), "length");[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:628:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  628 |                  if (len == 0 && tmp->stlen > 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  629 |                          len = tmp->stlen;[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:630:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  630 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  631 |                 len = tmp->stlen;[0m
      | [0;1;32m                                 
[0m[1mbuiltin.c:648:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  648 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  649 |                 lintwarn(_("%s: received non-numeric argument"), "log");[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:651:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  651 |         if (arg < 0.0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  652 |                 warning(_("%s: received negative argument %g"), "log", arg);[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:885:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  885 |                 bchunk(s0, s1 - s0);[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:885:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  885 |                 bchunk(s0, s1 - s0);[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:890:3: [0m[0;1;35mwarning: [0m[1mValue stored to 'base' is never read [clang-analyzer-deadcode.DeadStores][0m
  890 |                 base = 0;[0m
      | [0;1;32m                ^      ~
[0m[1mbuiltin.c:890:3: [0m[0;1;36mnote: [0mValue stored to 'base' is never read[0m
  890 |                 base = 0;[0m
      | [0;1;32m                ^      ~
[0m[1mbuiltin.c:905:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  905 |                 memset(modifier_seen, 0, sizeof(modifier_seen));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:905:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  905 |                 memset(modifier_seen, 0, sizeof(modifier_seen));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:913:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  913 |                 if (n0-- == 0)  /* ran out early! */[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  914 |                         break;[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:918:1: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  918 | check_pos:[0m
      | [0;1;32m^
[0m      | [0;32m{
[0m  919 |                         if (cur != &fw)[0m
  920 |                                 break;          /* reject as a valid format */[0m
  921 |                         goto retry;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mbuiltin.c:919:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  919 |                         if (cur != &fw)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  920 |                                 break;          /* reject as a valid format */[0m
      | [0;1;32m                                                                              
[0m[1mbuiltin.c:923:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  923 |                         need_format = false;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:934:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  934 |                                 if (fw && ! have_prec)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  935 |                                         msg = _("field width is ignored for `%%' specifier");[0m
  936 |                                 else if (fw == 0 && have_prec)[0m
      | [0;32m                                } 
[0m[1mbuiltin.c:936:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  936 |                                 else if (fw == 0 && have_prec)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  937 |                                         msg = _("precision is ignored for `%%' specifier");[0m
  938 |                                 else if (fw && have_prec)[0m
      | [0;32m                                } 
[0m[1mbuiltin.c:938:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  938 |                                 else if (fw && have_prec)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  939 |                                         msg = _("field width and precision are ignored for `%%' specifier");[0m
      | [0;1;32m                                                                                                            
[0m[1mbuiltin.c:941:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  941 |                                 if (msg != NULL)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  942 |                                         lintwarn("%s", msg);[0m
      | [0;1;32m                                                            
[0m[1mbuiltin.c:944:4: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
  944 |                         bchunk_one("%");[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:736:13: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk_one'[0m
  736 |         *obufout++ = *s; \[0m
      | [0;1;32m        ~~~~~~~~~~~^~~~
[0m[1mbuiltin.c:820:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  820 |                 for (k = 0; k < sizeof(cpbufs)/sizeof(cpbufs[0]); k++) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:820:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
[1mbuiltin.c:820:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 875[0m
[1mbuiltin.c:879:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  879 |         while (n0-- > 0) {[0m
      | [0;1;32m               ^~~~~~~~
[0m[1mbuiltin.c:879:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  879 |         while (n0-- > 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:880:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  880 |                 if (*s1 != '%') {[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mbuiltin.c:880:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  880 |                 if (*s1 != '%') {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:885:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  885 |                 bchunk(s0, s1 - s0);[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:714:22: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  714 | #define bchunk(s, l) if (l) { \[0m
      | [0;1;32m                     ^
[0m[1mbuiltin.c:913:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  913 |                 if (n0-- == 0)  /* ran out early! */[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1mbuiltin.c:913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  913 |                 if (n0-- == 0)  /* ran out early! */[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:916:3: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 1686[0m
  916 |                 switch (cs1 = *s1++) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:1687:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1687 |                         if (do_lint && is_alpha(cs1))[0m
      | [0;1;32m                            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1687:16: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1687 |                         if (do_lint && is_alpha(cs1))[0m
      | [0;1;32m                                    ^
[0m[1mbuiltin.c:1689:4: [0m[0;1;36mnote: [0m Execution continues on line 1691[0m
 1689 |                         break;[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:1691:7: [0m[0;1;36mnote: [0m'toofew' is false[0m
 1691 |                 if (toofew) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:1691:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1691 |                 if (toofew) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:879:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  879 |         while (n0-- > 0) {[0m
      | [0;1;32m               ^~~~~~~~
[0m[1mbuiltin.c:879:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  879 |         while (n0-- > 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:880:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  880 |                 if (*s1 != '%') {[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mbuiltin.c:880:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  880 |                 if (*s1 != '%') {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:885:14: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  885 |                 bchunk(s0, s1 - s0);[0m
      | [0;1;32m                           ^
[0m[1mbuiltin.c:714:26: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  714 | #define bchunk(s, l) if (l) { \[0m
      | [0;1;32m                         ^
[0m[1mbuiltin.c:885:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  885 |                 bchunk(s0, s1 - s0);[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:714:22: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  714 | #define bchunk(s, l) if (l) { \[0m
      | [0;1;32m                     ^
[0m[1mbuiltin.c:885:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 885[0m
  885 |                 bchunk(s0, s1 - s0);[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:715:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  715 |         while ((l) > ofre) { \[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:913:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  913 |                 if (n0-- == 0)  /* ran out early! */[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1mbuiltin.c:913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  913 |                 if (n0-- == 0)  /* ran out early! */[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:916:3: [0m[0;1;36mnote: [0mControl jumps to 'case 37:'  at line 922[0m
  916 |                 switch (cs1 = *s1++) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:931:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  931 |                         if (do_lint) {[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:944:4: [0m[0;1;36mnote: [0mAssuming 'ofre' is < 1[0m
  944 |                         bchunk_one("%");[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:729:6: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk_one'[0m
  729 |         if (ofre < 1) { \[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mbuiltin.c:944:4: [0m[0;1;36mnote: [0mTaking true branch[0m
  944 |                         bchunk_one("%");[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:729:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk_one'[0m
  729 |         if (ofre < 1) { \[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:944:4: [0m[0;1;36mnote: [0mNull pointer value stored to 'obufout'[0m
  944 |                         bchunk_one("%");[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:736:3: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk_one'[0m
  736 |         *obufout++ = *s; \[0m
      | [0;1;32m         ^~~~~~~~~
[0m[1mbuiltin.c:944:4: [0m[0;1;36mnote: [0mDereference of null pointer[0m
  944 |                         bchunk_one("%");[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:736:13: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk_one'[0m
  736 |         *obufout++ = *s; \[0m
      | [0;1;32m        ~~~~~~~~~~~^~~~
[0m[1mbuiltin.c:954:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  954 |                         if (cur == & fw)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  955 |                                 zero_flag = true;[0m
  956 |                         if (lj)[0m
  957 |                                 goto retry;[0m
      | [0;1;32m                                          
[0m      | [0;32m                                          ;} 
[0m[1mbuiltin.c:954:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  954 |                         if (cur == & fw)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  955 |                                 zero_flag = true;[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:956:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  956 |                         if (lj)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  957 |                                 goto retry;[0m
      | [0;1;32m                                           
[0m[1mbuiltin.c:968:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  968 |                         if (cur == NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  969 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:970:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  970 |                         if (prec >= 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:970:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  970 |                         if (prec >= 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  971 |                                 *cur = cs1 - '0';[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:981:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  981 |                         if (prec < 0)   /* negative precision is discarded */[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  982 |                                 have_prec = false;[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:983:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  983 |                         if (cur == &prec)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  984 |                                 cur = NULL;[0m
      | [0;1;32m                                           
[0m[1mbuiltin.c:985:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  985 |                         if (n0 == 0)    /* badly formatted control string */[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  986 |                                 continue;[0m
      | [0;1;32m                                         
[0m[1mbuiltin.c:989:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  989 |                         if (do_traditional) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:1013:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1013 |                         if (cur == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:1013:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1013 |                         if (cur == NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1014 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1050:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1050 |                                 if (*cur >= 0)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1051 |                                         have_prec = true;[0m
 1052 |                                 else[0m
      | [0;32m                                } 
[0m[1mbuiltin.c:1052:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1052 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1053 |                                         have_prec = false;[0m
      | [0;1;32m                                                          
[0m[1mbuiltin.c:1060:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1060 |                         if (signchar != false)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1061 |                                 goto check_pos;[0m
      | [0;1;32m                                              
[0m      | [0;32m                                              ;} 
[0m[1mbuiltin.c:1060:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1060 |                         if (signchar != false)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1061 |                                 goto check_pos;[0m
      | [0;1;32m                                               
[0m[1mbuiltin.c:1064:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1064 |                         signchar = cs1;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1065 |                         goto check_pos;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mbuiltin.c:1067:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1067 |                         if (prec < 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1068 |                                 break;[0m
 1069 |                         if (cur == &prec) {[0m
 1070 |                                 prec = -1;[0m
 1071 |                                 goto retry;[0m
 1072 |                         }[0m
 1073 |                         fill = sp;      /* if left justified then other */[0m
 1074 |                         lj = true;      /* filling is ignored */[0m
 1075 |                         goto check_pos;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mbuiltin.c:1067:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1067 |                         if (prec < 0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1068 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1077:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1077 |                         if (cur != &fw)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1078 |                                 break;[0m
 1079 |                         cur = &prec;[0m
 1080 |                         have_prec = true;[0m
 1081 |                         goto retry;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mbuiltin.c:1077:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1077 |                         if (cur != &fw)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1078 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1083:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1083 |                         alt = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1084 |                         goto check_pos;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mbuiltin.c:1087:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1087 |                         quote_flag = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1088 |                         goto check_pos;[0m
      | [0;1;32m                                      
[0m      | [0;32m                                      ;} 
[0m[1mbuiltin.c:1098:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1098 |                         if (modifier_seen[modifier_index(cs1)])[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1099 |                                 break;[0m
 1100 |                         else {[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:1112:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1112 |                         modifier_seen[modifier_index(cs1)] = true;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1113 |                         goto retry;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mbuiltin.c:1116:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1116 |                         if (magic_posix_flag)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1117 |                                 break;[0m
 1118 |                         magic_posix_flag = true;[0m
 1119 |                         goto retry;[0m
      | [0;1;32m                                  
[0m      | [0;32m                                  ;} 
[0m[1mbuiltin.c:1116:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1116 |                         if (magic_posix_flag)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1117 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1121:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1121 |                         need_format = false;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:1133:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1133 |                                         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:1133:6: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1133 |                                         memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:1137:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1137 |                                                 if (do_lint)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1138 |                                                         lintwarn([0m
 1139 |                                                 _("[s]printf: value %g is too big for %%c format"),[0m
 1140 |                                                                         arg->numbr);[0m
      | [0;1;32m                                                                                    
[0m[1mbuiltin.c:1150:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1150 |                                                 if (do_lint)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1151 |                                                         lintwarn([0m
 1152 |                                                 _("[s]printf: value %g is not a valid wide character"),[0m
 1153 |                                                                         arg->numbr);[0m
      | [0;1;32m                                                                                    
[0m[1mbuiltin.c:1158:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1158 |                                         memcpy(cpbuf, buf, count);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:1158:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1158 |                                         memcpy(cpbuf, buf, count);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:1189:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1189 |                                 memset(& state, 0, sizeof(state));[0m
      | [0;1;32m                                ^~~~~~
[0m[1mbuiltin.c:1189:5: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1189 |                                 memset(& state, 0, sizeof(state));[0m
      | [0;1;32m                                ^~~~~~
[0m[1mbuiltin.c:1194:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1194 |                                         if (fw > 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1195 |                                                 fw += count - 1;[0m
      | [0;1;32m                                                                
[0m[1mbuiltin.c:1200:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1200 |                         need_format = false;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1201 |                         parse_next_arg();[0m
 1202 |                         arg = force_string(arg);[0m
 1203 |                         if (fw == 0 && ! have_prec)[0m
 1204 |                                 prec = arg->stlen;[0m
 1205 |                         else {[0m
 1206 |                                 char_count = mbc_char_count(arg->stptr, arg->stlen);[0m
 1207 |                                 if (! have_prec || prec > char_count)[0m
 1208 |                                         prec = char_count;[0m
 1209 |                         }[0m
 1210 |                         cp = arg->stptr;[0m
 1211 |                         goto pr_tail;[0m
      | [0;1;32m                                    
[0m      | [0;32m                                    ;} 
[0m[1mbuiltin.c:1203:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1203 |                         if (fw == 0 && ! have_prec)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1204 |                                 prec = arg->stlen;[0m
 1205 |                         else {[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:1207:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1207 |                                 if (! have_prec || prec > char_count)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1208 |                                         prec = char_count;[0m
      | [0;1;32m                                                          
[0m[1mbuiltin.c:1215:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1215 |                         parse_next_arg();[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:854:26: [0m[0;1;36mnote: [0mexpanded from macro 'parse_next_arg'[0m
  854 | #define parse_next_arg() { \[0m
      | [0;1;32m                         ^
[0m[1mbuiltin.c:1221:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1221 |                         if (out_of_range(arg))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1222 |                                 goto out_of_range;[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1236:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1236 |                         if (have_prec && prec == 0 && tmpval == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 1237 |                                 goto pr_tail;[0m
      | [0;1;32m                                             
[0m[1mbuiltin.c:1243:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1243 |                                 if (tmpval == -0.0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1244 |                                         /* avoid printing -0 */[0m
 1245 |                                         tmpval = 0.0;[0m
      | [0;1;32m                                                     
[0m[1mbuiltin.c:1252:16: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1252 |                         while ((i = snprintf(cpbufs[1].buf,[0m
      | [0;1;32m                                    ^~~~~~~~
[0m[1mbuiltin.c:1252:16: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 1252 |                         while ((i = snprintf(cpbufs[1].buf,[0m
      | [0;1;32m                                    ^~~~~~~~
[0m[1mbuiltin.c:1256:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1256 |                                 if (cpbufs[1].buf == cpbufs[1].stackbuf)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 1257 |                                         cpbufs[1].buf = NULL;[0m
      | [0;1;32m                                                             
[0m[1mbuiltin.c:1262:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1262 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1263 |                                         cpbufs[1].bufsize *= 2;[0m
      | [0;1;32m                                                               
[0m[1mbuiltin.c:1268:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1268 |                         if (i < 1)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1269 |                                 goto out_of_range;[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1276:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1276 |                                 PREPEND(*chp);[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1276:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1276 |                                 PREPEND(*chp);[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1285:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1285 |                                                         PREPEND(ts[k]);[0m
      | [0;1;32m                                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1285:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1285 |                                                         PREPEND(ts[k]);[0m
      | [0;1;32m                                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1288:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1288 |                                         if (loc.grouping[ii+1] == 0)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1289 |                                                 jj = 0;         /* keep using current val in loc.grouping[ii] */[0m
 1290 |                                         else if (loc.grouping[ii+1] == CHAR_MAX)[0m
      | [0;32m                                        } 
[0m[1mbuiltin.c:1290:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1290 |                                         else if (loc.grouping[ii+1] == CHAR_MAX)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1291 |                                                 quote_flag = false;[0m
 1292 |                                         else {[0m
      | [0;32m                                        } 
[0m[1mbuiltin.c:1302:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1302 |                                 while (cend - cp < prec)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1303 |                                         PREPEND('0');[0m
      | [0;1;32m                                                     
[0m[1mbuiltin.c:1303:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1303 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1303:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1303 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1306:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1306 |                         if (sgn)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1307 |                                 PREPEND('-');[0m
 1308 |                         else if (signchar)[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:1307:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1307 |                                 PREPEND('-');[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1307:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1307 |                                 PREPEND('-');[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1308:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1308 |                         else if (signchar)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1309 |                                 PREPEND(signchar);[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1309:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1309 |                                 PREPEND(signchar);[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1309:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1309 |                                 PREPEND(signchar);[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1320:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1320 |                                  || (fw == 0 && have_prec)))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1321 |                                 fill = zero_string;[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:1322:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1322 |                         if (prec > fw)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1323 |                                 fw = prec;[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:1334:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1334 |                         chbuf = Uchbuf; /* FALL THROUGH */[0m
      | [0;1;32m                        ^             
[0m      | [0;32m                        {             ;} 
[0m[1mbuiltin.c:1336:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1336 |                         base += 6;      /* FALL THROUGH */[0m
      | [0;1;32m                        ^        
[0m      | [0;32m                        {        ;} 
[0m[1mbuiltin.c:1338:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1338 |                         base += 2;      /* FALL THROUGH */[0m
      | [0;1;32m                        ^        
[0m      | [0;32m                        {        ;} 
[0m[1mbuiltin.c:1340:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1340 |                         base += 8;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:1345:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1345 |                         if (out_of_range(arg))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1346 |                                 goto out_of_range;[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1431:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1431 |                         if (! alt && have_prec && prec == 0 && tmpval == 0)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 1432 |                                 goto pr_tail;[0m
      | [0;1;32m                                             
[0m[1mbuiltin.c:1436:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1436 |                                 if ((AWKNUM)(intmax_t)uval != double_to_int(tmpval))[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m 1437 |                                         goto out_of_range;[0m
      | [0;1;32m                                                          
[0m[1mbuiltin.c:1440:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1440 |                                 if ((AWKNUM)uval != double_to_int(tmpval))[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 1441 |                                         goto out_of_range;[0m
      | [0;1;32m                                                          
[0m[1mbuiltin.c:1459:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1459 |                                  || (fw == 0 && have_prec)))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1460 |                                 fill = zero_string;[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:1463:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1463 |                                 PREPEND(chbuf[uval % base]);[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1463:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1463 |                                 PREPEND(chbuf[uval % base]);[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1472:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1472 |                                                         PREPEND(ts[k]);[0m
      | [0;1;32m                                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1472:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1472 |                                                         PREPEND(ts[k]);[0m
      | [0;1;32m                                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1475:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1475 |                                         if (loc.grouping[ii+1] == 0)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1476 |                                                 jj = 0;     /* keep using current val in loc.grouping[ii] */[0m
 1477 |                                         else if (loc.grouping[ii+1] == CHAR_MAX)[0m
      | [0;32m                                        } 
[0m[1mbuiltin.c:1477:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1477 |                                         else if (loc.grouping[ii+1] == CHAR_MAX)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1478 |                                                 quote_flag = false;[0m
 1479 |                                         else {[0m
      | [0;32m                                        } 
[0m[1mbuiltin.c:1489:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1489 |                                 while (cend - cp < prec)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1490 |                                         PREPEND('0');[0m
      | [0;1;32m                                                     
[0m[1mbuiltin.c:1490:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1490 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1490:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1490 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1495:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1495 |                                         PREPEND(cs1);[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1495:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1495 |                                         PREPEND(cs1);[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1496:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1496 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1496:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1496 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1498:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1498 |                                                 bchunk(cp, 2);[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1498:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1498 |                                                 bchunk(cp, 2);[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1502:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1502 |                                 } else if (base == 8)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1503 |                                         PREPEND('0');[0m
      | [0;1;32m                                                     
[0m[1mbuiltin.c:1503:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1503 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1503:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1503 |                                         PREPEND('0');[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:836:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREPEND'[0m
  836 |                 memcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,    \[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:1505:4: [0m[0;1;35mwarning: [0m[1mValue stored to 'base' is never read [clang-analyzer-deadcode.DeadStores][0m
 1505 |                         base = 0;[0m
      | [0;1;32m                        ^      ~
[0m[1mbuiltin.c:1505:4: [0m[0;1;36mnote: [0mValue stored to 'base' is never read[0m
 1505 |                         base = 0;[0m
      | [0;1;32m                        ^      ~
[0m[1mbuiltin.c:1506:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1506 |                         if (prec > fw)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1507 |                                 fw = prec;[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:1517:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1517 |                         if (fw == 0 && ! have_prec)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1518 |                                 ;[0m
 1519 |                         else if (gawk_mb_cur_max > 1) {[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:1528:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1528 |                         bchunk(cp, copy_count);[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1528:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1528 |                         bchunk(cp, copy_count);[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1543:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1543 |                                 if (do_lint && ! do_posix && ! magic_posix_flag)[0m
      | [0;1;32m                                                                                ^
[0m      | [0;32m                                                                                 {
[0m 1544 |                                         lintwarn(_("[s]printf: value %g is out of range for `%%%c' format"),[0m
 1545 |                                                                 (double) tmpval, cs1);[0m
      | [0;1;32m                                                                                      
[0m[1mbuiltin.c:1547:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1547 |                                 if (strchr("aAeEfFgG", cs1) == NULL)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 1548 |                                         cs1 = 'g';[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1551:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1551 |                                 if (do_lint)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1552 |                                         lintwarn(_("[s]printf: value %s is out of range for `%%%c' format"),[0m
 1553 |                                                                 nan_inf_val, cs1);[0m
      | [0;1;32m                                                                                  
[0m[1mbuiltin.c:1554:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1554 |                                 bchunk(nan_inf_val, strlen(nan_inf_val));[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1554:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1554 |                                 bchunk(nan_inf_val, strlen(nan_inf_val));[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1581:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1581 |                         need_format = false;[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m[1mbuiltin.c:1585:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1585 |                         if (! is_mpg_number(arg))[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1586 |                                 tmpval = arg->numbr;[0m
      | [0;1;32m                                                    
[0m[1mbuiltin.c:1598:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1598 |                         if (out_of_range(arg))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1599 |                                 goto out_of_range;[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1602:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1602 |                         if (! have_prec)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1603 |                                 prec = DEFAULT_G_PRECISION;[0m
      | [0;1;32m                                                           
[0m[1mbuiltin.c:1610:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1610 |                         if (lj)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1611 |                                 *cp++ = '-';[0m
      | [0;1;32m                                            
[0m[1mbuiltin.c:1612:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1612 |                         if (signchar)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1613 |                                 *cp++ = signchar;[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:1614:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1614 |                         if (alt)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1615 |                                 *cp++ = '#';[0m
      | [0;1;32m                                            
[0m[1mbuiltin.c:1616:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1616 |                         if (zero_flag)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1617 |                                 *cp++ = '0';[0m
      | [0;1;32m                                            
[0m[1mbuiltin.c:1618:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1618 |                         if (quote_flag)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1619 |                                 *cp++ = '\'';[0m
      | [0;1;32m                                             
[0m[1mbuiltin.c:1622:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1622 |                         if (quote_flag && ! use_lc_numeric)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1623 |                                 setlocale(LC_NUMERIC, "");[0m
      | [0;1;32m                                                          
[0m[1mbuiltin.c:1651:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1651 |                                 if (have_prec || tolower(cs1) != 'a') {[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 1652 |                                         sprintf(cp, "*.*%c", cs1);[0m
 1653 |                                         while ((nc = snprintf(obufout, ofre, cpbuf,[0m
 1654 |                                                      (int) fw, (int) prec,[0m
 1655 |                                                      (double) tmpval)) >= (int) ofre)[0m
 1656 |                                                 chksize(nc)[0m
 1657 |                                 } else {[0m
 1658 |                                         // For %a and %A, use the default precision if it[0m
 1659 |                                         // wasn't supplied by the user.[0m
 1660 |                                         sprintf(cp, "*%c", cs1);[0m
 1661 |                                         while ((nc = snprintf(obufout, ofre, cpbuf,[0m
 1662 |                                                      (int) fw,[0m
 1663 |                                                      (double) tmpval)) >= (int) ofre)[0m
 1664 |                                                 chksize(nc)[0m
 1665 |                                 }[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mbuiltin.c:1652:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1652 |                                         sprintf(cp, "*.*%c", cs1);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mbuiltin.c:1652:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1652 |                                         sprintf(cp, "*.*%c", cs1);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mbuiltin.c:1653:19: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1653 |                                         while ((nc = snprintf(obufout, ofre, cpbuf,[0m
      | [0;1;32m                                                     ^~~~~~~~
[0m[1mbuiltin.c:1653:19: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 1653 |                                         while ((nc = snprintf(obufout, ofre, cpbuf,[0m
      | [0;1;32m                                                     ^~~~~~~~
[0m[1mbuiltin.c:1655:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1655 |                                                      (double) tmpval)) >= (int) ofre)[0m
      | [0;1;32m                                                                                     ^
[0m[1mbuiltin.c:1660:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1660 |                                         sprintf(cp, "*%c", cs1);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mbuiltin.c:1660:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1660 |                                         sprintf(cp, "*%c", cs1);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mbuiltin.c:1661:19: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1661 |                                         while ((nc = snprintf(obufout, ofre, cpbuf,[0m
      | [0;1;32m                                                     ^~~~~~~~
[0m[1mbuiltin.c:1661:19: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 1661 |                                         while ((nc = snprintf(obufout, ofre, cpbuf,[0m
      | [0;1;32m                                                     ^~~~~~~~
[0m[1mbuiltin.c:1663:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1663 |                                                      (double) tmpval)) >= (int) ofre)[0m
      | [0;1;32m                                                                                     ^
[0m[1mbuiltin.c:1669:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1669 |                         if (quote_flag && ! use_lc_numeric)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1670 |                                 setlocale(LC_NUMERIC, "C");[0m
      | [0;1;32m                                                           
[0m[1mbuiltin.c:1678:5: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1678 |                                 strcpy(obufout, new_text);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mbuiltin.c:1678:5: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 1678 |                                 strcpy(obufout, new_text);[0m
      | [0;1;32m                                ^~~~~~
[0m[1mbuiltin.c:1687:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1687 |                         if (do_lint && is_alpha(cs1))[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 1688 |                                 lintwarn(_("ignoring unknown format specifier character `%c': no argument converted"), cs1);[0m
 1689 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mbuiltin.c:1687:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1687 |                         if (do_lint && is_alpha(cs1))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1688 |                                 lintwarn(_("ignoring unknown format specifier character `%c': no argument converted"), cs1);[0m
      | [0;1;32m                                                                                                                            
[0m[1mbuiltin.c:1700:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1700 |                 if (need_format)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1701 |                         lintwarn([0m
 1702 |                         _("[s]printf: format specifier does not have control letter"));[0m
      | [0;1;32m                                                                                       
[0m[1mbuiltin.c:1703:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1703 |                 if (cur_arg < num_args)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1704 |                         lintwarn([0m
 1705 |                         _("too many arguments supplied for format string"));[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:1707:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1707 |         bchunk(s0, s1 - s0);[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1707:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1707 |         bchunk(s0, s1 - s0);[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:722:2: [0m[0;1;36mnote: [0mexpanded from macro 'bchunk'[0m
  722 |         memcpy(obufout, s, (size_t) (l)); \[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:1710:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1710 |         if (ofre > GIVE_BACK_SIZE)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1711 |                 erealloc(obuf, char *, olen_final + 1, "format_tree");[0m
      | [0;1;32m                                                                      
[0m[1mbuiltin.c:1719:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1719 |                         if (cpbufs[k].buf != cpbufs[k].stackbuf)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 1720 |                                 efree(cpbufs[k].buf);[0m
      | [0;1;32m                                                     
[0m[1mbuiltin.c:1722:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1722 |                 if (obuf != NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1723 |                         efree(obuf);[0m
      | [0;1;32m                                    
[0m[1mbuiltin.c:1726:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1726 |         if (r == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1727 |                 gawk_exit(EXIT_FATAL);[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1744:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1744 |                         while (--i > 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1745 |                                 DEREF(args_array[nargs - i]);[0m
      | [0;1;32m                                                             
[0m[1mbuiltin.c:1751:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1751 |         if (do_lint && (fixtype(args_array[0])->flags & STRING) == 0)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1752 |                 lintwarn(_("%s: received non-string format string argument"), "printf/sprintf");[0m
      | [0;1;32m                                                                                                
[0m[1mbuiltin.c:1754:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1754 |         for (i = 0; i < nargs; i++)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1755 |                 DEREF(args_array[i]);[0m
      | [0;1;32m                                     
[0m[1mbuiltin.c:1766:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1766 |         if (nargs == 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1767 |                 fatal(_("sprintf: no arguments"));[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1770:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1770 |         if (r == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1771 |                 gawk_exit(EXIT_FATAL);[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1789:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1789 |                         if (do_lint)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1790 |                                 lintwarn(_("printf: no arguments"));[0m
      | [0;1;32m                                                                    
[0m[1mbuiltin.c:1793:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1793 |                                 if (redir_exp->type != Node_val)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 1794 |                                         fatal(_("attempt to use array `%s' in a scalar context"), array_vname(redir_exp));[0m
      | [0;1;32m                                                                                                                          
[0m[1mbuiltin.c:1795:5: [0m[0;1;35mwarning: [0m[1mValue stored to 'rp' is never read [clang-analyzer-deadcode.DeadStores][0m
 1795 |                                 rp = redirect(redir_exp, redirtype, & errflg, true);[0m
      | [0;1;32m                                ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1795:5: [0m[0;1;36mnote: [0mValue stored to 'rp' is never read[0m
 1795 |                                 rp = redirect(redir_exp, redirtype, & errflg, true);[0m
      | [0;1;32m                                ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1806:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1806 |                 if (redir_exp->type != Node_val)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1807 |                         fatal(_("attempt to use array `%s' in a scalar context"), array_vname(redir_exp));[0m
      | [0;1;32m                                                                                                          
[0m[1mbuiltin.c:1824:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1824 |         } else if (do_debug)    /* only the debugger can change the default output */[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1825 |                 fp = output_fp;[0m
 1826 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:1826:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1826 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1827 |                 fp = stdout;[0m
      | [0;1;32m                            
[0m[1mbuiltin.c:1840:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1840 |                 if (rp != NULL && (rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1841 |                         rp->output.gawk_fflush(rp->output.fp, rp->output.opaque);[0m
      | [0;1;32m                                                                                 
[0m[1mbuiltin.c:1843:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1843 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1844 |                 gawk_exit(EXIT_FATAL);[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:1858:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1858 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1859 |                 lintwarn(_("%s: received non-numeric argument"), "sqrt");[0m
      | [0;1;32m                                                                         
[0m[1mbuiltin.c:1862:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1862 |         if (arg < 0.0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1863 |                 warning(_("%s: received negative argument %g"), "sqrt", arg);[0m
      | [0;1;32m                                                                             
[0m[1mbuiltin.c:1883:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1883 |                 if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 1884 |                         lintwarn(_("%s: received non-numeric third argument"), "substr");[0m
      | [0;1;32m                                                                                         
[0m[1mbuiltin.c:1890:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1890 |         if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1891 |                 lintwarn(_("%s: received non-numeric second argument"), "substr");[0m
      | [0;1;32m                                                                                  
[0m[1mbuiltin.c:1896:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1896 |         if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 1897 |                 lintwarn(_("%s: received non-string first argument"), "substr");[0m
      | [0;1;32m                                                                                
[0m[1mbuiltin.c:1901:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1901 |                         if (do_lint == DO_LINT_ALL)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1902 |                                 lintwarn(_("substr: length %g is not >= 1"), d_length);[0m
 1903 |                         else if (do_lint == DO_LINT_INVALID && ! (d_length >= 0))[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:1903:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1903 |                         else if (do_lint == DO_LINT_INVALID && ! (d_length >= 0))[0m
      | [0;1;32m                                                                                 ^
[0m      | [0;32m                                                                                  {
[0m 1904 |                                 lintwarn(_("substr: length %g is not >= 0"), d_length);[0m
      | [0;1;32m                                                                                       
[0m[1mbuiltin.c:1916:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1916 |                         if (double_to_int(d_length) != d_length)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 1917 |                                 lintwarn([0m
 1918 |                         _("substr: non-integer length %g will be truncated"),[0m
 1919 |                                         d_length);[0m
      | [0;1;32m                                                  
[0m[1mbuiltin.c:1921:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1921 |                         if (d_length > SIZE_MAX)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1922 |                                 lintwarn([0m
 1923 |                         _("substr: length %g too big for string indexing, truncating to %g"),[0m
 1924 |                                         d_length, (double) SIZE_MAX);[0m
      | [0;1;32m                                                                     
[0m[1mbuiltin.c:1926:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1926 |                 if (d_length < SIZE_MAX)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1927 |                         length = d_length;[0m
 1928 |                 else[0m
      | [0;32m                } 
[0m[1mbuiltin.c:1928:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1928 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1929 |                         length = SIZE_MAX;[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:1934:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1934 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1935 |                         lintwarn(_("substr: start index %g is invalid, using 1"),[0m
 1936 |                                  d_index);[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:1939:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1939 |         if (do_lint && double_to_int(d_index) != d_index)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1940 |                 lintwarn(_("substr: non-integer start index %g will be truncated"),[0m
 1941 |                          d_index);[0m
      | [0;1;32m                                  
[0m[1mbuiltin.c:1944:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1944 |         if (d_index <= SIZE_MAX)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1945 |                 indx = d_index - 1;[0m
 1946 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:1946:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1946 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1947 |                 indx = SIZE_MAX;[0m
      | [0;1;32m                                
[0m[1mbuiltin.c:1954:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1954 |                         if (t1->wstlen > 0)     /* use length of wide char string if we have one */[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1955 |                                 length = t1->wstlen - indx;[0m
      | [0;1;32m                                                           
[0m[1mbuiltin.c:1962:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1962 |                 if (do_lint && (do_lint == DO_LINT_ALL || ((indx | length) != 0)))[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 1963 |                         lintwarn(_("substr: source string is zero length"));[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:1972:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1972 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1973 |                 src_len = t1->stlen;[0m
      | [0;1;32m                                    
[0m[1mbuiltin.c:1976:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1976 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1977 |                         lintwarn(_("substr: start index %g is past end of string"),[0m
 1978 |                                 d_index);[0m
      | [0;1;32m                                         
[0m[1mbuiltin.c:1983:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1983 |                 if (do_lint)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1984 |                         lintwarn([0m
 1985 |         _("substr: length %g at start index %g exceeds length of first argument (%lu)"),[0m
 1986 |                         d_length, d_index, (unsigned long int) src_len);[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:1991:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1991 |         if (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1992 |                 /* single byte case */[0m
 1993 |                 r = make_string(t1->stptr + indx, length);[0m
 1994 |         else {[0m
      | [0;32m        } 
[0m[1mbuiltin.c:2006:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2006 |                 memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:2006:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 2006 |                 memset(& mbs, 0, sizeof(mbs));[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:2011:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2011 |                         if (result == (size_t) -1)      /* what to do? break seems best */[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 2012 |                                 break;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:2016:7: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'cp') [clang-analyzer-core.NullDereference][0m
 2016 |                 *cp = '\0';[0m
      | [0;1;32m                 ~~ ^
[0m[1mbuiltin.c:1881:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 3[0m
 1881 |         if (nargs == 3) {[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mbuiltin.c:1881:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1881 |         if (nargs == 3) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1890:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1890 |         if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1890:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1890 |         if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                    ^
[0m[1mbuiltin.c:1896:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1896 |         if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1896:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1896 |         if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                    ^
[0m[1mbuiltin.c:1899:6: [0m[0;1;36mnote: [0m'nargs' is not equal to 3[0m
 1899 |         if (nargs == 3) {[0m
      | [0;1;32m            ^~~~~
[0m[1mbuiltin.c:1899:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1899 |         if (nargs == 3) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1933:6: [0m[0;1;36mnote: [0mAssuming 'd_index' is >= 1[0m
 1933 |         if (! (d_index >= 1)) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1933:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1933 |         if (! (d_index >= 1)) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1939:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1939 |         if (do_lint && double_to_int(d_index) != d_index)[0m
      | [0;1;32m                    ^
[0m[1mbuiltin.c:1944:6: [0m[0;1;36mnote: [0mAssuming 'd_index' is <= SIZE_MAX[0m
 1944 |         if (d_index <= SIZE_MAX)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1944:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1944 |         if (d_index <= SIZE_MAX)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1949:6: [0m[0;1;36mnote: [0m'nargs' is equal to 2[0m
 1949 |         if (nargs == 2) {       /* third arg. missing */[0m
      | [0;1;32m            ^~~~~
[0m[1mbuiltin.c:1949:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 1949 |         if (nargs == 2) {       /* third arg. missing */[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1952:7: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 1952 |                 if (gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1952:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1952 |                 if (gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:1960:6: [0m[0;1;36mnote: [0mAssuming field 'slen' is not equal to 0[0m
 1960 |         if (t1->stlen == 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~
[0m[1mbuiltin.c:1960:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1960 |         if (t1->stlen == 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1969:6: [0m[0;1;36mnote: [0m'gawk_mb_cur_max' is <= 1[0m
 1969 |         if (gawk_mb_cur_max > 1) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1969:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1969 |         if (gawk_mb_cur_max > 1) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1975:6: [0m[0;1;36mnote: [0mAssuming 'indx' is < 'src_len'[0m
 1975 |         if (indx >= src_len) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1975:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1975 |         if (indx >= src_len) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1982:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1982 |         if (length > src_len - indx) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:1991:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is not equal to 1[0m
 1991 |         if (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1991:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:1991:30: [0m[0;1;36mnote: [0mAssuming field 'wslen' is not equal to field 'slen'[0m
 1991 |         if (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:1991:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 1991 |         if (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:2009:21: [0m[0;1;36mnote: [0mAssuming 'length' is > 0[0m
 2009 |                 for (cp = substr; length > 0; length--) {[0m
      | [0;1;32m                                  ^~~~~~~~~~
[0m[1mbuiltin.c:2009:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 2009 |                 for (cp = substr; length > 0; length--) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:2010:4: [0m[0;1;36mnote: [0mValue assigned to 'result'[0m
 2010 |                         result = wcrtomb(cp, *wp, & mbs);[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2011:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 2011 |                         if (result == (size_t) -1)      /* what to do? break seems best */[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2011:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 2011 |                         if (result == (size_t) -1)      /* what to do? break seems best */[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:2013:4: [0m[0;1;36mnote: [0mNull pointer value stored to 'cp'[0m
 2013 |                         cp += result;[0m
      | [0;1;32m                        ^~~~~~~~~~~~
[0m[1mbuiltin.c:2009:21: [0m[0;1;36mnote: [0mAssuming 'length' is <= 0[0m
 2009 |                 for (cp = substr; length > 0; length--) {[0m
      | [0;1;32m                                  ^~~~~~~~~~
[0m[1mbuiltin.c:2009:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 2016[0m
 2009 |                 for (cp = substr; length > 0; length--) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:2016:7: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'cp')[0m
 2016 |                 *cp = '\0';[0m
      | [0;1;32m                 ~~ ^
[0m[1mbuiltin.c:2059:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2059 |                         if (do_lint && (fixtype(val)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m 2060 |                                 lintwarn(_("strftime: format value in PROCINFO[\"strftime\"] has numeric type"));[0m
      | [0;1;32m                                                                                                                 
[0m[1mbuiltin.c:2080:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2080 |                         if (do_lint && (fixtype(t2)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 2081 |                                 lintwarn(_("%s: received non-numeric second argument"), "strftime");[0m
      | [0;1;32m                                                                                                    
[0m[1mbuiltin.c:2090:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2090 |                                 if (do_lint)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2091 |                                         lintwarn(_("strftime: second argument less than 0 or too big for time_t"));[0m
      | [0;1;32m                                                                                                                   
[0m[1mbuiltin.c:2097:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2097 |                                 if (do_lint)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2098 |                                         lintwarn(_("strftime: second argument out of range for time_t"));[0m
      | [0;1;32m                                                                                                         
[0m[1mbuiltin.c:2106:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2106 |                 if (do_lint && (fixtype(tmp)->flags & STRING) == 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 2107 |                         lintwarn(_("%s: received non-string first argument"), "strftime");[0m
      | [0;1;32m                                                                                          
[0m[1mbuiltin.c:2113:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2113 |                         if (do_lint)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2114 |                                 lintwarn(_("strftime: received empty format string"));[0m
      | [0;1;32m                                                                                      
[0m[1mbuiltin.c:2121:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2121 |         if (do_gmt)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 2122 |                 tm = gmtime(& fclock);[0m
 2123 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:2123:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2123 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2124 |                 tm = localtime(& fclock);[0m
      | [0;1;32m                                         
[0m[1mbuiltin.c:2144:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2144 |                 if (buflen > 0 || bufsize >= 1024 * formatlen)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2145 |                         break;[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:2147:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2147 |                 if (bufp == buf)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 2148 |                         emalloc(bufp, char *, bufsize, "do_strftime");[0m
 2149 |                 else[0m
      | [0;32m                } 
[0m[1mbuiltin.c:2149:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2149 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2150 |                         erealloc(bufp, char *, bufsize, "do_strftime");[0m
      | [0;1;32m                                                                       
[0m[1mbuiltin.c:2153:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2153 |         if (bufp != buf)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2154 |                 efree(bufp);[0m
      | [0;1;32m                            
[0m[1mbuiltin.c:2197:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2197 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2198 |                 do_gmt = false;[0m
      | [0;1;32m                               
[0m[1mbuiltin.c:2200:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2200 |         if (do_lint && (fixtype(t1)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2201 |                 lintwarn(_("%s: received non-string argument"), "mktime");[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:2207:10: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2207 |         count = sscanf(t1->stptr, "%ld %d %d %d %d %d %d",[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:2207:10: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
 2207 |         count = sscanf(t1->stptr, "%ld %d %d %d %d %d %d",[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:2219:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2219 |                 || (month < 1 || month > 12) ))[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 2220 |                         lintwarn(_("mktime: at least one of the values is out of the default range"));[0m
      | [0;1;32m                                                                                                      
[0m[1mbuiltin.c:2228:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2228 |             || year - 1900 > INT_MAX)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2229 |                 return make_number((AWKNUM) -1);[0m
      | [0;1;32m                                                
[0m[1mbuiltin.c:2231:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2231 |         memset(& then, '\0', sizeof(then));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:2231:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 2231 |         memset(& then, '\0', sizeof(then));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:2257:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2257 |         if (do_sandbox)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2258 |                 fatal(_("'system' function not allowed in sandbox mode"));[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:2262:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2262 |         if (do_lint && (fixtype(tmp)->flags & STRING) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2263 |                 lintwarn(_("%s: received non-string argument"), "system");[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:2284:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2284 |                         if (do_posix)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2285 |                                 ;       /* leave it alone, full 16 bits */[0m
 2286 |                         else if (do_traditional)[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:2286:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2286 |                         else if (do_traditional)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 2287 | #ifdef __MINGW32__[0m
 2288 |                                 ret = (((unsigned)status) & ~0xC0000000);[0m
 2289 | #else[0m
 2290 |                                 ret = (status / 256.0);[0m
 2291 | #endif[0m
 2292 |                         else[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:2292:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2292 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2293 |                                 ret = sanitize_exit_status(status);[0m
      | [0;1;32m                                                                   
[0m[1mbuiltin.c:2296:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2296 |                 if ((BINMODE & BINMODE_INPUT) != 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2297 |                         os_setbinmode(fileno(stdin), O_BINARY);[0m
      | [0;1;32m                                                               
[0m[1mbuiltin.c:2322:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2322 |                 if (redir_exp->type != Node_val)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 2323 |                         fatal(_("attempt to use array `%s' in a scalar context"), array_vname(redir_exp));[0m
      | [0;1;32m                                                                                                          
[0m[1mbuiltin.c:2340:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2340 |         } else if (do_debug)    /* only the debugger can change the default output */[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2341 |                 fp = output_fp;[0m
 2342 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:2342:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2342 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 2343 |                 fp = stdout;[0m
      | [0;1;32m                            
[0m[1mbuiltin.c:2348:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2348 |                         while (--i > 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2349 |                                 DEREF(args_array[i]);[0m
      | [0;1;32m                                                     
[0m[1mbuiltin.c:2355:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2355 |                 if (args_array[i] != tmp)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2356 |                         DEREF(tmp);[0m
      | [0;1;32m                                   
[0m[1mbuiltin.c:2365:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2365 |                 for (i = nargs; i > 0; i--)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2366 |                         DEREF(args_array[i]);[0m
      | [0;1;32m                                             
[0m[1mbuiltin.c:2373:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2373 |                 if (i != 1 && OFSlen > 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2374 |                         efwrite(OFS, sizeof(char), (size_t) OFSlen,[0m
 2375 |                                 fp, "print", rp, false);[0m
      | [0;1;32m                                                        
[0m[1mbuiltin.c:2378:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2378 |         if (ORSlen > 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2379 |                 efwrite(ORS, sizeof(char), (size_t) ORSlen, fp, "print", rp, true);[0m
      | [0;1;32m                                                                                   
[0m[1mbuiltin.c:2381:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2381 |         if (rp != NULL && (rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2382 |                 rp->output.gawk_fflush(rp->output.fp, rp->output.opaque);[0m
      | [0;1;32m                                                                         
[0m[1mbuiltin.c:2413:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2413 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2414 |                 fp = output_fp;[0m
      | [0;1;32m                               
[0m[1mbuiltin.c:2421:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2421 |         if (fp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2422 |                 return;[0m
      | [0;1;32m                       
[0m[1mbuiltin.c:2424:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2424 |         if (! field0_valid || do_lint)  // lint check for field access in END[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2425 |                 (void) get_field(0L, NULL);[0m
      | [0;1;32m                                           
[0m[1mbuiltin.c:2429:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2429 |         if (do_lint && (f0->flags & NULL_FIELD) != 0)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2430 |                 lintwarn(_("reference to uninitialized field `$%d'"), 0);[0m
      | [0;1;32m                                                                         
[0m[1mbuiltin.c:2434:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2434 |         if (ORSlen > 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2435 |                 efwrite(ORS, sizeof(char), (size_t) ORSlen, fp, "print", rp, true);[0m
      | [0;1;32m                                                                                   
[0m[1mbuiltin.c:2437:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2437 |         if (rp != NULL && (rp->flag & RED_TWOWAY) != 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2438 |                 rp->output.gawk_fflush(rp->output.fp, rp->output.opaque);[0m
      | [0;1;32m                                                                         
[0m[1mbuiltin.c:2485:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2485 |         for (i = 0, wcp = wstr; i < wlen; i++, wcp++)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 2486 |                 if (is_x(*wcp))[0m
 2487 |                         *wcp = to_y(*wcp);[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:2486:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2486 |                 if (is_x(*wcp))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2487 |                         *wcp = to_y(*wcp);[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:2516:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2516 |         if (do_lint && (fixtype(t1)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2517 |                 lintwarn(_("%s: received non-string argument"), "tolower");[0m
      | [0;1;32m                                                                           
[0m[1mbuiltin.c:2526:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2526 |                         cp < cp2; cp++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2527 |                         if (isupper(*cp))[0m
 2528 |                                 *cp = tolower(*cp);[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:2527:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2527 |                         if (isupper(*cp))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2528 |                                 *cp = tolower(*cp);[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:2549:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2549 |         if (do_lint && (fixtype(t1)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2550 |                 lintwarn(_("%s: received non-string argument"), "toupper");[0m
      | [0;1;32m                                                                           
[0m[1mbuiltin.c:2559:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2559 |                         cp < cp2; cp++)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2560 |                         if (islower(*cp))[0m
 2561 |                                 *cp = toupper(*cp);[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:2560:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2560 |                         if (islower(*cp))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2561 |                                 *cp = toupper(*cp);[0m
      | [0;1;32m                                                   
[0m[1mbuiltin.c:2584:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2584 |                 if ((fixtype(t1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2585 |                         lintwarn(_("%s: received non-numeric first argument"), "atan2");[0m
      | [0;1;32m                                                                                        
[0m[1mbuiltin.c:2586:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2586 |                 if ((fixtype(t2)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2587 |                         lintwarn(_("%s: received non-numeric second argument"), "atan2");[0m
      | [0;1;32m                                                                                         
[0m[1mbuiltin.c:2607:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2607 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2608 |                 lintwarn(_("%s: received non-numeric argument"), "sin");[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:2625:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2625 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2626 |                 lintwarn(_("%s: received non-numeric argument"), "cos");[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:2740:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2740 |         if (nargs == 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2741 |                 srandom((unsigned int) (save_seed = (long) time((time_t *) 0)));[0m
 2742 |         else {[0m
      | [0;32m        } 
[0m[1mbuiltin.c:2744:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2744 |                 if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 2745 |                         lintwarn(_("%s: received non-numeric argument"), "srand");[0m
      | [0;1;32m                                                                                  
[0m[1mbuiltin.c:2777:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2777 |                 if (dest->type != Node_var_array)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2778 |                         fatal(_("match: third argument is not an array"));[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:2786:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2786 |         if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 2787 |                 lintwarn(_("%s: received non-string first argument"), "match");[0m
      | [0;1;32m                                                                               
[0m[1mbuiltin.c:2820:22: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'wc_indices') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 2820 |                                                 subpat_start = wc_indices[s];[0m
      | [0;1;32m                                                               ^
[0m[1mbuiltin.c:3470:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is >= 2[0m
 3470 |         if (nargs < 2 || nargs > 3)[0m
      | [0;1;32m            ^~~~~~~~~
[0m[1mbuiltin.c:3470:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3470:19: [0m[0;1;36mnote: [0mAssuming 'nargs' is <= 3[0m
 3470 |         if (nargs < 2 || nargs > 3)[0m
      | [0;1;32m                         ^~~~~~~~~
[0m[1mbuiltin.c:3470:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3470 |         if (nargs < 2 || nargs > 3)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3474:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is equal to 3[0m
 3474 |         if (nargs == 3)[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mbuiltin.c:3474:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3474 |         if (nargs == 3)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3481:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3481 |         if ((regex->flags & REGEX) != 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3481:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3481 |         if ((regex->flags & REGEX) != 0)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3488:2: [0m[0;1;36mnote: [0mAssuming 'stack_ptr' is < 'stack_top'[0m
 3488 |         PUSH(regex);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1262:27: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH'[0m
 1262 | #define PUSH(r)                 (void) (incr_sp()->rptr = (r))[0m
      | [0;1;32m                                        ^~~~~~~~~
[0m[1m./awk.h:1253:22: [0m[0;1;36mnote: [0mexpanded from macro 'incr_sp'[0m
 1253 | #define incr_sp()               ((stack_ptr < stack_top) ? ++stack_ptr : grow_stack())[0m
      | [0;1;32m                                  ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3488:2: [0m[0;1;36mnote: [0m'?' condition is true[0m
 3488 |         PUSH(regex);[0m
      | [0;1;32m        ^
[0m[1m./awk.h:1262:27: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH'[0m
 1262 | #define PUSH(r)                 (void) (incr_sp()->rptr = (r))[0m
      | [0;1;32m                                        ^
[0m[1m./awk.h:1253:21: [0m[0;1;36mnote: [0mexpanded from macro 'incr_sp'[0m
 1253 | #define incr_sp()               ((stack_ptr < stack_top) ? ++stack_ptr : grow_stack())[0m
      | [0;1;32m                                 ^
[0m[1mbuiltin.c:3490:6: [0m[0;1;36mnote: [0mAssuming 'array' is null[0m
 3490 |         if (array)[0m
      | [0;1;32m            ^~~~~
[0m[1mbuiltin.c:3490:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3490 |         if (array)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3493:11: [0m[0;1;36mnote: [0mCalling 'do_match'[0m
 3493 |         result = do_match(nargs);[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2775:6: [0m[0;1;36mnote: [0m'nargs' is equal to 3[0m
 2775 |         if (nargs == 3) {       /* 3rd optional arg for the subpatterns */[0m
      | [0;1;32m            ^~~~~
[0m[1mbuiltin.c:2775:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 2775 |         if (nargs == 3) {       /* 3rd optional arg for the subpatterns */[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:2777:7: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to Node_var_array[0m
 2777 |                 if (dest->type != Node_var_array)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2777:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 2777 |                 if (dest->type != Node_var_array)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:2786:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 2786 |         if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m            ^
[0m[1m./awk.h:1201:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_lint'[0m
 1201 | #define do_lint             (do_flags & (DO_LINT_INVALID|DO_LINT_ALL))[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2786:14: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 2786 |         if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)[0m
      | [0;1;32m                    ^
[0m[1mbuiltin.c:2790:6: [0m[0;1;36mnote: [0mAssuming 'rstart' is >= 0[0m
 2790 |         if (rstart >= 0) {      /* match succeded */[0m
      | [0;1;32m            ^~~~~~~~~~~
[0m[1mbuiltin.c:2790:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 2790 |         if (rstart >= 0) {      /* match succeded */[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:2791:3: [0m[0;1;36mnote: [0m'wc_indices' initialized to a null pointer value[0m
 2791 |                 size_t *wc_indices = NULL;[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2794:7: [0m[0;1;36mnote: [0mAssuming 'rlength' is <= 0[0m
 2794 |                 if (rlength > 0 && gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                    ^~~~~~~~~~~
[0m[1mbuiltin.c:2794:19: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 2794 |                 if (rlength > 0 && gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:2803:7: [0m[0;1;36mnote: [0m'dest' is not equal to NULL[0m
 2803 |                 if (dest != NULL) {[0m
      | [0;1;32m                    ^~~~
[0m[1mbuiltin.c:2803:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 2803 |                 if (dest != NULL) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:2807:17: [0m[0;1;36mnote: [0mAssuming 'ii' is < field 'num_regs'[0m
 2807 |                         for (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {[0m
      | [0;1;32m                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2807:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 2807 |                         for (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:2812:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 2812 |                                 if ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2812:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 2812 |                                 if ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:2807:17: [0m[0;1;36mnote: [0mAssuming 'ii' is < field 'num_regs'[0m
 2807 |                         for (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {[0m
      | [0;1;32m                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2807:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 2807 |                         for (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:2812:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 2812 |                                 if ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2812:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 2812 |                                 if ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:2819:10: [0m[0;1;36mnote: [0mAssuming 'len' is > 0[0m
 2819 |                                         if (len > 0 && gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                                            ^~~~~~~
[0m[1mbuiltin.c:2819:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:2819:21: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is > 1[0m
 2819 |                                         if (len > 0 && gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                                                       ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:2819:6: [0m[0;1;36mnote: [0mTaking true branch[0m
 2819 |                                         if (len > 0 && gawk_mb_cur_max > 1) {[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:2820:22: [0m[0;1;36mnote: [0mArray access (from variable 'wc_indices') results in a null pointer dereference[0m
 2820 |                                                 subpat_start = wc_indices[s];[0m
      | [0;1;32m                                                               ^~~~~~~~~~
[0m[1mbuiltin.c:2828:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2828 |                                         sprintf(buff, "%d", ii);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mbuiltin.c:2828:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 2828 |                                         sprintf(buff, "%d", ii);[0m
      | [0;1;32m                                        ^~~~~~~
[0m[1mbuiltin.c:2838:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2838 |                                         memcpy(buf, buff, ilen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2838:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2838 |                                         memcpy(buf, buff, ilen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2839:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2839 |                                         memcpy(buf + ilen, subsepstr, subseplen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2839:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2839 |                                         memcpy(buf + ilen, subsepstr, subseplen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2840:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2840 |                                         memcpy(buf + ilen + subseplen, "start", 6);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2840:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2840 |                                         memcpy(buf + ilen + subseplen, "start", 6);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2846:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2846 |                                         memcpy(buf, buff, ilen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2846:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2846 |                                         memcpy(buf, buff, ilen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2847:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2847 |                                         memcpy(buf + ilen, subsepstr, subseplen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2847:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2847 |                                         memcpy(buf + ilen, subsepstr, subseplen);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2848:6: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2848 |                                         memcpy(buf + ilen + subseplen, "length", 7);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2848:6: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2848 |                                         memcpy(buf + ilen + subseplen, "length", 7);[0m
      | [0;1;32m                                        ^~~~~~
[0m[1mbuiltin.c:2858:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2858 |                 if (wc_indices != NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2859 |                         efree(wc_indices);[0m
      | [0;1;32m                                          
[0m[1mbuiltin.c:3014:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3014 |                     && (glob_flag->stptr[0] == 'g' || glob_flag->stptr[0] == 'G'))[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 3015 |                         how_many = -1;[0m
 3016 |                 else {[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3019:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3019 |                         if (d < 1)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3020 |                                 how_many = 1;[0m
 3021 |                         else if (d < LONG_MAX)[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:3021:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3021 |                         else if (d < LONG_MAX)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 3022 |                                 how_many = d;[0m
 3023 |                         else[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:3023:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3023 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3024 |                                 how_many = LONG_MAX;[0m
      | [0;1;32m                                                    
[0m[1mbuiltin.c:3045:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3046 |                         how_many = -1;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:3050:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 3051 |                         target = POP_STRING();[0m
 3052 |                 else {[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3065:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 3066 |                 goto done;[0m
      | [0;1;32m                          
[0m[1mbuiltin.c:3092:48: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'mb_indices') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 3092 |                 if ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                             ^~~~~~~~~~
[0m[1mbuiltin.c:2998:2: [0m[0;1;36mnote: [0m'mb_indices' initialized to a null pointer value[0m
 2998 |         char *mb_indices = NULL;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3092:8: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is not equal to 1[0m
 3092 |                 if ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3092:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3092:33: [0m[0;1;36mnote: [0mAssuming 'repllen' is > 0[0m
 3092 |                 if ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                              ^~~~~~~~~~~
[0m[1mbuiltin.c:3092:33: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3092:48: [0m[0;1;36mnote: [0mArray access (from variable 'mb_indices') results in a null pointer dereference[0m
 3092 |                 if ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                             ^~~~~~~~~~
[0m[1mbuiltin.c:3169:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 3170 |                         *bp++ = *scan;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:3170:10: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3170 |                         *bp++ = *scan;[0m
      | [0;1;32m                        ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3170:5: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3170 |                         *bp++ = *scan;[0m
      | [0;1;32m                         ^~~~
[0m[1mbuiltin.c:3170:10: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3170 |                         *bp++ = *scan;[0m
      | [0;1;32m                        ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3191:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m[1mbuiltin.c:3198:10: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'mb_indices') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 3198 |                                                 || mb_indices[scan - repl] == 1)[0m
      | [0;1;32m                                                   ^~~~~~~~~~
[0m[1mbuiltin.c:2998:2: [0m[0;1;36mnote: [0m'mb_indices' initialized to a null pointer value[0m
 2998 |         char *mb_indices = NULL;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3197:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is not equal to 1[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3197:10: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3198:10: [0m[0;1;36mnote: [0mArray access (from variable 'mb_indices') results in a null pointer dereference[0m
 3198 |                                                 || mb_indices[scan - repl] == 1)[0m
      | [0;1;32m                                                   ^~~~~~~~~~
[0m[1mbuiltin.c:3200:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3200 |                                                 for (cp = matchstart; cp < matchend; cp++)[0m
      | [0;1;32m                                                                                          ^
[0m      | [0;32m                                                                                           {
[0m 3201 |                                                                 *bp++ = *cp;[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:3201:15: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3201 |                                                                 *bp++ = *cp;[0m
      | [0;1;32m                                                                ~~~~~~^~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3197:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3198:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3198 |                                                 || mb_indices[scan - repl] == 1)[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3200:29: [0m[0;1;36mnote: [0mAssuming 'cp' is < 'matchend'[0m
 3200 |                                                 for (cp = matchstart; cp < matchend; cp++)[0m
      | [0;1;32m                                                                      ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3200:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3200 |                                                 for (cp = matchstart; cp < matchend; cp++)[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3201:10: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3201 |                                                                 *bp++ = *cp;[0m
      | [0;1;32m                                                                 ^~~~
[0m[1mbuiltin.c:3201:15: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3201 |                                                                 *bp++ = *cp;[0m
      | [0;1;32m                                                                ~~~~~~^~~~~
[0m[1mbuiltin.c:3204:26: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'mb_indices') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                                   ^~~~~~~~~~
[0m[1mbuiltin.c:2998:2: [0m[0;1;36mnote: [0m'mb_indices' initialized to a null pointer value[0m
 2998 |         char *mb_indices = NULL;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is not equal to 1[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3204:11: [0m[0;1;36mnote: [0mAssuming 'repllen' is > 0[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                    ^~~~~~~~~~~
[0m[1mbuiltin.c:3204:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3204:26: [0m[0;1;36mnote: [0mArray access (from variable 'mb_indices') results in a null pointer dereference[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                                   ^~~~~~~~~~
[0m[1mbuiltin.c:3217:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3217 |                                                                 for (cp = start; cp < end; cp++)[0m
      | [0;1;32m                                                                                                ^
[0m      | [0;32m                                                                                                 {
[0m 3218 |                                                                         *bp++ = *cp;[0m
      | [0;1;32m                                                                                    
[0m[1mbuiltin.c:3221:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3221 |                                                 } else  /* \q for any q --> q */[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3222 |                                                         *bp++ = *++scan;[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:3225:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3225 |                                                 if (scan[1] == '&' || scan[1] == '\\')[0m
      | [0;1;32m                                                                                      ^
[0m      | [0;32m                                                                                       {
[0m 3226 |                                                         scan++;[0m
      | [0;1;32m                                                               
[0m[1mbuiltin.c:3227:13: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3227 |                                                 *bp++ = *scan;[0m
      | [0;1;32m                                                ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3204:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3206:6: [0m[0;1;36mnote: [0mTaking false branch[0m
 3206 |                                         if (flags & GENSUB) {   /* gensub, behave sanely */[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3223:17: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                                   ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3223:13: [0m[0;1;36mnote: [0mTaking true branch[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                               ^
[0m[1mbuiltin.c:3225:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3225 |                                                 if (scan[1] == '&' || scan[1] == '\\')[0m
      | [0;1;32m                                                    ^~~~~~~~~~~~~~
[0m[1mbuiltin.c:3225:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3225:29: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3225 |                                                 if (scan[1] == '&' || scan[1] == '\\')[0m
      | [0;1;32m                                                                      ^~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3225:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3225 |                                                 if (scan[1] == '&' || scan[1] == '\\')[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3227:8: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3227 |                                                 *bp++ = *scan;[0m
      | [0;1;32m                                                 ^~~~
[0m[1mbuiltin.c:3227:13: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3227 |                                                 *bp++ = *scan;[0m
      | [0;1;32m                                                ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3234:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3234 |                                                         *bp++ = '\\';[0m
      | [0;1;32m                                                        ~~~~~~^~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3204:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3206:6: [0m[0;1;36mnote: [0mTaking false branch[0m
 3206 |                                         if (flags & GENSUB) {   /* gensub, behave sanely */[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3223:17: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                                   ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3223:13: [0m[0;1;36mnote: [0mTaking false branch[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                               ^
[0m[1mbuiltin.c:3231:11: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3231 |                                                     || strncmp(scan, "\\\\\\\\", 4) == 0) {     /* 2016: fixed */[0m
      | [0;1;32m                                                    ^
[0m[1mbuiltin.c:3234:9: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3234 |                                                         *bp++ = '\\';[0m
      | [0;1;32m                                                         ^~~~
[0m[1mbuiltin.c:3234:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3234 |                                                         *bp++ = '\\';[0m
      | [0;1;32m                                                        ~~~~~~^~~~~~
[0m[1mbuiltin.c:3239:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3239 |                                                         *bp++ = '\\';[0m
      | [0;1;32m                                                        ~~~~~~^~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3204:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3206:6: [0m[0;1;36mnote: [0mTaking false branch[0m
 3206 |                                         if (flags & GENSUB) {   /* gensub, behave sanely */[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3223:17: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                                   ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3223:13: [0m[0;1;36mnote: [0mTaking false branch[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                               ^
[0m[1mbuiltin.c:3230:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3230 |                                                 if (strncmp(scan, "\\\\\\&", 4) == 0[0m
      | [0;1;32m                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3230:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3231:14: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3231 |                                                     || strncmp(scan, "\\\\\\\\", 4) == 0) {     /* 2016: fixed */[0m
      | [0;1;32m                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3230:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3230 |                                                 if (strncmp(scan, "\\\\\\&", 4) == 0[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3237:14: [0m[0;1;36mnote: [0mTaking true branch[0m
 3237 |                                                 } else if (strncmp(scan, "\\\\&", 3) == 0) {[0m
      | [0;1;32m                                                       ^
[0m[1mbuiltin.c:3239:9: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3239 |                                                         *bp++ = '\\';[0m
      | [0;1;32m                                                         ^~~~
[0m[1mbuiltin.c:3239:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3239 |                                                         *bp++ = '\\';[0m
      | [0;1;32m                                                        ~~~~~~^~~~~~
[0m[1mbuiltin.c:3240:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3240 |                                                         for (cp = matchstart; cp < matchend; cp++)[0m
      | [0;1;32m                                                                                                  ^
[0m      | [0;32m                                                                                                   {
[0m 3241 |                                                                 *bp++ = *cp;[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:3245:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3245 |                                                         *bp++ = '&';[0m
      | [0;1;32m                                                        ~~~~~~^~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3204:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3206:6: [0m[0;1;36mnote: [0mTaking false branch[0m
 3206 |                                         if (flags & GENSUB) {   /* gensub, behave sanely */[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3223:17: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                                   ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3223:13: [0m[0;1;36mnote: [0mTaking false branch[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                               ^
[0m[1mbuiltin.c:3230:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3230 |                                                 if (strncmp(scan, "\\\\\\&", 4) == 0[0m
      | [0;1;32m                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3230:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3231:14: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3231 |                                                     || strncmp(scan, "\\\\\\\\", 4) == 0) {     /* 2016: fixed */[0m
      | [0;1;32m                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3230:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3230 |                                                 if (strncmp(scan, "\\\\\\&", 4) == 0[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3237:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3237 |                                                 } else if (strncmp(scan, "\\\\&", 3) == 0) {[0m
      | [0;1;32m                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3237:14: [0m[0;1;36mnote: [0mTaking false branch[0m
 3237 |                                                 } else if (strncmp(scan, "\\\\&", 3) == 0) {[0m
      | [0;1;32m                                                       ^
[0m[1mbuiltin.c:3243:18: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3243 |                                                 } else if (scan[1] == '&') {[0m
      | [0;1;32m                                                           ^~~~~~~~~~~~~~
[0m[1mbuiltin.c:3243:14: [0m[0;1;36mnote: [0mTaking true branch[0m
 3243 |                                                 } else if (scan[1] == '&') {[0m
      | [0;1;32m                                                       ^
[0m[1mbuiltin.c:3245:9: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3245 |                                                         *bp++ = '&';[0m
      | [0;1;32m                                                         ^~~~
[0m[1mbuiltin.c:3245:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3245 |                                                         *bp++ = '&';[0m
      | [0;1;32m                                                        ~~~~~~^~~~~
[0m[1mbuiltin.c:3247:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3247 |                                                 } else[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 3248 |                                                         *bp++ = *scan;[0m
      | [0;1;32m                                                                      
[0m[1mbuiltin.c:3248:14: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3248 |                                                         *bp++ = *scan;[0m
      | [0;1;32m                                                        ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3203:10: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is equal to 1[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3204:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3204 |                                                 || (repllen > 0 && mb_indices[scan - repl] == 1))[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3206:6: [0m[0;1;36mnote: [0mTaking false branch[0m
 3206 |                                         if (flags & GENSUB) {   /* gensub, behave sanely */[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3223:17: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                                   ^
[0m[1m./awk.h:1179:30: [0m[0;1;36mnote: [0mexpanded from macro 'do_posix'[0m
 1179 | #define do_posix            (do_flags & DO_POSIX)[0m
      | [0;1;32m                             ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3223:13: [0m[0;1;36mnote: [0mTaking false branch[0m
 3223 |                                         } else if (do_posix) {[0m
      | [0;1;32m                                               ^
[0m[1mbuiltin.c:3230:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3230 |                                                 if (strncmp(scan, "\\\\\\&", 4) == 0[0m
      | [0;1;32m                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3230:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3231:14: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3231 |                                                     || strncmp(scan, "\\\\\\\\", 4) == 0) {     /* 2016: fixed */[0m
      | [0;1;32m                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3230:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3230 |                                                 if (strncmp(scan, "\\\\\\&", 4) == 0[0m
      | [0;1;32m                                                ^
[0m[1mbuiltin.c:3237:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3237 |                                                 } else if (strncmp(scan, "\\\\&", 3) == 0) {[0m
      | [0;1;32m                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3237:14: [0m[0;1;36mnote: [0mTaking false branch[0m
 3237 |                                                 } else if (strncmp(scan, "\\\\&", 3) == 0) {[0m
      | [0;1;32m                                                       ^
[0m[1mbuiltin.c:3243:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3243 |                                                 } else if (scan[1] == '&') {[0m
      | [0;1;32m                                                           ^~~~~~~~~~~~~~
[0m[1mbuiltin.c:3243:14: [0m[0;1;36mnote: [0mTaking false branch[0m
 3243 |                                                 } else if (scan[1] == '&') {[0m
      | [0;1;32m                                                       ^
[0m[1mbuiltin.c:3248:9: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3248 |                                                         *bp++ = *scan;[0m
      | [0;1;32m                                                         ^~~~
[0m[1mbuiltin.c:3248:14: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3248 |                                                         *bp++ = *scan;[0m
      | [0;1;32m                                                        ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3250:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3250 |                                 } else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 3251 |                                         *bp++ = *scan;[0m
      | [0;1;32m                                                      
[0m[1mbuiltin.c:3251:12: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3251 |                                         *bp++ = *scan;[0m
      | [0;1;32m                                        ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3192:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3192 |                                 if (*scan == '&'[0m
      | [0;1;32m                                    ^~~~~~~~~~~~
[0m[1mbuiltin.c:3197:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3197 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3202:16: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3202 |                                 } else if (*scan == '\\'[0m
      | [0;1;32m                                           ^~~~~~~~~~~~~
[0m[1mbuiltin.c:3203:6: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3203 |                                         && (gawk_mb_cur_max == 1[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:3251:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3251 |                                         *bp++ = *scan;[0m
      | [0;1;32m                                         ^~~~
[0m[1mbuiltin.c:3251:12: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3251 |                                         *bp++ = *scan;[0m
      | [0;1;32m                                        ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3252:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3252 |                         if (matchstart != matchend)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 3253 |                                 lastmatchnonzero = true;[0m
      | [0;1;32m                                                        
[0m[1mbuiltin.c:3259:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3259 |                         for (cp = matchstart; cp < matchend; cp++)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3260 |                                 *bp++ = *cp;[0m
      | [0;1;32m                                            
[0m[1mbuiltin.c:3265:10: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3265 |                         *bp++ = *matchend;[0m
      | [0;1;32m                        ~~~~~~^~~~~~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3180:11: [0m[0;1;36mnote: [0m'lastmatchnonzero' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                               ^~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3181:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3181 |                             && matchstart == text) {[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3252[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3252:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is equal to 'matchend'[0m
 3252 |                         if (matchstart != matchend)[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3252:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 3252 |                         if (matchstart != matchend)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3264:7: [0m[0;1;36mnote: [0m'matchstart' is equal to 'matchend'[0m
 3264 |                 if (matchstart == matchend && matchend < text + textlen) {[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mbuiltin.c:3264:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3264:33: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3264 |                 if (matchstart == matchend && matchend < text + textlen) {[0m
      | [0;1;32m                                              ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3264:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3264 |                 if (matchstart == matchend && matchend < text + textlen) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3265:5: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3265 |                         *bp++ = *matchend;[0m
      | [0;1;32m                         ^~~~
[0m[1mbuiltin.c:3265:10: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3265 |                         *bp++ = *matchend;[0m
      | [0;1;32m                        ~~~~~~^~~~~~~~~~~
[0m[1mbuiltin.c:3278:90: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3278 |                     || research(rp, target->stptr, text - target->stptr, textlen, RE_NEED_START) == -1)[0m
      | [0;1;32m                                                                                                       ^
[0m      | [0;32m                                                                                                        {
[0m 3279 |                         break;[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:3293:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3293 |         for (scan = text; scan < text + textlen; scan++)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 3294 |                 *bp++ = *scan;[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:3294:9: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3294 |                 *bp++ = *scan;[0m
      | [0;1;32m                ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3000:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3000:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3000 |         if ((flags & GENSUB) != 0) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3034:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3034:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3034 |                 if ((flags & GSUB) != 0) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3045:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3045 |                 if ((flags & GSUB) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3050:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3050:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3050 |                 if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3064:6: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3065:4: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3065 |                         RESTART(rp, target->stptr) > target->stlen)[0m
      | [0;1;32m                        ^
[0m[1m./awk.h:193:23: [0m[0;1;36mnote: [0mexpanded from macro 'RESTART'[0m
  193 | #define RESTART(rp,s)   (rp)->regs.start[0][0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3064:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 3064 |         if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3085:6: [0m[0;1;36mnote: [0mAssuming 'gawk_mb_cur_max' is <= 1[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3085:26: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3085 |         if (gawk_mb_cur_max > 1 && repllen > 0) {[0m
      | [0;1;32m                                ^
[0m[1mbuiltin.c:3091:2: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3135[0m
 3091 |         for (scan = repl; scan < replend; scan++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3143:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3143 |         for (current = 1;; current++) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3164:10: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3164:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3169[0m
 3164 |                 while (buflen < (sofar + len + 1)) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3169:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3171[0m
 3169 |                 for (scan = text; scan < matchstart; scan++)[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0m'global' is false[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                    ^~~~~~
[0m[1mbuiltin.c:3171:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mbuiltin.c:3171:17: [0m[0;1;36mnote: [0m'current' is equal to 'how_many'[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                              ^~~~~~~
[0m[1mbuiltin.c:3171:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3171 |                 if (global || current == how_many) {[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:3179:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3179 |                         if (matchstart == matchend[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3180:8: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3180 |                             && lastmatchnonzero[0m
      | [0;1;32m                            ^
[0m[1mbuiltin.c:3191:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3252[0m
 3191 |                         for (scan = repl; scan < replend; scan++)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3252:8: [0m[0;1;36mnote: [0mAssuming 'matchstart' is not equal to 'matchend'[0m
 3252 |                         if (matchstart != matchend)[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3252:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 3252 |                         if (matchstart != matchend)[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3264:7: [0m[0;1;36mnote: [0m'matchstart' is not equal to 'matchend'[0m
 3264 |                 if (matchstart == matchend && matchend < text + textlen) {[0m
      | [0;1;32m                    ^~~~~~~~~~
[0m[1mbuiltin.c:3264:30: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3264 |                 if (matchstart == matchend && matchend < text + textlen) {[0m
      | [0;1;32m                                           ^
[0m[1mbuiltin.c:3276:8: [0m[0;1;36mnote: [0m'current' is >= 'how_many'[0m
 3276 |                 if ((current >= how_many && ! global)[0m
      | [0;1;32m                     ^~~~~~~
[0m[1mbuiltin.c:3276:8: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mbuiltin.c:3276:33: [0m[0;1;36mnote: [0m'global' is false[0m
 3276 |                 if ((current >= how_many && ! global)[0m
      | [0;1;32m                                              ^~~~~~
[0m[1mbuiltin.c:3277:7: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 3277 |                     || ((long) textlen <= 0 && matchstart == matchend)[0m
      | [0;1;32m                    ^
[0m[1mbuiltin.c:3279:4: [0m[0;1;36mnote: [0m Execution continues on line 3282[0m
 3279 |                         break;[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:3283:6: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3283 |         if (buflen < (sofar + textlen + 1)) {[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3283:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 3283 |         if (buflen < (sofar + textlen + 1)) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3293:20: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 3293 |         for (scan = text; scan < text + textlen; scan++)[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~
[0m[1mbuiltin.c:3293:2: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3293 |         for (scan = text; scan < text + textlen; scan++)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:3294:4: [0m[0;1;36mnote: [0mNull pointer value stored to 'bp'[0m
 3294 |                 *bp++ = *scan;[0m
      | [0;1;32m                 ^~~~
[0m[1mbuiltin.c:3294:9: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3294 |                 *bp++ = *scan;[0m
      | [0;1;32m                ~~~~~~^~~~~~~
[0m[1mbuiltin.c:3298:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3298 |         if (mb_indices != NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3299 |                 efree(mb_indices);[0m
      | [0;1;32m                                  
[0m[1mbuiltin.c:3326:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3326 |         if ((flags & LITERAL) != 0)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3327 |                 DEREF(target);[0m
 3328 |         else if (matches > 0) {[0m
      | [0;32m        } 
[0m[1mbuiltin.c:3349:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3349 |                                 if (target->typed_re->re_reg[1] != NULL)[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 3350 |                                         refree(target->typed_re->re_reg[1]);[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:3355:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3355 |                 if (is_regex)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 3356 |                         *lhs = make_typed_regex(buf, textlen);[0m
 3357 |                 else[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3357:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3357 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3358 |                         *lhs = make_str_node(buf, textlen, ALREADY_MALLOCED);[0m
      | [0;1;32m                                                                             
[0m[1mbuiltin.c:3376:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3376 |                 if (name[1] == 'e')[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3377 |                         flags = GENSUB;[0m
 3378 |                 else[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3378:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3378 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3379 |                         flags = GSUB;[0m
      | [0;1;32m                                     
[0m[1mbuiltin.c:3385:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3385 |                 if (nargs != 2)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3386 |                         fatal(_("%s: can be called indirectly only with two arguments"), name);[0m
      | [0;1;32m                                                                                               
[0m[1mbuiltin.c:3395:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3395 |                 if ((regex->flags & REGEX) != 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3396 |                         regex = regex->typed_re;[0m
 3397 |                 else {[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3408:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3408 |                 if (nargs < 3 || nargs > 4)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 3409 |                         fatal(_("indirect call to gensub requires three or four arguments"));[0m
      | [0;1;32m                                                                                             
[0m[1mbuiltin.c:3411:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3411 |                 if (nargs == 4)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3412 |                         rhs = POP();[0m
 3413 |                 else[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3413:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3413 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3414 |                         rhs = NULL;[0m
      | [0;1;32m                                   
[0m[1mbuiltin.c:3427:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3427 |                 if ((regex->flags & REGEX) != 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3428 |                         regex = regex->typed_re;[0m
 3429 |                 else {[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3443:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3443 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3444 |                         PUSH(rhs);[0m
      | [0;1;32m                                  
[0m[1mbuiltin.c:3452:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3452 |                 if (regex->re_reg[1] != NULL)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3453 |                         refree(regex->re_reg[1]);[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:3457:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3457 |         if (flags != GENSUB)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3458 |                 reset_record();[0m
      | [0;1;32m                               
[0m[1mbuiltin.c:3470:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3470 |         if (nargs < 2 || nargs > 3)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3471 |                 fatal(_("indirect call to match requires two or three arguments"));[0m
      | [0;1;32m                                                                                   
[0m[1mbuiltin.c:3474:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3474 |         if (nargs == 3)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 3475 |                 array = POP();[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:3481:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3481 |         if ((regex->flags & REGEX) != 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3482 |                 regex = regex->typed_re;[0m
 3483 |         else {[0m
      | [0;32m        } 
[0m[1mbuiltin.c:3490:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3490 |         if (array)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 3491 |                 PUSH(array);[0m
      | [0;1;32m                            
[0m[1mbuiltin.c:3497:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3497 |                 if (regex->re_reg[1] != NULL)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3498 |                         refree(regex->re_reg[1]);[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:3514:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3514 |         if (nargs < 2 || nargs > 4)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3515 |                 fatal(_("indirect call to %s requires two to four arguments"),[0m
 3516 |                                 name);[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:3518:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3518 |         if (nargs == 4)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 3519 |                 seps = POP();[0m
      | [0;1;32m                             
[0m[1mbuiltin.c:3524:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3524 |                 if ((regex->flags & REGEX) != 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3525 |                         regex = regex->typed_re;[0m
 3526 |                 else {[0m
      | [0;32m                } 
[0m[1mbuiltin.c:3534:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3534 |                 } else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3535 |                         regex = make_regnode(Node_regex, FPAT_node->var_value);[0m
      | [0;1;32m                                                                               
[0m[1mbuiltin.c:3545:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3545 |         if (seps)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 3546 |                 PUSH(seps);[0m
      | [0;1;32m                           
[0m[1mbuiltin.c:3552:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3552 |                 if (regex->re_reg[1] != NULL)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3553 |                         refree(regex->re_reg[1]);[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:3583:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3583 |                 if ((fixtype(s1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 3584 |                         lintwarn(_("%s: received non-numeric first argument"), "lshift");[0m
      | [0;1;32m                                                                                         
[0m[1mbuiltin.c:3585:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3585 |                 if ((fixtype(s2)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 3586 |                         lintwarn(_("%s: received non-numeric second argument"), "lshift");[0m
      | [0;1;32m                                                                                          
[0m[1mbuiltin.c:3591:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3591 |         if (val < 0 || shift < 0)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3592 |                 fatal(_("lshift(%f, %f): negative values are not allowed"), val, shift);[0m
      | [0;1;32m                                                                                        
[0m[1mbuiltin.c:3595:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3595 |                 if (double_to_int(val) != val || double_to_int(shift) != shift)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 3596 |                         lintwarn(_("lshift(%f, %f): fractional values will be truncated"), val, shift);[0m
      | [0;1;32m                                                                                                       
[0m[1mbuiltin.c:3597:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3597 |                 if (shift >= sizeof(uintmax_t) * CHAR_BIT)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3598 |                         lintwarn(_("lshift(%f, %f): too large shift value will give strange results"), val, shift);[0m
      | [0;1;32m                                                                                                                   
[0m[1mbuiltin.c:3624:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3624 |                 if ((fixtype(s1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 3625 |                         lintwarn(_("%s: received non-numeric first argument"), "rshift");[0m
      | [0;1;32m                                                                                         
[0m[1mbuiltin.c:3626:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3626 |                 if ((fixtype(s2)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 3627 |                         lintwarn(_("%s: received non-numeric second argument"), "rshift");[0m
      | [0;1;32m                                                                                          
[0m[1mbuiltin.c:3632:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3632 |         if (val < 0 || shift < 0)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3633 |                 fatal(_("rshift(%f, %f): negative values are not allowed"), val, shift);[0m
      | [0;1;32m                                                                                        
[0m[1mbuiltin.c:3636:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3636 |                 if (double_to_int(val) != val || double_to_int(shift) != shift)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 3637 |                         lintwarn(_("rshift(%f, %f): fractional values will be truncated"), val, shift);[0m
      | [0;1;32m                                                                                                       
[0m[1mbuiltin.c:3638:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3638 |                 if (shift >= sizeof(uintmax_t) * CHAR_BIT)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3639 |                         lintwarn(_("rshift(%f, %f): too large shift value will give strange results"), val, shift);[0m
      | [0;1;32m                                                                                                                   
[0m[1mbuiltin.c:3662:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3662 |         if (nargs < 2)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3663 |                 fatal(_("%s: called with less than two arguments"), "and");[0m
      | [0;1;32m                                                                           
[0m[1mbuiltin.c:3667:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3667 |                 if (do_lint && (fixtype(s1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3668 |                         lintwarn(_("%s: argument %d is non-numeric"), "and", nargs);[0m
      | [0;1;32m                                                                                    
[0m[1mbuiltin.c:3671:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3671 |                 if (val < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3672 |                         fatal(_("%s: argument %d negative value %g is not allowed"), "and", nargs, val);[0m
      | [0;1;32m                                                                                                        
[0m[1mbuiltin.c:3693:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3693 |         if (nargs < 2)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3694 |                 fatal(_("%s: called with less than two arguments"), "or");[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:3698:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3698 |                 if (do_lint && (fixtype(s1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3699 |                         lintwarn(_("%s: argument %d is non-numeric"), "or", nargs);[0m
      | [0;1;32m                                                                                   
[0m[1mbuiltin.c:3702:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3702 |                 if (val < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3703 |                         fatal(_("%s: argument %d negative value %g is not allowed"), "or", nargs, val);[0m
      | [0;1;32m                                                                                                       
[0m[1mbuiltin.c:3723:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3723 |         if (nargs < 2)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3724 |                 fatal(_("%s: called with less than two arguments"), "xor");[0m
      | [0;1;32m                                                                           
[0m[1mbuiltin.c:3729:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3729 |                 if (do_lint && (fixtype(s1)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3730 |                         lintwarn(_("%s: argument %d is non-numeric"), "xor", nargs);[0m
      | [0;1;32m                                                                                    
[0m[1mbuiltin.c:3733:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3733 |                 if (val < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3734 |                         fatal(_("%s: argument %d negative value %g is not allowed"), "xor", nargs, val);[0m
      | [0;1;32m                                                                                                        
[0m[1mbuiltin.c:3757:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3757 |         if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 3758 |                 lintwarn(_("%s: received non-numeric argument"), "compl");[0m
      | [0;1;32m                                                                          
[0m[1mbuiltin.c:3762:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3762 |         if (d < 0)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 3763 |                 fatal(_("compl(%f): negative value is not allowed"), d);[0m
      | [0;1;32m                                                                        
[0m[1mbuiltin.c:3765:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3765 |         if (do_lint && double_to_int(d) != d)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 3766 |                 lintwarn(_("compl(%f): fractional value will be truncated"), d);[0m
      | [0;1;32m                                                                                
[0m[1mbuiltin.c:3784:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3784 |         if ((tmp->flags & NUMBER) != 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3785 |                 d = (AWKNUM) tmp->numbr;[0m
 3786 |         else if (get_numbase(tmp->stptr, tmp->stlen, use_lc_numeric) != 10)[0m
      | [0;32m        } 
[0m[1mbuiltin.c:3786:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3786 |         else if (get_numbase(tmp->stptr, tmp->stlen, use_lc_numeric) != 10)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 3787 |                 d = nondec2awknum(tmp->stptr, tmp->stlen, NULL);[0m
 3788 |         else[0m
      | [0;32m        } 
[0m[1mbuiltin.c:3788:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3788 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 3789 |                 d = (AWKNUM) force_number(tmp)->numbr;[0m
      | [0;1;32m                                                      
[0m[1mbuiltin.c:3817:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3817 |                         if (endptr)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 3818 |                                 *endptr = start;[0m
      | [0;1;32m                                                
[0m[1mbuiltin.c:3835:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3835 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1mbuiltin.c:3843:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3843 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1mbuiltin.c:3851:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3851 |                                 break;[0m
      | [0;1;32m                                ^    
[0m      | [0;32m                                {    ;} 
[0m[1mbuiltin.c:3853:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3853 |                                 if (endptr)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 3854 |                                         *endptr = str;[0m
 3855 |                                 goto done;[0m
      | [0;1;32m                                         
[0m      | [0;32m                                         ;} 
[0m[1mbuiltin.c:3853:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3853 |                                 if (endptr)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 3854 |                                         *endptr = str;[0m
      | [0;1;32m                                                      
[0m[1mbuiltin.c:3859:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3859 |                 if (endptr)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 3860 |                         *endptr = str;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:3866:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3866 |                                 if (endptr)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 3867 |                                         *endptr = str;[0m
      | [0;1;32m                                                      
[0m[1mbuiltin.c:3877:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3877 |                 if (endptr)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 3878 |                         *endptr = str;[0m
      | [0;1;32m                                      
[0m[1mbuiltin.c:3943:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3943 |                         if (i < 0)              /* category < mid */[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 3944 |                                 high = mid - 1;[0m
 3945 |                         else if (i > 0)         /* category > mid */[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:3945:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3945 |                         else if (i > 0)         /* category > mid */[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3946 |                                 low = mid + 1;[0m
 3947 |                         else {[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:3953:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3953 |                 if (lc_cat == -1)       /* not there */[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 3954 |                         fatal(_("dcgettext: `%s' is not a valid locale category"), category);[0m
      | [0;1;32m                                                                                             
[0m[1mbuiltin.c:3957:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3957 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 3958 |                 return LC_MESSAGES;[0m
      | [0;1;32m                                   
[0m[1mbuiltin.c:3988:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3988 |                 if (do_lint && (fixtype(tmp)->flags & STRING) == 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 3989 |                         lintwarn(_("%s: received non-string third argument"), "dcgettext");[0m
      | [0;1;32m                                                                                           
[0m[1mbuiltin.c:3992:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3992 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 3993 |                 lc_cat = LC_MESSAGES;[0m
      | [0;1;32m                                     
[0m[1mbuiltin.c:3997:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3997 |                 if (do_lint && (fixtype(t2)->flags & STRING) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 3998 |                         lintwarn(_("%s: received non-string second argument"), "dcgettext");[0m
      | [0;1;32m                                                                                            
[0m[1mbuiltin.c:4001:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4001 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4002 |                 domain = TEXTDOMAIN;[0m
      | [0;1;32m                                    
[0m[1mbuiltin.c:4019:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4019 |         if (do_lint && (fixtype(t1)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 4020 |                 lintwarn(_("%s: received non-string first argument"), "dcgettext");[0m
      | [0;1;32m                                                                                   
[0m[1mbuiltin.c:4061:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4061 |                 if (do_lint && (fixtype(tmp)->flags & STRING) == 0)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 4062 |                         lintwarn(_("%s: received non-string fifth argument"), "dcngettext");[0m
      | [0;1;32m                                                                                            
[0m[1mbuiltin.c:4065:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4065 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4066 |                 lc_cat = LC_MESSAGES;[0m
      | [0;1;32m                                     
[0m[1mbuiltin.c:4071:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4071 |                 if (do_lint && (fixtype(t3)->flags & STRING) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 4072 |                         lintwarn(_("%s: received non-string fourth argument"), "dcngettext");[0m
      | [0;1;32m                                                                                             
[0m[1mbuiltin.c:4077:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4077 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4078 |                 domain = TEXTDOMAIN;[0m
      | [0;1;32m                                    
[0m[1mbuiltin.c:4095:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4095 |         if (do_lint && (fixtype(t2)->flags & NUMBER) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 4096 |                 lintwarn(_("%s: received non-numeric third argument"), "dcngettext");[0m
      | [0;1;32m                                                                                     
[0m[1mbuiltin.c:4102:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4102 |         if (do_lint && (fixtype(t2)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 4103 |                 lintwarn(_("%s: received non-string second argument"), "dcngettext");[0m
      | [0;1;32m                                                                                     
[0m[1mbuiltin.c:4106:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4106 |         if (do_lint && (fixtype(t1)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 4107 |                 lintwarn(_("%s: received non-string first argument"), "dcngettext");[0m
      | [0;1;32m                                                                                    
[0m[1mbuiltin.c:4118:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4118 |         if (saved_end)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4119 |                 domain[t3->stlen] = save;[0m
      | [0;1;32m                                         
[0m[1mbuiltin.c:4120:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4120 |         if (t3 != NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 4121 |                 DEREF(t3);[0m
      | [0;1;32m                          
[0m[1mbuiltin.c:4164:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4164 |                 if (do_lint && (fixtype(t2)->flags & STRING) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 4165 |                         lintwarn(_("%s: received non-string second argument"), "bindtextdomain");[0m
      | [0;1;32m                                                                                                 
[0m[1mbuiltin.c:4173:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4173 |         if (do_lint && (fixtype(t1)->flags & STRING) == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 4174 |                 lintwarn(_("%s: received non-string first argument"), "bindtextdomain");[0m
      | [0;1;32m                                                                                        
[0m[1mbuiltin.c:4181:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4181 |         if (directory)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 4182 |                 str_restore(t1, save1);[0m
      | [0;1;32m                                       
[0m[1mbuiltin.c:4190:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4190 |         if (the_result == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 4191 |                 the_result = "";[0m
      | [0;1;32m                                
[0m[1mbuiltin.c:4276:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4276 |                 if (dbg->type != Node_var_array)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 4277 |                         fatal(_("typeof: second argument is not an array"));[0m
      | [0;1;32m                                                                            
[0m[1mbuiltin.c:4280:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4280 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 4281 |                 dbg = NULL;[0m
      | [0;1;32m                           
[0m[1mbuiltin.c:4286:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4286 |                 res = "array";[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mbuiltin.c:4309:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4309 |                                                 for (ip = nextfree[i].freep; ip; ip = ip->freep)[0m
      | [0;1;32m                                                                                                ^
[0m      | [0;32m                                                                                                 {
[0m 4310 |                                                         active--;[0m
      | [0;1;32m                                                                 
[0m[1mbuiltin.c:4320:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4320 |                                         SETVAL(highwater, hw)[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:4317:2: [0m[0;1;36mnote: [0mexpanded from macro 'SETVAL'[0m
 4317 |         sprintf(p, "%s_" #X, nextfree[i].name); \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mbuiltin.c:4320:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 4320 |                                         SETVAL(highwater, hw)[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:4317:2: [0m[0;1;36mnote: [0mexpanded from macro 'SETVAL'[0m
 4317 |         sprintf(p, "%s_" #X, nextfree[i].name); \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mbuiltin.c:4321:6: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4321 |                                         SETVAL(active, active)[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:4317:2: [0m[0;1;36mnote: [0mexpanded from macro 'SETVAL'[0m
 4317 |         sprintf(p, "%s_" #X, nextfree[i].name); \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mbuiltin.c:4321:6: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 4321 |                                         SETVAL(active, active)[0m
      | [0;1;32m                                        ^
[0m[1mbuiltin.c:4317:2: [0m[0;1;36mnote: [0mexpanded from macro 'SETVAL'[0m
 4317 |         sprintf(p, "%s_" #X, nextfree[i].name); \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mbuiltin.c:4340:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4340 |                 arg = arg->var_value;[0m
      | [0;1;32m                ^                   
[0m      | [0;32m                {                   ;} 
[0m[1mbuiltin.c:4343:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4343 |                 switch (fixtype(arg)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m[1mbuiltin.c:4345:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4345 |                         res = "number|bool";[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4346 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mbuiltin.c:4348:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4348 |                         res = "number";[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4349 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mbuiltin.c:4351:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4351 |                         res = "strnum";[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4352 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mbuiltin.c:4354:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4354 |                         res = "regexp";[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4355 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mbuiltin.c:4357:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4357 |                         res = "string";[0m
      | [0;1;32m                        ^             
[0m      | [0;32m                        {             ;} 
[0m[1mbuiltin.c:4360:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4360 |                         if (arg == Nnull_string || (arg->flags & NULL_FIELD) != 0) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4361 |                                 res = "unassigned";[0m
 4362 |                                 break;[0m
 4363 |                         }[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mbuiltin.c:4366:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4366 |                         if (res == NULL) {[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m 4367 |                                 warning(_("typeof detected invalid flags combination `%s'; please file a bug report"), flags2str(arg->flags));[0m
 4368 |                                 res = "unknown";[0m
 4369 |                         }[0m
 4370 |                         break;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mbuiltin.c:4380:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4380 |                 deref = false;[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4381 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mbuiltin.c:4395:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4395 |                 if (arg->orig_array->type == Node_var[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4396 |                     && (arg->orig_array->var_value == Nnull_string[0m
 4397 |                         || (arg->orig_array->var_value->flags & NULL_FIELD) != 0)) {[0m
 4398 |                         res = "unassigned";[0m
 4399 |                 } else {[0m
 4400 |                         res = "untyped";[0m
 4401 |                 }[0m
 4402 |                 deref = false;[0m
 4403 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mbuiltin.c:4405:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4405 |                 fatal(_("typeof: unknown argument type `%s'"),[0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 4406 |                                 nodetype2str(arg->type));[0m
 4407 |                 break;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1m./awk.h:1388:16: [0m[0;1;36mnote: [0mexpanded from macro 'fatal'[0m
 1388 | #define fatal           (*(set_loc(__FILE__, __LINE__), r_fatal))[0m
      | [0;1;32m                        ^
[0m[1mbuiltin.c:4410:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4410 |         if (deref)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 4411 |                 DEREF(arg);[0m
      | [0;1;32m                           
[0m[1mbuiltin.c:4412:26: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 4412 |         return make_string(res, strlen(res));[0m
      | [0;1;32m                                ^
[0m[1m./awk.h:1372:47: [0m[0;1;36mnote: [0mexpanded from macro 'make_string'[0m
 1372 | #define make_string(s, l)       make_str_node((s), (l), 0)[0m
      | [0;1;32m                                                    ^
[0m[1mbuiltin.c:4268:2: [0m[0;1;36mnote: [0m'res' initialized to a null pointer value[0m
 4268 |         const char *res = NULL;[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~
[0m[1mbuiltin.c:4274:6: [0m[0;1;36mnote: [0mAssuming 'nargs' is not equal to 2[0m
 4274 |         if (nargs == 2) {       /* 2nd optional arg for debugging */[0m
      | [0;1;32m            ^~~~~~~~~~
[0m[1mbuiltin.c:4274:2: [0m[0;1;36mnote: [0mTaking false branch[0m
 4274 |         if (nargs == 2) {       /* 2nd optional arg for debugging */[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:4283:2: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 4404[0m
 4283 |         switch (arg->type) {[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:4407:3: [0m[0;1;36mnote: [0m Execution continues on line 4410[0m
 4407 |                 break;[0m
      | [0;1;32m                ^
[0m[1mbuiltin.c:4410:6: [0m[0;1;36mnote: [0m'deref' is true[0m
 4410 |         if (deref)[0m
      | [0;1;32m            ^~~~~
[0m[1mbuiltin.c:4410:2: [0m[0;1;36mnote: [0mTaking true branch[0m
 4410 |         if (deref)[0m
      | [0;1;32m        ^
[0m[1mbuiltin.c:4412:26: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 4412 |         return make_string(res, strlen(res));[0m
      | [0;1;32m                                ^
[0m[1m./awk.h:1372:47: [0m[0;1;36mnote: [0mexpanded from macro 'make_string'[0m
 1372 | #define make_string(s, l)       make_str_node((s), (l), 0)[0m
      | [0;1;32m                                                    ^
[0m[1mbuiltin.c:4424:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4424 |         memset(& cur_state, 0, sizeof(cur_state));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:4424:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 4424 |         memset(& cur_state, 0, sizeof(cur_state));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:4428:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4428 |         if (mb_len <= 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 4429 |                 return numchars;        /* no valid m.b. char */[0m
      | [0;1;32m                                                                
[0m[1mbuiltin.c:4433:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4433 |                 if (mb_len <= 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 4434 |                         break;[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:4451:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4451 |         if (gawk_mb_cur_max == 1)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4452 |                 return numbytes;[0m
      | [0;1;32m                                
[0m[1mbuiltin.c:4454:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4454 |         memset(& cur_state, 0, sizeof(cur_state));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:4454:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 4454 |         memset(& cur_state, 0, sizeof(cur_state));[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:4457:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4457 |         if (mb_len <= 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 4458 |                 return numbytes;        /* no valid m.b. char */[0m
      | [0;1;32m                                                                
[0m[1mbuiltin.c:4462:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4462 |                 if (mb_len <= 0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 4463 |                         break;[0m
      | [0;1;32m                              
[0m[1mbuiltin.c:4479:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4479 |         if (WIFEXITED(status))[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 4480 |                 ret = WEXITSTATUS(status); /* normal exit */[0m
 4481 |         else if (WIFSIGNALED(status)) {[0m
      | [0;32m        } 
[0m[1mbuiltin.c:4488:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4488 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4489 |                 ret = 0;        /* shouldn't get here */[0m
      | [0;1;32m                                                        
[0m[1mbuiltin.c:4537:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 4537 |                 strcpy(buf, signbit(val) != 0 ? "-nan" : "+nan");[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:4537:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 4537 |                 strcpy(buf, signbit(val) != 0 ? "-nan" : "+nan");[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:4541:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 4541 |                 strcpy(buf, val < 0 ? "-inf" : "+inf");[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:4541:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 4541 |                 strcpy(buf, val < 0 ? "-inf" : "+inf");[0m
      | [0;1;32m                ^~~~~~
[0m[1mbuiltin.c:4544:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4544 |         } else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4545 |                 return NULL;[0m
      | [0;1;32m                            
[0m[1mbuiltin.c:4553:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4553 |                 for (i = 0; buf[i] != '\0'; i++)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 4554 |                         buf[i] = toupper(buf[i]);[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:4565:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4565 |         if (dest == symbol_table)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4566 |                 fatal(msg, fname, "SYMTAB");[0m
 4567 |         else if (dest == func_table)[0m
      | [0;32m        } 
[0m[1mbuiltin.c:4567:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4567 |         else if (dest == func_table)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 4568 |                 fatal(msg, fname, "FUNCTAB");[0m
      | [0;1;32m                                             
[0m[1mbuiltin.c:4622:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4622 |         memset(newbuf, '\0', new_len);[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:4622:2: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 4622 |         memset(newbuf, '\0', new_len);[0m
      | [0;1;32m        ^~~~~~
[0m[1mbuiltin.c:4630:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4630 |                         while (src >= dec)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 4631 |                                 *dest++ = *src--;[0m
      | [0;1;32m                                                 
[0m[1mbuiltin.c:4645:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4645 |                                 for (k = strlen(ts) - 1; k >= 0; k--)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 4646 |                                         *dest++ = ts[k];[0m
      | [0;1;32m                                                        
[0m[1mbuiltin.c:4648:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4648 |                         if (loc->grouping[ii+1] == 0)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 4649 |                                 jj = 0;         /* keep using current val in loc.grouping[ii] */[0m
 4650 |                         else if (loc->grouping[ii+1] == CHAR_MAX) {[0m
      | [0;32m                        } 
[0m[1mbuiltin.c:4652:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4652 |                                 while (src >= original)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 4653 |                                         *dest++ = *src--;[0m
      | [0;1;32m                                                         
[0m457 warnings generated.
Suppressed 34 warnings (34 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.



Process exited with return code 0
