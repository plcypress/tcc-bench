Command: /itch/common/crepos/tcc-scripts/tidy-braces.sh
Directory: /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6
----------------------------------------

Enabled checks:
    clang-analyzer-apiModeling.Errno
    clang-analyzer-apiModeling.TrustNonnull
    clang-analyzer-apiModeling.TrustReturnsNonnull
    clang-analyzer-apiModeling.google.GTest
    clang-analyzer-apiModeling.llvm.CastValue
    clang-analyzer-apiModeling.llvm.ReturnValue
    clang-analyzer-core.BitwiseShift
    clang-analyzer-core.CallAndMessage
    clang-analyzer-core.CallAndMessageModeling
    clang-analyzer-core.DereferenceModeling
    clang-analyzer-core.DivideZero
    clang-analyzer-core.DynamicTypePropagation
    clang-analyzer-core.NonNullParamChecker
    clang-analyzer-core.NonnilStringConstants
    clang-analyzer-core.NullDereference
    clang-analyzer-core.StackAddrEscapeBase
    clang-analyzer-core.StackAddressEscape
    clang-analyzer-core.UndefinedBinaryOperatorResult
    clang-analyzer-core.VLASize
    clang-analyzer-core.builtin.BuiltinFunctions
    clang-analyzer-core.builtin.NoReturnFunctions
    clang-analyzer-core.uninitialized.ArraySubscript
    clang-analyzer-core.uninitialized.Assign
    clang-analyzer-core.uninitialized.Branch
    clang-analyzer-core.uninitialized.CapturedBlockVariable
    clang-analyzer-core.uninitialized.NewArraySize
    clang-analyzer-core.uninitialized.UndefReturn
    clang-analyzer-cplusplus.ArrayDelete
    clang-analyzer-cplusplus.InnerPointer
    clang-analyzer-cplusplus.Move
    clang-analyzer-cplusplus.NewDelete
    clang-analyzer-cplusplus.NewDeleteLeaks
    clang-analyzer-cplusplus.PlacementNew
    clang-analyzer-cplusplus.PureVirtualCall
    clang-analyzer-cplusplus.SelfAssignment
    clang-analyzer-cplusplus.SmartPtrModeling
    clang-analyzer-cplusplus.StringChecker
    clang-analyzer-cplusplus.VirtualCallModeling
    clang-analyzer-deadcode.DeadStores
    clang-analyzer-fuchsia.HandleChecker
    clang-analyzer-nullability.NullPassedToNonnull
    clang-analyzer-nullability.NullReturnedFromNonnull
    clang-analyzer-nullability.NullabilityBase
    clang-analyzer-nullability.NullableDereferenced
    clang-analyzer-nullability.NullablePassedToNonnull
    clang-analyzer-nullability.NullableReturnedFromNonnull
    clang-analyzer-optin.core.EnumCastOutOfRange
    clang-analyzer-optin.cplusplus.UninitializedObject
    clang-analyzer-optin.cplusplus.VirtualCall
    clang-analyzer-optin.mpi.MPI-Checker
    clang-analyzer-optin.osx.OSObjectCStyleCast
    clang-analyzer-optin.osx.cocoa.localizability.EmptyLocalizationContextChecker
    clang-analyzer-optin.osx.cocoa.localizability.NonLocalizedStringChecker
    clang-analyzer-optin.performance.GCDAntipattern
    clang-analyzer-optin.performance.Padding
    clang-analyzer-optin.portability.UnixAPI
    clang-analyzer-optin.taint.GenericTaint
    clang-analyzer-optin.taint.TaintPropagation
    clang-analyzer-optin.taint.TaintedAlloc
    clang-analyzer-optin.taint.TaintedDiv
    clang-analyzer-osx.API
    clang-analyzer-osx.MIG
    clang-analyzer-osx.NSOrCFErrorDerefChecker
    clang-analyzer-osx.NumberObjectConversion
    clang-analyzer-osx.OSObjectRetainCount
    clang-analyzer-osx.ObjCProperty
    clang-analyzer-osx.SecKeychainAPI
    clang-analyzer-osx.cocoa.AtSync
    clang-analyzer-osx.cocoa.AutoreleaseWrite
    clang-analyzer-osx.cocoa.ClassRelease
    clang-analyzer-osx.cocoa.Dealloc
    clang-analyzer-osx.cocoa.IncompatibleMethodTypes
    clang-analyzer-osx.cocoa.Loops
    clang-analyzer-osx.cocoa.MissingSuperCall
    clang-analyzer-osx.cocoa.NSAutoreleasePool
    clang-analyzer-osx.cocoa.NSError
    clang-analyzer-osx.cocoa.NilArg
    clang-analyzer-osx.cocoa.NonNilReturnValue
    clang-analyzer-osx.cocoa.ObjCGenerics
    clang-analyzer-osx.cocoa.RetainCount
    clang-analyzer-osx.cocoa.RetainCountBase
    clang-analyzer-osx.cocoa.RunLoopAutoreleaseLeak
    clang-analyzer-osx.cocoa.SelfInit
    clang-analyzer-osx.cocoa.SuperDealloc
    clang-analyzer-osx.cocoa.UnusedIvars
    clang-analyzer-osx.cocoa.VariadicMethodTypes
    clang-analyzer-osx.coreFoundation.CFError
    clang-analyzer-osx.coreFoundation.CFNumber
    clang-analyzer-osx.coreFoundation.CFRetainRelease
    clang-analyzer-osx.coreFoundation.containers.OutOfBounds
    clang-analyzer-osx.coreFoundation.containers.PointerSizedValues
    clang-analyzer-security.ArrayBound
    clang-analyzer-security.FloatLoopCounter
    clang-analyzer-security.MmapWriteExec
    clang-analyzer-security.PointerSub
    clang-analyzer-security.PutenvStackArray
    clang-analyzer-security.SetgidSetuidOrder
    clang-analyzer-security.cert.env.InvalidPtr
    clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling
    clang-analyzer-security.insecureAPI.SecuritySyntaxChecker
    clang-analyzer-security.insecureAPI.UncheckedReturn
    clang-analyzer-security.insecureAPI.bcmp
    clang-analyzer-security.insecureAPI.bcopy
    clang-analyzer-security.insecureAPI.bzero
    clang-analyzer-security.insecureAPI.decodeValueOfObjCType
    clang-analyzer-security.insecureAPI.getpw
    clang-analyzer-security.insecureAPI.gets
    clang-analyzer-security.insecureAPI.mkstemp
    clang-analyzer-security.insecureAPI.mktemp
    clang-analyzer-security.insecureAPI.rand
    clang-analyzer-security.insecureAPI.strcpy
    clang-analyzer-security.insecureAPI.vfork
    clang-analyzer-unix.API
    clang-analyzer-unix.BlockInCriticalSection
    clang-analyzer-unix.Chroot
    clang-analyzer-unix.DynamicMemoryModeling
    clang-analyzer-unix.Errno
    clang-analyzer-unix.Malloc
    clang-analyzer-unix.MallocSizeof
    clang-analyzer-unix.MismatchedDeallocator
    clang-analyzer-unix.StdCLibraryFunctions
    clang-analyzer-unix.Stream
    clang-analyzer-unix.Vfork
    clang-analyzer-unix.cstring.BadSizeArg
    clang-analyzer-unix.cstring.CStringModeling
    clang-analyzer-unix.cstring.NotNullTerminated
    clang-analyzer-unix.cstring.NullArg
    clang-analyzer-valist.CopyToSelf
    clang-analyzer-valist.Uninitialized
    clang-analyzer-valist.Unterminated
    clang-analyzer-valist.ValistBase
    clang-analyzer-webkit.NoUncountedMemberChecker
    clang-analyzer-webkit.RefCntblBaseVirtualDtor
    clang-analyzer-webkit.UncountedLambdaCapturesChecker
    readability-braces-around-statements

Running clang-tidy for 33 files out of 33 in compilation database ...
[ 1/33][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp6hyp60ya.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/compat/getopt1.c
[ 2/33][0.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp77ajfwdb.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/compat/getopt.c
[ 3/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp4p201odj.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/states/lex.c
[1mlex.c:770:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  770 |                 if ( ! (yy_start) )[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  771 |                         (yy_start) = 1; /* first start state */[0m
      | [0;1;32m                                                               
[0m[1mlex.c:773:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  773 |                 if ( ! yyin )[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  774 |                         yyin = stdin;[0m
      | [0;1;32m                                     
[0m[1mlex.c:776:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  776 |                 if ( ! yyout )[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  777 |                         yyout = stdout;[0m
      | [0;1;32m                                       
[0m[1mlex.c:813:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  813 |                                 if ( yy_current_state >= 114 )[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m  814 |                                         yy_c = yy_meta[(unsigned int) yy_c];[0m
      | [0;1;32m                                                                            
[0m[1mlex.c:838:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  838 |                         *yy_cp = (yy_hold_char);[0m
      | [0;1;32m                        ^
[0m      | [0;32m                        {
[0m  839 |                         yy_cp = (yy_last_accepting_cpos);[0m
  840 |                         yy_current_state = (yy_last_accepting_state);[0m
  841 |                         goto yy_find_action;[0m
      | [0;1;32m                                           
[0m      | [0;32m                                           ;} 
[0m[1mlex.c:884:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  884 |                       yylval.node->u.integer = '\n';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  885 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:888:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  888 |                       yylval.node->u.integer = '\t';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  889 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:892:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  892 |                       yylval.node->u.integer = '\v';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  893 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:896:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  896 |                       yylval.node->u.integer = '\b';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  897 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:900:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  900 |                       yylval.node->u.integer = '\r';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  901 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:904:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  904 |                       yylval.node->u.integer = '\f';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  905 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:908:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  908 |                       yylval.node->u.integer = '\a';[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  909 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:912:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  912 |                       yylval.node->u.integer = yytext[2];[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  913 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mlex.c:1098:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1098 |         yyterminate();[0m
      | [0;1;32m        ^            
[0m      | [0;32m        {            ;} 
[0m[1mlex.c:708:23: [0m[0;1;36mnote: [0mexpanded from macro 'yyterminate'[0m
  708 | #define yyterminate() return YY_NULL[0m
      | [0;1;32m                      ^
[0m[1mlex.c:1168:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1168 |                 else switch ( yy_get_next_buffer(  ) )[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m[1mlex.c:1193:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1193 |                                         if ( ! (yy_did_buffer_switch_on_eof) )[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1194 |                                                 YY_NEW_FILE;[0m
      | [0;1;32m                                                            
[0m[1mlex.c:1200:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1200 |                                 (yy_c_buf_p) =[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 1201 |                                         (yytext_ptr) + yy_amount_of_matched_text;[0m
 1202 | [0m
 1203 |                                 yy_current_state = yy_get_previous_state(  );[0m
 1204 | [0m
 1205 |                                 yy_cp = (yy_c_buf_p);[0m
 1206 |                                 yy_bp = (yytext_ptr) + YY_MORE_ADJ;[0m
 1207 |                                 goto yy_match;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1mlex.c:1210:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1210 |                                 (yy_c_buf_p) =[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                {
[0m 1211 |                                 &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];[0m
 1212 | [0m
 1213 |                                 yy_current_state = yy_get_previous_state(  );[0m
 1214 | [0m
 1215 |                                 yy_cp = (yy_c_buf_p);[0m
 1216 |                                 yy_bp = (yytext_ptr) + YY_MORE_ADJ;[0m
 1217 |                                 goto yy_find_action;[0m
      | [0;1;32m                                                   
[0m      | [0;32m                                                   ;} 
[0m[1mlex.c:1223:3: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1223 |                 YY_FATAL_ERROR([0m
      | [0;1;32m                ^
[0m      | [0;32m                {
[0m 1224 |                         "fatal flex scanner internal error--no action found" );[0m
      | [0;1;32m                                                                              
[0m      | [0;32m                                                                              ;} 
[0m[1mlex.c:718:29: [0m[0;1;36mnote: [0mexpanded from macro 'YY_FATAL_ERROR'[0m
  718 | #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )[0m
      | [0;1;32m                            ^
[0m[1mlex.c:1243:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1243 |         if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )[0m
      | [0;1;32m                                                                                    ^
[0m      | [0;32m                                                                                     {
[0m 1244 |                 YY_FATAL_ERROR([0m
 1245 |                 "fatal flex scanner internal error--end of buffer missed" );[0m
      | [0;1;32m                                                                            
[0m[1mlex.c:1271:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1271 |         for ( i = 0; i < number_to_move; ++i )[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1272 |                 *(dest++) = *(source++);[0m
      | [0;1;32m                                        
[0m[1mlex.c:1274:76: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1274 |         if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )[0m
      | [0;1;32m                                                                                  ^
[0m      | [0;32m                                                                                   {
[0m 1275 |                 /* don't do the read, it's not guaranteed to return an EOF,[0m
 1276 |                  * just force an EOF[0m
 1277 |                  */[0m
 1278 |                 YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;[0m
 1279 | [0m
 1280 |         else[0m
      | [0;32m        } 
[0m[1mlex.c:1298:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1298 |                                 if ( new_size <= 0 )[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1299 |                                         b->yy_buf_size += b->yy_buf_size / 8;[0m
 1300 |                                 else[0m
      | [0;32m                                } 
[0m[1mlex.c:1300:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1300 |                                 else[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1301 |                                         b->yy_buf_size *= 2;[0m
      | [0;1;32m                                                            
[0m[1mlex.c:1307:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1307 |                         else[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1308 |                                 /* Can't grow it, we don't own it. */[0m
 1309 |                                 b->yy_ch_buf = 0;[0m
      | [0;1;32m                                                 
[0m[1mlex.c:1311:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1311 |                         if ( ! b->yy_ch_buf )[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1312 |                                 YY_FATAL_ERROR([0m
 1313 |                                 "fatal error - scanner input buffer overflow" );[0m
      | [0;1;32m                                                                                
[0m[1mlex.c:1322:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1322 |                 if ( num_to_read > YY_READ_BUF_SIZE )[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1323 |                         num_to_read = YY_READ_BUF_SIZE;[0m
      | [0;1;32m                                                       
[0m[1mlex.c:1348:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1348 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1349 |                 ret_val = EOB_ACT_CONTINUE_SCAN;[0m
      | [0;1;32m                                                
[0m[1mlex.c:1355:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1355 |                 if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1356 |                         YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );[0m
      | [0;1;32m                                                                                          
[0m[1mlex.c:1388:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1388 |                         if ( yy_current_state >= 114 )[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1389 |                                 yy_c = yy_meta[(unsigned int) yy_c];[0m
      | [0;1;32m                                                                    
[0m[1mlex.c:1416:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1416 |                 if ( yy_current_state >= 114 )[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1417 |                         yy_c = yy_meta[(unsigned int) yy_c];[0m
      | [0;1;32m                                                            
[0m[1mlex.c:1443:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1443 |                 while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1444 |                         *--dest = *--source;[0m
      | [0;1;32m                                            
[0m[1mlex.c:1451:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1451 |                 if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1452 |                         YY_FATAL_ERROR( "flex scanner push-back overflow" );[0m
      | [0;1;32m                                                                            
[0m[1mlex.c:1480:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1480 |                 if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )[0m
      | [0;1;32m                                                                                        ^
[0m      | [0;32m                                                                                         {
[0m 1481 |                         /* This was really a NUL. */[0m
 1482 |                         *(yy_c_buf_p) = '\0';[0m
 1483 | [0m
 1484 |                 else[0m
      | [0;32m                } 
[0m[1mlex.c:1503:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1503 |                                         yyrestart(yyin );[0m
      | [0;1;32m                                        ^               
[0m      | [0;32m                                        {               ;} 
[0m[1mlex.c:1509:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1509 |                                         if ( yywrap( ) )[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1510 |                                                 return EOF;[0m
      | [0;1;32m                                                           
[0m[1mlex.c:1512:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1512 |                                         if ( ! (yy_did_buffer_switch_on_eof) )[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1513 |                                                 YY_NEW_FILE;[0m
      | [0;1;32m                                                            
[0m[1mlex.c:1522:6: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1522 |                                         (yy_c_buf_p) = (yytext_ptr) + offset;[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                        {
[0m 1523 |                                         break;[0m
      | [0;1;32m                                             
[0m      | [0;32m                                             ;} 
[0m[1mlex.c:1567:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1567 |         if ( YY_CURRENT_BUFFER == new_buffer )[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1568 |                 return;[0m
      | [0;1;32m                       
[0m[1mlex.c:1608:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1608 |         if ( ! b )[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1609 |                 YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );[0m
      | [0;1;32m                                                                                
[0m[1mlex.c:1617:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1617 |         if ( ! b->yy_ch_buf )[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1618 |                 YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );[0m
      | [0;1;32m                                                                                
[0m[1mlex.c:1634:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1634 |         if ( ! b )[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1635 |                 return;[0m
      | [0;1;32m                       
[0m[1mlex.c:1637:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1637 |         if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1638 |                 YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;[0m
      | [0;1;32m                                                               
[0m[1mlex.c:1640:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1640 |         if ( b->yy_is_our_buffer )[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1641 |                 yyfree((void *) b->yy_ch_buf  );[0m
      | [0;1;32m                                                
[0m[1mlex.c:1684:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1684 |         if ( ! b )[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1685 |                 return;[0m
      | [0;1;32m                       
[0m[1mlex.c:1701:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1701 |         if ( b == YY_CURRENT_BUFFER )[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1702 |                 yy_load_buffer_state( );[0m
      | [0;1;32m                                        
[0m[1mlex.c:1713:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1713 |         if (new_buffer == NULL)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1714 |                 return;[0m
      | [0;1;32m                       
[0m[1mlex.c:1728:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1728 |         if (YY_CURRENT_BUFFER)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1729 |                 (yy_buffer_stack_top)++;[0m
      | [0;1;32m                                        
[0m[1mlex.c:1743:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1743 |         if (!YY_CURRENT_BUFFER)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 1744 |                 return;[0m
      | [0;1;32m                       
[0m[1mlex.c:1748:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1748 |         if ((yy_buffer_stack_top) > 0)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1749 |                 --(yy_buffer_stack_top);[0m
      | [0;1;32m                                        
[0m[1mlex.c:1774:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1774 |                 if ( ! (yy_buffer_stack) )[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1775 |                         YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );[0m
      | [0;1;32m                                                                                             
[0m[1mlex.c:1794:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1794 |                 if ( ! (yy_buffer_stack) )[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1795 |                         YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );[0m
      | [0;1;32m                                                                                             
[0m[1mlex.c:1815:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1815 |              base[size-1] != YY_END_OF_BUFFER_CHAR )[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1816 |                 /* They forgot to leave room for the EOB's. */[0m
 1817 |                 return 0;[0m
      | [0;1;32m                         
[0m[1mlex.c:1820:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1820 |         if ( ! b )[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1821 |                 YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );[0m
      | [0;1;32m                                                                              
[0m[1mlex.c:1869:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1869 |         if ( ! buf )[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1870 |                 YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );[0m
      | [0;1;32m                                                                             
[0m[1mlex.c:1872:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1872 |         for ( i = 0; i < _yybytes_len; ++i )[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1873 |                 buf[i] = yybytes[i];[0m
      | [0;1;32m                                    
[0m[1mlex.c:1878:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1878 |         if ( ! b )[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1879 |                 YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );[0m
      | [0;1;32m                                                                  
[0m[1mlex.c:2105:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2105 |       if (c == '\n')[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2106 |         linenum++;[0m
 2107 |       else if (c == '*')[0m
      | [0;32m      } 
[0m[1mlex.c:2110:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2110 |           if (c == '/')[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2111 |             /* All done. */[0m
 2112 |             return;[0m
      | [0;1;32m                   
[0m[1mlex.c:2133:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2133 | read_string (len_return)[0m
      | [0;1;32m^
[0m[1mlex.c:2146:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2146 |       if (ch == '\n')[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2147 |         linenum++;[0m
      | [0;1;32m                  
[0m[1mlex.c:2152:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2152 |         unexpected_eof:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m 2153 |           yyerror (_("error: EOF in string constant"));[0m
 2154 |           done = 1;[0m
 2155 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2158:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2158 |           done = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2159 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2162:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2162 |           ch = input ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mlex.c:2166:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2166 |               ch = '\n';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2167 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2170:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2170 |               ch = '\t';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2171 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2174:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2174 |               ch = '\v';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2175 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2178:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2178 |               ch = '\b';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2179 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2182:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2182 |               ch = '\r';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2183 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2186:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2186 |               ch = '\f';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2187 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2190:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2190 |               ch = '\a';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2191 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2194:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2194 |               goto unexpected_eof;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2195 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2198:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2198 |               if (ch == '0')[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mlex.c:2206:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2206 |                       if ('0' <= ch && ch <= '7')[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2207 |                         val = val * 8 + ch - '0';[0m
 2208 |                       else[0m
      | [0;32m                      } 
[0m[1mlex.c:2221:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2221 |           if (bufpos >= buflen)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2222 |             {[0m
 2223 |               buflen += 1024;[0m
 2224 |               buf = (char *) xrealloc (buf, buflen);[0m
 2225 |             }[0m
 2226 |           buf[bufpos++] = ch;[0m
 2227 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2243:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2243 | read_regexp (node)[0m
      | [0;1;32m^
[0m[1mlex.c:2259:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2259 |         unexpected_eof:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m 2260 |           yyerror (_("error: EOF in regular expression"));[0m
 2261 |           done = 1;[0m
 2262 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2265:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2265 |           done = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2266 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2269:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2269 |           ch = input ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mlex.c:2274:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2274 |               linenum++;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2275 |               continue;[0m
 2276 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2279:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2279 |               ch = '\n';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2280 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2283:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2283 |               ch = '\r';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2284 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2287:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2287 |               ch = '\f';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2288 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2291:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2291 |               ch = '\t';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2292 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2300:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2300 |               goto unexpected_eof;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2301 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mlex.c:2304:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2304 |               if (ch == '0')[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mlex.c:2312:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2312 |                       if ('0' <= ch && ch <= '7')[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2313 |                         val = val * 8 + ch - '0';[0m
 2314 |                       else[0m
      | [0;32m                      } 
[0m[1mlex.c:2333:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2333 |           if (bufpos >= buflen)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2334 |             {[0m
 2335 |               buflen += 1024;[0m
 2336 |               buf = (char *) xrealloc (buf, buflen);[0m
 2337 |             }[0m
 2338 |           buf[bufpos++] = ch;[0m
 2339 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2352:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2352 |           node->u.re.flags |= fRE_CASE_INSENSITIVE;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2353 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:2357:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2357 |           unput (ch);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2358 |           done = 1;[0m
 2359 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mlex.c:188:18: [0m[0;1;36mnote: [0mexpanded from macro 'unput'[0m
  188 | #define unput(c) yyunput( c, (yytext_ptr)  )[0m
      | [0;1;32m                 ^
[0m98 warnings generated.
Suppressed 8 warnings (8 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 4/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpw21_xr21.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88597.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 5/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp0qu42gbf.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88594.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 6/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpj_vwtrzu.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_koi8.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 7/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpw843lff4.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_885910.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 8/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpjltalbe4.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_mac.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[ 9/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp5myivtol.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88592.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[10/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpiqfzt392.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88599.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[11/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp3nv5n3pn.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_hp8.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[12/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpeby9z8_2.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/compat/xalloc.c
[1mxalloc.c:62:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   62 | xmalloc (size)[0m
      | [0;1;32m^
[0m[1mxalloc.c:70:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   70 |       fprintf (stderr, _("xmalloc(): couldn't allocate %d bytes\n"), size);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mxalloc.c:70:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   70 |       fprintf (stderr, _("xmalloc(): couldn't allocate %d bytes\n"), size);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mxalloc.c:70:70: [0m[0;1;35mwarning: [0m[1mformat specifies type 'int' but the argument has type 'size_t' (aka 'unsigned long') [clang-diagnostic-format][0m
   70 |       fprintf (stderr, _("xmalloc(): couldn't allocate %d bytes\n"), size);[0m
      | [0;1;32m                                                       ~~            ^~~~
[0m      | [0;32m                                                       %zu
[0m[1mxalloc.c:79:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   79 | xcalloc (num, size)[0m
      | [0;1;32m^
[0m[1mxalloc.c:88:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   88 |       fprintf (stderr, _("xcalloc(): couldn't allocate %d bytes\n"), size);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mxalloc.c:88:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   88 |       fprintf (stderr, _("xcalloc(): couldn't allocate %d bytes\n"), size);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mxalloc.c:88:70: [0m[0;1;35mwarning: [0m[1mformat specifies type 'int' but the argument has type 'size_t' (aka 'unsigned long') [clang-diagnostic-format][0m
   88 |       fprintf (stderr, _("xcalloc(): couldn't allocate %d bytes\n"), size);[0m
      | [0;1;32m                                                       ~~            ^~~~
[0m      | [0;32m                                                       %zu
[0m[1mxalloc.c:97:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   97 | xrealloc (ptr, size)[0m
      | [0;1;32m^
[0m[1mxalloc.c:103:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  103 |   if (ptr == NULL)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  104 |     return xmalloc (size);[0m
      | [0;1;32m                          
[0m[1mxalloc.c:109:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  109 |       fprintf (stderr, _("xrealloc(): couldn't reallocate %d bytes\n"), size);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mxalloc.c:109:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  109 |       fprintf (stderr, _("xrealloc(): couldn't reallocate %d bytes\n"), size);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mxalloc.c:109:73: [0m[0;1;35mwarning: [0m[1mformat specifies type 'int' but the argument has type 'size_t' (aka 'unsigned long') [clang-diagnostic-format][0m
  109 |       fprintf (stderr, _("xrealloc(): couldn't reallocate %d bytes\n"), size);[0m
      | [0;1;32m                                                          ~~            ^~~~
[0m      | [0;32m                                                          %zu
[0m[1mxalloc.c:118:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  118 | xfree (ptr)[0m
      | [0;1;32m^
[0m[1mxalloc.c:121:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  121 |   if (ptr == NULL)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  122 |     return;[0m
      | [0;1;32m           
[0m[1mxalloc.c:129:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  129 | xstrdup (str)[0m
      | [0;1;32m^
[0m[1mxalloc.c:135:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  135 |   strcpy (tmp, str);[0m
      | [0;1;32m  ^~~~~~
[0m[1mxalloc.c:135:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  135 |   strcpy (tmp, str);[0m
      | [0;1;32m  ^~~~~~
[0m16 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[13/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpstx90w8d.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88591.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[14/33][0.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmprs6ogym2.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_vms.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[15/33][0.3s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpszvu2q0f.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88595.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[16/33][0.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpyiehjlyr.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/deffont.c
[1mdeffont.c:313:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  313 |   if (font == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  314 |     goto error_out;[0m
      | [0;1;32m                   
[0m[1mdeffont.c:317:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  317 |   if (font->private == NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  318 |     goto error_out;[0m
      | [0;1;32m                   
[0m[1mdeffont.c:320:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  320 |   if (font->private->fontnames == NULL)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  321 |     goto error_out;[0m
      | [0;1;32m                   
[0m[1mdeffont.c:329:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  329 |   if (font->global_info.FontName == NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  330 |     goto error_out;[0m
      | [0;1;32m                   
[0m[1mdeffont.c:331:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  331 |   strcpy (font->global_info.FontName, "Courier");[0m
      | [0;1;32m  ^~~~~~
[0m[1mdeffont.c:331:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  331 |   strcpy (font->global_info.FontName, "Courier");[0m
      | [0;1;32m  ^~~~~~
[0m[1mdeffont.c:350:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  350 |   if (font->character_metrics == NULL)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  351 |     goto error_out;[0m
      | [0;1;32m                   
[0m[1mdeffont.c:357:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  357 |       if (cm->name == NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  358 |         goto error_out;[0m
      | [0;1;32m                       
[0m[1mdeffont.c:359:7: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  359 |       strcpy (cm->name, builtin_courier[i].character);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdeffont.c:359:7: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  359 |       strcpy (cm->name, builtin_courier[i].character);[0m
      | [0;1;32m      ^~~~~~
[0m[1mdeffont.c:362:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  362 |                         strlen (cm->name), cm, NULL))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  363 |         goto error_out;[0m
      | [0;1;32m                       
[0m11 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[17/33][0.8s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpinq1dcx_.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/states/gram.c
[1mgram.c:1368:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1368 |   if (!yymsg)[0m
      | [0;1;32m             ^
[0m      | [0;32m              {
[0m 1369 |     yymsg = "Deleting";[0m
      | [0;1;32m                       
[0m[1mgram.c:1376:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1376 |         break;[0m
      | [0;1;32m        ^    
[0m      | [0;32m        {    ;} 
[0m[1mgram.c:1539:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1539 |       if (YYMAXDEPTH <= yystacksize)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1540 |         goto yyexhaustedlab;[0m
      | [0;1;32m                            
[0m[1mgram.c:1542:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1542 |       if (YYMAXDEPTH < yystacksize)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1543 |         yystacksize = YYMAXDEPTH;[0m
      | [0;1;32m                                 
[0m[1mgram.c:1549:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1549 |         if (! yyptr)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1550 |           goto yyexhaustedlab;[0m
      | [0;1;32m                              
[0m[1mgram.c:1554:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1554 |         if (yyss1 != yyssa)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1555 |           YYSTACK_FREE (yyss1);[0m
      | [0;1;32m                               
[0m[1mgram.c:1566:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1566 |       if (yyss + yystacksize - 1 <= yyssp)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1567 |         YYABORT;[0m
      | [0;1;32m                
[0m[1mgram.c:1572:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1572 |   if (yystate == YYFINAL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1573 |     YYACCEPT;[0m
      | [0;1;32m             
[0m[1mgram.c:1587:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1587 |   if (yypact_value_is_default (yyn))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1588 |     goto yydefault;[0m
      | [0;1;32m                   
[0m[1mgram.c:1613:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1613 |   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1614 |     goto yydefault;[0m
      | [0;1;32m                   
[0m[1mgram.c:1618:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1618 |       if (yytable_value_is_error (yyn))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1619 |         goto yyerrlab;[0m
      | [0;1;32m                      
[0m[1mgram.c:1626:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1626 |   if (yyerrstatus)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1627 |     yyerrstatus--;[0m
      | [0;1;32m                  
[0m[1mgram.c:1646:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1646 |   if (yyn == 0)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m 1647 |     goto yyerrlab;[0m
      | [0;1;32m                  
[0m[1mgram.c:1676:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1676 |     { start_stmts = (yyvsp[(3) - (4)].lst); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1677 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1683:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1683 |     { startrules = (yyvsp[(3) - (4)].lst); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1684 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1690:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1690 |     { namerules = (yyvsp[(3) - (4)].lst); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1691 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1697:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1697 |     { define_state ((yyvsp[(2) - (5)].node), NULL, (yyvsp[(4) - (5)].lst)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1698 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1704:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1704 |     { define_state ((yyvsp[(2) - (7)].node), (yyvsp[(4) - (7)].node), (yyvsp[(6) - (7)].lst)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1705 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1711:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1711 |     { list_append (global_stmts, (yyvsp[(1) - (1)].stmt)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1712 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1718:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1718 |     { (yyval.lst) = list (); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1719 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1725:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1725 |     { list_append ((yyvsp[(1) - (4)].lst), cons ((yyvsp[(2) - (4)].node), (yyvsp[(3) - (4)].node))); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1726 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1732:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1732 |     { (yyval.lst) = list (); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1733 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1739:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1739 |     { list_append ((yyvsp[(1) - (2)].lst), (yyvsp[(2) - (2)].cons)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1740 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1746:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1746 |     { (yyval.cons) = cons (RULE_BEGIN, (yyvsp[(3) - (4)].lst)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1747 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1753:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1753 |     { (yyval.cons) = cons (RULE_END, (yyvsp[(3) - (4)].lst)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1754 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1760:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1760 |     { (yyval.cons) = cons ((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].lst)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1761 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1767:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1767 |     { (yyval.cons) = cons ((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].lst)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1768 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1774:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1774 |     { (yyval.lst) = list (); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1775 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1781:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1781 |     { (yyval.lst) = (yyvsp[(1) - (1)].lst); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1782 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1788:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1788 |     { (yyval.lst) = list (); list_append ((yyval.lst), (yyvsp[(1) - (1)].node)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1789 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1795:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1795 |     { list_append ((yyvsp[(1) - (3)].lst), (yyvsp[(3) - (3)].node)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1796 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1802:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1802 |     { (yyval.lst) = list (); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1803 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1809:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1809 |     { (yyval.lst) = (yyvsp[(2) - (3)].lst); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1810 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1816:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1816 |     { (yyval.lst) = list (); list_append ((yyval.lst), (yyvsp[(1) - (1)].cons)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1817 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1823:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1823 |     { list_append ((yyvsp[(1) - (3)].lst), (yyvsp[(3) - (3)].cons)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1824 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1830:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1830 |     { (yyval.cons) = cons ((yyvsp[(1) - (1)].node), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1831 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1837:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1837 |     { (yyval.cons) = cons ((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].expr)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1838 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1844:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1844 |     { (yyval.lst) = list (); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1845 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1851:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1851 |     { list_append ((yyvsp[(1) - (2)].lst), (yyvsp[(2) - (2)].stmt)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1852 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1858:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1858 |     { (yyval.stmt) = mk_stmt (sRETURN, NULL, NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1859 |                                                         NULL, NULL); }[0m
 1860 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1866:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1866 |     { (yyval.stmt) = mk_stmt (sRETURN, (yyvsp[(2) - (3)].expr), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1867 |                                                         NULL, NULL); }[0m
 1868 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1874:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1874 |     { (yyval.stmt) = mk_stmt (sDEFSUB, (yyvsp[(2) - (9)].node),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1875 |                                                         cons (cons ((yyvsp[(4) - (9)].lst), (yyvsp[(7) - (9)].lst)),[0m
 1876 |                                                               (yyvsp[(8) - (9)].lst)),[0m
 1877 |                                                         NULL, NULL); }[0m
 1878 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1884:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1884 |     { (yyval.stmt) = mk_stmt (sBLOCK, (yyvsp[(2) - (3)].lst), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1885 |                                                         NULL, NULL); }[0m
 1886 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1892:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1892 |     { (yyval.stmt) = mk_stmt (sIF, (yyvsp[(3) - (5)].expr), (yyvsp[(5) - (5)].stmt), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1893 |                                                         NULL); }[0m
 1894 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1900:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1900 |     { (yyval.stmt) = mk_stmt (sIF, (yyvsp[(3) - (7)].expr), (yyvsp[(5) - (7)].stmt), (yyvsp[(7) - (7)].stmt),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1901 |                                                         NULL); }[0m
 1902 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1908:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1908 |     { (yyval.stmt) = mk_stmt (sWHILE, (yyvsp[(3) - (5)].expr), (yyvsp[(5) - (5)].stmt),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1909 |                                                         NULL, NULL); }[0m
 1910 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1916:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1916 |     { (yyval.stmt) = mk_stmt (sFOR, (yyvsp[(3) - (9)].expr), (yyvsp[(5) - (9)].expr), (yyvsp[(7) - (9)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1917 |                                                         (yyvsp[(9) - (9)].stmt)); }[0m
 1918 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1924:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1924 |     { (yyval.stmt) = mk_stmt (sEXPR, (yyvsp[(1) - (2)].expr), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1925 |                                                         NULL, NULL); }[0m
 1926 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1932:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1932 |     { (yyval.expr) = mk_expr (eSTRING, (yyvsp[(1) - (1)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1933 |                                                         NULL); }[0m
 1934 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1940:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1940 |     { (yyval.expr) = mk_expr (eREGEXP, (yyvsp[(1) - (1)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1941 |                                                         NULL); }[0m
 1942 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1948:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1948 |     { (yyval.expr) = mk_expr (eINTEGER, (yyvsp[(1) - (1)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1949 |                                                         NULL); }[0m
 1950 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1956:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1956 |     { (yyval.expr) = mk_expr (eREAL, (yyvsp[(1) - (1)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1957 |                                                         NULL); }[0m
 1958 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1964:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1964 |     { (yyval.expr) = mk_expr (eSYMBOL, (yyvsp[(1) - (1)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1965 |                                                         NULL); }[0m
 1966 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1972:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1972 |     { (yyval.expr) = mk_expr (eNOT, (yyvsp[(2) - (2)].expr), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1973 |                                                         NULL); }[0m
 1974 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1980:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1980 |     { (yyval.expr) = mk_expr (eAND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1981 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1987:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1987 |     { (yyval.expr) = mk_expr (eOR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1988 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:1994:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1994 |     { (yyval.expr) = mk_expr (eFCALL, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].lst),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 1995 |                                                         NULL); }[0m
 1996 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2002:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2002 |     { (yyval.expr) = mk_expr (eASSIGN, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2003 |                                                         NULL); }[0m
 2004 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2010:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2010 |     { (yyval.expr) = mk_expr (eADDASSIGN, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2011 |                                                         NULL); }[0m
 2012 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2018:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2018 |     { (yyval.expr) = mk_expr (eSUBASSIGN, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2019 |                                                         NULL); }[0m
 2020 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2026:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2026 |     { (yyval.expr) = mk_expr (eMULASSIGN, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2027 |                                                         NULL); }[0m
 2028 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2034:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2034 |     { (yyval.expr) = mk_expr (eDIVASSIGN, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2035 |                                                         NULL); }[0m
 2036 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2042:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2042 |     { (yyval.expr) = mk_expr (ePOSTFIXADD, (yyvsp[(1) - (2)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2043 |                                                         NULL); }[0m
 2044 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2050:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2050 |     { (yyval.expr) = mk_expr (ePOSTFIXSUB, (yyvsp[(1) - (2)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2051 |                                                         NULL); }[0m
 2052 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2058:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2058 |     { (yyval.expr) = mk_expr (ePREFIXADD, (yyvsp[(2) - (2)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2059 |                                                         NULL); }[0m
 2060 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2066:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2066 |     { (yyval.expr) = mk_expr (ePREFIXSUB, (yyvsp[(2) - (2)].node), NULL,[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2067 |                                                         NULL); }[0m
 2068 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2074:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2074 |     { (yyval.expr) = mk_expr (eARRAYASSIGN, (yyvsp[(1) - (6)].expr), (yyvsp[(3) - (6)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2075 |                                                         (yyvsp[(6) - (6)].expr)); }[0m
 2076 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2082:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2082 |     { (yyval.expr) = (yyvsp[(2) - (3)].expr); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2083 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2089:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2089 |     { (yyval.expr) = mk_expr (eARRAYREF, (yyvsp[(1) - (4)].expr), (yyvsp[(3) - (4)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2090 |                                                         NULL); }[0m
 2091 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2097:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2097 |     { (yyval.expr) = mk_expr (eQUESTCOLON, (yyvsp[(1) - (5)].expr), (yyvsp[(3) - (5)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2098 |                                                         (yyvsp[(5) - (5)].expr)); }[0m
 2099 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2105:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2105 |     { (yyval.expr) = mk_expr (eMULT, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2106 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2112:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2112 |     { (yyval.expr) = mk_expr (eDIV, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2113 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2119:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2119 |     { (yyval.expr) = mk_expr (ePLUS, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2120 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2126:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2126 |     { (yyval.expr) = mk_expr (eMINUS, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr),[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2127 |                                                         NULL); }[0m
 2128 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2134:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2134 |     { (yyval.expr) = mk_expr (eLT, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2135 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2141:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2141 |     { (yyval.expr) = mk_expr (eGT, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2142 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2148:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2148 |     { (yyval.expr) = mk_expr (eEQ, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2149 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2155:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2155 |     { (yyval.expr) = mk_expr (eNE, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2156 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2162:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2162 |     { (yyval.expr) = mk_expr (eGE, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2163 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2169:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2169 |     { (yyval.expr) = mk_expr (eLE, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr), NULL); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2170 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2176:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2176 |     { (yyval.expr) = NULL; }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2177 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2183:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2183 |     { (yyval.expr) = (yyvsp[(1) - (1)].expr); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2184 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2190:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2190 |     { (yyval.lst) = list (); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2191 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2197:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2197 |     { (yyval.lst) = (yyvsp[(1) - (1)].lst); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2198 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2204:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2204 |     { (yyval.lst) = list (); list_append ((yyval.lst), (yyvsp[(1) - (1)].expr)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2205 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2211:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2211 |     { list_append ((yyvsp[(1) - (3)].lst), (yyvsp[(3) - (3)].expr)); }[0m
      | [0;1;32m    ^
[0m      | [0;32m    {
[0m 2212 |     break;[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mgram.c:2218:16: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2218 |       default: break;[0m
      | [0;1;32m               ^    
[0m      | [0;32m               {    ;} 
[0m[1mgram.c:2246:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2246 |   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 2247 |     yystate = yytable[yystate];[0m
 2248 |   else[0m
      | [0;32m  } 
[0m[1mgram.c:2248:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2248 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 2249 |     yystate = yydefgoto[yyn - YYNTOKENS];[0m
      | [0;1;32m                                         
[0m[1mgram.c:2312:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2312 |           if (yychar == YYEOF)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2313 |             YYABORT;[0m
      | [0;1;32m                    
[0m[1mgram.c:2336:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2336 |   if (/*CONSTCOND*/ 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2337 |      goto yyerrorlab;[0m
      | [0;1;32m                     
[0m[1mgram.c:2363:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2363 |               if (0 < yyn)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2364 |                 break;[0m
      | [0;1;32m                      
[0m[1mgram.c:2369:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2369 |       if (yyssp == yyss)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2370 |         YYABORT;[0m
      | [0;1;32m                
[0m[1mgram.c:2434:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2434 |   if (yyss != yyssa)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2435 |     YYSTACK_FREE (yyss);[0m
      | [0;1;32m                        
[0m[1mgram.c:2452:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2452 | yyerror (msg)[0m
      | [0;1;32m^
[0m103 warnings generated.
Suppressed 8 warnings (8 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[18/33][0.9s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpwn8ichlp.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_88593.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[19/33][1.5s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmprpxq66dc.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/e_pc.c
2 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[20/33][3.7s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp2mmx9z3p.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/src/prt_lpr.c
12 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[21/33][4.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpxnttpn0n.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/strhash.c
[1mstrhash.c:77:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   77 |   if (!tmp)[0m
      | [0;1;32m           ^
[0m      | [0;32m            {
[0m   78 |     return NULL;[0m
      | [0;1;32m                
[0m[1mstrhash.c:100:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  100 |   if (!hash)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  101 |     return;[0m
      | [0;1;32m           
[0m[1mstrhash.c:104:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  104 |   for (i = 0; i < HASH_SIZE; i++)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  105 |     for (list = hash->hash_table[i]; list; list = list_next)[0m
  106 |       {[0m
  107 |         list_next = list->next;[0m
  108 |         free (list->key);[0m
  109 |         free (list);[0m
  110 |       }[0m
      | [0;1;32m       
[0m[1mstrhash.c:125:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  125 |   if (!hash || !key || keylen <= 0)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  126 |     return 0;[0m
      | [0;1;32m             
[0m[1mstrhash.c:128:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  128 |   if (old_data)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m  129 |     *old_data = NULL;[0m
      | [0;1;32m                     
[0m[1mstrhash.c:133:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  133 |   for (list = hash->hash_table[pos]; list; prev = list, list = list->next)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m[1mstrhash.c:140:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  140 |             if (old_data)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  141 |               *old_data = list->data;[0m
      | [0;1;32m                                     
[0m[1mstrhash.c:151:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  151 |     else if (list->keylen > keylen)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  152 |       /* Lists are kept sorted so that smallest keys are at the head and[0m
  153 |          keys with equal length are in normal sorted order. */[0m
  154 |       break;[0m
      | [0;1;32m            
[0m[1mstrhash.c:158:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  158 |   if (!list)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  159 |     return 0;[0m
      | [0;1;32m             
[0m[1mstrhash.c:167:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  167 |   memcpy (list->key, key, keylen);[0m
      | [0;1;32m  ^~~~~~
[0m[1mstrhash.c:167:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  167 |   memcpy (list->key, key, keylen);[0m
      | [0;1;32m  ^~~~~~
[0m[1mstrhash.c:195:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  195 |   if (!hash || !key || keylen <= 0 || !data)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  196 |     return 0;[0m
      | [0;1;32m             
[0m[1mstrhash.c:200:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  200 |   for (list = hash->hash_table[pos]; list; list = list->next)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  201 |     if (list->keylen == keylen)[0m
  202 |       {[0m
  203 |         cmp_val = memcmp (key, list->key, keylen);[0m
  204 |         if (cmp_val == 0)[0m
  205 |           {[0m
  206 |             *data = list->data;[0m
  207 |             return 1;[0m
  208 |           }[0m
  209 |         else if (cmp_val < 0)[0m
  210 |           /* Run over. */[0m
  211 |           break;[0m
  212 |       }[0m
  213 |     else if (list->keylen > keylen)[0m
  214 |       /* Run over. */[0m
  215 |       break;[0m
      | [0;1;32m            
[0m[1mstrhash.c:209:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  209 |         else if (cmp_val < 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  210 |           /* Run over. */[0m
  211 |           break;[0m
      | [0;1;32m                
[0m[1mstrhash.c:213:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  213 |     else if (list->keylen > keylen)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  214 |       /* Run over. */[0m
  215 |       break;[0m
      | [0;1;32m            
[0m[1mstrhash.c:227:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  227 |   if (!hash || !key || keylen <= 0 || !data)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  228 |     return 0;[0m
      | [0;1;32m             
[0m[1mstrhash.c:232:75: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  232 |   for (list = hash->hash_table[pos]; list; prev = list, list = list->next)[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m[1mstrhash.c:239:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  239 |             if (prev == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  240 |               hash->hash_table[pos] = list->next;[0m
  241 |             else[0m
      | [0;32m            } 
[0m[1mstrhash.c:241:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  241 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  242 |               prev->next = list->next;[0m
      | [0;1;32m                                      
[0m[1mstrhash.c:257:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  257 |         else if (cmp_val < 0)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  258 |           /* Not found. */[0m
  259 |           break;[0m
      | [0;1;32m                
[0m[1mstrhash.c:261:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  261 |     else if (list->keylen > keylen)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  262 |       /* Run over. */[0m
  263 |       break;[0m
      | [0;1;32m            
[0m[1mstrhash.c:273:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  273 |   if (!hash || !key_return || !keylen_return || !data_return)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  274 |     return 0;[0m
      | [0;1;32m             
[0m[1mstrhash.c:295:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  295 |   if (!hash || !key_return || !keylen_return || !data_return)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m  296 |     return 0;[0m
      | [0;1;32m             
[0m[1mstrhash.c:300:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  300 |       if (hash->next_item == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  301 |         hash->next_item = hash->hash_table[hash->next_idx];[0m
  302 |       else[0m
      | [0;32m      } 
[0m[1mstrhash.c:302:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  302 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  303 |         hash->next_item = hash->next_item->next;[0m
      | [0;1;32m                                                
[0m[1mstrhash.c:382:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  382 |   for (i = 0; i < keylen; i++)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  383 |     val = (val << 5) ^ (unsigned char) key[i][0m
  384 |       ^ (val >> 16) ^ (val >> 7);[0m
      | [0;1;32m                                 
[0m27 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[22/33][5.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp6i0g5wxu.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/afmtest.c
[1mafmtest.c:81:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   81 |   if (program)[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m   82 |     program++;[0m
   83 |   else[0m
      | [0;32m  } 
[0m[1mafmtest.c:83:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   83 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   84 |     program = argv[0];[0m
      | [0;1;32m                      
[0m[1mafmtest.c:87:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   87 |   HANDLE_ERROR ("couldn't create library");[0m
      | [0;1;32m  ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:87:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
   87 |   HANDLE_ERROR ("couldn't create library");[0m
      | [0;1;32m  ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:100:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  100 |           fprintf (stderr, "%s: couldn't open font \"%s\", using default\n",[0m
      | [0;1;32m          ^~~~~~~
[0m[1mafmtest.c:100:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  100 |           fprintf (stderr, "%s: couldn't open font \"%s\", using default\n",[0m
      | [0;1;32m          ^~~~~~~
[0m[1mafmtest.c:103:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  103 |           HANDLE_ERROR ("couldn't open default font");[0m
      | [0;1;32m          ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:103:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  103 |           HANDLE_ERROR ("couldn't open default font");[0m
      | [0;1;32m          ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:109:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  109 |       HANDLE_ERROR ("couldn't close font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:109:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  109 |       HANDLE_ERROR ("couldn't close font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:114:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  114 |       HANDLE_ERROR ("couldn't open font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:114:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  114 |       HANDLE_ERROR ("couldn't open font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:117:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  117 |       HANDLE_ERROR ("couldn't encode font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:117:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  117 |       HANDLE_ERROR ("couldn't encode font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:119:7: [0m[0;1;35mwarning: [0m[1mValue stored to 'error' is never read [clang-analyzer-deadcode.DeadStores][0m
  119 |       error = afm_font_stringwidth (font, atof (argv[3]), argv[4],[0m
      | [0;1;32m      ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  120 |                                     strlen (argv[4]), &width, &height);[0m
      | [0;1;32m                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmtest.c:119:7: [0m[0;1;36mnote: [0mValue stored to 'error' is never read[0m
  119 |       error = afm_font_stringwidth (font, atof (argv[3]), argv[4],[0m
      | [0;1;32m      ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  120 |                                     strlen (argv[4]), &width, &height);[0m
      | [0;1;32m                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmtest.c:124:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  124 |       HANDLE_ERROR ("couldn't close font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:124:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  124 |       HANDLE_ERROR ("couldn't close font");[0m
      | [0;1;32m      ^
[0m[1mafmtest.c:48:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   48 |       fprintf (stderr, "afmtest: %s: %s\n", msg, buf);  \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmtest.c:136:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  136 |               fprintf (stderr, "%s: couldn't open AFM file \"%s\": %s\n",[0m
      | [0;1;32m              ^~~~~~~
[0m[1mafmtest.c:136:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  136 |               fprintf (stderr, "%s: couldn't open AFM file \"%s\": %s\n",[0m
      | [0;1;32m              ^~~~~~~
[0m[1mafmtest.c:179:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  179 |   fprintf (stderr,[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafmtest.c:179:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  179 |   fprintf (stderr,[0m
      | [0;1;32m  ^~~~~~~
[0m14 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[23/33][8.8s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp7jr2w0fh.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/src/mkafmmap.c
[1mmkafmmap.c:111:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  111 |   if (program == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  112 |     program = argv[0];[0m
  113 |   else[0m
      | [0;32m  } 
[0m[1mmkafmmap.c:113:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  113 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  114 |     program++;[0m
      | [0;1;32m              
[0m[1mmkafmmap.c:137:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  137 |       if (c == -1)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  138 |         break;[0m
      | [0;1;32m              
[0m[1mmkafmmap.c:143:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  143 |           usage ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  144 |           exit (0);[0m
      | [0;1;32m                  
[0m      | [0;32m                  ;} 
[0m[1mmkafmmap.c:148:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  148 |           if (strcmp (optarg, "-") == 0)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  149 |             fname = NULL;[0m
  150 |           else[0m
  151 |             fname = optarg;[0m
  152 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmkafmmap.c:148:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  148 |           if (strcmp (optarg, "-") == 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  149 |             fname = NULL;[0m
  150 |           else[0m
      | [0;32m          } 
[0m[1mmkafmmap.c:150:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  150 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  151 |             fname = optarg;[0m
      | [0;1;32m                           
[0m[1mmkafmmap.c:155:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  155 |           printf ("%s for GNU %s %s\n", program, PACKAGE, VERSION);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  156 |           exit (0);[0m
  157 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmkafmmap.c:160:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  160 |           usage ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  161 |           exit (1);[0m
  162 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmkafmmap.c:175:4: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  175 |           sprintf (buf, _("%s: couldn't open output file \"%s\""),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmkafmmap.c:175:4: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  175 |           sprintf (buf, _("%s: couldn't open output file \"%s\""),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmkafmmap.c:189:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  189 |   HANDLE_ERROR (_("couldn't create AFM library"));[0m
      | [0;1;32m  ^
[0m[1mmkafmmap.c:59:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   59 |       fprintf (stderr, "%s: %s: %s\n", program, msg, buf);      \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmkafmmap.c:189:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  189 |   HANDLE_ERROR (_("couldn't create AFM library"));[0m
      | [0;1;32m  ^
[0m[1mmkafmmap.c:59:7: [0m[0;1;36mnote: [0mexpanded from macro 'HANDLE_ERROR'[0m
   59 |       fprintf (stderr, "%s: %s: %s\n", program, msg, buf);      \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmkafmmap.c:193:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  193 |       fprintf (mfp, "%s...\n", argv[i]);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmkafmmap.c:193:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  193 |       fprintf (mfp, "%s...\n", argv[i]);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmkafmmap.c:202:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  202 |           if (cp == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  203 |             cp = argv[i];[0m
  204 |           else[0m
      | [0;32m          } 
[0m[1mmkafmmap.c:204:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  204 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  205 |             cp++;[0m
      | [0;1;32m                 
[0m[1mmkafmmap.c:208:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  208 |           if (sf)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m  209 |             len = sf - cp;[0m
  210 |           else[0m
      | [0;32m          } 
[0m[1mmkafmmap.c:210:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  210 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  211 |             len = strlen (cp);[0m
      | [0;1;32m                              
[0m[1mmkafmmap.c:213:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  213 |           fprintf (ofp, "%-30s\t%.*s\n", font->global_info.FontName, len, cp);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmkafmmap.c:213:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  213 |           fprintf (ofp, "%-30s\t%.*s\n", font->global_info.FontName, len, cp);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmkafmmap.c:220:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  220 |           fprintf (mfp, "%s: %s\n", program, buf);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmkafmmap.c:220:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  220 |           fprintf (mfp, "%s: %s\n", program, buf);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmkafmmap.c:224:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  224 |   if (fname)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  225 |     fclose (ofp);[0m
      | [0;1;32m                 
[0m32 warnings generated.
Suppressed 13 warnings (13 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[24/33][54.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp3p0bhl9l.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/states/main.c
[1mmain.c:176:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  176 | main (argc, argv)[0m
      | [0;1;32m^
[0m[1mmain.c:188:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  188 |   if (program == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  189 |     program = argv[0];[0m
  190 |   else[0m
      | [0;32m  } 
[0m[1mmain.c:190:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  190 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  191 |     program++;[0m
      | [0;1;32m              
[0m[1mmain.c:197:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  197 |   sprintf (version, _("states for %s"), PACKAGE_STRING);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mmain.c:197:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  197 |   sprintf (version, _("states for %s"), PACKAGE_STRING);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mmain.c:239:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  239 |       if (c == -1)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  240 |         break;[0m
      | [0;1;32m              
[0m[1mmain.c:245:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  245 |           vardef = (VariableDef *) xcalloc (1, sizeof (*vardef));[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mmain.c:247:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  247 |           strcpy (vardef->sym, optarg);[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:247:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  247 |           strcpy (vardef->sym, optarg);[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:252:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  252 |               fprintf (stderr, _("%s: malformed variable definition \"%s\"\n"),[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:252:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  252 |               fprintf (stderr, _("%s: malformed variable definition \"%s\"\n"),[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:259:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  259 |           if (vardefs)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  260 |             vardefs_tail->next = vardef;[0m
  261 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:261:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  261 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  262 |             vardefs = vardef;[0m
      | [0;1;32m                             
[0m[1mmain.c:267:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  267 |           defs_file = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  268 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:271:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  271 |           usage ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  272 |           exit (0);[0m
  273 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:276:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  276 |           ofp = fopen (optarg, "w");[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  277 |           if (ofp == NULL)[0m
  278 |             {[0m
  279 |               fprintf (stderr,[0m
  280 |                        _("%s: couldn't create output file \"%s\": %s\n"),[0m
  281 |                        program, optarg, strerror (errno));[0m
  282 |               exit (1);[0m
  283 |             }[0m
  284 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:279:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  279 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:279:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  279 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:287:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  287 |           path = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  288 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:291:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  291 |           start_state_arg = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  292 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:295:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  295 |           verbose++;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  296 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:299:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  299 |           printf ("%s\n", version);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  300 |           exit (0);[0m
  301 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:304:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  304 |           if (strcmp (optarg, "light") == 0)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  305 |             warning_level = WARN_LIGHT;[0m
  306 |           else if (strcmp (optarg, "all") == 0)[0m
  307 |             warning_level = WARN_ALL;[0m
  308 |           else[0m
  309 |             {[0m
  310 |               fprintf (stderr,[0m
  311 |                        _("%s: unknown warning level `%s'\n"),[0m
  312 |                        program, optarg);[0m
  313 |               exit (1);[0m
  314 |             }[0m
  315 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:304:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  304 |           if (strcmp (optarg, "light") == 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  305 |             warning_level = WARN_LIGHT;[0m
  306 |           else if (strcmp (optarg, "all") == 0)[0m
      | [0;32m          } 
[0m[1mmain.c:306:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  306 |           else if (strcmp (optarg, "all") == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  307 |             warning_level = WARN_ALL;[0m
  308 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:310:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  310 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:310:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  310 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:318:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  318 |           fprintf (stderr, _("Try `%s --help' for more information.\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:318:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  318 |           fprintf (stderr, _("Try `%s --help' for more information.\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:318:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  318 |           fprintf (stderr, _("Try `%s --help' for more information.\n"),[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  319 |                    program);[0m
  320 |           exit (1);[0m
  321 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:324:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  324 |           printf ("Hey! main() didn't handle option \"%c\" (%d)", c, c);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  325 |           if (optarg)[0m
  326 |             printf (" with arg %s", optarg);[0m
  327 |           printf ("\n");[0m
  328 |           abort ();[0m
  329 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:325:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  325 |           if (optarg)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  326 |             printf (" with arg %s", optarg);[0m
      | [0;1;32m                                            
[0m[1mmain.c:348:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  348 |         if (strcmp (argv[i], "-") == 0)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  349 |           data = STDIN_NAME;[0m
  350 |         else[0m
      | [0;32m        } 
[0m[1mmain.c:350:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  350 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  351 |           data = argv[i];[0m
      | [0;1;32m                         
[0m[1mmain.c:360:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  360 |         fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:360:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  360 |         fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:374:4: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  374 |           sprintf (path, ".%c%.*s", PATH_SEPARATOR, cp - defs_file, defs_file);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:374:4: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  374 |           sprintf (path, ".%c%.*s", PATH_SEPARATOR, cp - defs_file, defs_file);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:374:25: [0m[0;1;35mwarning: [0m[1mfield precision should have type 'int', but argument has type 'long' [clang-diagnostic-format][0m
  374 |           sprintf (path, ".%c%.*s", PATH_SEPARATOR, cp - defs_file, defs_file);[0m
      | [0;1;32m                             ~~^~                   ~~~~~~~~~~~~~~
[0m[1mmain.c:376:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  376 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  377 |         path = ".";[0m
      | [0;1;32m                   
[0m[1mmain.c:396:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  396 |           fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:396:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  396 |           fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:408:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  408 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m[1mmain.c:421:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  421 |                 fprintf (stderr, _("%s: couldn't open input file `%s': %s\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:421:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  421 |                 fprintf (stderr, _("%s: couldn't open input file `%s': %s\n"),[0m
      | [0;1;32m                ^~~~~~~
[0m[1mmain.c:426:6: [0m[0;1;35mwarning: [0m[1mStream pointer might be NULL [clang-analyzer-unix.Stream][0m
  426 |             fclose (ifp);[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mmain.c:188:7: [0m[0;1;36mnote: [0mAssuming 'program' is not equal to NULL[0m
  188 |   if (program == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~
[0m[1mmain.c:188:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  188 |   if (program == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:233:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  233 |   while (1)[0m
      | [0;1;32m  ^
[0m[1mmain.c:239:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  239 |       if (c == -1)[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:239:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  239 |       if (c == -1)[0m
      | [0;1;32m      ^
[0m[1mmain.c:240:2: [0m[0;1;36mnote: [0m Execution continues on line 335[0m
  240 |         break;[0m
      | [0;1;32m        ^
[0m[1mmain.c:343:22: [0m[0;1;36mnote: [0mAssuming 'i' is >= 'argc'[0m
  343 |     for (i = optind; i < argc; i++)[0m
      | [0;1;32m                     ^~~~~~~~
[0m[1mmain.c:343:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 358[0m
  343 |     for (i = optind; i < argc; i++)[0m
      | [0;1;32m    ^
[0m[1mmain.c:358:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  358 |     if (!strhash_put (ns_vars, "argv", 4, v, (void **) &n))[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:358:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  358 |     if (!strhash_put (ns_vars, "argv", 4, v, (void **) &n))[0m
      | [0;1;32m    ^
[0m[1mmain.c:367:7: [0m[0;1;36mnote: [0m'path' is equal to NULL[0m
  367 |   if (path == NULL)[0m
      | [0;1;32m      ^~~~
[0m[1mmain.c:367:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  367 |   if (path == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:371:11: [0m[0;1;36mnote: [0mAssuming 'cp' is null[0m
  371 |       if (cp)[0m
      | [0;1;32m          ^~
[0m[1mmain.c:371:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  371 |       if (cp)[0m
      | [0;1;32m      ^
[0m[1mmain.c:384:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 403[0m
  384 |   for (vardef = vardefs; vardef; vardef = vardef->next)[0m
      | [0;1;32m  ^
[0m[1mmain.c:403:7: [0m[0;1;36mnote: [0mAssuming 'optind' is not equal to 'argc'[0m
  403 |   if (optind == argc)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mmain.c:403:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  403 |   if (optind == argc)[0m
      | [0;1;32m  ^
[0m[1mmain.c:409:12: [0m[0;1;36mnote: [0mAssuming 'optind' is < 'argc'[0m
  409 |     for (; optind < argc; optind++)[0m
      | [0;1;32m           ^~~~~~~~~~~~~
[0m[1mmain.c:409:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  409 |     for (; optind < argc; optind++)[0m
      | [0;1;32m    ^
[0m[1mmain.c:411:6: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  411 |         if (strcmp (argv[optind], "-") == 0)[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:411:2: [0m[0;1;36mnote: [0mTaking false branch[0m
  411 |         if (strcmp (argv[optind], "-") == 0)[0m
      | [0;1;32m        ^
[0m[1mmain.c:419:10: [0m[0;1;36mnote: [0m'ifp' is not equal to NULL[0m
  419 |             if (ifp == NULL)[0m
      | [0;1;32m                ^~~
[0m[1mmain.c:419:6: [0m[0;1;36mnote: [0mTaking false branch[0m
  419 |             if (ifp == NULL)[0m
      | [0;1;32m            ^
[0m[1mmain.c:425:6: [0m[0;1;36mnote: [0mNull pointer value stored to 'ifp'[0m
  425 |             process_file (argv[optind]);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:426:6: [0m[0;1;36mnote: [0mStream pointer might be NULL[0m
  426 |             fclose (ifp);[0m
      | [0;1;32m            ^~~~~~~~~~~~
[0m[1mmain.c:431:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  431 |   if (ofp != stdout)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  432 |     fclose (ofp);[0m
      | [0;1;32m                 
[0m[1mmain.c:432:5: [0m[0;1;35mwarning: [0m[1mStream pointer might be NULL [clang-analyzer-unix.Stream][0m
  432 |     fclose (ofp);[0m
      | [0;1;32m    ^~~~~~~~~~~~
[0m[1mmain.c:188:7: [0m[0;1;36mnote: [0mAssuming 'program' is not equal to NULL[0m
  188 |   if (program == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~
[0m[1mmain.c:188:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  188 |   if (program == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:211:14: [0m[0;1;36mnote: [0mNull pointer value stored to 'ofp'[0m
  211 |   ns_prims = strhash_init ();[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~
[0m[1mmain.c:233:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  233 |   while (1)[0m
      | [0;1;32m  ^
[0m[1mmain.c:239:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  239 |       if (c == -1)[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:239:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  239 |       if (c == -1)[0m
      | [0;1;32m      ^
[0m[1mmain.c:240:2: [0m[0;1;36mnote: [0m Execution continues on line 335[0m
  240 |         break;[0m
      | [0;1;32m        ^
[0m[1mmain.c:343:22: [0m[0;1;36mnote: [0mAssuming 'i' is >= 'argc'[0m
  343 |     for (i = optind; i < argc; i++)[0m
      | [0;1;32m                     ^~~~~~~~
[0m[1mmain.c:343:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 358[0m
  343 |     for (i = optind; i < argc; i++)[0m
      | [0;1;32m    ^
[0m[1mmain.c:358:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  358 |     if (!strhash_put (ns_vars, "argv", 4, v, (void **) &n))[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:358:5: [0m[0;1;36mnote: [0mTaking false branch[0m
  358 |     if (!strhash_put (ns_vars, "argv", 4, v, (void **) &n))[0m
      | [0;1;32m    ^
[0m[1mmain.c:367:7: [0m[0;1;36mnote: [0m'path' is equal to NULL[0m
  367 |   if (path == NULL)[0m
      | [0;1;32m      ^~~~
[0m[1mmain.c:367:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  367 |   if (path == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:371:11: [0m[0;1;36mnote: [0mAssuming 'cp' is null[0m
  371 |       if (cp)[0m
      | [0;1;32m          ^~
[0m[1mmain.c:371:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  371 |       if (cp)[0m
      | [0;1;32m      ^
[0m[1mmain.c:384:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 403[0m
  384 |   for (vardef = vardefs; vardef; vardef = vardef->next)[0m
      | [0;1;32m  ^
[0m[1mmain.c:403:7: [0m[0;1;36mnote: [0mAssuming 'optind' is not equal to 'argc'[0m
  403 |   if (optind == argc)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mmain.c:403:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  403 |   if (optind == argc)[0m
      | [0;1;32m  ^
[0m[1mmain.c:409:12: [0m[0;1;36mnote: [0mAssuming 'optind' is >= 'argc'[0m
  409 |     for (; optind < argc; optind++)[0m
      | [0;1;32m           ^~~~~~~~~~~~~
[0m[1mmain.c:409:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 431[0m
  409 |     for (; optind < argc; optind++)[0m
      | [0;1;32m    ^
[0m[1mmain.c:431:7: [0m[0;1;36mnote: [0mAssuming 'ofp' is not equal to 'stdout'[0m
  431 |   if (ofp != stdout)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mmain.c:431:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  431 |   if (ofp != stdout)[0m
      | [0;1;32m  ^
[0m[1mmain.c:432:5: [0m[0;1;36mnote: [0mStream pointer might be NULL[0m
  432 |     fclose (ofp);[0m
      | [0;1;32m    ^~~~~~~~~~~~
[0m51 warnings generated.
Suppressed 13 warnings (13 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[25/33][99.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpbo6qzuyn.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/states/process.c
[1mprocess.c:48:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   48 | process_file (fname)[0m
      | [0;1;32m^
[0m[1mprocess.c:68:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   68 |   if (data_in_buffer < INBUFSIZE)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m   69 |     eof_seen = 1;[0m
      | [0;1;32m                 
[0m[1mprocess.c:71:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   71 |   if (start_state_arg)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m   72 |     start_state = start_state_arg;[0m
      | [0;1;32m                                  
[0m[1mprocess.c:96:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   96 | execute_state (name)[0m
      | [0;1;32m^
[0m[1mprocess.c:105:9: [0m[0;1;35mwarning: [0m[1mValue stored to 'result' during its initialization is never read [clang-analyzer-deadcode.DeadStores][0m
  105 |   Node *result = nvoid;[0m
      | [0;1;32m        ^~~~~~   ~~~~~
[0m[1mprocess.c:105:9: [0m[0;1;36mnote: [0mValue stored to 'result' during its initialization is never read[0m
  105 |   Node *result = nvoid;[0m
      | [0;1;32m        ^~~~~~   ~~~~~
[0m[1mprocess.c:115:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  115 |       fprintf (stderr, _("%s: undefined state `%s'\n"), program, name);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprocess.c:115:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  115 |       fprintf (stderr, _("%s: undefined state `%s'\n"), program, name);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprocess.c:121:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  121 |   if (return_seen)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  122 |     goto out;[0m
      | [0;1;32m             
[0m[1mprocess.c:132:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  132 |           if (eof_seen)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  133 |             /* All done. */[0m
  134 |             break;[0m
      | [0;1;32m                  
[0m[1mprocess.c:138:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  138 |           if (data_in_buffer < INBUFSIZE)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  139 |             eof_seen = 1;[0m
      | [0;1;32m                         
[0m[1mprocess.c:146:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  146 |       if (bufpos > 0 && inbuf[bufpos - 1] == '\n')[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  147 |         current_linenum++;[0m
      | [0;1;32m                          
[0m[1mprocess.c:150:76: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  150 |       for (eol = bufpos; eol < data_in_buffer && inbuf[eol] != '\n'; eol++)[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m  151 |         ;[0m
      | [0;1;32m         
[0m[1mprocess.c:152:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  152 |       if (eol < data_in_buffer && inbuf[eol] == '\n')[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  153 |         eol++;[0m
      | [0;1;32m              
[0m[1mprocess.c:157:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  157 |           memmove (inbuf, inbuf + bufpos, eol - bufpos);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprocess.c:157:4: [0m[0;1;36mnote: [0mCall to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11[0m
  157 |           memmove (inbuf, inbuf + bufpos, eol - bufpos);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprocess.c:163:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  163 |           if (got < to_read)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  164 |             eof_seen = 1;[0m
      | [0;1;32m                         
[0m[1mprocess.c:184:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  184 |               if (exp == RULE_BEGIN || exp == RULE_END)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  185 |                 continue;[0m
      | [0;1;32m                         
[0m[1mprocess.c:195:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  195 |                       fprintf (stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mprocess.c:195:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  195 |                       fprintf (stderr,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mprocess.c:200:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  200 |                   if (n->type != nREGEXP)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  201 |                     /* Skip this rule */[0m
  202 |                     continue;[0m
      | [0;1;32m                             
[0m[1mprocess.c:209:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  209 |               if (err < 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  210 |                 /* No mach. */[0m
  211 |                 continue;[0m
      | [0;1;32m                         
[0m[1mprocess.c:243:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  243 |           if (return_seen)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  244 |             goto out;[0m
      | [0;1;32m                     
[0m[1mprocess.c:246:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  246 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  247 |         bufpos = first_idx;[0m
      | [0;1;32m                           
[0m[1mprocess.c:274:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  274 | eval_begin_rules (state, return_seen)[0m
      | [0;1;32m^
[0m[1mprocess.c:290:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  290 |           fprintf (stderr, _("%s: undefined super state `%s'\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprocess.c:290:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  290 |           fprintf (stderr, _("%s: undefined super state `%s'\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprocess.c:299:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  299 |       if (*return_seen)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  300 |         return result;[0m
      | [0;1;32m                      
[0m[1mprocess.c:311:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  311 |           if (*return_seen)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  312 |             break;[0m
      | [0;1;32m                  
[0m[1mprocess.c:321:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  321 | eval_end_rules (state, found_return)[0m
      | [0;1;32m^
[0m[1mprocess.c:332:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  332 |   for (; state; state = state->super)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  333 |     for (rule = state->rules->head; rule; rule = rule->next)[0m
  334 |       {[0m
  335 |         r = (Cons *) rule->data;[0m
  336 |         if (r->car == RULE_END)[0m
  337 |           {[0m
  338 |             *found_return = 1;[0m
  339 |             node_free (result);[0m
  340 |             result = eval_statement_list ((List *) r->cdr, NULL, &return_seen);[0m
  341 |           }[0m
  342 |       }[0m
      | [0;1;32m       
[0m38 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[26/33][101.0s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpsgzlj11j.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/afmparse.c
[1mafmparse.c:183:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  184 |     parse_error (handle, SYSERROR (AFM_ERROR_FILE_IO));[0m
      | [0;1;32m                                                       
[0m[1mafmparse.c:189:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  190 |     parse_error (handle, AFM_ERROR_NOT_AFM_FILE);[0m
      | [0;1;32m                                                 
[0m[1mafmparse.c:201:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  201 |           (void) get_line_token (handle, ctx);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  202 |           continue;[0m
  203 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:208:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  208 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  209 |           font->version = node.u.number;[0m
  210 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:213:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  213 |           done = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  214 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:221:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  221 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mafmparse.c:225:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  225 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  226 |           font->global_info.FontName = node.u.string;[0m
  227 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:230:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  230 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  231 |           font->global_info.FullName = node.u.string;[0m
  232 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:235:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  235 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  236 |           font->global_info.FamilyName = node.u.string;[0m
  237 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:240:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  240 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  241 |           font->global_info.Weight = node.u.string;[0m
  242 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:245:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  245 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  246 |           font->global_info.FontBBox_llx = node.u.number;[0m
  247 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  248 |           font->global_info.FontBBox_lly = node.u.number;[0m
  249 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  250 |           font->global_info.FontBBox_urx = node.u.number;[0m
  251 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  252 |           font->global_info.FontBBox_ury = node.u.number;[0m
  253 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:256:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  256 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  257 |           font->global_info.Version = node.u.string;[0m
  258 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:261:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  261 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  262 |           font->global_info.Notice = node.u.string;[0m
  263 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:266:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  266 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  267 |           font->global_info.EncodingScheme = node.u.string;[0m
  268 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:271:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  271 |           GET_VALUE (AFM_TYPE_INTEGER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  272 |           font->global_info.MappingScheme = node.u.integer;[0m
  273 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:276:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  276 |           GET_VALUE (AFM_TYPE_INTEGER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  277 |           font->global_info.EscChar = node.u.integer;[0m
  278 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:281:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  281 |           GET_VALUE (AFM_TYPE_STRING);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  282 |           font->global_info.CharacterSet = node.u.string;[0m
  283 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:286:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  286 |           GET_VALUE (AFM_TYPE_INTEGER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  287 |           font->global_info.Characters = node.u.integer;[0m
  288 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:291:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  291 |           GET_VALUE (AFM_TYPE_BOOLEAN);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  292 |           font->global_info.IsBaseFont = node.u.boolean;[0m
  293 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:296:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  296 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  297 |           font->global_info.VVector_0 = node.u.number;[0m
  298 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  299 |           font->global_info.VVector_1 = node.u.number;[0m
  300 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:303:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  303 |           GET_VALUE (AFM_TYPE_BOOLEAN);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  304 |           font->global_info.IsFixedV = node.u.boolean;[0m
  305 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:308:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  308 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  309 |           font->global_info.CapHeight = node.u.number;[0m
  310 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:313:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  313 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  314 |           font->global_info.XHeight = node.u.number;[0m
  315 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:318:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  318 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  319 |           font->global_info.Ascender = node.u.number;[0m
  320 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:323:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  323 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  324 |           font->global_info.Descender = node.u.number;[0m
  325 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:329:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  329 |           GET_VALUE (AFM_TYPE_INTEGER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  330 |           wd = node.u.integer;[0m
  331 |           font->writing_direction_metrics[wd].is_valid = AFMTrue;[0m
  332 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:335:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  335 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  336 |           font->writing_direction_metrics[wd].UnderlinePosition[0m
  337 |             = node.u.number;[0m
  338 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:341:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  341 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  342 |           font->writing_direction_metrics[wd].UnderlineThickness[0m
  343 |             = node.u.number;[0m
  344 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:347:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  347 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  348 |           font->writing_direction_metrics[wd].ItalicAngle = node.u.number;[0m
  349 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:352:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  352 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  353 |           font->writing_direction_metrics[wd].CharWidth_x = node.u.number;[0m
  354 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  355 |           font->writing_direction_metrics[wd].CharWidth_y = node.u.number;[0m
  356 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:359:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  359 |           GET_VALUE (AFM_TYPE_BOOLEAN);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  360 |           font->writing_direction_metrics[wd].IsFixedPitch = node.u.boolean;[0m
  361 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:364:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  364 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mafmparse.c:368:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  368 |           GET_VALUE (AFM_TYPE_INTEGER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  369 |           font->num_character_metrics = node.u.integer;[0m
  370 |           font->character_metrics[0m
  371 |             = ((AFMIndividualCharacterMetrics *)[0m
  372 |                calloc (font->num_character_metrics + 1,[0m
  373 |                        sizeof (AFMIndividualCharacterMetrics)));[0m
  374 |           if (font->character_metrics == NULL)[0m
  375 |             parse_error (handle, AFM_ERROR_MEMORY);[0m
  376 | [0m
  377 |           read_character_metrics (handle, ctx, font);[0m
  378 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:374:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  375 |             parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                                   
[0m[1mafmparse.c:382:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  382 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mafmparse.c:385:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  385 |           if (font->info_level & AFM_I_KERN_PAIRS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mafmparse.c:392:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  392 |               if (font->kern_pairs == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  393 |                 parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                                       
[0m[1mafmparse.c:409:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  409 |           if (font->info_level & AFM_I_TRACK_KERNS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mafmparse.c:416:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  416 |               if (font->track_kerns == NULL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  417 |                 parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                                       
[0m[1mafmparse.c:433:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  433 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mafmparse.c:437:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  437 |           if (font->info_level & AFM_I_COMPOSITES)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mafmparse.c:444:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  444 |               if (font->composites == NULL)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  445 |                 parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                                       
[0m[1mafmparse.c:462:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  462 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mafmparse.c:470:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  470 |       && !font->writing_direction_metrics[1].is_valid)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  471 |     /* No direction specified, 0 implied. */[0m
  472 |     font->writing_direction_metrics[0].is_valid = AFMTrue;[0m
      | [0;1;32m                                                          
[0m[1mafmparse.c:515:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  515 |   fprintf (stderr, "AFM: fatal internal longjmp() error.\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafmparse.c:515:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  515 |   fprintf (stderr, "AFM: fatal internal longjmp() error.\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafmparse.c:527:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  527 |   while ((ch = getc (ctx->fp)) != EOF)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  528 |     if (!ISSPACE (ch))[0m
  529 |       break;[0m
      | [0;1;32m            
[0m[1mafmparse.c:528:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  528 |     if (!ISSPACE (ch))[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  529 |       break;[0m
      | [0;1;32m            
[0m[1mafmparse.c:531:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  531 |   if (ch == EOF)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  532 |     return 0;[0m
      | [0;1;32m             
[0m[1mafmparse.c:539:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  539 |        i++, ch = getc (ctx->fp))[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  540 |     ctx->token[i] = ch;[0m
      | [0;1;32m                       
[0m[1mafmparse.c:542:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  542 |   if (i >= sizeof (ctx->token))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  543 |     /* Line is too long, this is against AFM specification. */[0m
  544 |     parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                           
[0m[1mafmparse.c:559:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  559 |   while ((ch = getc (ctx->fp)) != EOF)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m  560 |     if (!ISSPACE (ch))[0m
  561 |       break;[0m
      | [0;1;32m            
[0m[1mafmparse.c:560:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  560 |     if (!ISSPACE (ch))[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  561 |       break;[0m
      | [0;1;32m            
[0m[1mafmparse.c:563:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  563 |   if (ch == EOF)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  564 |     return 0;[0m
      | [0;1;32m             
[0m[1mafmparse.c:571:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  571 |        i++, ch = getc (ctx->fp))[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  572 |     ctx->token[i] = ch;[0m
      | [0;1;32m                       
[0m[1mafmparse.c:574:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  574 |   if (i >= sizeof (ctx->token))[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  575 |     parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                           
[0m[1mafmparse.c:578:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  578 |   for (i--; i >= 0 && ISSPACE (ctx->token[i]); i--)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  579 |     ;[0m
      | [0;1;32m     
[0m[1mafmparse.c:600:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  601 |         break;[0m
      | [0;1;32m              
[0m[1mafmparse.c:604:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  605 |         found = AFMTrue;[0m
  606 |       else if (cmpvalue < 0)[0m
      | [0;32m      } 
[0m[1mafmparse.c:606:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  606 |       else if (cmpvalue < 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  607 |         upper = midpoint - 1;[0m
  608 |       else[0m
      | [0;32m      } 
[0m[1mafmparse.c:608:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  608 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  609 |         lower = midpoint + 1;[0m
      | [0;1;32m                             
[0m[1mafmparse.c:612:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  612 |   if (found)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  613 |     return keynames[midpoint].key;[0m
      | [0;1;32m                                  
[0m[1mafmparse.c:627:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  628 |         /* Unexpected EOF. */[0m
  629 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:639:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  639 |       sprintf (msg, "skipping key \"%s\"", ctx->token);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmparse.c:639:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  639 |       sprintf (msg, "skipping key \"%s\"", ctx->token);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmparse.c:657:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  657 |       if (!get_line_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  658 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
  659 | [0m
  660 |       type_return->u.string = (AFMString) calloc (1, ctx->tokenlen + 1);[0m
  661 |       if (type_return->u.string == NULL)[0m
  662 |         parse_error (handle, AFM_ERROR_MEMORY);[0m
  663 | [0m
  664 |       memcpy (type_return->u.string, ctx->token, ctx->tokenlen);[0m
  665 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:657:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  657 |       if (!get_line_token (handle, ctx))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  658 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:661:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  661 |       if (type_return->u.string == NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  662 |         parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:664:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  664 |       memcpy (type_return->u.string, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:664:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  664 |       memcpy (type_return->u.string, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:668:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  668 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  669 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
  670 | [0m
  671 |       type_return->u.name = (AFMName) calloc (1, ctx->tokenlen + 1);[0m
  672 |       if (type_return->u.string == NULL)[0m
  673 |         parse_error (handle, AFM_ERROR_MEMORY);[0m
  674 | [0m
  675 |       memcpy (type_return->u.name, ctx->token, ctx->tokenlen);[0m
  676 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:668:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  668 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  669 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:672:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  672 |       if (type_return->u.string == NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  673 |         parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:675:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  675 |       memcpy (type_return->u.name, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:675:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  675 |       memcpy (type_return->u.name, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:679:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  679 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  680 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
  681 | [0m
  682 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
  683 |       buf[ctx->tokenlen] = '\0';[0m
  684 |       type_return->u.number = atof (buf);[0m
  685 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:679:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  679 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  680 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:682:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  682 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:682:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  682 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:688:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  688 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  689 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
  690 | [0m
  691 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
  692 |       buf[ctx->tokenlen] = '\0';[0m
  693 |       type_return->u.integer = atoi (buf);[0m
  694 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:688:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  688 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  689 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:691:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  691 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:691:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  691 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:697:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  697 |       fprintf (stderr, "Array types not implemented yet.\n");[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmparse.c:697:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  697 |       fprintf (stderr, "Array types not implemented yet.\n");[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmparse.c:697:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  697 |       fprintf (stderr, "Array types not implemented yet.\n");[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  698 |       abort ();[0m
  699 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:702:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  702 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  703 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
  704 | [0m
  705 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
  706 |       buf[ctx->tokenlen] = '\0';[0m
  707 | [0m
  708 |       if (strcmp (buf, "true") == 0)[0m
  709 |         type_return->u.boolean = AFMTrue;[0m
  710 |       else if (strcmp (buf, "false") == 0)[0m
  711 |         type_return->u.boolean = AFMFalse;[0m
  712 |       else[0m
  713 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
  714 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:702:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  702 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  703 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:705:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  705 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:705:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  705 |       memcpy (buf, ctx->token, ctx->tokenlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafmparse.c:708:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  708 |       if (strcmp (buf, "true") == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  709 |         type_return->u.boolean = AFMTrue;[0m
  710 |       else if (strcmp (buf, "false") == 0)[0m
      | [0;32m      } 
[0m[1mafmparse.c:710:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  710 |       else if (strcmp (buf, "false") == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  711 |         type_return->u.boolean = AFMFalse;[0m
  712 |       else[0m
      | [0;32m      } 
[0m[1mafmparse.c:712:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  712 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  713 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:717:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  717 |       fprintf (stderr, "get_type(): illegal type %d\n", type_return->type);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmparse.c:717:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  717 |       fprintf (stderr, "get_type(): illegal type %d\n", type_return->type);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafmparse.c:717:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  717 |       fprintf (stderr, "get_type(): illegal type %d\n", type_return->type);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  718 |       abort ();[0m
  719 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafmparse.c:740:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  740 |           if (first)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  741 |             first = 0;[0m
  742 |           else[0m
  743 |             i++;[0m
  744 |           if (i >= font->num_character_metrics)[0m
  745 |             parse_error (handle, AFM_ERROR_SYNTAX);[0m
  746 | [0m
  747 |           cm = &font->character_metrics[i];[0m
  748 |           GET_VALUE (AFM_TYPE_INTEGER);[0m
  749 |           cm->character_code = node.u.integer;[0m
  750 |           if (cm->character_code >= 0 && cm->character_code <= 255)[0m
  751 |             font->encoding[cm->character_code] = cm;[0m
  752 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:740:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  740 |           if (first)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m  741 |             first = 0;[0m
  742 |           else[0m
      | [0;32m          } 
[0m[1mafmparse.c:742:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  742 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  743 |             i++;[0m
      | [0;1;32m                
[0m[1mafmparse.c:744:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  744 |           if (i >= font->num_character_metrics)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m  745 |             parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                                   
[0m[1mafmparse.c:750:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  750 |           if (cm->character_code >= 0 && cm->character_code <= 255)[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  751 |             font->encoding[cm->character_code] = cm;[0m
      | [0;1;32m                                                    
[0m[1mafmparse.c:755:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  755 |           printf ("* CH\n");[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  756 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:761:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  761 |           cm->w0x = node.u.number;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  762 |           cm->w0y = 0.0;[0m
  763 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:761:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'w0x' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  761 |           cm->w0x = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:736:7: [0m[0;1;36mnote: [0mCalling 'get_key'[0m
  736 |       get_key (handle, ctx, &key);[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:625:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  625 |   while (1)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:627:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:627:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:631:13: [0m[0;1;36mnote: [0mCalling 'match_key'[0m
  631 |       key = match_key (ctx->token);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:597:11: [0m[0;1;36mnote: [0m'upper' is >= 'lower'[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m          ^~~~~
[0m[1mafmparse.c:597:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m         ^
[0m[1mafmparse.c:597:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:600:11: [0m[0;1;36mnote: [0mAssuming field 'name' is not equal to NULL[0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:600:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:604:11: [0m[0;1;36mnote: [0mAssuming 'cmpvalue' is equal to 0[0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m          ^~~~~~~~~~~~~
[0m[1mafmparse.c:604:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:597:11: [0m[0;1;36mnote: [0m'upper' is >= 'lower'[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m          ^~~~~
[0m[1mafmparse.c:597:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m         ^
[0m[1mafmparse.c:597:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 612[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:612:7: [0m[0;1;36mnote: [0m'found' is 1[0m
  612 |   if (found)[0m
      | [0;1;32m      ^~~~~
[0m[1mafmparse.c:612:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  612 |   if (found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:613:5: [0m[0;1;36mnote: [0mReturning value, which participates in a condition later[0m
  613 |     return keynames[midpoint].key;[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:631:13: [0m[0;1;36mnote: [0mReturning from 'match_key'[0m
  631 |       key = match_key (ctx->token);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:632:11: [0m[0;1;36mnote: [0mAssuming 'key' is >= 0, which participates in a condition later[0m
  632 |       if (key >= 0)[0m
      | [0;1;32m          ^~~~~~~~
[0m[1mafmparse.c:632:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  632 |       if (key >= 0)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:634:4: [0m[0;1;36mnote: [0mThe value of 'key' is assigned to 'key', which participates in a condition later[0m
  634 |           *key_return = key;[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:736:7: [0m[0;1;36mnote: [0mReturning from 'get_key'[0m
  736 |       get_key (handle, ctx, &key);[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kW0X:'  at line 759[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:761:12: [0m[0;1;36mnote: [0mAccess to field 'w0x' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  761 |           cm->w0x = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:766:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  766 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  767 |           cm->w1x = node.u.number;[0m
  768 |           cm->w1y = 0.0;[0m
  769 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:767:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'w1x' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  767 |           cm->w1x = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kW1X:'  at line 765[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:767:12: [0m[0;1;36mnote: [0mAccess to field 'w1x' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  767 |           cm->w1x = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:774:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  774 |           cm->w0y = node.u.number;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  775 |           cm->w0x = 0.0;[0m
  776 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:774:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'w0y' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  774 |           cm->w0y = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:736:7: [0m[0;1;36mnote: [0mCalling 'get_key'[0m
  736 |       get_key (handle, ctx, &key);[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:625:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  625 |   while (1)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:627:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:627:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:631:13: [0m[0;1;36mnote: [0mCalling 'match_key'[0m
  631 |       key = match_key (ctx->token);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:597:11: [0m[0;1;36mnote: [0m'upper' is >= 'lower'[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m          ^~~~~
[0m[1mafmparse.c:597:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m         ^
[0m[1mafmparse.c:597:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:600:11: [0m[0;1;36mnote: [0mAssuming field 'name' is not equal to NULL[0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:600:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:604:11: [0m[0;1;36mnote: [0mAssuming 'cmpvalue' is equal to 0[0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m          ^~~~~~~~~~~~~
[0m[1mafmparse.c:604:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:597:11: [0m[0;1;36mnote: [0m'upper' is >= 'lower'[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m          ^~~~~
[0m[1mafmparse.c:597:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m         ^
[0m[1mafmparse.c:597:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 612[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:612:7: [0m[0;1;36mnote: [0m'found' is 1[0m
  612 |   if (found)[0m
      | [0;1;32m      ^~~~~
[0m[1mafmparse.c:612:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  612 |   if (found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:613:5: [0m[0;1;36mnote: [0mReturning value, which participates in a condition later[0m
  613 |     return keynames[midpoint].key;[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:631:13: [0m[0;1;36mnote: [0mReturning from 'match_key'[0m
  631 |       key = match_key (ctx->token);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:632:11: [0m[0;1;36mnote: [0mAssuming 'key' is >= 0, which participates in a condition later[0m
  632 |       if (key >= 0)[0m
      | [0;1;32m          ^~~~~~~~
[0m[1mafmparse.c:632:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  632 |       if (key >= 0)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:634:4: [0m[0;1;36mnote: [0mThe value of 'key' is assigned to 'key', which participates in a condition later[0m
  634 |           *key_return = key;[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:736:7: [0m[0;1;36mnote: [0mReturning from 'get_key'[0m
  736 |       get_key (handle, ctx, &key);[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kW0Y:'  at line 772[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:774:12: [0m[0;1;36mnote: [0mAccess to field 'w0y' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  774 |           cm->w0y = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:779:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  779 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  780 |           cm->w1y = node.u.number;[0m
  781 |           cm->w1x = 0.0;[0m
  782 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:780:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'w1y' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  780 |           cm->w1y = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kW1Y:'  at line 778[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:780:12: [0m[0;1;36mnote: [0mAccess to field 'w1y' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  780 |           cm->w1y = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:787:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  787 |           cm->w0x = node.u.number;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  788 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  789 |           cm->w0y = node.u.number;[0m
  790 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:787:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'w0x' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  787 |           cm->w0x = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:736:7: [0m[0;1;36mnote: [0mCalling 'get_key'[0m
  736 |       get_key (handle, ctx, &key);[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:625:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  625 |   while (1)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:627:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:627:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  627 |       if (!get_token (handle, ctx))[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:631:13: [0m[0;1;36mnote: [0mCalling 'match_key'[0m
  631 |       key = match_key (ctx->token);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:597:11: [0m[0;1;36mnote: [0m'upper' is >= 'lower'[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m          ^~~~~
[0m[1mafmparse.c:597:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m         ^
[0m[1mafmparse.c:597:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:600:11: [0m[0;1;36mnote: [0mAssuming field 'name' is not equal to NULL[0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:600:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  600 |       if (keynames[midpoint].name == NULL)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:604:11: [0m[0;1;36mnote: [0mAssuming 'cmpvalue' is equal to 0[0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m          ^~~~~~~~~~~~~
[0m[1mafmparse.c:604:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  604 |       if (cmpvalue == 0)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:597:11: [0m[0;1;36mnote: [0m'upper' is >= 'lower'[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m          ^~~~~
[0m[1mafmparse.c:597:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m         ^
[0m[1mafmparse.c:597:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 612[0m
  597 |   while ((upper >= lower) && !found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:612:7: [0m[0;1;36mnote: [0m'found' is 1[0m
  612 |   if (found)[0m
      | [0;1;32m      ^~~~~
[0m[1mafmparse.c:612:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  612 |   if (found)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:613:5: [0m[0;1;36mnote: [0mReturning value, which participates in a condition later[0m
  613 |     return keynames[midpoint].key;[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:631:13: [0m[0;1;36mnote: [0mReturning from 'match_key'[0m
  631 |       key = match_key (ctx->token);[0m
      | [0;1;32m            ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:632:11: [0m[0;1;36mnote: [0mAssuming 'key' is >= 0, which participates in a condition later[0m
  632 |       if (key >= 0)[0m
      | [0;1;32m          ^~~~~~~~
[0m[1mafmparse.c:632:7: [0m[0;1;36mnote: [0mTaking true branch[0m
  632 |       if (key >= 0)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:634:4: [0m[0;1;36mnote: [0mThe value of 'key' is assigned to 'key', which participates in a condition later[0m
  634 |           *key_return = key;[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:736:7: [0m[0;1;36mnote: [0mReturning from 'get_key'[0m
  736 |       get_key (handle, ctx, &key);[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kW0:'  at line 785[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:787:12: [0m[0;1;36mnote: [0mAccess to field 'w0x' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  787 |           cm->w0x = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:793:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  793 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  794 |           cm->w1x = node.u.number;[0m
  795 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  796 |           cm->w1y = node.u.number;[0m
  797 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:794:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'w1x' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  794 |           cm->w1x = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kW1:'  at line 792[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:794:12: [0m[0;1;36mnote: [0mAccess to field 'w1x' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  794 |           cm->w1x = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:800:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  800 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  801 |           cm->vv_x = node.u.number;[0m
  802 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  803 |           cm->vv_y = node.u.number;[0m
  804 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:801:13: [0m[0;1;35mwarning: [0m[1mAccess to field 'vv_x' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  801 |           cm->vv_x = node.u.number;[0m
      | [0;1;32m                   ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kVV:'  at line 799[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:801:13: [0m[0;1;36mnote: [0mAccess to field 'vv_x' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  801 |           cm->vv_x = node.u.number;[0m
      | [0;1;32m          ~~       ^
[0m[1mafmparse.c:807:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  807 |           GET_VALUE (AFM_TYPE_NAME);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  808 |           cm->name = node.u.name;[0m
  809 |           if (!strhash_put (font->private->fontnames, cm->name,[0m
  810 |                             strlen (cm->name), cm, NULL))[0m
  811 |             parse_error (handle, AFM_ERROR_MEMORY);[0m
  812 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:808:13: [0m[0;1;35mwarning: [0m[1mAccess to field 'name' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  808 |           cm->name = node.u.name;[0m
      | [0;1;32m                   ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kN:'  at line 806[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:808:13: [0m[0;1;36mnote: [0mAccess to field 'name' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  808 |           cm->name = node.u.name;[0m
      | [0;1;32m          ~~       ^
[0m[1mafmparse.c:810:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  810 |                             strlen (cm->name), cm, NULL))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  811 |             parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                                   
[0m[1mafmparse.c:815:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  815 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  816 |           cm->llx = node.u.number;[0m
  817 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  818 |           cm->lly = node.u.number;[0m
  819 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  820 |           cm->urx = node.u.number;[0m
  821 |           GET_VALUE (AFM_TYPE_NUMBER);[0m
  822 |           cm->ury = node.u.number;[0m
  823 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:33:28: [0m[0;1;36mnote: [0mexpanded from macro 'GET_VALUE'[0m
   33 | #define GET_VALUE(typenum) get_type (handle, ctx, (typenum), &node)[0m
      | [0;1;32m                           ^
[0m[1mafmparse.c:816:12: [0m[0;1;35mwarning: [0m[1mAccess to field 'llx' results in a dereference of a null pointer (loaded from variable 'cm') [clang-analyzer-core.NullDereference][0m
  816 |           cm->llx = node.u.number;[0m
      | [0;1;32m                  ^
[0m[1mafmparse.c:183:12: [0m[0;1;36mnote: [0mField 'fp' is not equal to NULL[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m           ^
[0m[1mafmparse.c:183:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  183 |   if (ctx->fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:189:7: [0m[0;1;36mnote: [0mAssuming 'key' is equal to kStartFontMetrics[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:189:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  189 |   if (key != kStartFontMetrics)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:195:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  195 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:198:7: [0m[0;1;36mnote: [0mControl jumps to 'case kStartCharMetrics:'  at line 367[0m
  198 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:374:8: [0m[0;1;36mnote: [0mAssuming field 'character_metrics' is not equal to NULL[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:374:4: [0m[0;1;36mnote: [0mTaking false branch[0m
  374 |           if (font->character_metrics == NULL)[0m
      | [0;1;32m          ^
[0m[1mafmparse.c:377:4: [0m[0;1;36mnote: [0mCalling 'read_character_metrics'[0m
  377 |           read_character_metrics (handle, ctx, font);[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:729:3: [0m[0;1;36mnote: [0m'cm' initialized to a null pointer value[0m
  729 |   AFMIndividualCharacterMetrics *cm = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafmparse.c:734:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  734 |   while (!done)[0m
      | [0;1;32m  ^
[0m[1mafmparse.c:737:7: [0m[0;1;36mnote: [0mControl jumps to 'case kB:'  at line 814[0m
  737 |       switch (key)[0m
      | [0;1;32m      ^
[0m[1mafmparse.c:816:12: [0m[0;1;36mnote: [0mAccess to field 'llx' results in a dereference of a null pointer (loaded from variable 'cm')[0m
  816 |           cm->llx = node.u.number;[0m
      | [0;1;32m          ~~      ^
[0m[1mafmparse.c:827:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  827 |           get_line_token (handle, ctx);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  828 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:831:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  831 |           if (i != font->num_character_metrics - 1)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  832 |             {[0m
  833 |               /*[0m
  834 |                * My opinion is that this is a syntax error; the[0m
  835 |                * creator of this AFM file should have been smart[0m
  836 |                * enought to count these character metrics.  Well,[0m
  837 |                * maybe that is too much asked...[0m
  838 |                */[0m
  839 |               font->num_character_metrics = i + 1;[0m
  840 |             }[0m
  841 | [0m
  842 |           done = 1;[0m
  843 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:846:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  846 |           parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  847 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:872:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  872 |           kp->name1 = node.u.name;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mafmparse.c:882:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  882 |               kp->kx = node.u.number;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  883 |               GET_VALUE (AFM_TYPE_NUMBER);[0m
  884 |               kp->ky = node.u.number;[0m
  885 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mafmparse.c:888:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  888 |               kp->kx = node.u.number;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  889 |               kp->ky = 0.0;[0m
  890 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mafmparse.c:893:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  893 |               kp->ky = node.u.number;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  894 |               kp->kx = 0.0;[0m
  895 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mafmparse.c:898:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  898 |               fprintf (stderr, "AFM: fatal corruption\n");[0m
      | [0;1;32m              ^~~~~~~
[0m[1mafmparse.c:898:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  898 |               fprintf (stderr, "AFM: fatal corruption\n");[0m
      | [0;1;32m              ^~~~~~~
[0m[1mafmparse.c:898:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  898 |               fprintf (stderr, "AFM: fatal corruption\n");[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  899 |               abort ();[0m
  900 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mafmparse.c:906:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  906 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mafmparse.c:909:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  909 |           parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  910 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mafmparse.c:916:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  916 |   if (key != kEndKernPairs)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  917 |     parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                           
[0m[1mafmparse.c:936:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  936 |       if (key != kTrackKern)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  937 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:957:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  957 |   if (key != kEndTrackKern)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  958 |     parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                           
[0m[1mafmparse.c:975:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  975 |       if (key != kCC)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  976 |         parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:983:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  983 |                         strlen (cm->name), cm, NULL))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m  984 |         parse_error (handle, AFM_ERROR_MEMORY);[0m
      | [0;1;32m                                               
[0m[1mafmparse.c:997:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  997 |           if (key != kPCC)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  998 |             parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                                   
[0m[1mafmparse.c:1015:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1015 |   if (key != kEndComposites)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1016 |     parse_error (handle, AFM_ERROR_SYNTAX);[0m
      | [0;1;32m                                           
[0m132 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[27/33][145.3s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmp6ksz183l.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/src/main.c
[1mmain.c:939:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  939 |   if (program == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  940 |     program = argv[0];[0m
  941 |   else[0m
      | [0;32m  } 
[0m[1mmain.c:941:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  941 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  942 |     program++;[0m
      | [0;1;32m              
[0m[1mmain.c:970:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  970 |   memcpy (&run_tm, tm, sizeof (*tm));[0m
      | [0;1;32m  ^~~~~~
[0m[1mmain.c:970:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  970 |   memcpy (&run_tm, tm, sizeof (*tm));[0m
      | [0;1;32m  ^~~~~~
[0m[1mmain.c:978:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  978 |   if (passwd == NULL)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  979 |     FATAL ((stderr, _("couldn't get passwd entry for uid=%d: %s"), getuid (),[0m
  980 |             strerror (errno)));[0m
      | [0;1;32m                               
[0m[1mmain.c:979:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  979 |     FATAL ((stderr, _("couldn't get passwd entry for uid=%d: %s"), getuid (),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:979:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  979 |     FATAL ((stderr, _("couldn't get passwd entry for uid=%d: %s"), getuid (),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:979:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  979 |     FATAL ((stderr, _("couldn't get passwd entry for uid=%d: %s"), getuid (),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:979:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  979 |     FATAL ((stderr, _("couldn't get passwd entry for uid=%d: %s"), getuid (),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:997:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  997 |   if (cp)[0m
      | [0;1;32m         ^
[0m      | [0;32m          {
[0m  998 |     enscript_library = cp;[0m
      | [0;1;32m                          
[0m[1mmain.c:1003:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1003 |   if (cp == NULL)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1004 |     cp = passwd->pw_dir;[0m
      | [0;1;32m                        
[0m[1mmain.c:1071:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1071 |                   ERROR ((stderr, _("couldn't read config file \"%s/%s\": %s"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1071:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1071 |                   ERROR ((stderr, _("couldn't read config file \"%s/%s\": %s"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1071:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1071 |                   ERROR ((stderr, _("couldn't read config file \"%s/%s\": %s"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1071:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1071 |                   ERROR ((stderr, _("couldn't read config file \"%s/%s\": %s"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1074:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1074 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1074:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1074 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1074:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1074 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1074:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1074 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1076:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1076 |                   ERROR ((stderr, _("\t%s"), SYSCONFDIR));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1076:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1076 |                   ERROR ((stderr, _("\t%s"), SYSCONFDIR));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1076:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1076 |                   ERROR ((stderr, _("\t%s"), SYSCONFDIR));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1076:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1076 |                   ERROR ((stderr, _("\t%s"), SYSCONFDIR));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1077:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1077 |                   ERROR ((stderr, _("\t%s"), enscript_library));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1077:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1077 |                   ERROR ((stderr, _("\t%s"), enscript_library));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1077:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1077 |                   ERROR ((stderr, _("\t%s"), enscript_library));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1077:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1077 |                   ERROR ((stderr, _("\t%s"), enscript_library));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1078:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1078 |                   ERROR ((stderr, _("\t%s"), buffer_ptr (&buffer)));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1078:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1078 |                   ERROR ((stderr, _("\t%s"), buffer_ptr (&buffer)));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1078:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1078 |                   ERROR ((stderr, _("\t%s"), buffer_ptr (&buffer)));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1078:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1078 |                   ERROR ((stderr, _("\t%s"), buffer_ptr (&buffer)));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1079:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1079 |                   ERROR ((stderr, _("\t../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1079:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1079 |                   ERROR ((stderr, _("\t../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1079:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1079 |                   ERROR ((stderr, _("\t../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1079:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1079 |                   ERROR ((stderr, _("\t../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1080:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1080 |                   ERROR ((stderr, _("\t../../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1080:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1080 |                   ERROR ((stderr, _("\t../../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1080:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1080 |                   ERROR ((stderr, _("\t../../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1080:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1080 |                   ERROR ((stderr, _("\t../../lib")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1081:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1081 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1081:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1081 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1081:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1081 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1081:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1081 |                   ERROR ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1083:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1083 |                   ERROR ((stderr, _("\tmake distclean")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1083:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1083 |                   ERROR ((stderr, _("\tmake distclean")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1083:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1083 |                   ERROR ((stderr, _("\tmake distclean")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1083:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1083 |                   ERROR ((stderr, _("\tmake distclean")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1084:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1084 |                   ERROR ((stderr, _("\t./configure --prefix=PREFIX")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1084:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1084 |                   ERROR ((stderr, _("\t./configure --prefix=PREFIX")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1084:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1084 |                   ERROR ((stderr, _("\t./configure --prefix=PREFIX")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1084:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1084 |                   ERROR ((stderr, _("\t./configure --prefix=PREFIX")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1085:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1085 |                   ERROR ((stderr, _("\tmake")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1085:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1085 |                   ERROR ((stderr, _("\tmake")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1085:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1085 |                   ERROR ((stderr, _("\tmake")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1085:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1085 |                   ERROR ((stderr, _("\tmake")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1086:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1086 |                   ERROR ((stderr, _("\tmake check")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1086:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1086 |                   ERROR ((stderr, _("\tmake check")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1086:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1086 |                   ERROR ((stderr, _("\tmake check")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1086:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1086 |                   ERROR ((stderr, _("\tmake check")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1087:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1087 |                   ERROR ((stderr, _("\tmake install")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1087:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1087 |                   ERROR ((stderr, _("\tmake install")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1087:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1087 |                   ERROR ((stderr, _("\tmake install")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1087:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1087 |                   ERROR ((stderr, _("\tmake install")));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1088:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1088 |                   ERROR ((stderr, _("or set the environment variable `ENSCRIPT_LIBRARY'"[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1088:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1088 |                   ERROR ((stderr, _("or set the environment variable `ENSCRIPT_LIBRARY'"[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1088:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1088 |                   ERROR ((stderr, _("or set the environment variable `ENSCRIPT_LIBRARY'"[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1088:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1088 |                   ERROR ((stderr, _("or set the environment variable `ENSCRIPT_LIBRARY'"[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1142:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1142 |   for (i = 0; !found && encodings[i].names[0]; i++)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m[1mmain.c:1143:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1143 |     for (j = 0; j < 3; j++)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m[1mmain.c:1144:44: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 2nd parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1144 |       if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],[0m
      | [0;1;32m                                           ^
[0m[1m./gsint.h:127:22: [0m[0;1;36mnote: [0mexpanded from macro 'MATCH'[0m
  127 | #define MATCH(a, b) (strcmp (a, b) == 0)[0m
      | [0;1;32m                     ^          ~
[0m[1mmain.c:939:7: [0m[0;1;36mnote: [0mAssuming 'program' is equal to NULL[0m
  939 |   if (program == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~
[0m[1mmain.c:939:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  939 |   if (program == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:978:7: [0m[0;1;36mnote: [0mAssuming 'passwd' is not equal to NULL[0m
  978 |   if (passwd == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mmain.c:978:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  978 |   if (passwd == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:985:15: [0m[0;1;36mnote: [0mNull pointer value stored to 'encoding_name'[0m
  985 |   npf_name              = xstrdup ("octal");[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~
[0m[1mmain.c:997:7: [0m[0;1;36mnote: [0m'cp' is null[0m
  997 |   if (cp)[0m
      | [0;1;32m      ^~
[0m[1mmain.c:997:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  997 |   if (cp)[0m
      | [0;1;32m  ^
[0m[1mmain.c:1003:7: [0m[0;1;36mnote: [0m'cp' is equal to NULL[0m
 1003 |   if (cp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mmain.c:1003:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 1003 |   if (cp == NULL)[0m
      | [0;1;32m  ^
[0m[1mmain.c:1047:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1047 |   if (!read_config (SYSCONFDIR, CFG_FILE_NAME))[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mmain.c:1047:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1047 |   if (!read_config (SYSCONFDIR, CFG_FILE_NAME))[0m
      | [0;1;32m  ^
[0m[1mmain.c:1142:16: [0m[0;1;36mnote: [0m'found' is 0[0m
 1142 |   for (i = 0; !found && encodings[i].names[0]; i++)[0m
      | [0;1;32m               ^~~~~
[0m[1mmain.c:1142:15: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1142 |   for (i = 0; !found && encodings[i].names[0]; i++)[0m
      | [0;1;32m              ^
[0m[1mmain.c:1142:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1142 |   for (i = 0; !found && encodings[i].names[0]; i++)[0m
      | [0;1;32m  ^
[0m[1mmain.c:1143:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1143 |     for (j = 0; j < 3; j++)[0m
      | [0;1;32m    ^
[0m[1mmain.c:1144:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1144 |       if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],[0m
      | [0;1;32m          ^
[0m[1mmain.c:1144:44: [0m[0;1;36mnote: [0mNull pointer passed to 2nd parameter expecting 'nonnull'[0m
 1144 |       if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],[0m
      | [0;1;32m                                           ^
[0m[1m./gsint.h:127:22: [0m[0;1;36mnote: [0mexpanded from macro 'MATCH'[0m
  127 | #define MATCH(a, b) (strcmp (a, b) == 0)[0m
      | [0;1;32m                     ^          ~
[0m[1mmain.c:1154:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1154 |           if (nl < 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1155 |             nl = encodings[i].nl;[0m
      | [0;1;32m                                 
[0m[1mmain.c:1160:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1160 |   if (!found)[0m
      | [0;1;32m             ^
[0m      | [0;32m              {
[0m 1161 |     FATAL ((stderr, _("unknown encoding: %s"), encoding_name));[0m
      | [0;1;32m                                                               
[0m[1mmain.c:1161:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1161 |     FATAL ((stderr, _("unknown encoding: %s"), encoding_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1161:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1161 |     FATAL ((stderr, _("unknown encoding: %s"), encoding_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1161:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1161 |     FATAL ((stderr, _("unknown encoding: %s"), encoding_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1161:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1161 |     FATAL ((stderr, _("unknown encoding: %s"), encoding_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1166:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1166 |   if (!user_body_font_defined && landscape && num_columns > 1)[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1167 |     Fpt.w = Fpt.h = 7.0;[0m
      | [0;1;32m                        
[0m[1mmain.c:1180:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1180 |       FATAL ((stderr, _("couldn't open AFM library: %s"), buf));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1180:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1180 |       FATAL ((stderr, _("couldn't open AFM library: %s"), buf));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1180:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1180 |       FATAL ((stderr, _("couldn't open AFM library: %s"), buf));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1180:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1180 |       FATAL ((stderr, _("couldn't open AFM library: %s"), buf));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1212:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1212 |       for (mentry = media_names; mentry; mentry = mentry->next)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1213 |         printf ("%-16s %d\t%d\t%d\t%d\t%d\t%d\n",[0m
 1214 |                 mentry->name, mentry->w, mentry->h,[0m
 1215 |                 mentry->llx, mentry->lly, mentry->urx, mentry->ury);[0m
      | [0;1;32m                                                                    
[0m[1mmain.c:1221:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1221 |   for (mentry = media_names; mentry; mentry = mentry->next)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1222 |     if (strcmp (media_name, mentry->name) == 0)[0m
 1223 |       {[0m
 1224 |         media = mentry;[0m
 1225 |         break;[0m
 1226 |       }[0m
      | [0;1;32m       
[0m[1mmain.c:1227:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1227 |   if (media == NULL)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1228 |     FATAL ((stderr, _("do not know anything about media \"%s\""), media_name));[0m
      | [0;1;32m                                                                               
[0m[1mmain.c:1228:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1228 |     FATAL ((stderr, _("do not know anything about media \"%s\""), media_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1228:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1228 |     FATAL ((stderr, _("do not know anything about media \"%s\""), media_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1228:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1228 |     FATAL ((stderr, _("do not know anything about media \"%s\""), media_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1228:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1228 |     FATAL ((stderr, _("do not know anything about media \"%s\""), media_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1235:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1235 |           if (*margins_spec == '\0')[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1236 |             /* All done. */[0m
 1237 |             break;[0m
      | [0;1;32m                  
[0m[1mmain.c:1246:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1246 |           for (; *margins_spec != ':' && *margins_spec != '\0'; margins_spec++)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 1247 |             ;[0m
      | [0;1;32m             
[0m[1mmain.c:1248:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1248 |           if (*margins_spec == ':')[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1249 |             margins_spec++;[0m
      | [0;1;32m                           
[0m[1mmain.c:1254:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1254 |               media->llx = j;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1255 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mmain.c:1258:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1258 |               media->urx = media->w - j;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1259 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mmain.c:1262:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1262 |               media->ury = media->h - j;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1263 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mmain.c:1266:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1266 |               media->lly = j;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1267 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mmain.c:1270:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1270 |       MESSAGE (1,[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1270:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1270 |       MESSAGE (1,[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1278:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1278 |   if (MATCH (page_label_format, "short"))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1279 |     page_label = LABEL_SHORT;[0m
 1280 |   else if (MATCH (page_label_format, "long"))[0m
      | [0;32m  } 
[0m[1mmain.c:1280:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1280 |   else if (MATCH (page_label_format, "long"))[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1281 |     page_label = LABEL_LONG;[0m
 1282 |   else[0m
      | [0;32m  } 
[0m[1mmain.c:1282:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1282 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1283 |     FATAL ((stderr, _("illegal page label format \"%s\""), page_label_format));[0m
      | [0;1;32m                                                                               
[0m[1mmain.c:1283:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1283 |     FATAL ((stderr, _("illegal page label format \"%s\""), page_label_format));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1283:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1283 |     FATAL ((stderr, _("illegal page label format \"%s\""), page_label_format));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1283:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1283 |     FATAL ((stderr, _("illegal page label format \"%s\""), page_label_format));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1283:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1283 |     FATAL ((stderr, _("illegal page label format \"%s\""), page_label_format));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1286:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1286 |   if (MATCH (npf_name, "space"))[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 1287 |     non_printable_format = NPF_SPACE;[0m
 1288 |   else if (MATCH (npf_name, "questionmark"))[0m
      | [0;32m  } 
[0m[1mmain.c:1288:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1288 |   else if (MATCH (npf_name, "questionmark"))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1289 |     non_printable_format = NPF_QUESTIONMARK;[0m
 1290 |   else if (MATCH (npf_name, "caret"))[0m
      | [0;32m  } 
[0m[1mmain.c:1290:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1290 |   else if (MATCH (npf_name, "caret"))[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1291 |     non_printable_format = NPF_CARET;[0m
 1292 |   else if (MATCH (npf_name, "octal"))[0m
      | [0;32m  } 
[0m[1mmain.c:1292:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1292 |   else if (MATCH (npf_name, "octal"))[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1293 |     non_printable_format = NPF_OCTAL;[0m
 1294 |   else[0m
      | [0;32m  } 
[0m[1mmain.c:1294:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1294 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1295 |     FATAL ((stderr, _("illegal non-printable format \"%s\""), npf_name));[0m
      | [0;1;32m                                                                         
[0m[1mmain.c:1295:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1295 |     FATAL ((stderr, _("illegal non-printable format \"%s\""), npf_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1295:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1295 |     FATAL ((stderr, _("illegal non-printable format \"%s\""), npf_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1295:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1295 |     FATAL ((stderr, _("illegal non-printable format \"%s\""), npf_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1295:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1295 |     FATAL ((stderr, _("illegal non-printable format \"%s\""), npf_name));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1300:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1300 |       if (MATCH (mark_wrapped_lines_style_name, "none"))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1301 |         mark_wrapped_lines_style = MWLS_NONE;[0m
 1302 |       else if (MATCH (mark_wrapped_lines_style_name, "plus"))[0m
      | [0;32m      } 
[0m[1mmain.c:1302:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1302 |       else if (MATCH (mark_wrapped_lines_style_name, "plus"))[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1303 |         mark_wrapped_lines_style = MWLS_PLUS;[0m
 1304 |       else if (MATCH (mark_wrapped_lines_style_name, "box"))[0m
      | [0;32m      } 
[0m[1mmain.c:1304:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1304 |       else if (MATCH (mark_wrapped_lines_style_name, "box"))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 1305 |         mark_wrapped_lines_style = MWLS_BOX;[0m
 1306 |       else if (MATCH (mark_wrapped_lines_style_name, "arrow"))[0m
      | [0;32m      } 
[0m[1mmain.c:1306:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1306 |       else if (MATCH (mark_wrapped_lines_style_name, "arrow"))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1307 |         mark_wrapped_lines_style = MWLS_ARROW;[0m
 1308 |       else[0m
      | [0;32m      } 
[0m[1mmain.c:1308:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1308 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1309 |         FATAL ((stderr, _("illegal style for wrapped line marker: \"%s\""),[0m
 1310 |                 mark_wrapped_lines_style_name));[0m
      | [0;1;32m                                                
[0m[1mmain.c:1309:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1309 |         FATAL ((stderr, _("illegal style for wrapped line marker: \"%s\""),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1309:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1309 |         FATAL ((stderr, _("illegal style for wrapped line marker: \"%s\""),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1309:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1309 |         FATAL ((stderr, _("illegal style for wrapped line marker: \"%s\""),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1309:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1309 |         FATAL ((stderr, _("illegal style for wrapped line marker: \"%s\""),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1318:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1318 |       if (ui == 0)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1319 |         FATAL ((stderr, _("illegal N-up argument: %d"), nup));[0m
      | [0;1;32m                                                              
[0m[1mmain.c:1319:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1319 |         FATAL ((stderr, _("illegal N-up argument: %d"), nup));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1319:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1319 |         FATAL ((stderr, _("illegal N-up argument: %d"), nup));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1319:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1319 |         FATAL ((stderr, _("illegal N-up argument: %d"), nup));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1319:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1319 |         FATAL ((stderr, _("illegal N-up argument: %d"), nup));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1323:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1323 |           if (ui != 1)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1324 |             FATAL ((stderr, _("N-up argument must be power of 2: %d"), nup));[0m
      | [0;1;32m                                                                             
[0m[1mmain.c:1324:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1324 |             FATAL ((stderr, _("N-up argument must be power of 2: %d"), nup));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1324:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1324 |             FATAL ((stderr, _("N-up argument must be power of 2: %d"), nup));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1324:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1324 |             FATAL ((stderr, _("N-up argument must be power of 2: %d"), nup));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1324:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1324 |             FATAL ((stderr, _("N-up argument must be power of 2: %d"), nup));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1332:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1332 |   if (nup_rows == 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1333 |     nup_rows = 1;[0m
      | [0;1;32m                 
[0m[1mmain.c:1335:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1335 |   if (nup_columns == 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1336 |     nup_columns = 1;[0m
      | [0;1;32m                    
[0m[1mmain.c:1401:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1401 |       FATAL ((stderr, _("malformed underlay position: %s"), ul_position));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1401:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1401 |       FATAL ((stderr, _("malformed underlay position: %s"), ul_position));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1401:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1401 |       FATAL ((stderr, _("malformed underlay position: %s"), ul_position));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1401:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1401 |       FATAL ((stderr, _("malformed underlay position: %s"), ul_position));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1403:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1403 |   if (ul_position[0] == '-')[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1404 |     ul_x += d_page_w;[0m
      | [0;1;32m                     
[0m[1mmain.c:1408:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1408 |   if (cp2 == cp)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 1409 |     goto malformed_position;[0m
      | [0;1;32m                            
[0m[1mmain.c:1410:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1410 |   if (cp[0] == '-')[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 1411 |     ul_y += d_page_h;[0m
      | [0;1;32m                     
[0m[1mmain.c:1414:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1414 |   if (!ul_angle_p)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1415 |     /* No angle given, count the default. */[0m
 1416 |     ul_angle = (atan2 (-d_page_h, d_page_w) / 3.14159265 * 180);[0m
      | [0;1;32m                                                                
[0m[1mmain.c:1419:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1419 |   if (strcmp (ul_style_str, "outline") == 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1420 |     ul_style = UL_STYLE_OUTLINE;[0m
 1421 |   else if (strcmp (ul_style_str, "filled") == 0)[0m
      | [0;32m  } 
[0m[1mmain.c:1421:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1421 |   else if (strcmp (ul_style_str, "filled") == 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1422 |     ul_style = UL_STYLE_FILLED;[0m
 1423 |   else[0m
      | [0;32m  } 
[0m[1mmain.c:1423:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1423 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1424 |     FATAL ((stderr, _("illegal underlay style: %s"), ul_style_str));[0m
      | [0;1;32m                                                                    
[0m[1mmain.c:1424:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1424 |     FATAL ((stderr, _("illegal underlay style: %s"), ul_style_str));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1424:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1424 |     FATAL ((stderr, _("illegal underlay style: %s"), ul_style_str));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1424:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1424 |     FATAL ((stderr, _("illegal underlay style: %s"), ul_style_str));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1424:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1424 |     FATAL ((stderr, _("illegal underlay style: %s"), ul_style_str));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1435:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1435 |       d_header_h = 0;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1436 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mmain.c:1439:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1439 |       d_header_h = HFpt.h * 1.5;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1440 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mmain.c:1443:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1443 |       d_header_h = 36;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1444 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mmain.c:1485:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1485 |       if (hl_start_state)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1486 |         start_state = hl_start_state;[0m
 1487 |       else if (highlight)[0m
      | [0;32m      } 
[0m[1mmain.c:1487:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1487 |       else if (highlight)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1488 |         start_state = NULL;[0m
 1489 |       else[0m
      | [0;32m      } 
[0m[1mmain.c:1489:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1489 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1490 |         start_state = "passthrough";[0m
      | [0;1;32m                                    
[0m[1mmain.c:1503:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1503 |       if (verbose > 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1504 |         buffer_append (&cmd, "-v ");[0m
      | [0;1;32m                                    
[0m[1mmain.c:1526:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1526 |       sprintf (intbuf, "%d", optind == argc ? 1 : argc - optind);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1526:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1526 |       sprintf (intbuf, "%d", optind == argc ? 1 : argc - optind);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1591:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1591 |           if (verbose > 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1592 |             buffer_append (&buffer, " -v");[0m
      | [0;1;32m                                           
[0m[1mmain.c:1608:4: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1608 |           sprintf (fbuf, "@%g/%g", Fpt.w, Fpt.h);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:1608:4: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1608 |           sprintf (fbuf, "@%g/%g", Fpt.w, Fpt.h);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:1631:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1631 |           if (toc_fp == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1632 |             FATAL ((stderr, _("couldn't create temporary toc file: %s"),[0m
 1633 |                     strerror (errno)));[0m
      | [0;1;32m                                       
[0m[1mmain.c:1632:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1632 |             FATAL ((stderr, _("couldn't create temporary toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1632:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1632 |             FATAL ((stderr, _("couldn't create temporary toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1632:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1632 |             FATAL ((stderr, _("couldn't create temporary toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1632:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1632 |             FATAL ((stderr, _("couldn't create temporary toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1644:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1644 |           memcpy (&mod_tm, &run_tm, sizeof (run_tm));[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1644:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1644 |           memcpy (&mod_tm, &run_tm, sizeof (run_tm));[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1667:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1667 |                       memcpy (&mod_tm, tm, sizeof (*tm));[0m
      | [0;1;32m                      ^~~~~~
[0m[1mmain.c:1667:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1667 |                       memcpy (&mod_tm, tm, sizeof (*tm));[0m
      | [0;1;32m                      ^~~~~~
[0m[1mmain.c:1678:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1678 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1679 |                     ERROR ((stderr, _("couldn't stat input file \"%s\": %s"),[0m
 1680 |                             argv[optind],[0m
 1681 |                             strerror (errno)));[0m
      | [0;1;32m                                               
[0m[1mmain.c:1679:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1679 |                     ERROR ((stderr, _("couldn't stat input file \"%s\": %s"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1679:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1679 |                     ERROR ((stderr, _("couldn't stat input file \"%s\": %s"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1679:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1679 |                     ERROR ((stderr, _("couldn't stat input file \"%s\": %s"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1679:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1679 |                     ERROR ((stderr, _("couldn't stat input file \"%s\": %s"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1698:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1698 |           if (fseek (toc_fp, 0, SEEK_SET) != 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1699 |             FATAL ((stderr, _("couldn't rewind toc file: %s"),[0m
 1700 |                     strerror (errno)));[0m
      | [0;1;32m                                       
[0m[1mmain.c:1699:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1699 |             FATAL ((stderr, _("couldn't rewind toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1699:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1699 |             FATAL ((stderr, _("couldn't rewind toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1699:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1699 |             FATAL ((stderr, _("couldn't rewind toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1699:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1699 |             FATAL ((stderr, _("couldn't rewind toc file: %s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1702:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1702 |           memcpy (&mod_tm, &run_tm, sizeof (run_tm));[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1702:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1702 |           memcpy (&mod_tm, &run_tm, sizeof (run_tm));[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1717:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1717 |       if (ofp != NULL && append_ctrl_D)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 1718 |         fprintf (ofp, "\004\n");[0m
      | [0;1;32m                                
[0m[1mmain.c:1718:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1718 |         fprintf (ofp, "\004\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:1718:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1718 |         fprintf (ofp, "\004\n");[0m
      | [0;1;32m        ^~~~~~~
[0m[1mmain.c:1731:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1731 |       MESSAGE (0, (stderr, _("no output generated\n")));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1731:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1731 |       MESSAGE (0, (stderr, _("no output generated\n")));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1735:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1735 |       if (output_file == OUTPUT_FILE_NONE)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1736 |         MESSAGE (0, (stderr, _("output sent to %s\n"),[0m
 1737 |                      printer ? printer : _("printer")));[0m
 1738 |       else[0m
      | [0;32m      } 
[0m[1mmain.c:1736:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1736 |         MESSAGE (0, (stderr, _("output sent to %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1736:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1736 |         MESSAGE (0, (stderr, _("output sent to %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1738:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1738 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1739 |         MESSAGE (0, (stderr, _("output left in %s\n"),[0m
 1740 |                      output_file == OUTPUT_FILE_STDOUT ? "-" : output_file));[0m
      | [0;1;32m                                                                             
[0m[1mmain.c:1739:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1739 |         MESSAGE (0, (stderr, _("output left in %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1739:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1739 |         MESSAGE (0, (stderr, _("output left in %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1748:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1748 |           if (total_pages > 0)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1749 |             real_total_pages = (total_pages - 1) / nup + 1;[0m
 1750 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:1750:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1750 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1751 |             real_total_pages = 0;[0m
      | [0;1;32m                                 
[0m[1mmain.c:1753:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1753 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1754 |         real_total_pages = total_pages;[0m
      | [0;1;32m                                       
[0m[1mmain.c:1758:7: [0m[0;1;35mwarning: [0m[1mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1758 |       snprintf(message, sizeof message, "%s%s%s%s%s",[0m
      | [0;1;32m      ^~~~~~~~
[0m[1mmain.c:1758:7: [0m[0;1;36mnote: [0mCall to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11[0m
 1758 |       snprintf(message, sizeof message, "%s%s%s%s%s",[0m
      | [0;1;32m      ^~~~~~~~
[0m[1mmain.c:1764:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1764 |       MESSAGE (0, (stderr, message, real_total_pages, num_copies));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1764:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1764 |       MESSAGE (0, (stderr, message, real_total_pages, num_copies));[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1766:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1766 |       if (output_file == OUTPUT_FILE_NONE)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 1767 |         MESSAGE (0, (stderr, _(" sent to %s\n"),[0m
 1768 |                      printer ? printer : _("printer")));[0m
 1769 |       else[0m
      | [0;32m      } 
[0m[1mmain.c:1767:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1767 |         MESSAGE (0, (stderr, _(" sent to %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1767:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1767 |         MESSAGE (0, (stderr, _(" sent to %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1769:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1769 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1770 |         MESSAGE (0, (stderr, _(" left in %s\n"),[0m
 1771 |                      output_file == OUTPUT_FILE_STDOUT ? "-" : output_file));[0m
      | [0;1;32m                                                                             
[0m[1mmain.c:1770:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1770 |         MESSAGE (0, (stderr, _(" left in %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1770:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1770 |         MESSAGE (0, (stderr, _(" left in %s\n"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1775:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1775 |           MESSAGE (0, (stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1775:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1775 |           MESSAGE (0, (stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1787:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1787 |           MESSAGE (0, (stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1787:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1787 |           MESSAGE (0, (stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1794:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1794 |               MESSAGE (0, (stderr, _("missing character codes (decimal):\n")));[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1794:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1794 |               MESSAGE (0, (stderr, _("missing character codes (decimal):\n")));[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1802:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1802 |           MESSAGE (0, (stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1802:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1802 |           MESSAGE (0, (stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1809:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1809 |               MESSAGE (0, (stderr,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1809:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1809 |               MESSAGE (0, (stderr,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1820:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1820 |   if (!extended_return_values)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1821 |     retval = 0;[0m
      | [0;1;32m               
[0m[1mmain.c:1835:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1835 |   if (ofp)[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1836 |     /* Output file has already been opened, do nothing. */[0m
 1837 |     return;[0m
      | [0;1;32m           
[0m[1mmain.c:1845:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1845 |       if (mail)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m 1846 |         strcat (spooler_options, "-m ");[0m
      | [0;1;32m                                        
[0m[1mmain.c:1846:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1846 |         strcat (spooler_options, "-m ");[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1846:2: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
 1846 |         strcat (spooler_options, "-m ");[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1849:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1849 |           strcat (spooler_options, no_job_header_switch);[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1849:4: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
 1849 |           strcat (spooler_options, no_job_header_switch);[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1850:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1850 |           strcat (spooler_options, " ");[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1850:4: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
 1850 |           strcat (spooler_options, " ");[0m
      | [0;1;32m          ^~~~~~
[0m[1mmain.c:1852:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1852 |       if (printer_options)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1853 |         strcat (spooler_options, printer_options);[0m
      | [0;1;32m                                                  
[0m[1mmain.c:1853:2: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1853 |         strcat (spooler_options, printer_options);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1853:2: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
 1853 |         strcat (spooler_options, printer_options);[0m
      | [0;1;32m        ^~~~~~
[0m[1mmain.c:1858:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1858 |       if (ofp == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1859 |         FATAL ((stderr, _("couldn't open printer `%s': %s"), printer,[0m
 1860 |                 strerror (errno)));[0m
      | [0;1;32m                                   
[0m[1mmain.c:1859:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1859 |         FATAL ((stderr, _("couldn't open printer `%s': %s"), printer,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1859:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1859 |         FATAL ((stderr, _("couldn't open printer `%s': %s"), printer,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1859:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1859 |         FATAL ((stderr, _("couldn't open printer `%s': %s"), printer,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1859:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1859 |         FATAL ((stderr, _("couldn't open printer `%s': %s"), printer,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1862:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1862 |   else if (output_file == OUTPUT_FILE_STDOUT)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1863 |     ofp = stdout;[0m
 1864 |   else[0m
      | [0;32m  } 
[0m[1mmain.c:1867:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1867 |       if (ofp == NULL)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1868 |         FATAL ((stderr, _("couldn't create output file \"%s\": %s"),[0m
 1869 |                 output_file, strerror (errno)));[0m
      | [0;1;32m                                                
[0m[1mmain.c:1868:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1868 |         FATAL ((stderr, _("couldn't create output file \"%s\": %s"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1868:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1868 |         FATAL ((stderr, _("couldn't create output file \"%s\": %s"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1868:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1868 |         FATAL ((stderr, _("couldn't create output file \"%s\": %s"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1868:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1868 |         FATAL ((stderr, _("couldn't create output file \"%s\": %s"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1877:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1877 |   if (ofp == NULL)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1878 |     /* Output file hasn't been opened, we are done. */[0m
 1879 |     return;[0m
      | [0;1;32m           
[0m[1mmain.c:1881:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1881 |   if (output_file == OUTPUT_FILE_NONE)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1882 |     printer_close (printer_context);[0m
 1883 |   else if (output_file != OUTPUT_FILE_STDOUT)[0m
      | [0;32m  } 
[0m[1mmain.c:1883:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1883 |   else if (output_file != OUTPUT_FILE_STDOUT)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1884 |     if (fclose (ofp))[0m
 1885 |       FATAL ((stderr, _("couldn't close output file \"%s\": %s"),[0m
 1886 |               output_file, strerror (errno)));[0m
      | [0;1;32m                                              
[0m[1mmain.c:1884:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1884 |     if (fclose (ofp))[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1885 |       FATAL ((stderr, _("couldn't close output file \"%s\": %s"),[0m
 1886 |               output_file, strerror (errno)));[0m
      | [0;1;32m                                              
[0m[1mmain.c:1885:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1885 |       FATAL ((stderr, _("couldn't close output file \"%s\": %s"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1885:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1885 |       FATAL ((stderr, _("couldn't close output file \"%s\": %s"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1885:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1885 |       FATAL ((stderr, _("couldn't close output file \"%s\": %s"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1885:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1885 |       FATAL ((stderr, _("couldn't close output file \"%s\": %s"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1902:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1902 |   if (string == NULL)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1903 |     return;[0m
      | [0;1;32m           
[0m[1mmain.c:1905:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1905 |   MESSAGE (2, (stderr, "handle_env_options(): %s=\"%s\"\n", var, string));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1905:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1905 |   MESSAGE (2, (stderr, "handle_env_options(): %s=\"%s\"\n", var, string));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1927:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1927 |       for (; str[i] && isspace (str[i]); i++)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1928 |         ;[0m
      | [0;1;32m         
[0m[1mmain.c:1929:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1929 |       if (!str[i])[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1930 |         break;[0m
      | [0;1;32m              
[0m[1mmain.c:1940:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1940 |           for (; str[i] && str[i] != endch; i++)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1941 |             ;[0m
      | [0;1;32m             
[0m[1mmain.c:1942:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1942 |           if (!str[i])[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1943 |             FATAL ((stderr, _("syntax error in option string %s=\"%s\":\n\[0m
 1944 | missing end of quotation: %c"), var, string, endch));[0m
      | [0;1;32m                                                     
[0m[1mmain.c:1943:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1943 |             FATAL ((stderr, _("syntax error in option string %s=\"%s\":\n\[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1943:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1943 |             FATAL ((stderr, _("syntax error in option string %s=\"%s\":\n\[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1943:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1943 |             FATAL ((stderr, _("syntax error in option string %s=\"%s\":\n\[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1943:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1943 |             FATAL ((stderr, _("syntax error in option string %s=\"%s\":\n\[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:1953:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1953 |           for (; str[i] && !isspace (str[i]); i++)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 1954 |             ;[0m
      | [0;1;32m             
[0m[1mmain.c:1955:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1955 |           if (str[i])[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1956 |             str[i++] = '\0';[0m
      | [0;1;32m                            
[0m[1mmain.c:1963:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1963 |   MESSAGE (2, (stderr, "found following options (argc=%d):\n", argc));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1963:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1963 |   MESSAGE (2, (stderr, "found following options (argc=%d):\n", argc));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1964:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1964 |   for (i = 0; i < argc; i++)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 1965 |     MESSAGE (2, (stderr, "%3d = \"%s\"\n", i, argv[i]));[0m
      | [0;1;32m                                                        
[0m[1mmain.c:1965:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1965 |     MESSAGE (2, (stderr, "%3d = \"%s\"\n", i, argv[i]));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1965:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1965 |     MESSAGE (2, (stderr, "%3d = \"%s\"\n", i, argv[i]));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1973:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1973 |       MESSAGE (0,[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1973:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1973 |       MESSAGE (0,[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1978:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1978 |       for (; optind < argc; optind++)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1979 |         MESSAGE (0, (stderr, _("  option %d = \"%s\"\n"), optind,[0m
 1980 |                      argv[optind]));[0m
      | [0;1;32m                                    
[0m[1mmain.c:1979:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1979 |         MESSAGE (0, (stderr, _("  option %d = \"%s\"\n"), optind,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:1979:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1979 |         MESSAGE (0, (stderr, _("  option %d = \"%s\"\n"), optind,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mmain.c:2012:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2012 |       if (c == -1)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2013 |         break;[0m
      | [0;1;32m              
[0m[1mmain.c:2018:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2018 |           cp = long_options[option_index].name;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2019 | [0m
 2020 |           if (strcmp (cp, "columns") == 0)[0m
 2021 |             {[0m
 2022 |               num_columns = atoi (optarg);[0m
 2023 |               if (num_columns < 1)[0m
 2024 |                 FATAL ((stderr,[0m
 2025 |                         _("number of columns must be larger than zero")));[0m
 2026 |             }[0m
 2027 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2023:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2023 |               if (num_columns < 1)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2024 |                 FATAL ((stderr,[0m
 2025 |                         _("number of columns must be larger than zero")));[0m
      | [0;1;32m                                                                          
[0m[1mmain.c:2024:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2024 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2024:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2024 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2024:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2024 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2024:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2024 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2041:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2041 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mmain.c:2044:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2044 |           prange = (PageRange *) xcalloc (1, sizeof (PageRange));[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mmain.c:2046:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2046 |           if (strcmp (optarg, "odd") == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 2047 |             prange->odd = 1;[0m
 2048 |           else if (strcmp (optarg, "even") == 0)[0m
      | [0;32m          } 
[0m[1mmain.c:2048:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2048 |           else if (strcmp (optarg, "even") == 0)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 2049 |             prange->even = 1;[0m
 2050 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2055:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2055 |                   if (optarg[0] == '-')[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2056 |                     /* -end */[0m
 2057 |                     prange->end = atoi (optarg + 1);[0m
 2058 |                   else if (cp[1] == '\0')[0m
      | [0;32m                  } 
[0m[1mmain.c:2071:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2071 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2072 |                 /* pagenumber */[0m
 2073 |                 prange->start = prange->end = atoi (optarg);[0m
      | [0;1;32m                                                            
[0m[1mmain.c:2081:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2081 |           file_align = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2082 |           if (file_align == 0)[0m
 2083 |             FATAL ((stderr, _("file alignment must be larger than zero")));[0m
 2084 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2082:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2082 |           if (file_align == 0)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2083 |             FATAL ((stderr, _("file alignment must be larger than zero")));[0m
      | [0;1;32m                                                                           
[0m[1mmain.c:2083:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2083 |             FATAL ((stderr, _("file alignment must be larger than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2083:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2083 |             FATAL ((stderr, _("file alignment must be larger than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2083:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2083 |             FATAL ((stderr, _("file alignment must be larger than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2083:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2083 |             FATAL ((stderr, _("file alignment must be larger than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2087:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2087 |           page_header = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2088 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2091:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2091 |           header = HDR_NONE;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2092 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2095:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2095 |           line_end = LE_TRUNCATE;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2096 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2099:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2099 |           line_numbers = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2100 |           if (optarg)[0m
 2101 |             start_line_number = atoi (optarg);[0m
 2102 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2100:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2100 |           if (optarg)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2101 |             start_line_number = atoi (optarg);[0m
      | [0;1;32m                                              
[0m[1mmain.c:2107:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2107 |           printer = xstrdup (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2108 |           output_file = OUTPUT_FILE_NONE;[0m
 2109 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2112:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2112 |           parse_key_value_pair (pagedevice, optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2113 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2116:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2116 |           special_escapes = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2117 |           if (optarg)[0m
 2118 |             {[0m
 2119 |               /* Specify the escape character. */[0m
 2120 |               if (isdigit (optarg[0]))[0m
 2121 |                 /* As decimal, octal, or hexadicimal number. */[0m
 2122 |                 escape_char = (int) strtoul (optarg, NULL, 0);[0m
 2123 |               else[0m
 2124 |                 /* As character directly. */[0m
 2125 |                 escape_char = ((unsigned char *) optarg)[0];[0m
 2126 |             }[0m
 2127 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2120:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2120 |               if (isdigit (optarg[0]))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2121 |                 /* As decimal, octal, or hexadicimal number. */[0m
 2122 |                 escape_char = (int) strtoul (optarg, NULL, 0);[0m
 2123 |               else[0m
      | [0;32m              } 
[0m[1mmain.c:2123:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2123 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2124 |                 /* As character directly. */[0m
 2125 |                 escape_char = ((unsigned char *) optarg)[0];[0m
      | [0;1;32m                                                            
[0m[1mmain.c:2130:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2130 |           highlight = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2131 |           special_escapes = 1;[0m
 2132 |           escape_char = '\0';[0m
 2133 |           hl_start_state = optarg;[0m
 2134 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2137:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2137 |           if (!parse_font_spec (optarg, &Fname, &Fpt, NULL))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2138 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
 2139 |           user_body_font_defined = 1;[0m
 2140 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2137:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2137 |           if (!parse_font_spec (optarg, &Fname, &Fpt, NULL))[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 2138 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m                                                                   
[0m[1mmain.c:2138:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2138 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2138:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2138 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2138:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2138 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2138:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2138 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2143:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2143 |           if (!parse_font_spec (optarg, &HFname, &HFpt, NULL))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2144 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
 2145 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2143:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2143 |           if (!parse_font_spec (optarg, &HFname, &HFpt, NULL))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2144 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m                                                                   
[0m[1mmain.c:2144:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2144 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2144:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2144 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2144:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2144 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2144:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2144 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2149:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2149 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mmain.c:2152:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2152 |           header = HDR_FANCY;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2153 |           if (optarg)[0m
 2154 |             fancy_header_name = optarg;[0m
 2155 |           else[0m
 2156 |             fancy_header_name = fancy_header_default;[0m
 2157 | [0m
 2158 |           if (!file_existsp (fancy_header_name, ".hdr"))[0m
 2159 |             FATAL ((stderr,[0m
 2160 |                     _("couldn't find header definition file \"%s.hdr\""),[0m
 2161 |                     fancy_header_name));[0m
 2162 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2153:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2153 |           if (optarg)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2154 |             fancy_header_name = optarg;[0m
 2155 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2155:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2155 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2156 |             fancy_header_name = fancy_header_default;[0m
      | [0;1;32m                                                     
[0m[1mmain.c:2158:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2158 |           if (!file_existsp (fancy_header_name, ".hdr"))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2159 |             FATAL ((stderr,[0m
 2160 |                     _("couldn't find header definition file \"%s.hdr\""),[0m
 2161 |                     fancy_header_name));[0m
      | [0;1;32m                                        
[0m[1mmain.c:2159:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2159 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2159:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2159 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2159:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2159 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2159:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2159 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2165:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2165 |           no_job_header = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2166 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2169:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2169 |           if (optarg)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2170 |             highlight_bars = atoi (optarg);[0m
 2171 |           else[0m
 2172 |             highlight_bars = 2;[0m
 2173 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2169:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2169 |           if (optarg)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2170 |             highlight_bars = atoi (optarg);[0m
 2171 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2171:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2171 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2172 |             highlight_bars = 2;[0m
      | [0;1;32m                               
[0m[1mmain.c:2176:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2176 |           line_indent_spec = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2177 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2180:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2180 |           input_filter = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2181 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2184:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2184 |           borders = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2185 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2188:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2188 |           page_prefeed = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2189 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2192:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2192 |           page_prefeed = 0;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2193 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2196:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2196 |           lines_per_page = 66;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2197 |           header = HDR_NONE;[0m
 2198 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2201:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2201 |           lines_per_page = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2202 |           if (lines_per_page <= 0)[0m
 2203 |             FATAL ((stderr,[0m
 2204 |                     _("must print at least one line per each page: %s"),[0m
 2205 |                     argv[optind]));[0m
 2206 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2202:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2202 |           if (lines_per_page <= 0)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 2203 |             FATAL ((stderr,[0m
 2204 |                     _("must print at least one line per each page: %s"),[0m
 2205 |                     argv[optind]));[0m
      | [0;1;32m                                   
[0m[1mmain.c:2203:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2203 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2203:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2203 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2203:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2203 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2203:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2203 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2209:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2209 |           mail = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2210 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2213:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2213 |           media_name = xstrdup (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2214 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2219:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2219 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mmain.c:2222:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2222 |           if (!(optarg[0] == 'n' || optarg[0] == 'r') || optarg[1] != '\0')[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2223 |             {[0m
 2224 |               fprintf (stderr, _("%s: illegal newline character specifier: \[0m
 2225 | '%s': expected 'n' or 'r'\n"),[0m
 2226 |                        program, optarg);[0m
 2227 |               goto option_error;[0m
 2228 |             }[0m
 2229 |           if (optarg[0] == 'n')[0m
 2230 |             nl = '\n';[0m
 2231 |           else[0m
 2232 |             nl = '\r';[0m
 2233 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2224:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2224 |               fprintf (stderr, _("%s: illegal newline character specifier: \[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:2224:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2224 |               fprintf (stderr, _("%s: illegal newline character specifier: \[0m
      | [0;1;32m              ^~~~~~~
[0m[1mmain.c:2229:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2229 |           if (optarg[0] == 'n')[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2230 |             nl = '\n';[0m
 2231 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2231:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2231 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2232 |             nl = '\r';[0m
      | [0;1;32m                      
[0m[1mmain.c:2238:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2238 |           if (strcmp (optarg, "-") == 0)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2239 |             output_file = OUTPUT_FILE_STDOUT;[0m
 2240 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2240:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2240 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2241 |             output_file = optarg;[0m
      | [0;1;32m                                 
[0m[1mmain.c:2242:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2242 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mmain.c:2245:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2245 |           list_missing_characters = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2246 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2249:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2249 |           quiet = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2250 |           verbose = 0;[0m
 2251 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2254:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2254 |           landscape = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2255 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2258:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2258 |           landscape = 0;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2259 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2262:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2262 |           baselineskip = atof (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2263 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2266:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2266 |           parse_key_value_pair (statusdict, optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2267 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2272:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2272 |           title_given = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2273 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2276:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2276 |           tabsize = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2277 |           if (tabsize <= 0)[0m
 2278 |             tabsize = 1;[0m
 2279 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2277:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2277 |           if (tabsize <= 0)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2278 |             tabsize = 1;[0m
      | [0;1;32m                        
[0m[1mmain.c:2282:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2282 |           underlay = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2283 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2286:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2286 |           nup = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2287 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2290:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2290 |           if (optarg)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2291 |             verbose = atoi (optarg);[0m
 2292 |           else[0m
 2293 |             verbose++;[0m
 2294 |           quiet = 0;[0m
 2295 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2290:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2290 |           if (optarg)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2291 |             verbose = atoi (optarg);[0m
 2292 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2292:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2292 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2293 |             verbose++;[0m
      | [0;1;32m                      
[0m[1mmain.c:2298:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2298 |           version ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2299 |           exit (0);[0m
 2300 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2303:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2303 |           output_language = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2304 |           if (strcmp (output_language, "PostScript") != 0)[0m
 2305 |             /* Other output languages are handled with states. */[0m
 2306 |             output_language_pass_through = 1;[0m
 2307 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2304:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2304 |           if (strcmp (output_language, "PostScript") != 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2305 |             /* Other output languages are handled with states. */[0m
 2306 |             output_language_pass_through = 1;[0m
      | [0;1;32m                                             
[0m[1mmain.c:2310:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2310 |           cp = strchr (optarg, ',');[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mmain.c:2311:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2311 |           if (cp == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 2312 |             FATAL ((stderr,[0m
 2313 |                     _("malformed argument `%s' for option -W, --option: \[0m
 2314 | no comma found"),[0m
 2315 |                       optarg));[0m
      | [0;1;32m                               
[0m[1mmain.c:2312:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2312 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2312:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2312 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2312:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2312 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2312:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2312 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2317:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2317 |           if (cp - optarg != 1)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2318 |             FATAL ((stderr, _("helper application specification must be \[0m
 2319 | single character: %s"),[0m
 2320 |                               optarg));[0m
      | [0;1;32m                                       
[0m[1mmain.c:2318:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2318 |             FATAL ((stderr, _("helper application specification must be \[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2318:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2318 |             FATAL ((stderr, _("helper application specification must be \[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2318:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2318 |             FATAL ((stderr, _("helper application specification must be \[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2318:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2318 |             FATAL ((stderr, _("helper application specification must be \[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2327:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2327 |           if (helper_options[i] == NULL)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2328 |             helper_options[i] = buffer_alloc ();[0m
 2329 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2341:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2341 |           xfree (encoding_name);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2342 |           encoding_name = xstrdup (optarg);[0m
 2343 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2346:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2346 |           interpret_formfeed = 0;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2347 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2350:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2350 |           pass_through = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2351 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2354:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2354 |           if (!parse_font_spec (optarg, &ul_font, &ul_ptsize, NULL))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2355 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
 2356 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2354:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2354 |           if (!parse_font_spec (optarg, &ul_font, &ul_ptsize, NULL))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 2355 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m                                                                   
[0m[1mmain.c:2355:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2355 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2355:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2355 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2355:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2355 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2355:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2355 |             FATAL ((stderr, _("malformed font spec: %s"), optarg));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2359:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2359 |           ul_gray = atof (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2360 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2363:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2363 |           xfree (page_label_format);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2364 |           page_label_format = xstrdup (optarg);[0m
 2365 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2368:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2368 |           strhash_put (download_fonts, optarg, strlen (optarg) + 1, NULL,[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2369 |                        NULL);[0m
 2370 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2373:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2373 |           ul_angle = atof (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2374 |           ul_angle_p = 1;[0m
 2375 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2378:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2378 |           xfree (ul_position);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2379 |           ul_position = xstrdup (optarg);[0m
 2380 |           ul_position_p = 1;[0m
 2381 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2384:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2384 |           xfree (npf_name);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2385 |           npf_name = xstrdup (optarg);[0m
 2386 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2389:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2389 |           usage ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2390 |           exit (0);[0m
 2391 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2394:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2394 |           highlight_bar_gray = atof (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2395 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2398:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2398 |           xfree (ul_style_str);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2399 |           ul_style_str = xstrdup (optarg);[0m
 2400 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2403:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2403 |           input_filter_stdin = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2404 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2407:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2407 |           printer_options = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2408 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2411:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2411 |           slicing = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2412 |           slice = atoi (optarg);[0m
 2413 |           if (slice <= 0)[0m
 2414 |             FATAL ((stderr, _("slice must be greater than zero")));[0m
 2415 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2413:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2413 |           if (slice <= 0)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 2414 |             FATAL ((stderr, _("slice must be greater than zero")));[0m
      | [0;1;32m                                                                   
[0m[1mmain.c:2414:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2414 |             FATAL ((stderr, _("slice must be greater than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2414:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2414 |             FATAL ((stderr, _("slice must be greater than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2414:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2414 |             FATAL ((stderr, _("slice must be greater than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2414:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2414 |             FATAL ((stderr, _("slice must be greater than zero")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2418:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2418 |           help_highlight = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2419 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2422:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2422 |           if (optarg == NULL)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2423 |             states_color = 1;[0m
 2424 |           else[0m
 2425 |             states_color = atoi (optarg);[0m
 2426 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2422:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2422 |           if (optarg == NULL)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2423 |             states_color = 1;[0m
 2424 |           else[0m
      | [0;32m          } 
[0m[1mmain.c:2424:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2424 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2425 |             states_color = atoi (optarg);[0m
      | [0;1;32m                                         
[0m[1mmain.c:2429:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2429 |           if (optarg)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2430 |             {[0m
 2431 |               xfree (mark_wrapped_lines_style_name);[0m
 2432 |               mark_wrapped_lines_style_name = xstrdup (optarg);[0m
 2433 |             }[0m
 2434 |           else[0m
 2435 |             /* Set the system default. */[0m
 2436 |             mark_wrapped_lines_style = MWLS_BOX;[0m
 2437 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2434:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2434 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2435 |             /* Set the system default. */[0m
 2436 |             mark_wrapped_lines_style = MWLS_BOX;[0m
      | [0;1;32m                                                
[0m[1mmain.c:2440:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2440 |           margins_spec = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2441 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2444:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2444 |           nup_xpad = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2445 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2448:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2448 |           nup_ypad = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2449 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2452:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2452 |           line_end = LE_WORD_WRAP;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2453 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2456:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2456 |           horizontal_column_height = atof (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2457 |           formfeed_type = FORMFEED_HCOLUMN;[0m
 2458 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2461:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2461 |           pslevel = atoi (optarg);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2462 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2465:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2465 |           rotate_even_pages = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2466 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2469:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2469 |           xfree (states_highlight_style);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2470 |           states_highlight_style = xstrdup (optarg);[0m
 2471 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2474:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2474 |           nup_columnwise = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2475 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2478:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2478 |           swap_even_page_margins = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2479 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2482:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2482 |           extended_return_values = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2483 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2486:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2486 |           page_footer = optarg;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2487 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2490:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2490 |           continuous_page_numbers = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2491 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2494:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2494 |         option_error:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m 2495 |           fprintf (stderr, _("Try `%s --help' for more information.\n"),[0m
 2496 |                    program);[0m
 2497 |           exit (1);[0m
 2498 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2495:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2495 |           fprintf (stderr, _("Try `%s --help' for more information.\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:2495:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2495 |           fprintf (stderr, _("Try `%s --help' for more information.\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mmain.c:2501:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2501 |           printf ("Hey!  main() didn't handle option \"%c\" (%d)", c, c);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2502 |           if (optarg)[0m
 2503 |             printf (" with arg %s", optarg);[0m
 2504 |           printf ("\n");[0m
 2505 |           FATAL ((stderr, "This is a bug!"));[0m
 2506 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mmain.c:2502:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2502 |           if (optarg)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2503 |             printf (" with arg %s", optarg);[0m
      | [0;1;32m                                            
[0m[1mmain.c:2505:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2505 |           FATAL ((stderr, "This is a bug!"));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2505:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2505 |           FATAL ((stderr, "This is a bug!"));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2505:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2505 |           FATAL ((stderr, "This is a bug!"));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:517:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  517 |     fprintf body;                       \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mmain.c:2505:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2505 |           FATAL ((stderr, "This is a bug!"));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:517:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  517 |     fprintf body;                       \[0m
      | [0;1;32m    ^~~~~~~
[0m370 warnings generated.
Suppressed 13 warnings (13 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[28/33][165.6s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpvlfyb7rk.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/states/utils.c
[1mutils.c:48:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   48 | list_prepend (list, data)[0m
      | [0;1;32m^
[0m[1mutils.c:60:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   60 |   if (list->tail == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m   61 |     list->tail = item;[0m
      | [0;1;32m                      
[0m[1mutils.c:66:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   66 | list_append (list, data)[0m
      | [0;1;32m^
[0m[1mutils.c:75:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   75 |   if (list->tail)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m   76 |     list->tail->next = item;[0m
   77 |   else[0m
      | [0;32m  } 
[0m[1mutils.c:77:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   77 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   78 |     list->head = item;[0m
      | [0;1;32m                      
[0m[1mutils.c:87:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   87 | node_alloc (type)[0m
      | [0;1;32m^
[0m[1mutils.c:98:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   98 |   if (type == nREGEXP)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m   99 |     n->u.re.compiled.fastmap = xmalloc (256);[0m
      | [0;1;32m                                             
[0m[1mutils.c:106:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  106 | node_copy (n)[0m
      | [0;1;32m^
[0m[1mutils.c:120:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  120 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mutils.c:123:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  123 |       n2->u.str.len = n->u.str.len;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  124 |       /* +1 to avoid zero allocation. */[0m
  125 |       n2->u.str.data = (char *) xmalloc (n2->u.str.len + 1);[0m
  126 |       memcpy (n2->u.str.data, n->u.str.data, n->u.str.len);[0m
  127 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:126:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  126 |       memcpy (n2->u.str.data, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mutils.c:126:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  126 |       memcpy (n2->u.str.data, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mutils.c:130:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  130 |       n2->u.re.data = xstrdup (n->u.re.data);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  131 |       n2->u.re.len = n->u.re.len;[0m
  132 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:135:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  135 |       n2->u.integer = n->u.integer;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  136 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:139:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  139 |       n2->u.real = n->u.real;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  140 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:143:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  143 |       n2->u.sym = xstrdup (n->u.sym);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  144 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:147:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  147 |       n2->u.array.len = n->u.array.len;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  148 |       n2->u.array.allocated = n2->u.array.len + 1;[0m
  149 |       n2->u.array.array = (Node **) xcalloc (n2->u.array.allocated,[0m
  150 |                                              sizeof (Node *));[0m
  151 |       for (i = 0; i < n->u.array.len; i++)[0m
  152 |         n2->u.array.array[i] = node_copy (n->u.array.array[i]);[0m
  153 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:151:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  151 |       for (i = 0; i < n->u.array.len; i++)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  152 |         n2->u.array.array[i] = node_copy (n->u.array.array[i]);[0m
      | [0;1;32m                                                               
[0m[1mutils.c:161:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  161 | node_reference (node)[0m
      | [0;1;32m^
[0m[1mutils.c:169:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  169 | node_free (node)[0m
      | [0;1;32m^
[0m[1mutils.c:174:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  174 |   if (node == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  175 |     return;[0m
      | [0;1;32m           
[0m[1mutils.c:177:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  177 |   if (--node->refcount > 0)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  178 |     return;[0m
      | [0;1;32m           
[0m[1mutils.c:185:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  185 |       return;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  186 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:189:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  189 |       xfree (node->u.str.data);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  190 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:193:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  193 |       free (node->u.re.data);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  194 |       xfree (node->u.re.compiled.fastmap);[0m
  195 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:204:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  204 |       for (i = 0; i < node->u.array.len; i++)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  205 |         node_free (node->u.array.array[i]);[0m
  206 | [0m
  207 |       xfree (node->u.array.array);[0m
  208 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:204:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  204 |       for (i = 0; i < node->u.array.len; i++)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m  205 |         node_free (node->u.array.array[i]);[0m
      | [0;1;32m                                           
[0m[1mutils.c:216:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  216 | enter_system_variable (name, value)[0m
      | [0;1;32m^
[0m[1mutils.c:227:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  227 |       fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:227:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  227 |       fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:235:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  235 | compile_regexp (re)[0m
      | [0;1;32m^
[0m[1mutils.c:246:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  246 |       for (i = 0; i < 256; i++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  247 |         if (isupper (i))[0m
  248 |           case_insensitive_translate[i] = tolower (i);[0m
  249 |         else[0m
  250 |           case_insensitive_translate[i] = i;[0m
      | [0;1;32m                                            
[0m[1mutils.c:247:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  247 |         if (isupper (i))[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  248 |           case_insensitive_translate[i] = tolower (i);[0m
  249 |         else[0m
      | [0;32m        } 
[0m[1mutils.c:249:6: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  249 |         else[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  250 |           case_insensitive_translate[i] = i;[0m
      | [0;1;32m                                            
[0m[1mutils.c:253:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  253 |   if (re->u.re.flags & fRE_CASE_INSENSITIVE)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  254 |     re->u.re.compiled.translate = case_insensitive_translate;[0m
      | [0;1;32m                                                             
[0m[1mutils.c:259:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  259 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:259:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  259 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:274:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  274 | mk_stmt (type, arg1, arg2, arg3, arg4)[0m
      | [0;1;32m^
[0m[1mutils.c:293:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  293 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mutils.c:296:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  296 |       stmt->u.defsub.name = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  297 |       stmt->u.defsub.closure = arg2;[0m
  298 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:301:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  301 |       stmt->u.block = arg1;     /* Statement list. */[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  302 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:305:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  305 |       stmt->u.stmt_if.expr = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  306 |       stmt->u.stmt_if.then_stmt = arg2;[0m
  307 |       stmt->u.stmt_if.else_stmt = arg3;[0m
  308 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:311:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  311 |       stmt->u.stmt_while.expr = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  312 |       stmt->u.stmt_while.body = arg2;[0m
  313 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:316:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  316 |       stmt->u.stmt_for.init = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  317 |       stmt->u.stmt_for.cond = arg2;[0m
  318 |       stmt->u.stmt_for.incr = arg3;[0m
  319 |       stmt->u.stmt_for.body = arg4;[0m
  320 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:328:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  328 | mk_expr (type, arg1, arg2, arg3)[0m
      | [0;1;32m^
[0m[1mutils.c:349:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  349 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mutils.c:352:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  352 |       expr->u.not = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  353 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:356:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  356 |       expr->u.fcall.name = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  357 |       expr->u.fcall.args = arg2;[0m
  358 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:366:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  366 |       expr->u.assign.expr = arg2;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  367 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:374:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  374 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mutils.c:377:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  377 |       expr->u.arrayassign.expr1 = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  378 |       expr->u.arrayassign.expr2 = arg2;[0m
  379 |       expr->u.arrayassign.expr3 = arg3;[0m
  380 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:383:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  383 |       expr->u.arrayref.expr1 = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  384 |       expr->u.arrayref.expr2 = arg2;[0m
  385 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:388:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  388 |       expr->u.questcolon.cond = arg1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  389 |       expr->u.questcolon.expr1 = arg2;[0m
  390 |       expr->u.questcolon.expr2 = arg3;[0m
  391 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:406:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  406 |       expr->u.op.right = arg2;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  407 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:415:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  415 | cons (car, cdr)[0m
      | [0;1;32m^
[0m[1mutils.c:430:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  430 | define_state (sym, super, rules)[0m
      | [0;1;32m^
[0m[1mutils.c:443:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  443 |   if (super)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  444 |     state->super_name = xstrdup (super->u.sym);[0m
      | [0;1;32m                                               
[0m[1mutils.c:449:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  449 |       fprintf (stderr, _("%s: ouf of memory"), program);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:449:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  449 |       fprintf (stderr, _("%s: ouf of memory"), program);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:454:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  454 |       sprintf (msg, _("warning: redefining state `%s'"), sym->u.sym);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:454:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  454 |       sprintf (msg, _("warning: redefining state `%s'"), sym->u.sym);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:466:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  466 | define_sub (sym, args_body, filename, linenum)[0m
      | [0;1;32m^
[0m[1mutils.c:477:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  477 |       fprintf (stderr, _("%s: ouf of memory"), program);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:477:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  477 |       fprintf (stderr, _("%s: ouf of memory"), program);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:480:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  480 |   if (old_data && warning_level >= WARN_ALL)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  481 |     fprintf (stderr, _("%s:%d: warning: redefining subroutine `%s'\n"),[0m
  482 |              filename, linenum, sym->u.sym);[0m
      | [0;1;32m                                            
[0m[1mutils.c:481:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  481 |     fprintf (stderr, _("%s:%d: warning: redefining subroutine `%s'\n"),[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutils.c:481:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  481 |     fprintf (stderr, _("%s:%d: warning: redefining subroutine `%s'\n"),[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutils.c:488:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  488 | lookup_var (env, ns, sym, filename, linenum)[0m
      | [0;1;32m^
[0m[1mutils.c:521:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  521 |               memcpy (n->u.str.data,[0m
      | [0;1;32m              ^~~~~~
[0m[1mutils.c:521:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  521 |               memcpy (n->u.str.data,[0m
      | [0;1;32m              ^~~~~~
[0m[1mutils.c:548:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  548 |               memcpy (n->u.str.data, current_match_buf, n->u.str.len);[0m
      | [0;1;32m              ^~~~~~
[0m[1mutils.c:548:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  548 |               memcpy (n->u.str.data, current_match_buf, n->u.str.len);[0m
      | [0;1;32m              ^~~~~~
[0m[1mutils.c:569:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  569 |   for (e = env; e; e = e->next)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  570 |     if (strcmp (e->name, sym->u.sym) == 0)[0m
  571 |       return e->val;[0m
      | [0;1;32m                    
[0m[1mutils.c:570:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  570 |     if (strcmp (e->name, sym->u.sym) == 0)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  571 |       return e->val;[0m
      | [0;1;32m                    
[0m[1mutils.c:574:71: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  574 |   if (strhash_get (ns, sym->u.sym, strlen (sym->u.sym), (void **) &n))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m  575 |     return n;[0m
      | [0;1;32m             
[0m[1mutils.c:578:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  578 |   fprintf (stderr, _("%s:%d: error: undefined variable `%s'\n"),[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutils.c:578:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  578 |   fprintf (stderr, _("%s:%d: error: undefined variable `%s'\n"),[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutils.c:588:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  588 | set_var (env, ns, sym, val, filename, linenum)[0m
      | [0;1;32m^
[0m[1mutils.c:600:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  600 |   for (e = env; e; e = e->next)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  601 |     if (strcmp (e->name, sym->u.sym) == 0)[0m
  602 |       {[0m
  603 |         node_free (e->val);[0m
  604 |         e->val = val;[0m
  605 |         return;[0m
  606 |       }[0m
      | [0;1;32m       
[0m[1mutils.c:616:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  616 |   fprintf (stderr, _("%s:%d: error: couldn't set variable `%s'\n"),[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutils.c:616:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  616 |   fprintf (stderr, _("%s:%d: error: couldn't set variable `%s'\n"),[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutils.c:624:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  624 | calculate_binary (l, r, type, filename, linenum)[0m
      | [0;1;32m^
[0m[1mutils.c:651:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  651 |               n->u.integer = (l->u.integer * r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  652 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:655:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  655 |               n->u.integer = (l->u.integer / r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  656 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:659:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  659 |               n->u.integer = (l->u.integer + r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  660 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:663:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  663 |               n->u.integer = (l->u.integer - r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  664 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:667:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  667 |               n->u.integer = (l->u.integer < r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  668 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:671:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  671 |               n->u.integer = (l->u.integer > r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  672 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:675:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  675 |               n->u.integer = (l->u.integer == r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  676 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:679:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  679 |               n->u.integer = (l->u.integer != r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  680 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:683:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  683 |               n->u.integer = (l->u.integer >= r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  684 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:687:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  687 |               n->u.integer = (l->u.integer <= r->u.integer);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  688 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:692:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  692 |               break;[0m
      | [0;1;32m              ^    
[0m      | [0;32m              {    ;} 
[0m[1mutils.c:700:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  700 |           if (l->type == nINTEGER)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  701 |             dl = (double) l->u.integer;[0m
  702 |           else[0m
      | [0;32m          } 
[0m[1mutils.c:702:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  702 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  703 |             dl = l->u.real;[0m
      | [0;1;32m                           
[0m[1mutils.c:705:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  705 |           if (r->type == nINTEGER)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m  706 |             dr = (double) r->u.integer;[0m
  707 |           else[0m
      | [0;32m          } 
[0m[1mutils.c:707:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  707 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  708 |             dr = r->u.real;[0m
      | [0;1;32m                           
[0m[1mutils.c:714:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  714 |               n->u.real = (dl * dr);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  715 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:718:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  718 |               n->u.real = (dl / dr);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  719 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:722:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  722 |               n->u.real = (dl + dr);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  723 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:726:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  726 |               n->u.real = (dl - dr);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  727 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:730:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  730 |               n->type = nINTEGER;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  731 |               n->u.integer = (dl < dr);[0m
  732 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:735:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  735 |               n->type = nINTEGER;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  736 |               n->u.integer = (dl > dr);[0m
  737 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:740:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  740 |               n->type = nINTEGER;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  741 |               n->u.integer = (dl == dr);[0m
  742 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:745:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  745 |               n->type = nINTEGER;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  746 |               n->u.integer = (dl != dr);[0m
  747 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:750:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  750 |               n->type = nINTEGER;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  751 |               n->u.integer = (dl >= dr);[0m
  752 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:755:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  755 |               n->type = nINTEGER;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  756 |               n->u.integer = (dl <= dr);[0m
  757 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutils.c:761:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  761 |               break;[0m
      | [0;1;32m              ^    
[0m      | [0;32m              {    ;} 
[0m[1mutils.c:766:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  766 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:766:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  766 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:771:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  771 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mutils.c:775:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  775 |       abort ();[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  776 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:784:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  784 | eval_expr (expr, env)[0m
      | [0;1;32m^
[0m[1mutils.c:788:9: [0m[0;1;35mwarning: [0m[1mValue stored to 'n' during its initialization is never read [clang-analyzer-deadcode.DeadStores][0m
  788 |   Node *n = nvoid;[0m
      | [0;1;32m        ^   ~~~~~
[0m[1mutils.c:788:9: [0m[0;1;36mnote: [0mValue stored to 'n' during its initialization is never read[0m
  788 |   Node *n = nvoid;[0m
      | [0;1;32m        ^   ~~~~~
[0m[1mutils.c:798:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  798 |   if (expr == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  799 |     return nvoid;[0m
      | [0;1;32m                 
[0m[1mutils.c:808:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  808 |       return expr->u.node;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  809 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:812:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  812 |       n = lookup_var (env, ns_vars, expr->u.node, expr->filename,[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  813 |                       expr->linenum);[0m
  814 |       node_reference (n);[0m
  815 |       return n;[0m
  816 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:819:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  819 |       n = eval_expr (expr->u.not, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  820 |       i = !IS_TRUE (n);[0m
  821 |       node_free (n);[0m
  822 | [0m
  823 |       n = node_alloc (nINTEGER);[0m
  824 |       n->u.integer = i;[0m
  825 |       return n;[0m
  826 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:829:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  829 |       n = expr->u.fcall.name;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m[1mutils.c:842:4: [0m[0;1;35mwarning: [0m[1mValue stored to 'stmts' is never read [clang-analyzer-deadcode.DeadStores][0m
  842 |           stmts = (List *) c->cdr;[0m
      | [0;1;32m          ^       ~~~~~~~~~~~~~~~
[0m[1mutils.c:842:4: [0m[0;1;36mnote: [0mValue stored to 'stmts' is never read[0m
  842 |           stmts = (List *) c->cdr;[0m
      | [0;1;32m          ^       ~~~~~~~~~~~~~~~
[0m[1mutils.c:864:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  864 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mutils.c:864:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  864 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mutils.c:871:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  871 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mutils.c:871:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  871 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mutils.c:892:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  892 |               if (init)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  893 |                 ei->val = eval_expr (init, nenv);[0m
  894 |               else[0m
      | [0;32m              } 
[0m[1mutils.c:894:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  894 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  895 |                 ei->val = nvoid;[0m
      | [0;1;32m                                
[0m[1mutils.c:925:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  925 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:925:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  925 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:933:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  933 |       n = eval_expr (expr->u.assign.expr, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  934 |       set_var (env, ns_vars, expr->u.assign.sym, n, expr->filename,[0m
  935 |                expr->linenum);[0m
  936 | [0m
  937 |       node_reference (n);[0m
  938 |       return n;[0m
  939 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:946:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  946 |       n2 = lookup_var (env, ns_vars, expr->u.assign.sym, expr->filename,[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m[1mutils.c:952:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  952 |           n2 = calculate_binary (n2, n, ePLUS, expr->filename, expr->linenum);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  953 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutils.c:956:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  956 |           n2 = calculate_binary (n2, n, eMINUS, expr->filename, expr->linenum);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  957 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutils.c:960:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  960 |           n2 = calculate_binary (n2, n, eMULT, expr->filename, expr->linenum);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  961 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutils.c:964:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  964 |           n2 = calculate_binary (n2, n, eDIV, expr->filename, expr->linenum);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  965 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutils.c:969:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  969 |           abort ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  970 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutils.c:983:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  983 |       sn.u.integer = 1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  984 | [0m
  985 |       n2 = lookup_var (env, ns_vars, expr->u.node, expr->filename,[0m
  986 |                        expr->linenum);[0m
  987 |       node_reference (n2);[0m
  988 | [0m
  989 |       n = calculate_binary (n2, &sn,[0m
  990 |                             expr->type == ePOSTFIXADD ? ePLUS : eMINUS,[0m
  991 |                             expr->filename, expr->linenum);[0m
  992 |       set_var (env, ns_vars, expr->u.node, n, expr->filename, expr->linenum);[0m
  993 | [0m
  994 |       return n2;[0m
  995 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1000:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1000 |       sn.u.integer = 1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1001 | [0m
 1002 |       n = lookup_var (env, ns_vars, expr->u.node, expr->filename,[0m
 1003 |                       expr->linenum);[0m
 1004 |       n = calculate_binary (n, &sn,[0m
 1005 |                             expr->type == ePREFIXADD ? ePLUS : eMINUS,[0m
 1006 |                             expr->filename, expr->linenum);[0m
 1007 |       set_var (env, ns_vars, expr->u.node, n, expr->filename, expr->linenum);[0m
 1008 | [0m
 1009 |       node_reference (n);[0m
 1010 |       return n;[0m
 1011 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1014:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1014 |       n = eval_expr (expr->u.arrayassign.expr1, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m[1mutils.c:1017:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1017 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1017:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1017 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1025:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1025 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1025:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1025 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1032:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1032 |           fprintf (stderr, _("%s:%d: error: negative array reference index\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1032:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1032 |           fprintf (stderr, _("%s:%d: error: negative array reference index\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1051:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1051 |               for (i = n->u.array.len; i <= n2->u.integer; i++)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 1052 |                 n->u.array.array[i] = nvoid;[0m
      | [0;1;32m                                            
[0m[1mutils.c:1076:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1076 |               for (; i < n->u.str.len; i++)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1077 |                 n->u.str.data[i] = ' ';[0m
      | [0;1;32m                                       
[0m[1mutils.c:1082:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1082 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mutils.c:1082:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1082 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mutils.c:1098:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1098 |       n = eval_expr (expr->u.arrayref.expr1, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m[1mutils.c:1101:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1101 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1101:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1101 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1109:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1109 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1109:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1109 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1118:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1118 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1118:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1118 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutils.c:1142:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1142 |       n = eval_expr (expr->u.questcolon.cond, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1143 |       i = IS_TRUE (n);[0m
 1144 |       node_free (n);[0m
 1145 | [0m
 1146 |       if (i)[0m
 1147 |         n = eval_expr (expr->u.questcolon.expr1, env);[0m
 1148 |       else[0m
 1149 |         n = eval_expr (expr->u.questcolon.expr2, env);[0m
 1150 | [0m
 1151 |       return n;[0m
 1152 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1146:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1146 |       if (i)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1147 |         n = eval_expr (expr->u.questcolon.expr1, env);[0m
 1148 |       else[0m
      | [0;32m      } 
[0m[1mutils.c:1148:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1148 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1149 |         n = eval_expr (expr->u.questcolon.expr2, env);[0m
      | [0;1;32m                                                      
[0m[1mutils.c:1155:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1155 |       n = eval_expr (expr->u.op.left, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1156 |       if (!IS_TRUE (n))[0m
 1157 |         return n;[0m
 1158 |       node_free (n);[0m
 1159 |       return eval_expr (expr->u.op.right, env);[0m
 1160 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1156:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1156 |       if (!IS_TRUE (n))[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1157 |         return n;[0m
      | [0;1;32m                 
[0m[1mutils.c:1163:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1163 |       n = eval_expr (expr->u.op.left, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1164 |       if (IS_TRUE (n))[0m
 1165 |         return n;[0m
 1166 |       node_free (n);[0m
 1167 |       return eval_expr (expr->u.op.right, env);[0m
 1168 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1164:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1164 |       if (IS_TRUE (n))[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1165 |         return n;[0m
      | [0;1;32m                 
[0m[1mutils.c:1183:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1183 |       r = eval_expr (expr->u.op.right, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1184 | [0m
 1185 |       n = calculate_binary (l, r, expr->type, expr->filename, expr->linenum);[0m
 1186 | [0m
 1187 |       node_free (l);[0m
 1188 |       node_free (r);[0m
 1189 |       return n;[0m
 1190 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1199:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1199 | eval_statement (stmt, env, return_seen)[0m
      | [0;1;32m^
[0m[1mutils.c:1211:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1211 |       n = eval_expr (stmt->u.expr, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1212 |       *return_seen = 1;[0m
 1213 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1216:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1216 |       define_sub (stmt->u.defsub.name, stmt->u.defsub.closure,[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1217 |                   stmt->filename, stmt->linenum);[0m
 1218 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1221:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1221 |       n = eval_statement_list (stmt->u.block, env, return_seen);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1222 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1225:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1225 |       n = eval_expr (stmt->u.stmt_if.expr, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1226 |       i = IS_TRUE (n);[0m
 1227 |       node_free (n);[0m
 1228 | [0m
 1229 |       if (i)[0m
 1230 |         /* Then branch. */[0m
 1231 |         n = eval_statement (stmt->u.stmt_if.then_stmt, env, return_seen);[0m
 1232 |       else[0m
 1233 |         {[0m
 1234 |           /* Optional else branch.  */[0m
 1235 |           if (stmt->u.stmt_if.else_stmt)[0m
 1236 |             n = eval_statement (stmt->u.stmt_if.else_stmt, env, return_seen);[0m
 1237 |           else[0m
 1238 |             n = nvoid;[0m
 1239 |         }[0m
 1240 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1229:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1229 |       if (i)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m 1230 |         /* Then branch. */[0m
 1231 |         n = eval_statement (stmt->u.stmt_if.then_stmt, env, return_seen);[0m
 1232 |       else[0m
      | [0;32m      } 
[0m[1mutils.c:1235:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1235 |           if (stmt->u.stmt_if.else_stmt)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1236 |             n = eval_statement (stmt->u.stmt_if.else_stmt, env, return_seen);[0m
 1237 |           else[0m
      | [0;32m          } 
[0m[1mutils.c:1237:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1237 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1238 |             n = nvoid;[0m
      | [0;1;32m                      
[0m[1mutils.c:1243:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1243 |       while (1)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m[1mutils.c:1249:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1249 |           if (!i)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1250 |             break;[0m
      | [0;1;32m                  
[0m[1mutils.c:1256:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1256 |           if (*return_seen)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1257 |             break;[0m
      | [0;1;32m                  
[0m[1mutils.c:1263:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1263 |       if (stmt->u.stmt_for.init)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m[1mutils.c:1276:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1276 |           if (!i)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1277 |             break;[0m
      | [0;1;32m                  
[0m[1mutils.c:1283:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1283 |           if (*return_seen)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1284 |             break;[0m
      | [0;1;32m                  
[0m[1mutils.c:1296:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1296 |       n = eval_expr (stmt->u.expr, env);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1297 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mutils.c:1305:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1305 | eval_statement_list (lst, env, return_seen)[0m
      | [0;1;32m^
[0m[1mutils.c:1314:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1314 |   if (lst == NULL)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1315 |     return nvoid;[0m
      | [0;1;32m                 
[0m[1mutils.c:1324:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1324 |       if (*return_seen)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1325 |         return n;[0m
      | [0;1;32m                 
[0m[1mutils.c:1333:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1333 | load_states_file (name)[0m
      | [0;1;32m^
[0m[1mutils.c:1345:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1345 |       fprintf (stderr, _("%s: couldn't open definition file `%s': %s\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:1345:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1345 |       fprintf (stderr, _("%s: couldn't open definition file `%s': %s\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:1364:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1364 | autoload_file (name)[0m
      | [0;1;32m^
[0m[1mutils.c:1387:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1387 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1388 |         len = strlen (start);[0m
      | [0;1;32m                             
[0m[1mutils.c:1395:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1395 |       sprintf (buf, "%.*s/%s.st", len, start, name);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:1395:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1395 |       sprintf (buf, "%.*s/%s.st", len, start, name);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutils.c:1399:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1399 |           if (verbose)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1400 |             fprintf (stderr,[0m
 1401 |                      _("%s: autoloading `%s' from `%s'\n"),[0m
 1402 |                      program, name, buf);[0m
      | [0;1;32m                                         
[0m[1mutils.c:1400:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1400 |             fprintf (stderr,[0m
      | [0;1;32m            ^~~~~~~
[0m[1mutils.c:1400:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1400 |             fprintf (stderr,[0m
      | [0;1;32m            ^~~~~~~
[0m[1mutils.c:1416:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1416 | lookup_state (name)[0m
      | [0;1;32m^
[0m[1mutils.c:1424:74: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1424 |       if (strhash_get (ns_states, name, strlen (name), (void **) &state))[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 1425 |         return state;[0m
      | [0;1;32m                     
[0m[1mutils.c:1427:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1427 |       if (retry_count > 0)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 1428 |         break;[0m
      | [0;1;32m              
[0m181 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[29/33][172.1s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpvy6t1v5j.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/afmlib/afm.c
[1mafm.c:67:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   67 |   if (syserrno)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m   68 |     syserr = strerror (syserrno);[0m
   69 |   else[0m
      | [0;32m  } 
[0m[1mafm.c:69:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   69 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   70 |     syserr = NULL;[0m
      | [0;1;32m                  
[0m[1mafm.c:74:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   74 |       sprintf (buf, "afm_error_to_string(): illegal error code: %d\n",[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:74:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
   74 |       sprintf (buf, "afm_error_to_string(): illegal error code: %d\n",[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:79:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   79 |   if (code == 0)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m   80 |     sprintf (buf, "AFM Success");[0m
   81 |   else if (code == 1)[0m
      | [0;32m  } 
[0m[1mafm.c:80:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   80 |     sprintf (buf, "AFM Success");[0m
      | [0;1;32m    ^~~~~~~
[0m[1mafm.c:80:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
   80 |     sprintf (buf, "AFM Success");[0m
      | [0;1;32m    ^~~~~~~
[0m[1mafm.c:81:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   81 |   else if (code == 1)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m   82 |     sprintf (buf, "%s%s%s", "AFM Error",[0m
   83 |              syserr ? ":" : "",[0m
   84 |              syserr ? syserr : "");[0m
   85 |   else[0m
      | [0;32m  } 
[0m[1mafm.c:82:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   82 |     sprintf (buf, "%s%s%s", "AFM Error",[0m
      | [0;1;32m    ^~~~~~~
[0m[1mafm.c:82:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
   82 |     sprintf (buf, "%s%s%s", "AFM Error",[0m
      | [0;1;32m    ^~~~~~~
[0m[1mafm.c:85:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
   85 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m   86 |     sprintf (buf, "AFM Error: %s%s%s", error_names[code],[0m
   87 |              syserr ? ": " : "",[0m
   88 |              syserr ? syserr : "");[0m
      | [0;1;32m                                   
[0m[1mafm.c:86:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
   86 |     sprintf (buf, "AFM Error: %s%s%s", error_names[code],[0m
      | [0;1;32m    ^~~~~~~
[0m[1mafm.c:86:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
   86 |     sprintf (buf, "AFM Error: %s%s%s", error_names[code],[0m
      | [0;1;32m    ^~~~~~~
[0m[1mafm.c:123:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  123 |   if (path == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  124 |     path = default_path;[0m
      | [0;1;32m                        
[0m[1mafm.c:129:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  129 |       if (cp != path)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  130 |         cp++;[0m
      | [0;1;32m             
[0m[1mafm.c:133:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  133 |       if (cp2)[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  134 |         len = cp2 - cp;[0m
  135 |       else[0m
      | [0;32m      } 
[0m[1mafm.c:135:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  135 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  136 |         len = strlen (cp);[0m
      | [0;1;32m                          
[0m[1mafm.c:138:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  138 |       memcpy (buf, cp, len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:138:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  138 |       memcpy (buf, cp, len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:140:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  140 |       if (len > 0 && buf[len - 1] == '/')[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  141 |         buf[len - 1] = '\0';[0m
      | [0;1;32m                            
[0m[1mafm.c:143:7: [0m[0;1;35mwarning: [0m[1mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  143 |       strcat (buf, "/font.map");[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:143:7: [0m[0;1;36mnote: [0mCall to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119[0m
  143 |       strcat (buf, "/font.map");[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:145:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  145 |       if (stat (buf, &stat_st) == 0)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  146 |         read_font_map (handle, buf);[0m
      | [0;1;32m                                    
[0m[1mafm.c:171:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  171 |   if (handle == NULL)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  172 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:175:76: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  175 |   while (strhash_get_first (handle->font_map, &key, &keylen, (void *) &cp))[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m  176 |     free (cp);[0m
      | [0;1;32m              
[0m[1mafm.c:188:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  188 |   if (handle == NULL)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m  189 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:203:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  203 |   if (handle == NULL || fontname == NULL || prefix_return == NULL)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  204 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:208:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  208 |                     (void *) &filename))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  209 |     return AFM_ERROR_UNKNOWN_FONT;[0m
      | [0;1;32m                                  
[0m[1mafm.c:224:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  224 |   if (handle == NULL || fontname == NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  225 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:229:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  229 |                     (void *) &filename))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  230 |     return AFM_ERROR_UNKNOWN_FONT;[0m
      | [0;1;32m                                  
[0m[1mafm.c:233:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  233 |   sprintf (fname, "%s.afm", filename);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:233:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  233 |   sprintf (fname, "%s.afm", filename);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:246:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  246 |   if (handle == NULL || filename == NULL)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  247 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:250:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  250 |   if (font == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  251 |     return AFM_ERROR_MEMORY;[0m
      | [0;1;32m                            
[0m[1mafm.c:309:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  309 |   if (font == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  310 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:323:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  323 |   for (i = 0; i < font->num_character_metrics; i++)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  324 |     FREE (font->character_metrics[i].name);[0m
      | [0;1;32m                                           
[0m[1mafm.c:328:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  328 |   for (i = 0; i < font->num_composites; i++)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  329 |     FREE (font->composites[i].name);[0m
      | [0;1;32m                                    
[0m[1mafm.c:344:17: [0m[0;1;35mwarning: [0m[1mAccess to field 'fontnames' results in a dereference of a null pointer (loaded from field 'private') [clang-analyzer-core.NullDereference][0m
  344 |   strhash_free (font->private->fontnames);[0m
      | [0;1;32m                ^
[0m[1mafm.c:224:7: [0m[0;1;36mnote: [0mAssuming 'handle' is not equal to NULL[0m
  224 |   if (handle == NULL || fontname == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mafm.c:224:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mafm.c:224:25: [0m[0;1;36mnote: [0mAssuming 'fontname' is not equal to NULL[0m
  224 |   if (handle == NULL || fontname == NULL)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~
[0m[1mafm.c:224:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  224 |   if (handle == NULL || fontname == NULL)[0m
      | [0;1;32m  ^
[0m[1mafm.c:228:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  228 |   if (!strhash_get (handle->font_map, fontname, strlen (fontname),[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m  229 |                     (void *) &filename))[0m
      | [0;1;32m                    ~~~~~~~~~~~~~~~~~~~
[0m[1mafm.c:228:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  228 |   if (!strhash_get (handle->font_map, fontname, strlen (fontname),[0m
      | [0;1;32m  ^
[0m[1mafm.c:235:10: [0m[0;1;36mnote: [0mCalling 'afm_open_file'[0m
  235 |   return afm_open_file (handle, info_level, fname, font_return);[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafm.c:246:7: [0m[0;1;36mnote: [0m'handle' is not equal to NULL[0m
  246 |   if (handle == NULL || filename == NULL)[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:246:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mafm.c:246:25: [0m[0;1;36mnote: [0m'filename' is not equal to NULL[0m
  246 |   if (handle == NULL || filename == NULL)[0m
      | [0;1;32m                        ^~~~~~~~
[0m[1mafm.c:246:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  246 |   if (handle == NULL || filename == NULL)[0m
      | [0;1;32m  ^
[0m[1mafm.c:250:7: [0m[0;1;36mnote: [0mAssuming 'font' is not equal to NULL[0m
  250 |   if (font == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~
[0m[1mafm.c:250:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  250 |   if (font == NULL)[0m
      | [0;1;32m  ^
[0m[1mafm.c:253:3: [0m[0;1;36mnote: [0mValue assigned to field 'private'[0m
  253 |   font->private[0m
      | [0;1;32m  ^~~~~~~~~~~~~
[0m  254 |     = (struct afm_font_private_data_st *) calloc (1, sizeof (*font->private));[0m
      | [0;1;32m    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mafm.c:255:7: [0m[0;1;36mnote: [0mAssuming field 'private' is equal to NULL[0m
  255 |   if (font->private == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~
[0m[1mafm.c:255:3: [0m[0;1;36mnote: [0mTaking true branch[0m
  255 |   if (font->private == NULL)[0m
      | [0;1;32m  ^
[0m[1mafm.c:258:7: [0m[0;1;36mnote: [0mControl jumps to line 297[0m
  258 |       goto error_out;[0m
      | [0;1;32m      ^
[0m[1mafm.c:297:10: [0m[0;1;36mnote: [0mCalling 'afm_close_font'[0m
  297 |   (void) afm_close_font (font);[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~
[0m[1mafm.c:309:7: [0m[0;1;36mnote: [0m'font' is not equal to NULL[0m
  309 |   if (font == NULL)[0m
      | [0;1;32m      ^~~~
[0m[1mafm.c:309:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  309 |   if (font == NULL)[0m
      | [0;1;32m  ^
[0m[1mafm.c:313:27: [0m[0;1;36mnote: [0mField 'FontName' is null[0m
  313 |   FREE (font->global_info.FontName);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:313:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  313 |   FREE (font->global_info.FontName);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:314:27: [0m[0;1;36mnote: [0mField 'FullName' is null[0m
  314 |   FREE (font->global_info.FullName);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:314:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  314 |   FREE (font->global_info.FullName);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:315:27: [0m[0;1;36mnote: [0mField 'FamilyName' is null[0m
  315 |   FREE (font->global_info.FamilyName);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:315:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  315 |   FREE (font->global_info.FamilyName);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:316:27: [0m[0;1;36mnote: [0mField 'Weight' is null[0m
  316 |   FREE (font->global_info.Weight);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:316:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  316 |   FREE (font->global_info.Weight);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:317:27: [0m[0;1;36mnote: [0mField 'Version' is null[0m
  317 |   FREE (font->global_info.Version);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:317:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  317 |   FREE (font->global_info.Version);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:318:27: [0m[0;1;36mnote: [0mField 'Notice' is null[0m
  318 |   FREE (font->global_info.Notice);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:318:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  318 |   FREE (font->global_info.Notice);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:319:27: [0m[0;1;36mnote: [0mField 'EncodingScheme' is null[0m
  319 |   FREE (font->global_info.EncodingScheme);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:319:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  319 |   FREE (font->global_info.EncodingScheme);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:320:27: [0m[0;1;36mnote: [0mField 'CharacterSet' is null[0m
  320 |   FREE (font->global_info.CharacterSet);[0m
      | [0;1;32m                          ^
[0m[1mafm.c:320:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  320 |   FREE (font->global_info.CharacterSet);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:323:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 325[0m
  323 |   for (i = 0; i < font->num_character_metrics; i++)[0m
      | [0;1;32m  ^
[0m[1mafm.c:325:15: [0m[0;1;36mnote: [0mField 'character_metrics' is null[0m
  325 |   FREE (font->character_metrics);[0m
      | [0;1;32m              ^
[0m[1mafm.c:325:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  325 |   FREE (font->character_metrics);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:328:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 330[0m
  328 |   for (i = 0; i < font->num_composites; i++)[0m
      | [0;1;32m  ^
[0m[1mafm.c:330:15: [0m[0;1;36mnote: [0mField 'composites' is null[0m
  330 |   FREE (font->composites);[0m
      | [0;1;32m              ^
[0m[1mafm.c:330:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  330 |   FREE (font->composites);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:333:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 338[0m
  333 |   for (i = 0; i < font->num_kern_pairs; i++)[0m
      | [0;1;32m  ^
[0m[1mafm.c:338:15: [0m[0;1;36mnote: [0mField 'kern_pairs' is null[0m
  338 |   FREE (font->kern_pairs);[0m
      | [0;1;32m              ^
[0m[1mafm.c:338:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  338 |   FREE (font->kern_pairs);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:341:15: [0m[0;1;36mnote: [0mField 'track_kerns' is null[0m
  341 |   FREE (font->track_kerns);[0m
      | [0;1;32m              ^
[0m[1mafm.c:341:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  341 |   FREE (font->track_kerns);[0m
      | [0;1;32m  ^
[0m[1mafm.c:303:19: [0m[0;1;36mnote: [0mexpanded from macro 'FREE'[0m
  303 | #define FREE(ptr) if (ptr) free (ptr)[0m
      | [0;1;32m                  ^
[0m[1mafm.c:344:17: [0m[0;1;36mnote: [0mAccess to field 'fontnames' results in a dereference of a null pointer (loaded from field 'private')[0m
  344 |   strhash_free (font->private->fontnames);[0m
      | [0;1;32m                ^     ~~~~~~~
[0m[1mafm.c:360:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  360 |   fprintf (fp, "AFM Format Specification version: %g\n", font->version);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:360:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  360 |   fprintf (fp, "AFM Format Specification version: %g\n", font->version);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:361:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  361 |   fprintf (fp, "Global Font Information\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:361:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  361 |   fprintf (fp, "Global Font Information\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:362:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  362 |   fprintf (fp, "  FontName:\t%s\n",     STR (font->global_info.FontName));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:362:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  362 |   fprintf (fp, "  FontName:\t%s\n",     STR (font->global_info.FontName));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:363:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  363 |   fprintf (fp, "  FullName:\t%s\n",     STR (font->global_info.FullName));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:363:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  363 |   fprintf (fp, "  FullName:\t%s\n",     STR (font->global_info.FullName));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:364:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  364 |   fprintf (fp, "  FamilyName:\t%s\n",   STR (font->global_info.FamilyName));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:364:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  364 |   fprintf (fp, "  FamilyName:\t%s\n",   STR (font->global_info.FamilyName));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:365:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  365 |   fprintf (fp, "  Weight:\t%s\n",       STR (font->global_info.Weight));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:365:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  365 |   fprintf (fp, "  Weight:\t%s\n",       STR (font->global_info.Weight));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:366:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  366 |   fprintf (fp, "  FontBBox:\t%g %g %g %g\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:366:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  366 |   fprintf (fp, "  FontBBox:\t%g %g %g %g\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:369:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  369 |   fprintf (fp, "  Version:\t%s\n",      STR (font->global_info.Version));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:369:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  369 |   fprintf (fp, "  Version:\t%s\n",      STR (font->global_info.Version));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:370:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  370 |   fprintf (fp, "  Notice:\t%s\n",       STR (font->global_info.Notice));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:370:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  370 |   fprintf (fp, "  Notice:\t%s\n",       STR (font->global_info.Notice));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:371:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  371 |   fprintf (fp, "  EncodingScheme:\t%s\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:371:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  371 |   fprintf (fp, "  EncodingScheme:\t%s\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:373:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  373 |   fprintf (fp, "  MappingScheme:\t%ld\n", font->global_info.MappingScheme);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:373:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  373 |   fprintf (fp, "  MappingScheme:\t%ld\n", font->global_info.MappingScheme);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:374:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  374 |   fprintf (fp, "  EscChar:\t%ld\n", font->global_info.EscChar);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:374:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  374 |   fprintf (fp, "  EscChar:\t%ld\n", font->global_info.EscChar);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:375:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  375 |   fprintf (fp, "  CharacterSet:\t%s\n", STR (font->global_info.CharacterSet));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:375:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  375 |   fprintf (fp, "  CharacterSet:\t%s\n", STR (font->global_info.CharacterSet));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:376:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  376 |   fprintf (fp, "  Characters:\t%ld\n",  font->global_info.Characters);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:376:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  376 |   fprintf (fp, "  Characters:\t%ld\n",  font->global_info.Characters);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:377:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  377 |   fprintf (fp, "  IsBaseFont:\t%s\n",   BOOL(font->global_info.IsBaseFont));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:377:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  377 |   fprintf (fp, "  IsBaseFont:\t%s\n",   BOOL(font->global_info.IsBaseFont));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:378:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  378 |   fprintf (fp, "  VVector:\t%g %g\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:378:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  378 |   fprintf (fp, "  VVector:\t%g %g\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:380:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  380 |   fprintf (fp, "  IsFixedV:\t%s\n",     BOOL(font->global_info.IsFixedV));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:380:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  380 |   fprintf (fp, "  IsFixedV:\t%s\n",     BOOL(font->global_info.IsFixedV));[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:381:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  381 |   fprintf (fp, "  CapHeight:\t%g\n",    font->global_info.CapHeight);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:381:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  381 |   fprintf (fp, "  CapHeight:\t%g\n",    font->global_info.CapHeight);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:382:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  382 |   fprintf (fp, "  XHeight:\t%g\n",      font->global_info.XHeight);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:382:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  382 |   fprintf (fp, "  XHeight:\t%g\n",      font->global_info.XHeight);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:383:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  383 |   fprintf (fp, "  Ascender:\t%g\n",     font->global_info.Ascender);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:383:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  383 |   fprintf (fp, "  Ascender:\t%g\n",     font->global_info.Ascender);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:384:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  384 |   fprintf (fp, "  Descender:\t%g\n",    font->global_info.Descender);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:384:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  384 |   fprintf (fp, "  Descender:\t%g\n",    font->global_info.Descender);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:386:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  386 |   for (i = 0; i < 2; i++)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  387 |     if (font->writing_direction_metrics[i].is_valid)[0m
  388 |       {[0m
  389 |         fprintf (fp, "Writing Direction %d\n", i);[0m
  390 |         fprintf (fp, "  UnderlinePosition: %g\n",[0m
  391 |                  font->writing_direction_metrics[i].UnderlinePosition);[0m
  392 |         fprintf (fp, "  UnderlineThickness: %g\n",[0m
  393 |                  font->writing_direction_metrics[i].UnderlineThickness);[0m
  394 |         fprintf (fp, "  ItalicAngle: %g\n",[0m
  395 |                  font->writing_direction_metrics[i].ItalicAngle);[0m
  396 |         fprintf (fp, "  CharWidth: %g %g\n",[0m
  397 |                  font->writing_direction_metrics[i].CharWidth_x,[0m
  398 |                  font->writing_direction_metrics[i].CharWidth_y);[0m
  399 |         fprintf (fp, "  IsFixedPitch: %s\n",[0m
  400 |                  BOOL (font->writing_direction_metrics[i].IsFixedPitch));[0m
  401 |       }[0m
      | [0;1;32m       
[0m[1mafm.c:389:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  389 |         fprintf (fp, "Writing Direction %d\n", i);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:389:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  389 |         fprintf (fp, "Writing Direction %d\n", i);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:390:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  390 |         fprintf (fp, "  UnderlinePosition: %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:390:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  390 |         fprintf (fp, "  UnderlinePosition: %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:392:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  392 |         fprintf (fp, "  UnderlineThickness: %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:392:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  392 |         fprintf (fp, "  UnderlineThickness: %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:394:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  394 |         fprintf (fp, "  ItalicAngle: %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:394:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  394 |         fprintf (fp, "  ItalicAngle: %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:396:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  396 |         fprintf (fp, "  CharWidth: %g %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:396:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  396 |         fprintf (fp, "  CharWidth: %g %g\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:399:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  399 |         fprintf (fp, "  IsFixedPitch: %s\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:399:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  399 |         fprintf (fp, "  IsFixedPitch: %s\n",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:404:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  404 |   fprintf (fp, "Individual Character Metrics %ld\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:404:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  404 |   fprintf (fp, "Individual Character Metrics %ld\n",[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:411:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  411 |       fprintf (fp, "  C %ld ; N %s ; B %g %g %g %g\n",[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:411:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  411 |       fprintf (fp, "  C %ld ; N %s ; B %g %g %g %g\n",[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:414:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  414 |       fprintf (fp,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:414:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  414 |       fprintf (fp,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:420:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  420 |   fprintf (fp, "Composite Character Data %ld\n", font->num_composites);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:420:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  420 |   fprintf (fp, "Composite Character Data %ld\n", font->num_composites);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:428:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  428 |       fprintf (fp, "  CC %s %ld", cm->name, cm->num_components);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:428:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  428 |       fprintf (fp, "  CC %s %ld", cm->name, cm->num_components);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:429:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  429 |       for (j = 0; j < cm->num_components; j++)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  430 |         fprintf (fp, " ; PCC %s %g %g",[0m
  431 |                  cm->components[j].name,[0m
  432 |                  cm->components[j].deltax,[0m
  433 |                  cm->components[j].deltay);[0m
      | [0;1;32m                                           
[0m[1mafm.c:430:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  430 |         fprintf (fp, " ; PCC %s %g %g",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:430:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  430 |         fprintf (fp, " ; PCC %s %g %g",[0m
      | [0;1;32m        ^~~~~~~
[0m[1mafm.c:434:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  434 |       fprintf (fp, "\n");[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:434:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  434 |       fprintf (fp, "\n");[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:438:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  438 |   fprintf (fp, "Pair-Wise Kerning %ld\n", font->num_kern_pairs);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:438:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  438 |   fprintf (fp, "Pair-Wise Kerning %ld\n", font->num_kern_pairs);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:444:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  444 |       fprintf (fp, "  KP %s %s %g %g\n", STR (kp->name1), STR (kp->name2),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:444:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  444 |       fprintf (fp, "  KP %s %s %g %g\n", STR (kp->name1), STR (kp->name2),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:448:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  448 |   fprintf (fp, "Track Kerning %ld\n", font->num_track_kerns);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:448:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  448 |   fprintf (fp, "Track Kerning %ld\n", font->num_track_kerns);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:454:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  454 |       fprintf (fp, "  TrackKern %ld %g %g %g %g\n", tk->degree,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:454:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  454 |       fprintf (fp, "  TrackKern %ld %g %g %g %g\n", tk->degree,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:471:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  471 |   if (!font || !string || !font->writing_direction_metrics[0].is_valid)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m  472 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:517:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  517 |   if (!font || !font->writing_direction_metrics[0].is_valid)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  518 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:557:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  557 |   if (font == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  558 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:569:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  569 |                               strlen (name), (void *) &comp) == 0)[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m  570 |             cm = AFM_ENC_NON_EXISTENT;[0m
  571 |           else[0m
      | [0;32m          } 
[0m[1mafm.c:580:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  580 |                                 (void *) &cm))[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  581 |                 cm = AFM_ENC_NON_EXISTENT;[0m
      | [0;1;32m                                          
[0m[1mafm.c:585:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  585 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  586 |     cm = AFM_ENC_NONE;[0m
      | [0;1;32m                      
[0m[1mafm.c:600:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  600 |   if (font == NULL)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  601 |     return AFM_ERROR_ARGUMENT;[0m
      | [0;1;32m                              
[0m[1mafm.c:607:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  607 |       for (i = 0; i < 256; i++)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  608 |         font->encoding[i] = AFM_ENC_NONE;[0m
  609 | [0m
  610 |       /* Apply font's default encoding. */[0m
  611 |       for (i = 0; i < font->num_character_metrics; i++)[0m
  612 |         {[0m
  613 |           cm = &font->character_metrics[i];[0m
  614 |           font->encoding[cm->character_code] = cm;[0m
  615 |         }[0m
  616 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:607:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  607 |       for (i = 0; i < 256; i++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  608 |         font->encoding[i] = AFM_ENC_NONE;[0m
      | [0;1;32m                                         
[0m[1mafm.c:619:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  619 |       apply_encoding (font, afm_88591_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  620 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:623:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  623 |       apply_encoding (font, afm_88592_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  624 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:627:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  627 |       apply_encoding (font, afm_88593_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  628 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:631:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  631 |       apply_encoding (font, afm_88594_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  632 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:635:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  635 |       apply_encoding (font, afm_88595_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  636 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:639:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  639 |       apply_encoding (font, afm_88597_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  640 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:643:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  643 |       apply_encoding (font, afm_88599_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  644 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:647:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  647 |       apply_encoding (font, afm_885910_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  648 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:651:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  651 |       apply_encoding (font, afm_ibmpc_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  652 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:659:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  659 |       apply_encoding (font, afm_88591_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  660 |       for (i = 128; i < 256; i++)[0m
  661 |         font->encoding[i] = AFM_ENC_NONE;[0m
  662 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:660:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  660 |       for (i = 128; i < 256; i++)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m  661 |         font->encoding[i] = AFM_ENC_NONE;[0m
      | [0;1;32m                                         
[0m[1mafm.c:665:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  665 |       apply_encoding (font, afm_mac_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  666 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:669:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  669 |       apply_encoding (font, afm_vms_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  670 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:673:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  673 |       apply_encoding (font, afm_hp8_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  674 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:677:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  677 |       apply_encoding (font, afm_koi8_encoding, flags);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  678 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mafm.c:693:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  693 |   if (handle->verbose < level)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m  694 |     return;[0m
      | [0;1;32m           
[0m[1mafm.c:696:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  696 |   fprintf (stderr, "%s", message);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:696:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  696 |   fprintf (stderr, "%s", message);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:703:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  703 |   fprintf (stderr, "AFM Error: %s\n", message);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:703:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  703 |   fprintf (stderr, "AFM Error: %s\n", message);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:721:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  721 |   sprintf (msg, "AFM: reading font map \"%s\"\n", name);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:721:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  721 |   sprintf (msg, "AFM: reading font map \"%s\"\n", name);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mafm.c:727:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  727 |       sprintf (msg, "AFM: couldn't open font map \"%s\": %s\n", name,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:727:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  727 |       sprintf (msg, "AFM: couldn't open font map \"%s\": %s\n", name,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:738:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  738 |       memcpy (fullname, name, dirlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:738:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  738 |       memcpy (fullname, name, dirlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:743:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  743 |       memcpy (fullname, "./", dirlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:743:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  743 |       memcpy (fullname, "./", dirlen);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:751:11: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  751 |       if (sscanf (buf, "%s %s", font, file) != 2)[0m
      | [0;1;32m          ^~~~~~
[0m[1mafm.c:751:11: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
  751 |       if (sscanf (buf, "%s %s", font, file) != 2)[0m
      | [0;1;32m          ^~~~~~
[0m[1mafm.c:753:4: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  753 |           sprintf (msg, "malformed line in font map \"%s\":\n%s",[0m
      | [0;1;32m          ^~~~~~~
[0m[1mafm.c:753:4: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  753 |           sprintf (msg, "malformed line in font map \"%s\":\n%s",[0m
      | [0;1;32m          ^~~~~~~
[0m[1mafm.c:760:77: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  760 |       if (strhash_get (handle->font_map, font, strlen (font), (void *) &cp))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m  761 |         continue;[0m
      | [0;1;32m                 
[0m[1mafm.c:764:7: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  764 |       strcpy (fullname + dirlen, file);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:764:7: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  764 |       strcpy (fullname + dirlen, file);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:771:7: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  771 |       strcpy (cp, fullname);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:771:7: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  771 |       strcpy (cp, fullname);[0m
      | [0;1;32m      ^~~~~~
[0m[1mafm.c:773:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  773 |       sprintf (msg, "AFM: font mapping: %s -> %s\n", font, cp);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:773:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  773 |       sprintf (msg, "AFM: font mapping: %s -> %s\n", font, cp);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mafm.c:793:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  793 |       if (enc[i].character == AFM_ENC_NONE)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  794 |         font->encoding[enc[i].code] = AFM_ENC_NONE;[0m
  795 |       else if (enc[i].character == AFM_ENC_NON_EXISTENT)[0m
      | [0;32m      } 
[0m[1mafm.c:795:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  795 |       else if (enc[i].character == AFM_ENC_NON_EXISTENT)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  796 |         font->encoding[enc[i].code] = AFM_ENC_NON_EXISTENT;[0m
  797 |       else[0m
      | [0;32m      } 
[0m[1mafm.c:800:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  800 |                            strlen (enc[i].character), (void *) &cm))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  801 |             font->encoding[enc[i].code] = cm;[0m
  802 |           else[0m
      | [0;32m          } 
[0m[1mafm.c:808:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  808 |                                   (void *) &comp) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  809 |                 font->encoding[enc[i].code] = AFM_ENC_NON_EXISTENT;[0m
  810 |               else[0m
      | [0;32m              } 
[0m[1mafm.c:816:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  816 |                                    (void *) &cm))[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  817 |                     font->encoding[enc[i].code] = cm;[0m
  818 |                   else[0m
      | [0;32m                  } 
[0m[1mafm.c:818:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  818 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  819 |                     font->encoding[enc[i].code] = AFM_ENC_NON_EXISTENT;[0m
      | [0;1;32m                                                                       
[0m116 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[30/33][212.7s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpi33_y37p.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/src/psgen.c
[1mpsgen.c:287:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  287 |   if (ps_header_dumped)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m  288 |     return;[0m
      | [0;1;32m           
[0m[1mpsgen.c:300:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  300 |   OUTPUT ((cofp, "%s\n", output_first_line));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:300:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  300 |   OUTPUT ((cofp, "%s\n", output_first_line));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:301:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  301 |   OUTPUT ((cofp, "%%%%BoundingBox: %d %d %d %d\n", media->llx, media->lly,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:301:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  301 |   OUTPUT ((cofp, "%%%%BoundingBox: %d %d %d %d\n", media->llx, media->lly,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:303:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  303 |   OUTPUT ((cofp, "%%%%Title: %s\n", title));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:303:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  303 |   OUTPUT ((cofp, "%%%%Title: %s\n", title));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:304:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  304 |   OUTPUT ((cofp, "%%%%For: %s\n", passwd->pw_gecos));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:304:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  304 |   OUTPUT ((cofp, "%%%%For: %s\n", passwd->pw_gecos));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:305:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  305 |   OUTPUT ((cofp, "%%%%Creator: %s\n", PACKAGE_STRING));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:305:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  305 |   OUTPUT ((cofp, "%%%%Creator: %s\n", PACKAGE_STRING));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:306:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  306 |   OUTPUT ((cofp, "%%%%CreationDate: %s\n", date_string));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:306:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  306 |   OUTPUT ((cofp, "%%%%CreationDate: %s\n", date_string));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:307:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  307 |   OUTPUT ((cofp, "%%%%Orientation: %s\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:307:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  307 |   OUTPUT ((cofp, "%%%%Orientation: %s\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:310:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  310 |   OUTPUT ((cofp, "%%%%Pages: (atend)\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:310:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  310 |   OUTPUT ((cofp, "%%%%Pages: (atend)\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:311:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  311 |   OUTPUT ((cofp, "%%%%DocumentMedia: %s %d %d 0 () ()\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:311:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  311 |   OUTPUT ((cofp, "%%%%DocumentMedia: %s %d %d 0 () ()\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:313:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  313 |   OUTPUT ((cofp, "%%%%DocumentNeededResources: (atend)\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:313:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  313 |   OUTPUT ((cofp, "%%%%DocumentNeededResources: (atend)\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:315:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  315 |   if (count_key_value_set (pagedevice) > 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m  316 |     OUTPUT ((cofp, "%%%%LanguageLevel: 2\n"));[0m
      | [0;1;32m                                              
[0m[1mpsgen.c:316:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  316 |     OUTPUT ((cofp, "%%%%LanguageLevel: 2\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:316:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  316 |     OUTPUT ((cofp, "%%%%LanguageLevel: 2\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:318:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  318 |   OUTPUT ((cofp, "%%%%EndComments\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:318:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  318 |   OUTPUT ((cofp, "%%%%EndComments\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:325:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  325 |   OUTPUT ((cofp, "%%%%BeginProlog\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:325:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  325 |   OUTPUT ((cofp, "%%%%BeginProlog\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:328:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  328 |   OUTPUT ((cofp, "%%%%BeginResource: procset Enscript-Prolog %s\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:328:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  328 |   OUTPUT ((cofp, "%%%%BeginResource: procset Enscript-Prolog %s\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:330:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  330 |   if (!paste_file ("enscript", ".pro"))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  331 |     FATAL ((stderr, _("couldn't find prolog \"%s\": %s\n"), "enscript.pro",[0m
  332 |             strerror (errno)));[0m
      | [0;1;32m                               
[0m[1mpsgen.c:331:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  331 |     FATAL ((stderr, _("couldn't find prolog \"%s\": %s\n"), "enscript.pro",[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:331:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  331 |     FATAL ((stderr, _("couldn't find prolog \"%s\": %s\n"), "enscript.pro",[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:331:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  331 |     FATAL ((stderr, _("couldn't find prolog \"%s\": %s\n"), "enscript.pro",[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:331:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  331 |     FATAL ((stderr, _("couldn't find prolog \"%s\": %s\n"), "enscript.pro",[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:333:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  333 |   OUTPUT ((cofp, "%%%%EndResource\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:333:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  333 |   OUTPUT ((cofp, "%%%%EndResource\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:336:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  336 |   OUTPUT ((cofp, "%%%%BeginResource: procset Enscript-Encoding-%s %s\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:336:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  336 |   OUTPUT ((cofp, "%%%%BeginResource: procset Enscript-Encoding-%s %s\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:338:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  338 |   if (!paste_file (encoding_name, ".enc"))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  339 |     FATAL ((stderr, _("couldn't find encoding file \"%s.enc\": %s\n"),[0m
  340 |             encoding_name, strerror (errno)));[0m
      | [0;1;32m                                              
[0m[1mpsgen.c:339:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  339 |     FATAL ((stderr, _("couldn't find encoding file \"%s.enc\": %s\n"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:339:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  339 |     FATAL ((stderr, _("couldn't find encoding file \"%s.enc\": %s\n"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:339:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  339 |     FATAL ((stderr, _("couldn't find encoding file \"%s.enc\": %s\n"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:339:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  339 |     FATAL ((stderr, _("couldn't find encoding file \"%s.enc\": %s\n"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:341:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  341 |   OUTPUT ((cofp, "%%%%EndResource\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:341:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  341 |   OUTPUT ((cofp, "%%%%EndResource\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:343:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  343 |   OUTPUT ((cofp, "%%%%EndProlog\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:343:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  343 |   OUTPUT ((cofp, "%%%%EndProlog\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:350:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  350 |   OUTPUT ((cofp, "%%%%BeginSetup\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:350:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  350 |   OUTPUT ((cofp, "%%%%BeginSetup\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:354:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  354 |        got = strhash_get_next (download_fonts, &cp, &j, (void **) &cp2))[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m  355 |     download_font (cp);[0m
      | [0;1;32m                       
[0m[1mpsgen.c:359:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  359 |        got = strhash_get_next (res_fonts, &cp, &j, (void **) &cp2))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m  360 |     OUTPUT ((cofp, "%%%%IncludeResource: font %s\n", cp));[0m
      | [0;1;32m                                                          
[0m[1mpsgen.c:360:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  360 |     OUTPUT ((cofp, "%%%%IncludeResource: font %s\n", cp));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:360:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  360 |     OUTPUT ((cofp, "%%%%IncludeResource: font %s\n", cp));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:362:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  362 |   OUTPUT ((cofp, "/HFpt_w %g def\n", HFpt.w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:362:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  362 |   OUTPUT ((cofp, "/HFpt_w %g def\n", HFpt.w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:363:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  363 |   OUTPUT ((cofp, "/HFpt_h %g def\n", HFpt.h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:363:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  363 |   OUTPUT ((cofp, "/HFpt_h %g def\n", HFpt.h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:369:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  369 |   OUTPUT ((cofp, "/%s /HF-gs-font MF\n", HFname));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:369:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  369 |   OUTPUT ((cofp, "/%s /HF-gs-font MF\n", HFname));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:370:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  370 |   OUTPUT ((cofp,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:370:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  370 |   OUTPUT ((cofp,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:374:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  374 |   OUTPUT ((cofp, "/%s /F-gs-font MF\n", Fname));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:374:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  374 |   OUTPUT ((cofp, "/%s /F-gs-font MF\n", Fname));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:375:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  375 |   OUTPUT ((cofp, "/F-gs-font %g %g SF\n", Fpt.w, Fpt.h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:375:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  375 |   OUTPUT ((cofp, "/F-gs-font %g %g SF\n", Fpt.w, Fpt.h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:380:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  380 |       OUTPUT ((cofp, "/ul_str (%s) def\n", underlay));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:380:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  380 |       OUTPUT ((cofp, "/ul_str (%s) def\n", underlay));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:381:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  381 |       OUTPUT ((cofp, "/ul_w_ptsize %g def\n", ul_ptsize.w));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:381:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  381 |       OUTPUT ((cofp, "/ul_w_ptsize %g def\n", ul_ptsize.w));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:382:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  382 |       OUTPUT ((cofp, "/ul_h_ptsize %g def\n", ul_ptsize.h));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:382:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  382 |       OUTPUT ((cofp, "/ul_h_ptsize %g def\n", ul_ptsize.h));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:383:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  383 |       OUTPUT ((cofp, "/ul_gray %g def\n", ul_gray));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:383:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  383 |       OUTPUT ((cofp, "/ul_gray %g def\n", ul_gray));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:384:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  384 |       OUTPUT ((cofp, "/ul_x %g def\n", ul_x));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:384:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  384 |       OUTPUT ((cofp, "/ul_x %g def\n", ul_x));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:385:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  385 |       OUTPUT ((cofp, "/ul_y %g def\n", ul_y));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:385:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  385 |       OUTPUT ((cofp, "/ul_y %g def\n", ul_y));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:386:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  386 |       OUTPUT ((cofp, "/ul_angle %g def\n", ul_angle));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:386:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  386 |       OUTPUT ((cofp, "/ul_angle %g def\n", ul_angle));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:387:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  387 |       OUTPUT ((cofp, "/ul_style %d def\n", ul_style));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:387:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  387 |       OUTPUT ((cofp, "/ul_style %d def\n", ul_style));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:388:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  388 |       OUTPUT ((cofp, "/%s /F-ul-font MF\n", ul_font));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:388:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  388 |       OUTPUT ((cofp, "/%s /F-ul-font MF\n", ul_font));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:389:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  389 |       OUTPUT ((cofp, "/ul_font /F-ul-font findfont \[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:389:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  389 |       OUTPUT ((cofp, "/ul_font /F-ul-font findfont \[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:394:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  394 |   OUTPUT ((cofp, "/#copies %d def\n", num_copies));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:394:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  394 |   OUTPUT ((cofp, "/#copies %d def\n", num_copies));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:397:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  397 |   if (page_prefeed)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  398 |     OUTPUT ((cofp, "true page_prefeed\n"));[0m
      | [0;1;32m                                           
[0m[1mpsgen.c:398:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  398 |     OUTPUT ((cofp, "true page_prefeed\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:398:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  398 |     OUTPUT ((cofp, "true page_prefeed\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:403:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  403 |       OUTPUT ((cofp, "%% Statustdict definitions:\nstatusdict begin\n  "));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:403:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  403 |       OUTPUT ((cofp, "%% Statustdict definitions:\nstatusdict begin\n  "));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:411:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  411 |               OUTPUT ((cofp, "\n  "));[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:411:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  411 |               OUTPUT ((cofp, "\n  "));[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:414:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  414 |           OUTPUT ((cofp, "%s %s ", cp2, cp));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:414:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  414 |           OUTPUT ((cofp, "%s %s ", cp2, cp));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:417:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  417 |       OUTPUT ((cofp, "\nend\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:417:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  417 |       OUTPUT ((cofp, "\nend\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:424:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  424 |       OUTPUT ((cofp, "%% Pagedevice definitions:\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:424:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  424 |       OUTPUT ((cofp, "%% Pagedevice definitions:\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:425:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  425 |       OUTPUT ((cofp, "gs_languagelevel 1 gt {\n  <<\n    "));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:425:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  425 |       OUTPUT ((cofp, "gs_languagelevel 1 gt {\n  <<\n    "));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:434:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  434 |               OUTPUT ((cofp, "\n    "));[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:434:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  434 |               OUTPUT ((cofp, "\n    "));[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:437:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  437 |           OUTPUT ((cofp, "/%s %s ", cp, cp2));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:437:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  437 |           OUTPUT ((cofp, "/%s %s ", cp, cp2));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:445:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  445 |               OUTPUT ((cofp, "\n    "));[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:445:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  445 |               OUTPUT ((cofp, "\n    "));[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:448:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  448 |           OUTPUT ((cofp, "/PageSize [%d %d] ", media->w, media->h));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:448:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  448 |           OUTPUT ((cofp, "/PageSize [%d %d] ", media->w, media->h));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:449:4: [0m[0;1;35mwarning: [0m[1mValue stored to 'i' is never read [clang-analyzer-deadcode.DeadStores][0m
  449 |           i += 21;[0m
      | [0;1;32m          ^    ~~
[0m[1mpsgen.c:449:4: [0m[0;1;36mnote: [0mValue stored to 'i' is never read[0m
  449 |           i += 21;[0m
      | [0;1;32m          ^    ~~
[0m[1mpsgen.c:452:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  452 |       OUTPUT ((cofp, "\n  >> setpagedevice\n} if\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:452:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  452 |       OUTPUT ((cofp, "\n  >> setpagedevice\n} if\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:462:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  462 |       if (header == HDR_SIMPLE)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  463 |         hdr = "simple";[0m
  464 |       else[0m
      | [0;32m      } 
[0m[1mpsgen.c:464:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  464 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  465 |         hdr = fancy_header_name;[0m
      | [0;1;32m                                
[0m[1mpsgen.c:467:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  467 |       OUTPUT ((cofp, "%%%%BeginResource: procset Enscript-Header-%s %s\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:467:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  467 |       OUTPUT ((cofp, "%%%%BeginResource: procset Enscript-Header-%s %s\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:469:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  469 |       if (!paste_file (hdr, ".hdr"))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  470 |         FATAL ((stderr,[0m
  471 |                 _("couldn't find header definition file \"%s.hdr\": %s\n"),[0m
  472 |                 hdr, strerror (errno)));[0m
      | [0;1;32m                                        
[0m[1mpsgen.c:470:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  470 |         FATAL ((stderr,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:470:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  470 |         FATAL ((stderr,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:470:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  470 |         FATAL ((stderr,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:470:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  470 |         FATAL ((stderr,[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:473:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  473 |       OUTPUT ((cofp, "%%%%EndResource\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:473:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  473 |       OUTPUT ((cofp, "%%%%EndResource\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:484:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  484 |   OUTPUT ((cofp, "/d_page_w %d def\n", d_page_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:484:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  484 |   OUTPUT ((cofp, "/d_page_w %d def\n", d_page_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:485:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  485 |   OUTPUT ((cofp, "/d_page_h %d def\n", d_page_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:485:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  485 |   OUTPUT ((cofp, "/d_page_h %d def\n", d_page_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:487:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  487 |   OUTPUT ((cofp, "/d_header_x %d def\n", 0));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:487:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  487 |   OUTPUT ((cofp, "/d_header_x %d def\n", 0));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:488:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  488 |   OUTPUT ((cofp, "/d_header_y %d def\n", d_output_h + d_footer_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:488:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  488 |   OUTPUT ((cofp, "/d_header_y %d def\n", d_output_h + d_footer_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:489:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  489 |   OUTPUT ((cofp, "/d_header_w %d def\n", d_header_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:489:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  489 |   OUTPUT ((cofp, "/d_header_w %d def\n", d_header_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:490:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  490 |   OUTPUT ((cofp, "/d_header_h %d def\n", d_header_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:490:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  490 |   OUTPUT ((cofp, "/d_header_h %d def\n", d_header_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:492:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  492 |   OUTPUT ((cofp, "/d_footer_x %d def\n", 0));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:492:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  492 |   OUTPUT ((cofp, "/d_footer_x %d def\n", 0));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:493:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  493 |   OUTPUT ((cofp, "/d_footer_y %d def\n", 0));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:493:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  493 |   OUTPUT ((cofp, "/d_footer_y %d def\n", 0));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:494:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  494 |   OUTPUT ((cofp, "/d_footer_w %d def\n", d_header_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:494:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  494 |   OUTPUT ((cofp, "/d_footer_w %d def\n", d_header_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:495:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  495 |   OUTPUT ((cofp, "/d_footer_h %d def\n", d_footer_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:495:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  495 |   OUTPUT ((cofp, "/d_footer_h %d def\n", d_footer_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:497:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  497 |   OUTPUT ((cofp, "/d_output_w %d def\n", d_output_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:497:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  497 |   OUTPUT ((cofp, "/d_output_w %d def\n", d_output_w));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:498:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  498 |   OUTPUT ((cofp, "/d_output_h %d def\n", d_output_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:498:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  498 |   OUTPUT ((cofp, "/d_output_h %d def\n", d_output_h));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:499:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  499 |   OUTPUT ((cofp, "/cols %d def\n", num_columns));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:499:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  499 |   OUTPUT ((cofp, "/cols %d def\n", num_columns));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:501:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  501 |   OUTPUT ((cofp, "%%%%EndSetup\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:501:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  501 |   OUTPUT ((cofp, "%%%%EndSetup\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:513:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  513 |   if (!ps_header_dumped)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  514 |     /* No header, let's be consistent and forget trailer also. */[0m
  515 |     return;[0m
      | [0;1;32m           
[0m[1mpsgen.c:519:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  519 |   if (nup > 1 && nup_subpage + 1 != nup)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  520 |     /* N-up showpage missing. */[0m
  521 |     OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m                               
[0m[1mpsgen.c:521:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  521 |     OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:521:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  521 |     OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:525:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  525 |   OUTPUT ((cofp, "%%%%Trailer\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:525:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  525 |   OUTPUT ((cofp, "%%%%Trailer\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:527:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  527 |   if (page_prefeed)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  528 |     OUTPUT ((cofp, "false page_prefeed\n"));[0m
      | [0;1;32m                                            
[0m[1mpsgen.c:528:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  528 |     OUTPUT ((cofp, "false page_prefeed\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:528:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  528 |     OUTPUT ((cofp, "false page_prefeed\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:530:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  530 |   OUTPUT ((cofp, "%%%%Pages: %d\n", total_pages));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:530:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  530 |   OUTPUT ((cofp, "%%%%Pages: %d\n", total_pages));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:535:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  535 |   OUTPUT ((cofp, "%%%%DocumentNeededResources: font "));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:535:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  535 |   OUTPUT ((cofp, "%%%%DocumentNeededResources: font "));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:542:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  542 |           OUTPUT ((cofp, "\n%%%%+ font "));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:542:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  542 |           OUTPUT ((cofp, "\n%%%%+ font "));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:545:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  545 |       OUTPUT ((cofp, "%s ", cp));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:545:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  545 |       OUTPUT ((cofp, "%s ", cp));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:548:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  548 |   OUTPUT ((cofp, "\n%%%%EOF\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:548:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  548 |   OUTPUT ((cofp, "\n%%%%EOF\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:579:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  579 |   if (!continuous_page_numbers)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  580 |     current_pagenum = 0;[0m
      | [0;1;32m                        
[0m[1mpsgen.c:597:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  597 |   if (pass_through || output_language_pass_through)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  598 |     if (do_pass_through (fname, is))[0m
  599 |       /* All done. */[0m
  600 |       return;[0m
      | [0;1;32m             
[0m[1mpsgen.c:598:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  598 |     if (do_pass_through (fname, is))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  599 |       /* All done. */[0m
  600 |       return;[0m
      | [0;1;32m             
[0m[1mpsgen.c:615:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  615 |   MESSAGE (1, (stderr, _("processing file \"%s\"...\n"), fname));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:615:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  615 |   MESSAGE (1, (stderr, _("processing file \"%s\"...\n"), fname));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:658:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  658 |               if (!reuse_last_token)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m  659 |                 get_next_token (is, lx, x, line_column, lineend, &token);[0m
      | [0;1;32m                                                                         
[0m[1mpsgen.c:689:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  689 |                   if (page_ranges == NULL)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  690 |                     do_print = 1;[0m
  691 |                   else[0m
      | [0;32m                  } 
[0m[1mpsgen.c:717:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  717 |                   if (do_print)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  718 |                     total_pages++;[0m
      | [0;1;32m                                  
[0m[1mpsgen.c:730:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  730 |                   if (is_toc)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m  731 |                     current_pagenum = save_current_pagenum;[0m
      | [0;1;32m                                                           
[0m[1mpsgen.c:735:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  735 |               if (line_column == 0 && line_highlight_gray < 1.0)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m  736 |                 OUTPUT ((cofp, "%g %g %g %g %g line_highlight\n",[0m
  737 |                          lx, (y - baselineskip[0m
  738 |                               + (font_bbox_lly * Fpt.h / UNITS_PER_POINT)),[0m
  739 |                          linewidth, Fpt.h + baselineskip,[0m
  740 |                          line_highlight_gray));[0m
      | [0;1;32m                                               
[0m[1mpsgen.c:736:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  736 |                 OUTPUT ((cofp, "%g %g %g %g %g line_highlight\n",[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:736:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  736 |                 OUTPUT ((cofp, "%g %g %g %g %g line_highlight\n",[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:743:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  743 |               if (line_numbers && line_column == 0 && token.type != tFORMFEED)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  744 |                 print_line_number (lx, y, linenumber_space, linenumber_margin,[0m
  745 |                                    current_file_linenum);[0m
      | [0;1;32m                                                         
[0m[1mpsgen.c:751:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  751 |                   switch (formfeed_type)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mpsgen.c:754:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  754 |                       goto end_of_column;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  755 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:758:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  758 |                       goto end_of_page;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  759 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:766:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  766 |                       {[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m  767 |                         int current_row;[0m
  768 | [0m
  769 |                         current_row = (ly - y) / horizontal_column_height;[0m
  770 |                         y = ly - (current_row + 1) * horizontal_column_height;[0m
  771 | [0m
  772 |                         /* Check the end of the page. */[0m
  773 |                         if (y < d_footer_h + d_output_y_margin)[0m
  774 |                           goto end_of_column;[0m
  775 |                       }[0m
  776 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:773:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  773 |                         if (y < d_footer_h + d_output_y_margin)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  774 |                           goto end_of_column;[0m
      | [0;1;32m                                             
[0m[1mpsgen.c:781:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  781 |                   if (CORRECT_SLICE ())[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mpsgen.c:785:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  785 |                           OUTPUT ((cofp, "%g %g %g %g %g (%s) bgs\n", x, y,[0m
      | [0;1;32m                          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:785:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  785 |                           OUTPUT ((cofp, "%g %g %g %g %g (%s) bgs\n", x, y,[0m
      | [0;1;32m                          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:794:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  794 |                           OUTPUT ((cofp, "%g %g %g %g %g %g %g (%s) bgcs\n",[0m
      | [0;1;32m                          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:794:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  794 |                           OUTPUT ((cofp, "%g %g %g %g %g %g %g (%s) bgcs\n",[0m
      | [0;1;32m                          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:805:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  805 |                           OUTPUT ((cofp, "%g %g M\n(%s) s\n", x, y,[0m
      | [0;1;32m                          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:805:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  805 |                           OUTPUT ((cofp, "%g %g M\n(%s) s\n", x, y,[0m
      | [0;1;32m                          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:815:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  815 |                   x = col * d_output_w / (float) num_columns[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m  816 |                     + d_output_x_margin + line_indent;[0m
  817 |                   line_column = 0;[0m
  818 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:838:10: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  838 |                               break;[0m
      | [0;1;32m                              ^    
[0m      | [0;32m                              {    ;} 
[0m[1mpsgen.c:841:10: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  841 |                               OUTPUT ((cofp, "%g %g M (+) s\n", x, y));[0m
      | [0;1;32m                              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:841:10: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  841 |                               OUTPUT ((cofp, "%g %g M (+) s\n", x, y));[0m
      | [0;1;32m                              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:841:10: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  841 |                               OUTPUT ((cofp, "%g %g M (+) s\n", x, y));[0m
      | [0;1;32m                              ^
[0m      | [0;32m                              {
[0m  842 |                               break;[0m
      | [0;1;32m                                   
[0m      | [0;32m                                   ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:846:10: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  846 |                               OUTPUT ((cofp,[0m
      | [0;1;32m                              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:846:10: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  846 |                               OUTPUT ((cofp,[0m
      | [0;1;32m                              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:846:10: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  846 |                               OUTPUT ((cofp,[0m
      | [0;1;32m                              ^
[0m      | [0;32m                              {
[0m  847 |                                        "%g %g %g %g %d wrapped_line_mark\n",[0m
  848 |                                        x, y, Fpt.w, Fpt.h,[0m
  849 |                                        mark_wrapped_lines_style));[0m
  850 |                               break;[0m
      | [0;1;32m                                   
[0m      | [0;32m                                   ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:861:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  861 |                       if (!slicing || current_slice > slice)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  862 |                         if (current_file_linenum != last_wrapped_line)[0m
  863 |                           {[0m
  864 |                             if (do_print)[0m
  865 |                               num_truncated_lines++;[0m
  866 |                             last_wrapped_line = current_file_linenum;[0m
  867 |                           }[0m
      | [0;1;32m                           
[0m[1mpsgen.c:864:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  864 |                             if (do_print)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m  865 |                               num_truncated_lines++;[0m
      | [0;1;32m                                                    
[0m[1mpsgen.c:870:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  870 |                   current_linenum++;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m  871 |                   if (current_linenum >= lines_per_page[0m
  872 |                       || y < d_footer_h + d_output_y_margin)[0m
  873 |                     goto end_of_column;[0m
  874 | [0m
  875 |                   x = col * d_output_w / (float) num_columns[0m
  876 |                     + d_output_x_margin + line_indent;[0m
  877 |                   line_column = 0;[0m
  878 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:872:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  872 |                       || y < d_footer_h + d_output_y_margin)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  873 |                     goto end_of_column;[0m
      | [0;1;32m                                       
[0m[1mpsgen.c:883:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  883 |                   if (token.flags & F_EPSF_ABSOLUTE_Y)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mpsgen.c:883:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  883 |                   if (token.flags & F_EPSF_ABSOLUTE_Y)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  884 |                     token.new_y = ly;[0m
  885 |                   else[0m
      | [0;32m                  } 
[0m[1mpsgen.c:885:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  885 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  886 |                     token.new_y = y;[0m
      | [0;1;32m                                    
[0m[1mpsgen.c:889:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  889 |                   if (token.flags & F_EPSF_ABSOLUTE_X)[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m  890 |                     token.new_x = lx;[0m
  891 |                   else[0m
      | [0;32m                  } 
[0m[1mpsgen.c:891:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  891 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  892 |                     token.new_x = x;[0m
      | [0;1;32m                                    
[0m[1mpsgen.c:898:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  898 |                   if (token.flags & F_EPSF_CENTER)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  899 |                     token.new_x = lx + (linewidth - token.u.epsf.w) / 2;[0m
      | [0;1;32m                                                                        
[0m[1mpsgen.c:900:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  900 |                   if (token.flags & F_EPSF_RIGHT)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  901 |                     token.new_x = lx + (linewidth - token.u.epsf.w);[0m
      | [0;1;32m                                                                    
[0m[1mpsgen.c:913:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  913 |                           MESSAGE (0, (stderr, _("EPS file \"%s\" is too \[0m
      | [0;1;32m                          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:913:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  913 |                           MESSAGE (0, (stderr, _("EPS file \"%s\" is too \[0m
      | [0;1;32m                          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:926:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  926 |                   if (CORRECT_SLICE ())[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  927 |                     paste_epsf (&token);[0m
      | [0;1;32m                                        
[0m[1mpsgen.c:930:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  930 |                   if (!(token.flags & F_EPSF_NO_CPOINT_UPDATE_Y))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  931 |                     y = token.new_y;[0m
      | [0;1;32m                                    
[0m[1mpsgen.c:932:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  932 |                   if (!(token.flags & F_EPSF_NO_CPOINT_UPDATE_X))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m  933 |                     x = token.new_x + token.u.epsf.w;[0m
      | [0;1;32m                                                     
[0m[1mpsgen.c:935:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  935 |                   if (y < d_footer_h + d_output_y_margin)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m  936 |                     goto end_of_column;[0m
      | [0;1;32m                                       
[0m[1mpsgen.c:941:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  941 |                   if (line_column == 0)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mpsgen.c:946:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  946 |                       if (token.u.font.name[0] == '\0')[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  947 |                         newh = default_Fpt.h;[0m
  948 |                       else[0m
      | [0;32m                      } 
[0m[1mpsgen.c:948:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  948 |                       else[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  949 |                         newh = token.u.font.size.h;[0m
      | [0;1;32m                                                   
[0m[1mpsgen.c:962:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  962 |                   MESSAGE (2, (stderr, "^@font="));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:962:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  962 |                   MESSAGE (2, (stderr, "^@font="));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:970:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  970 |                       OUTPUT ((cofp, "/F-gs-font %g %g SF\n", Fpt.w, Fpt.h));[0m
      | [0;1;32m                      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:970:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  970 |                       OUTPUT ((cofp, "/F-gs-font %g %g SF\n", Fpt.w, Fpt.h));[0m
      | [0;1;32m                      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:978:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  978 |                       if (token.u.font.encoding == default_Fencoding)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m  979 |                         OUTPUT ((cofp, "/%s %g %g SUF\n", token.u.font.name,[0m
  980 |                                  token.u.font.size.w, token.u.font.size.h));[0m
  981 |                       else if (token.u.font.encoding == ENC_PS)[0m
      | [0;32m                      } 
[0m[1mpsgen.c:979:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  979 |                         OUTPUT ((cofp, "/%s %g %g SUF\n", token.u.font.name,[0m
      | [0;1;32m                        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:979:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  979 |                         OUTPUT ((cofp, "/%s %g %g SUF\n", token.u.font.name,[0m
      | [0;1;32m                        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:981:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  981 |                       else if (token.u.font.encoding == ENC_PS)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m  982 |                         OUTPUT ((cofp, "/%s %g %g SUF_PS\n", token.u.font.name,[0m
  983 |                                  token.u.font.size.w, token.u.font.size.h));[0m
  984 |                       else[0m
      | [0;32m                      } 
[0m[1mpsgen.c:982:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  982 |                         OUTPUT ((cofp, "/%s %g %g SUF_PS\n", token.u.font.name,[0m
      | [0;1;32m                        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:982:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  982 |                         OUTPUT ((cofp, "/%s %g %g SUF_PS\n", token.u.font.name,[0m
      | [0;1;32m                        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:984:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  984 |                       else[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  985 |                         FATAL ((stderr,[0m
  986 |                                 _("user font encoding can be only the system's default or `ps'")));[0m
      | [0;1;32m                                                                                                   
[0m[1mpsgen.c:985:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  985 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:985:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  985 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:985:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  985 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:985:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  985 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:988:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  988 |                       memset  (user_font_name, 0, sizeof(user_font_name));[0m
      | [0;1;32m                      ^~~~~~
[0m[1mpsgen.c:988:9: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  988 |                       memset  (user_font_name, 0, sizeof(user_font_name));[0m
      | [0;1;32m                      ^~~~~~
[0m[1mpsgen.c:989:9: [0m[0;1;35mwarning: [0m[1mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  989 |                       strncpy (user_font_name, token.u.font.name, sizeof(user_font_name) - 1);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpsgen.c:989:9: [0m[0;1;36mnote: [0mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11[0m
  989 |                       strncpy (user_font_name, token.u.font.name, sizeof(user_font_name) - 1);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpsgen.c:1000:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1000 |                   MESSAGE (2, (stderr, "%s %g/%gpt\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1000:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1000 |                   MESSAGE (2, (stderr, "%s %g/%gpt\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1008:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1008 |                   if (y < d_footer_h + d_output_y_margin)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1009 |                     goto end_of_column;[0m
      | [0;1;32m                                       
[0m[1mpsgen.c:1014:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1014 |                   MESSAGE (2, (stderr, "^@color{%f %f %f}\n",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1014:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1014 |                   MESSAGE (2, (stderr, "^@color{%f %f %f}\n",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1014:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1014 |                   MESSAGE (2, (stderr, "^@color{%f %f %f}\n",[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:1023:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1023 |                       OUTPUT ((cofp, "0 setgray\n"));[0m
      | [0;1;32m                      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1023:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1023 |                       OUTPUT ((cofp, "0 setgray\n"));[0m
      | [0;1;32m                      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1028:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1028 |                       OUTPUT ((cofp, "%g %g %g setrgbcolor\n",[0m
      | [0;1;32m                      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1028:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1028 |                       OUTPUT ((cofp, "%g %g %g setrgbcolor\n",[0m
      | [0;1;32m                      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1042:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1042 |                   MESSAGE (2, (stderr, "^@bgcolor{%f %f %f}\n",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1042:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1042 |                   MESSAGE (2, (stderr, "^@bgcolor{%f %f %f}\n",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1042:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1042 |                   MESSAGE (2, (stderr, "^@bgcolor{%f %f %f}\n",[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:1064:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1064 |                   xfree (fname);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1065 |                   fname = xstrdup (token.u.filename);[0m
 1066 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1069:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1069 |                   current_pagenum = token.u.i - 1;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1070 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1073:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1073 |                   if (current_linenum >= token.u.i)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1074 |                     goto end_of_page;[0m
 1075 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1073:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1073 |                   if (current_linenum >= token.u.i)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1074 |                     goto end_of_page;[0m
      | [0;1;32m                                     
[0m[1mpsgen.c:1078:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1078 |                   xstore[(unsigned char) token.u.i] = x;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1079 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1082:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1082 |                   x = xstore[(unsigned char) token.u.i];[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1083 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1086:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1086 |                   OUTPUT ((cofp, "%g %g M\n%s\n", x, y, token.u.str));[0m
      | [0;1;32m                  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1086:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1086 |                   OUTPUT ((cofp, "%g %g M\n%s\n", x, y, token.u.str));[0m
      | [0;1;32m                  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1086:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1086 |                   OUTPUT ((cofp, "%g %g M\n%s\n", x, y, token.u.str));[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1087 |                   xfree (token.u.str);[0m
 1088 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:1092:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1092 |                   FATAL ((stderr, "process_file(): got illegal token %d",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1092:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1092 |                   FATAL ((stderr, "process_file(): got illegal token %d",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1092:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1092 |                   FATAL ((stderr, "process_file(): got illegal token %d",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:517:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  517 |     fprintf body;                       \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1092:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1092 |                   FATAL ((stderr, "process_file(): got illegal token %d",[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:517:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  517 |     fprintf body;                       \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1094:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1094 |                   break;[0m
      | [0;1;32m                  ^    
[0m      | [0;32m                  {    ;} 
[0m[1mpsgen.c:1102:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1102 |       if (!page_clear)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1103 |         dump_ps_page_trailer ();[0m
      | [0;1;32m                                
[0m[1mpsgen.c:1125:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1125 |       fprintf (toc_fp, "%s\n", cp);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1125:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1125 |       fprintf (toc_fp, "%s\n", cp);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:1218:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1218 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1219 |         escname[i] = ch;[0m
      | [0;1;32m                        
[0m[1mpsgen.c:1224:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1224 |   for (e = 0; escapes[e].name; e++)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1225 |     if (strcmp (escname, escapes[e].name) == 0)[0m
 1226 |       break;[0m
      | [0;1;32m            
[0m[1mpsgen.c:1225:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1225 |     if (strcmp (escname, escapes[e].name) == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1226 |       break;[0m
      | [0;1;32m            
[0m[1mpsgen.c:1227:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1227 |   if (escapes[e].name == NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1228 |     FATAL ((stderr, _("unknown special escape: %s"), escname));[0m
      | [0;1;32m                                                               
[0m[1mpsgen.c:1228:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1228 |     FATAL ((stderr, _("unknown special escape: %s"), escname));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1228:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1228 |     FATAL ((stderr, _("unknown special escape: %s"), escname));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1228:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1228 |     FATAL ((stderr, _("unknown special escape: %s"), escname));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1228:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1228 |     FATAL ((stderr, _("unknown special escape: %s"), escname));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1255:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1255 |                   token->flags &= ~M_EPSF_JUSTIFICATION;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1256 |                   token->flags |= F_EPSF_CENTER;[0m
 1257 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1261:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1261 |                   ch = is_getc (is);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mpsgen.c:1265:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1265 |                       token->flags |= F_EPSF_NO_CPOINT_UPDATE_X;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1266 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1269:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1269 |                       token->flags |= F_EPSF_NO_CPOINT_UPDATE_Y;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1270 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1273:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1273 |                       is_ungetc (ch, is);[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1274 |                       token->flags |= F_EPSF_NO_CPOINT_UPDATE_X;[0m
 1275 |                       token->flags |= F_EPSF_NO_CPOINT_UPDATE_Y;[0m
 1276 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1281:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1281 |                   token->flags &= ~M_EPSF_JUSTIFICATION;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1282 |                   token->flags |= F_EPSF_RIGHT;[0m
 1283 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1288:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1288 |                   ch = is_getc (is);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mpsgen.c:1292:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1292 |                       token->flags |= F_EPSF_SCALE_X;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1293 |                       token->u.epsf.xscale = read_float (is, 0, 1);[0m
 1294 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1297:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1297 |                       token->flags |= F_EPSF_SCALE_Y;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1298 |                       token->u.epsf.yscale = read_float (is, 0, 0);[0m
 1299 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1302:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1302 |                       is_ungetc (ch, is);[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1303 |                       token->flags |= F_EPSF_SCALE_X;[0m
 1304 |                       token->flags |= F_EPSF_SCALE_Y;[0m
 1305 |                       token->u.epsf.xscale = token->u.epsf.yscale[0m
 1306 |                         = read_float (is, 0, 1);[0m
 1307 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1312:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1312 |                   token->u.epsf.x = read_float (is, 1, 1);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1313 | [0m
 1314 |                   /* Check the next character. */[0m
 1315 |                   ch = is_getc (is);[0m
 1316 |                   switch (ch)[0m
 1317 |                     {[0m
 1318 |                     case 'a':[0m
 1319 |                       token->flags |= F_EPSF_ABSOLUTE_X;[0m
 1320 |                       break;[0m
 1321 | [0m
 1322 |                     default:[0m
 1323 |                       is_ungetc (ch, is);[0m
 1324 |                       break;[0m
 1325 |                     }[0m
 1326 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1319:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1319 |                       token->flags |= F_EPSF_ABSOLUTE_X;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1320 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1323:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1323 |                       is_ungetc (ch, is);[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1324 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1329:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1329 |                   token->u.epsf.y = - read_float (is, 1, 0);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1330 | [0m
 1331 |                   /* Check the next character. */[0m
 1332 |                   ch = is_getc (is);[0m
 1333 |                   switch (ch)[0m
 1334 |                     {[0m
 1335 |                     case 'a':[0m
 1336 |                       token->flags |= F_EPSF_ABSOLUTE_Y;[0m
 1337 |                       break;[0m
 1338 | [0m
 1339 |                     default:[0m
 1340 |                       is_ungetc (ch, is);[0m
 1341 |                       break;[0m
 1342 |                     }[0m
 1343 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1336:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1336 |                       token->flags |= F_EPSF_ABSOLUTE_Y;[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1337 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1340:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1340 |                       is_ungetc (ch, is);[0m
      | [0;1;32m                      ^
[0m      | [0;32m                      {
[0m 1341 |                       break;[0m
      | [0;1;32m                           
[0m      | [0;32m                           ;} 
[0m[1mpsgen.c:1346:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1346 |                   token->u.epsf.h = read_float (is, 1, 0);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1347 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1354:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1354 |                   FATAL ((stderr, _("illegal option %c for ^@epsf escape"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1354:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1354 |                   FATAL ((stderr, _("illegal option %c for ^@epsf escape"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1354:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1354 |                   FATAL ((stderr, _("illegal option %c for ^@epsf escape"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1354:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1354 |                   FATAL ((stderr, _("illegal option %c for ^@epsf escape"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1354:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1354 |                   FATAL ((stderr, _("illegal option %c for ^@epsf escape"),[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1355 |                           ch));[0m
      | [0;1;32m                              
[0m      | [0;32m                              ;} 
[0m[1m./gsint.h:515:3: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  515 |   do {                                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:1358:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1358 |           if (ch != ']')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1359 |             FATAL ((stderr,[0m
 1360 |                     _("malformed ^@epsf escape: no ']' after options")));[0m
      | [0;1;32m                                                                         
[0m[1mpsgen.c:1359:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1359 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1359:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1359 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1359:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1359 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1359:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1359 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1370:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1370 |               if (i + 1 >= sizeof (token->u.epsf.filename))[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 1371 |                 FATAL ((stderr,[0m
 1372 |                         _("too long file name for ^@epsf escape:\n%.*s"),[0m
 1373 |                         i, token->u.epsf.filename));[0m
      | [0;1;32m                                                    
[0m[1mpsgen.c:1371:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1371 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1371:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1371 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1371:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1371 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1371:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1371 |                 FATAL ((stderr,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1375:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1375 |           if (ch == EOF)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1376 |             FATAL ((stderr, _("unexpected EOF while scanning ^@epsf escape")));[0m
      | [0;1;32m                                                                               
[0m[1mpsgen.c:1376:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1376 |             FATAL ((stderr, _("unexpected EOF while scanning ^@epsf escape")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1376:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1376 |             FATAL ((stderr, _("unexpected EOF while scanning ^@epsf escape")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1376:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1376 |             FATAL ((stderr, _("unexpected EOF while scanning ^@epsf escape")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1376:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1376 |             FATAL ((stderr, _("unexpected EOF while scanning ^@epsf escape")));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1381:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1381 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1382 |         FATAL ((stderr, _("malformed ^@epsf escape: no '{' found")));[0m
      | [0;1;32m                                                                     
[0m[1mpsgen.c:1382:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1382 |         FATAL ((stderr, _("malformed ^@epsf escape: no '{' found")));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1382:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1382 |         FATAL ((stderr, _("malformed ^@epsf escape: no '{' found")));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1382:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1382 |         FATAL ((stderr, _("malformed ^@epsf escape: no '{' found")));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1382:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1382 |         FATAL ((stderr, _("malformed ^@epsf escape: no '{' found")));[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1388:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1388 |       if (!recognize_eps_file (token))[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1389 |         /* Recognize eps has already printed error message so we are done. */[0m
 1390 |         token->type = tNONE;[0m
 1391 |       else[0m
      | [0;32m      } 
[0m[1mpsgen.c:1395:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1395 |           if (token->u.epsf.h != 0.0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1396 |             token->u.epsf.h -= 1.0;[0m
      | [0;1;32m                                   
[0m[1mpsgen.c:1404:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1404 |           if (token->u.epsf.h == 0.0)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1405 |             scale = 1.0;[0m
 1406 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:1406:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1406 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1407 |             scale = token->u.epsf.h / ph;[0m
      | [0;1;32m                                         
[0m[1mpsgen.c:1409:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1409 |           if ((token->flags & F_EPSF_SCALE_X) == 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1410 |             token->u.epsf.xscale = scale;[0m
      | [0;1;32m                                         
[0m[1mpsgen.c:1411:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1411 |           if ((token->flags & F_EPSF_SCALE_Y) == 0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1412 |             token->u.epsf.yscale = scale;[0m
      | [0;1;32m                                         
[0m[1mpsgen.c:1424:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1424 |       while ((ch = is_getc (is)) != EOF && ch != nl)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 1425 |         ;[0m
      | [0;1;32m         
[0m[1mpsgen.c:1439:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1439 |       if (ch != '{')[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1440 |         FATAL ((stderr, _("malformed %s escape: no '{' found"),[0m
 1441 |                 escapes[e].name));[0m
      | [0;1;32m                                  
[0m[1mpsgen.c:1440:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1440 |         FATAL ((stderr, _("malformed %s escape: no '{' found"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1440:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1440 |         FATAL ((stderr, _("malformed %s escape: no '{' found"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1440:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1440 |         FATAL ((stderr, _("malformed %s escape: no '{' found"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1440:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1440 |         FATAL ((stderr, _("malformed %s escape: no '{' found"),[0m
      | [0;1;32m        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1447:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1447 |           if (ch == '{')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1448 |             parenlevel++;[0m
 1449 |           else if (ch == '}')[0m
      | [0;32m          } 
[0m[1mpsgen.c:1449:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1449 |           else if (ch == '}')[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 1450 |             parenlevel--;[0m
      | [0;1;32m                         
[0m[1mpsgen.c:1453:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1453 |           if (i + 1 >= sizeof (buf))[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1454 |             FATAL ((stderr, _("too long argument for %s escape:\n%.*s"),[0m
 1455 |                     escapes[e].name, i, buf));[0m
      | [0;1;32m                                              
[0m[1mpsgen.c:1454:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1454 |             FATAL ((stderr, _("too long argument for %s escape:\n%.*s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1454:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1454 |             FATAL ((stderr, _("too long argument for %s escape:\n%.*s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1454:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1454 |             FATAL ((stderr, _("too long argument for %s escape:\n%.*s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1454:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1454 |             FATAL ((stderr, _("too long argument for %s escape:\n%.*s"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1463:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1463 |           memset  (token->u.font.name, 0, sizeof(token->u.font.name));[0m
      | [0;1;32m          ^~~~~~
[0m[1mpsgen.c:1463:4: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1463 |           memset  (token->u.font.name, 0, sizeof(token->u.font.name));[0m
      | [0;1;32m          ^~~~~~
[0m[1mpsgen.c:1463:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1463 |           memset  (token->u.font.name, 0, sizeof(token->u.font.name));[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mpsgen.c:1464:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1464 |           strncpy (token->u.font.name, buf, sizeof(token->u.font.name) - 1);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mpsgen.c:1464:4: [0m[0;1;36mnote: [0mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11[0m
 1464 |           strncpy (token->u.font.name, buf, sizeof(token->u.font.name) - 1);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mpsgen.c:1467:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1467 |           if (strcmp (token->u.font.name, "default") == 0)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 1468 |             token->u.font.name[0] = '\0';[0m
 1469 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:1473:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1473 |                                     &token->u.font.encoding))[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1474 |                 FATAL ((stderr, _("malformed font spec for ^@font escape: %s"),[0m
 1475 |                         token->u.font.name));[0m
      | [0;1;32m                                             
[0m[1mpsgen.c:1474:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1474 |                 FATAL ((stderr, _("malformed font spec for ^@font escape: %s"),[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1474:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1474 |                 FATAL ((stderr, _("malformed font spec for ^@font escape: %s"),[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1474:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1474 |                 FATAL ((stderr, _("malformed font spec for ^@font escape: %s"),[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1474:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1474 |                 FATAL ((stderr, _("malformed font spec for ^@font escape: %s"),[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1477:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1477 |               memset  (token->u.font.name, 0, sizeof(token->u.font.name));[0m
      | [0;1;32m              ^~~~~~
[0m[1mpsgen.c:1477:8: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1477 |               memset  (token->u.font.name, 0, sizeof(token->u.font.name));[0m
      | [0;1;32m              ^~~~~~
[0m[1mpsgen.c:1478:8: [0m[0;1;35mwarning: [0m[1mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1478 |               strncpy (token->u.font.name, cp, sizeof(token->u.font.name) - 1);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mpsgen.c:1478:8: [0m[0;1;36mnote: [0mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11[0m
 1478 |               strncpy (token->u.font.name, cp, sizeof(token->u.font.name) - 1);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mpsgen.c:1491:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1491 |               if (escapes[e].escape == ESC_BGCOLOR)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 1492 |                 val = 1;[0m
      | [0;1;32m                        
[0m[1mpsgen.c:1502:14: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1502 |               got = sscanf (buf, "%g %g %g",[0m
      | [0;1;32m                    ^~~~~~
[0m[1mpsgen.c:1502:14: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
 1502 |               got = sscanf (buf, "%g %g %g",[0m
      | [0;1;32m                    ^~~~~~
[0m[1mpsgen.c:1510:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1510 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1510:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1510 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1510:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1510 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1510:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1510 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1515:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1515 |                   break;[0m
      | [0;1;32m                  ^    
[0m      | [0;32m                  {    ;} 
[0m[1mpsgen.c:1518:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1518 |                   token->u.color.g = token->u.color.b = token->u.color.r;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1519 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1523:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1523 |                   break;[0m
      | [0;1;32m                  ^    
[0m      | [0;32m                  {    ;} 
[0m[1mpsgen.c:1526:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1526 |           if (escapes[e].escape == ESC_COLOR)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1527 |             token->type = tCOLOR;[0m
 1528 |           else[0m
 1529 |             token->type = tBGCOLOR;[0m
 1530 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1526:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1526 |           if (escapes[e].escape == ESC_COLOR)[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                              {
[0m 1527 |             token->type = tCOLOR;[0m
 1528 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:1528:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1528 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1529 |             token->type = tBGCOLOR;[0m
      | [0;1;32m                                   
[0m[1mpsgen.c:1533:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1533 |           line_highlight_gray = atof (buf);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1534 |           if (line_highlight_gray < 0.0 || line_highlight_gray > 1.0)[0m
 1535 |             FATAL ((stderr, _("invalid value for ^@shade escape: %s"), buf));[0m
 1536 | [0m
 1537 |           token->type = tNONE;[0m
 1538 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1534:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1534 |           if (line_highlight_gray < 0.0 || line_highlight_gray > 1.0)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 1535 |             FATAL ((stderr, _("invalid value for ^@shade escape: %s"), buf));[0m
      | [0;1;32m                                                                             
[0m[1mpsgen.c:1535:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1535 |             FATAL ((stderr, _("invalid value for ^@shade escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1535:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1535 |             FATAL ((stderr, _("invalid value for ^@shade escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1535:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1535 |             FATAL ((stderr, _("invalid value for ^@shade escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1535:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1535 |             FATAL ((stderr, _("invalid value for ^@shade escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1541:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1541 |           bggray = atof (buf);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1542 |           if (bggray < 0.0 || bggray > 1.0)[0m
 1543 |             FATAL ((stderr, _("invalid value for ^@bggray escape: %s"), buf));[0m
 1544 | [0m
 1545 |           token->type = tNONE;[0m
 1546 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1542:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1542 |           if (bggray < 0.0 || bggray > 1.0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1543 |             FATAL ((stderr, _("invalid value for ^@bggray escape: %s"), buf));[0m
      | [0;1;32m                                                                              
[0m[1mpsgen.c:1543:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1543 |             FATAL ((stderr, _("invalid value for ^@bggray escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1543:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1543 |             FATAL ((stderr, _("invalid value for ^@bggray escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1543:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1543 |             FATAL ((stderr, _("invalid value for ^@bggray escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1543:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1543 |             FATAL ((stderr, _("invalid value for ^@bggray escape: %s"), buf));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:1549:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1549 |           if (strcmp (buf, "default") == 0)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1550 |             escape_char = default_escape_char;[0m
 1551 |           else[0m
 1552 |             escape_char = atoi (buf);[0m
 1553 |           token->type = tNONE;[0m
 1554 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1549:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1549 |           if (strcmp (buf, "default") == 0)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1550 |             escape_char = default_escape_char;[0m
 1551 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:1551:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1551 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1552 |             escape_char = atoi (buf);[0m
      | [0;1;32m                                     
[0m[1mpsgen.c:1557:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1557 |           memset  (token->u.filename, 0, sizeof(token->u.filename));[0m
      | [0;1;32m          ^~~~~~
[0m[1mpsgen.c:1557:4: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 1557 |           memset  (token->u.filename, 0, sizeof(token->u.filename));[0m
      | [0;1;32m          ^~~~~~
[0m[1mpsgen.c:1557:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1557 |           memset  (token->u.filename, 0, sizeof(token->u.filename));[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1558 |           strncpy (token->u.filename, buf, sizeof(token->u.filename) - 1);[0m
 1559 |           token->type = tSETFILENAME;[0m
 1560 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1558:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1558 |           strncpy (token->u.filename, buf, sizeof(token->u.filename) - 1);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mpsgen.c:1558:4: [0m[0;1;36mnote: [0mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11[0m
 1558 |           strncpy (token->u.filename, buf, sizeof(token->u.filename) - 1);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mpsgen.c:1563:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1563 |           token->u.i = atoi (buf);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1564 |           token->type = tSETPAGENUMBER;[0m
 1565 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1568:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1568 |           if (i == 0)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1569 |             token->u.i = 1;     /* The default is the first line. */[0m
 1570 |           else[0m
 1571 |             token->u.i = atoi (buf);[0m
 1572 |           token->type = tNEWPAGE;[0m
 1573 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1568:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1568 |           if (i == 0)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1569 |             token->u.i = 1;     /* The default is the first line. */[0m
 1570 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:1570:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1570 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1571 |             token->u.i = atoi (buf);[0m
      | [0;1;32m                                    
[0m[1mpsgen.c:1576:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1576 |           token->type = tSAVEX;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1577 |           token->u.i = atoi (buf);[0m
 1578 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1581:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1581 |           token->type = tLOADX;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1582 |           token->u.i = atoi (buf);[0m
 1583 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1586:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1586 |           token->u.str = xstrdup (buf);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1587 |           token->type = tPS;[0m
 1588 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1592:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1592 |           abort ();[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1593 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1629:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1629 |           if (BUFFER_EMPTY ())[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1630 |             {[0m
 1631 |               token->type = tEOF;[0m
 1632 |               return;[0m
 1633 |             }[0m
 1634 | [0m
 1635 |           done = DONE_DONE;[0m
 1636 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1672:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1672 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mpsgen.c:1675:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1675 |           if (font_is_fixed)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mpsgen.c:1680:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1680 |                   if (FITS_ON_LINE (' '))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1681 |                     EMIT (' ');[0m
 1682 |                   else[0m
      | [0;32m                  } 
[0m[1mpsgen.c:1699:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1699 |               if (linepos >= linew)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1700 |                 done = DONE_WRAP;[0m
 1701 |               else[0m
      | [0;32m              } 
[0m[1mpsgen.c:1701:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1701 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1702 |                 done = DONE_DONE;[0m
      | [0;1;32m                                 
[0m[1mpsgen.c:1707:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1707 |           if (BUFFER_EMPTY ())[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1708 |             {[0m
 1709 |               if (interpret_formfeed)[0m
 1710 |                 token->type = tFORMFEED;[0m
 1711 |               else[0m
 1712 |                 token->type = tNEWLINE;[0m
 1713 |               return;[0m
 1714 |             }[0m
 1715 |           else[0m
 1716 |             {[0m
 1717 |               is_ungetc (ch, is);[0m
 1718 |               done = DONE_DONE;[0m
 1719 |             }[0m
 1720 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:1709:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1709 |               if (interpret_formfeed)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1710 |                 token->type = tFORMFEED;[0m
 1711 |               else[0m
      | [0;32m              } 
[0m[1mpsgen.c:1711:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1711 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1712 |                 token->type = tNEWLINE;[0m
      | [0;1;32m                                       
[0m[1mpsgen.c:1724:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1724 |           if (special_escapes && ch == escape_char)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mpsgen.c:1730:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1730 |                   if (token->type != tNONE)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1731 |                     return;[0m
      | [0;1;32m                           
[0m[1mpsgen.c:1750:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1750 |               if (BUFFER_EMPTY () || !EXISTS (buffer[bufpos - 1]))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 1751 |                 linepos -= CHAR_WIDTH ('m');[0m
 1752 |               else[0m
      | [0;32m              } 
[0m[1mpsgen.c:1752:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1752 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1753 |                 linepos -= CHAR_WIDTH (buffer[bufpos - 1]);[0m
      | [0;1;32m                                                           
[0m[1mpsgen.c:1773:9: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1773 |                       sprintf (buf, "\\%03o", ch);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpsgen.c:1773:9: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1773 |                       sprintf (buf, "\\%03o", ch);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpsgen.c:1774:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1774 |                       for (i = 0; buf[i]; i++)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1775 |                         APPEND_CHAR (buf[i]);[0m
      | [0;1;32m                                             
[0m[1mpsgen.c:1787:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1787 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1788 |                     EMIT (ch);[0m
      | [0;1;32m                              
[0m[1mpsgen.c:1802:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1802 |                   if (missing_chars[ch]++ == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1803 |                     num_missing_chars++;[0m
      | [0;1;32m                                        
[0m[1mpsgen.c:1821:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1821 |               if (non_printable_chars[ch]++ == 0)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 1822 |                 num_non_printable_chars++;[0m
      | [0;1;32m                                          
[0m[1mpsgen.c:1827:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1827 |                   strcpy (buf, " ");[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1828 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1831:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1831 |                   strcpy (buf, "?");[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1832 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1835:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1835 |                   if (ch < 0x20)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1836 |                     {[0m
 1837 |                       buf[0] = '^';[0m
 1838 |                       buf[1] = '@' + ch;[0m
 1839 |                       buf[2] = '\0';[0m
 1840 |                       break;[0m
 1841 |                     }[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mpsgen.c:1845:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1845 |                   sprintf (buf, "\\%03o", ch);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mpsgen.c:1845:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1845 |                   sprintf (buf, "\\%03o", ch);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mpsgen.c:1845:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1845 |                   sprintf (buf, "\\%03o", ch);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1846 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mpsgen.c:1850:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1850 |               for (i = 0; buf[i]; i++)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1851 |                 len += CHAR_WIDTH (buf[i]);[0m
      | [0;1;32m                                           
[0m[1mpsgen.c:1858:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1858 |                       if (buf[i] == '\\')[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1859 |                         APPEND_CHAR ('\\'); /* Escape '\\' characters. */[0m
      | [0;1;32m                                                                         
[0m[1mpsgen.c:1883:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1883 |           while ((ch = is_getc (is)) != EOF && ch != nl)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1884 |             ;[0m
      | [0;1;32m             
[0m[1mpsgen.c:1893:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1893 |               while ((w = is_getc (is)) != EOF && ISSPACE (w))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 1894 |                 ;[0m
      | [0;1;32m                 
[0m[1mpsgen.c:1900:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1900 |               for (w = bufpos - 1; w >= 0 && !ISSPACE (buffer[w]); w--)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 1901 |                 ;[0m
      | [0;1;32m                 
[0m[1mpsgen.c:1953:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1953 |                                            tti++, ti++)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 1954 |                                         ;[0m
      | [0;1;32m                                         
[0m[1mpsgen.c:1956:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1956 |                                   else[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1957 |                                     /* Simple escape. */[0m
 1958 |                                     ti++;[0m
      | [0;1;32m                                         
[0m[1mpsgen.c:1979:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1979 |                           else[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1980 |                             /* Normal character. */[0m
 1981 |                             goto unemit_normal;[0m
      | [0;1;32m                                               
[0m[1mpsgen.c:2000:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2000 |               if (do_print)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2001 |                 num_truncated_lines++;[0m
      | [0;1;32m                                      
[0m[1mpsgen.c:2004:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2004 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2005 |             pending_token = tWRAPPED_NEWLINE;[0m
      | [0;1;32m                                             
[0m[1mpsgen.c:2007:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2007 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2008 |         pending_token = tEOF;[0m
      | [0;1;32m                             
[0m[1mpsgen.c:2049:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2049 |               OUTPUT ((cofp, "%%%%Page: (%d-%d) %d\n", current_pagenum,[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2049:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2049 |               OUTPUT ((cofp, "%%%%Page: (%d-%d) %d\n", current_pagenum,[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2049:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2049 |               OUTPUT ((cofp, "%%%%Page: (%d-%d) %d\n", current_pagenum,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2050 |                        current_pagenum + nup - 1, total_pages / nup + 1));[0m
 2051 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:2054:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2054 |               OUTPUT ((cofp, "%%%%Page: (%s:%3d-%3d) %d\n", ftail,[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2054:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2054 |               OUTPUT ((cofp, "%%%%Page: (%s:%3d-%3d) %d\n", ftail,[0m
      | [0;1;32m              ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2054:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2054 |               OUTPUT ((cofp, "%%%%Page: (%s:%3d-%3d) %d\n", ftail,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2055 |                        current_pagenum, current_pagenum + nup - 1,[0m
 2056 |                        total_pages / nup + 1));[0m
 2057 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:2061:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2061 |           OUTPUT ((cofp, "%%%%BeginPageSetup\n_S\n"));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2061:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2061 |           OUTPUT ((cofp, "%%%%BeginPageSetup\n_S\n"));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2063:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2063 |           if ((total_pages / nup + 1) % 2 == 0)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 2064 |             /* Two-side binding options for the even pages. */[0m
 2065 |             handle_two_side_options ();[0m
      | [0;1;32m                                       
[0m[1mpsgen.c:2078:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2078 |               if (nup_landscape)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 2079 |                 OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
 2080 |                          media->lly, -media->urx));[0m
 2081 |               else[0m
      | [0;32m              } 
[0m[1mpsgen.c:2079:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2079 |                 OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2079:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2079 |                 OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2081:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2081 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2082 |                 OUTPUT ((cofp, "%d %d translate\n", media->llx, media->lly));[0m
      | [0;1;32m                                                                             
[0m[1mpsgen.c:2082:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2082 |                 OUTPUT ((cofp, "%d %d translate\n", media->llx, media->lly));[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2082:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2082 |                 OUTPUT ((cofp, "%d %d translate\n", media->llx, media->lly));[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2086:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2086 |               if (nup_landscape)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 2087 |                 OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
 2088 |                          media->lly, -media->llx));[0m
 2089 |               else[0m
      | [0;32m              } 
[0m[1mpsgen.c:2087:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2087 |                 OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2087:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2087 |                 OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2089:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2089 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2090 |                 OUTPUT ((cofp, "%d %d translate\n", media->llx, media->ury));[0m
      | [0;1;32m                                                                             
[0m[1mpsgen.c:2090:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2090 |                 OUTPUT ((cofp, "%d %d translate\n", media->llx, media->ury));[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2090:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2090 |                 OUTPUT ((cofp, "%d %d translate\n", media->llx, media->ury));[0m
      | [0;1;32m                ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2099:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2099 |       OUTPUT ((cofp, "%sPage: (%d) %d\n", cstr, current_pagenum, total_pages));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2099:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2099 |       OUTPUT ((cofp, "%sPage: (%d) %d\n", cstr, current_pagenum, total_pages));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2099:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2099 |       OUTPUT ((cofp, "%sPage: (%d) %d\n", cstr, current_pagenum, total_pages));[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 2100 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:2103:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2103 |       OUTPUT ((cofp, "%sPage: (%s:%3d) %d\n", cstr, ftail, current_pagenum,[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2103:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2103 |       OUTPUT ((cofp, "%sPage: (%s:%3d) %d\n", cstr, ftail, current_pagenum,[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2103:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2103 |       OUTPUT ((cofp, "%sPage: (%s:%3d) %d\n", cstr, ftail, current_pagenum,[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 2104 |                total_pages));[0m
 2105 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mpsgen.c:200:3: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  200 |   do {                  \[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:2112:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2112 |   OUTPUT ((cofp, "%sBeginPageSetup\n_S\n", cstr));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2112:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2112 |   OUTPUT ((cofp, "%sBeginPageSetup\n_S\n", cstr));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2118:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2118 |       OUTPUT ((cofp, "%% N-up sub-page %d/%d\n", nup_subpage + 1, nup));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2118:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2118 |       OUTPUT ((cofp, "%% N-up sub-page %d/%d\n", nup_subpage + 1, nup));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2132:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2132 |           OUTPUT ((cofp, "%d %d translate\n",[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2132:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2132 |           OUTPUT ((cofp, "%d %d translate\n",[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2149:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2149 |           OUTPUT ((cofp, "%d %d translate\n",[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2149:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2149 |           OUTPUT ((cofp, "%d %d translate\n",[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2153:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2153 |       OUTPUT ((cofp, "%g dup scale\n", nup_scale));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2153:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2153 |       OUTPUT ((cofp, "%g dup scale\n", nup_scale));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2156:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2156 |       if (landscape)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2157 |         OUTPUT ((cofp, "90 rotate\n%d %d translate\n", 0, -d_page_h));[0m
      | [0;1;32m                                                                      
[0m[1mpsgen.c:2157:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2157 |         OUTPUT ((cofp, "90 rotate\n%d %d translate\n", 0, -d_page_h));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2157:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2157 |         OUTPUT ((cofp, "90 rotate\n%d %d translate\n", 0, -d_page_h));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2163:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2163 |       if (total_pages % 2 == 0)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 2164 |         /* Two-side binding options for the even pages. */[0m
 2165 |         handle_two_side_options ();[0m
      | [0;1;32m                                   
[0m[1mpsgen.c:2167:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2167 |       if (landscape)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2168 |         OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
 2169 |                  media->lly, -media->urx));[0m
 2170 |       else[0m
      | [0;32m      } 
[0m[1mpsgen.c:2168:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2168 |         OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2168:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2168 |         OUTPUT ((cofp, "90 rotate\n%d %d translate\n",[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2170:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2170 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2171 |         OUTPUT ((cofp, "%d %d translate\n", media->llx, media->lly));[0m
      | [0;1;32m                                                                     
[0m[1mpsgen.c:2171:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2171 |         OUTPUT ((cofp, "%d %d translate\n", media->llx, media->lly));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2171:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2171 |         OUTPUT ((cofp, "%d %d translate\n", media->llx, media->lly));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2175:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2175 |   OUTPUT ((cofp, "/pagenum %d def\n", current_pagenum));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2175:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2175 |   OUTPUT ((cofp, "/pagenum %d def\n", current_pagenum));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2178:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2178 |   OUTPUT ((cofp, "/fname (%s) def\n", cp));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2178:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2178 |   OUTPUT ((cofp, "/fname (%s) def\n", cp));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2182:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2182 |   OUTPUT ((cofp, "/fdir (%s) def\n", cp));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2182:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2182 |   OUTPUT ((cofp, "/fdir (%s) def\n", cp));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2187:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2187 |   OUTPUT ((cofp, "/ftail (%s) def\n", cp));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2187:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2187 |   OUTPUT ((cofp, "/ftail (%s) def\n", cp));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2194:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2194 |       if (encoding == default_Fencoding)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2195 |         OUTPUT ((cofp, "/%s %g %g SUF\n", Fname, Fpt.w, Fpt.h));[0m
 2196 |       else[0m
      | [0;32m      } 
[0m[1mpsgen.c:2195:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2195 |         OUTPUT ((cofp, "/%s %g %g SUF\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2195:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2195 |         OUTPUT ((cofp, "/%s %g %g SUF\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2196:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2196 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2197 |         /* This must be the case. */[0m
 2198 |         OUTPUT ((cofp, "/%s %g %g SUF_PS\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m                                                                   
[0m[1mpsgen.c:2198:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2198 |         OUTPUT ((cofp, "/%s %g %g SUF_PS\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2198:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2198 |         OUTPUT ((cofp, "/%s %g %g SUF_PS\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2204:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2204 |       OUTPUT ((cofp, "%% User defined strings:\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2204:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2204 |       OUTPUT ((cofp, "%% User defined strings:\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2210:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2210 |           OUTPUT ((cofp, "/%s (%s) def\n", cp, cp2));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2210:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2210 |           OUTPUT ((cofp, "/%s (%s) def\n", cp, cp2));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2237:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2237 |       OUTPUT ((cofp, "/user_header_p true def\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2237:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2237 |       OUTPUT ((cofp, "/user_header_p true def\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2238:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2238 |       OUTPUT ((cofp, "/user_header_left_str (%s) def\n", h_left));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2238:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2238 |       OUTPUT ((cofp, "/user_header_left_str (%s) def\n", h_left));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2239:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2239 |       OUTPUT ((cofp, "/user_header_center_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2239:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2239 |       OUTPUT ((cofp, "/user_header_center_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2241:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2241 |       OUTPUT ((cofp, "/user_header_right_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2241:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2241 |       OUTPUT ((cofp, "/user_header_right_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2245:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2245 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 2246 |     OUTPUT ((cofp, "/user_header_p false def\n"));[0m
      | [0;1;32m                                                  
[0m[1mpsgen.c:2246:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2246 |     OUTPUT ((cofp, "/user_header_p false def\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2246:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2246 |     OUTPUT ((cofp, "/user_header_p false def\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2270:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2270 |       OUTPUT ((cofp, "/user_footer_p true def\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2270:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2270 |       OUTPUT ((cofp, "/user_footer_p true def\n"));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2271:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2271 |       OUTPUT ((cofp, "/user_footer_left_str (%s) def\n", f_left));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2271:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2271 |       OUTPUT ((cofp, "/user_footer_left_str (%s) def\n", f_left));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2272:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2272 |       OUTPUT ((cofp, "/user_footer_center_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2272:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2272 |       OUTPUT ((cofp, "/user_footer_center_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2274:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2274 |       OUTPUT ((cofp, "/user_footer_right_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2274:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2274 |       OUTPUT ((cofp, "/user_footer_right_str (%s) def\n",[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2278:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2278 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 2279 |     OUTPUT ((cofp, "/user_footer_p false def\n"));[0m
      | [0;1;32m                                                  
[0m[1mpsgen.c:2279:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2279 |     OUTPUT ((cofp, "/user_footer_p false def\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2279:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2279 |     OUTPUT ((cofp, "/user_footer_p false def\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2281:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2281 |   OUTPUT ((cofp, "%%%%EndPageSetup\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2281:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2281 |   OUTPUT ((cofp, "%%%%EndPageSetup\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2290:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2290 |       if (highlight_bars)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 2291 |         OUTPUT ((cofp, "%d %f %d %f highlight_bars\n", highlight_bars,[0m
 2292 |                  LINESKIP, d_output_y_margin, highlight_bar_gray));[0m
      | [0;1;32m                                                                   
[0m[1mpsgen.c:2291:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2291 |         OUTPUT ((cofp, "%d %f %d %f highlight_bars\n", highlight_bars,[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2291:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2291 |         OUTPUT ((cofp, "%d %f %d %f highlight_bars\n", highlight_bars,[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2297:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2297 |           if (ul_position_p || ul_angle_p)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 2298 |             OUTPUT ((cofp, "user_underlay\n"));[0m
 2299 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:2298:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2298 |             OUTPUT ((cofp, "user_underlay\n"));[0m
      | [0;1;32m            ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2298:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2298 |             OUTPUT ((cofp, "user_underlay\n"));[0m
      | [0;1;32m            ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2299:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2299 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2300 |             OUTPUT ((cofp, "underlay\n"));[0m
      | [0;1;32m                                          
[0m[1mpsgen.c:2300:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2300 |             OUTPUT ((cofp, "underlay\n"));[0m
      | [0;1;32m            ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2300:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2300 |             OUTPUT ((cofp, "underlay\n"));[0m
      | [0;1;32m            ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2304:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2304 |       if (num_columns > 1 && (header == HDR_FANCY || borders))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 2305 |         OUTPUT ((cofp, "column_lines\n"));[0m
      | [0;1;32m                                          
[0m[1mpsgen.c:2305:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2305 |         OUTPUT ((cofp, "column_lines\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2305:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2305 |         OUTPUT ((cofp, "column_lines\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2308:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2308 |       if (borders)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2309 |         OUTPUT ((cofp, "column_borders\n"));[0m
      | [0;1;32m                                            
[0m[1mpsgen.c:2309:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2309 |         OUTPUT ((cofp, "column_borders\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2309:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2309 |         OUTPUT ((cofp, "column_borders\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2315:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2315 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mpsgen.c:2319:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2319 |           OUTPUT ((cofp, "do_header\n"));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2319:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2319 |           OUTPUT ((cofp, "do_header\n"));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2320:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2320 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mpsgen.c:2325:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2325 |   if (user_colorp)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2326 |     OUTPUT ((cofp, "%g %g %g setrgbcolor\n", user_color.r, user_color.g,[0m
 2327 |              user_color.b));[0m
      | [0;1;32m                            
[0m[1mpsgen.c:2326:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2326 |     OUTPUT ((cofp, "%g %g %g setrgbcolor\n", user_color.r, user_color.g,[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2326:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2326 |     OUTPUT ((cofp, "%g %g %g setrgbcolor\n", user_color.r, user_color.g,[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2336:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2336 |   OUTPUT ((cofp, "_R\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2336:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2336 |   OUTPUT ((cofp, "_R\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2340:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2340 |       if (nup_subpage + 1 == nup)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2341 |         /* Real end of page. */[0m
 2342 |         OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m                                   
[0m[1mpsgen.c:2342:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2342 |         OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2342:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2342 |         OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2344:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2344 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 2345 |     OUTPUT ((cofp, "S\n"));[0m
      | [0;1;32m                           
[0m[1mpsgen.c:2345:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2345 |     OUTPUT ((cofp, "S\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2345:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2345 |     OUTPUT ((cofp, "S\n"));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2360:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2360 |           OUTPUT ((cofp, "_R\n"));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2360:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2360 |           OUTPUT ((cofp, "_R\n"));[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2362:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2362 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2363 |         OUTPUT ((cofp, "%%Page: (-) %d\n", total_pages));[0m
      | [0;1;32m                                                         
[0m[1mpsgen.c:2363:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2363 |         OUTPUT ((cofp, "%%Page: (-) %d\n", total_pages));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2363:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2363 |         OUTPUT ((cofp, "%%Page: (-) %d\n", total_pages));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2365:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2365 |       if (nup_subpage + 1 == nup)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2366 |         /* This is the last page on this sheet, dump us. */[0m
 2367 |         OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m                                   
[0m[1mpsgen.c:2367:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2367 |         OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2367:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2367 |         OUTPUT ((cofp, "_R\nS\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2369:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2369 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 2370 |     OUTPUT ((cofp, "%%%%Page: (-) %d\nS\n", total_pages));[0m
      | [0;1;32m                                                          
[0m[1mpsgen.c:2370:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2370 |     OUTPUT ((cofp, "%%%%Page: (-) %d\nS\n", total_pages));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2370:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2370 |     OUTPUT ((cofp, "%%%%Page: (-) %d\nS\n", total_pages));[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2384:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2384 |   MESSAGE (2, (stderr, "^@epsf=\"%s\"\n", token->u.epsf.filename));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2384:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2384 |   MESSAGE (2, (stderr, "^@epsf=\"%s\"\n", token->u.epsf.filename));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2386:3: [0m[0;1;35mwarning: [0m[1mValue stored to 'i' is never read [clang-analyzer-deadcode.DeadStores][0m
 2386 |   i = strlen (token->u.epsf.filename);[0m
      | [0;1;32m  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpsgen.c:2386:3: [0m[0;1;36mnote: [0mValue stored to 'i' is never read[0m
 2386 |   i = strlen (token->u.epsf.filename);[0m
      | [0;1;32m  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mpsgen.c:2405:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2405 |           if (pathwalk (libpath, file_lookup, &ctx))[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2406 |             token->u.epsf.fp = fopen (buffer_ptr (ctx.fullname), "rb");[0m
      | [0;1;32m                                                                       
[0m[1mpsgen.c:2412:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2412 |           MESSAGE (0, (stderr, _("couldn't open EPS file \"%s\": %s\n"),[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2412:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2412 |           MESSAGE (0, (stderr, _("couldn't open EPS file \"%s\": %s\n"),[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2438:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2438 |       memcpy (token->u.epsf.skipbuf + token->u.epsf.skipbuf_pos, buf, i);[0m
      | [0;1;32m      ^~~~~~
[0m[1mpsgen.c:2438:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2438 |       memcpy (token->u.epsf.skipbuf + token->u.epsf.skipbuf_pos, buf, i);[0m
      | [0;1;32m      ^~~~~~
[0m[1mpsgen.c:2446:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2446 |               MESSAGE (0,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2446:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2446 |               MESSAGE (0,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2458:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2458 |           i = sscanf (buf + strlen (BB_DSC), "%f %f %f %f",[0m
      | [0;1;32m              ^~~~~~
[0m[1mpsgen.c:2458:8: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
 2458 |           i = sscanf (buf + strlen (BB_DSC), "%f %f %f %f",[0m
      | [0;1;32m              ^~~~~~
[0m[1mpsgen.c:2467:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2467 |                    i++)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2468 |                 ;[0m
      | [0;1;32m                 
[0m[1mpsgen.c:2473:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2473 |                   MESSAGE (0, (stderr, _("EPS file \"%s\" contains malformed \[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2473:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2473 |                   MESSAGE (0, (stderr, _("EPS file \"%s\" contains malformed \[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2474:27: [0m[0;1;35mwarning: [0m[1mfield precision should have type 'int', but argument has type 'unsigned long' [clang-diagnostic-format][0m
 2474 | %%%%BoundingBox row:\n\"%.*s\"\n"),[0m
      | [0;1;32m                          ^
[0m[1m./gsint.h:107:28: [0m[0;1;36mnote: [0mexpanded from macro '_'[0m
  107 | #define _(String) gettext (String)[0m
      | [0;1;32m                           ^~~~~~
[0m[1m/usr/include/libintl.h:109:41: [0m[0;1;36mnote: [0mexpanded from macro 'gettext'[0m
  109 | # define gettext(msgid) dgettext (NULL, msgid)[0m
      | [0;1;32m                                        ^~~~~
[0m[1m/usr/include/libintl.h:112:26: [0m[0;1;36mnote: [0mexpanded from macro 'dgettext'[0m
  112 |   dcgettext (domainname, msgid, LC_MESSAGES)[0m
      | [0;1;32m                         ^~~~~
[0m[1m./gsint.h:501:15: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m              ^~~~
[0m[1mpsgen.c:2498:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2498 |       MESSAGE (0, (stderr, _("EPS file \"%s\" is not a valid EPS file\n"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2498:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2498 |       MESSAGE (0, (stderr, _("EPS file \"%s\" is not a valid EPS file\n"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2500:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2500 |       if (token->u.epsf.pipe)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2501 |         pclose (token->u.epsf.fp);[0m
 2502 |       else[0m
      | [0;32m      } 
[0m[1mpsgen.c:2502:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2502 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 2503 |         fclose (token->u.epsf.fp);[0m
      | [0;1;32m                                  
[0m[1mpsgen.c:2508:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2508 |   MESSAGE (2, (stderr, "BoundingBox: %d %d %d %d\n",[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2508:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2508 |   MESSAGE (2, (stderr, "BoundingBox: %d %d %d %d\n",[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2523:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2523 |   OUTPUT ((cofp, "BeginEPSF\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2523:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2523 |   OUTPUT ((cofp, "BeginEPSF\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2524:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2524 |   OUTPUT ((cofp, "%g %g translate\n", token->new_x, token->new_y));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2524:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2524 |   OUTPUT ((cofp, "%g %g translate\n", token->new_x, token->new_y));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2525:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2525 |   OUTPUT ((cofp, "%g %g scale\n", token->u.epsf.xscale, token->u.epsf.yscale));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2525:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2525 |   OUTPUT ((cofp, "%g %g scale\n", token->u.epsf.xscale, token->u.epsf.yscale));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2526:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2526 |   OUTPUT ((cofp, "%d %d translate\n", -token->u.epsf.llx,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2526:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2526 |   OUTPUT ((cofp, "%d %d translate\n", -token->u.epsf.llx,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2528:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2528 |   OUTPUT ((cofp, "%d %d %d %d Box clip newpath\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2528:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2528 |   OUTPUT ((cofp, "%d %d %d %d Box clip newpath\n",[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2533:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2533 |   OUTPUT ((cofp, "%%%%BeginDocument: %s%s\n", token->u.epsf.filename,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2533:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2533 |   OUTPUT ((cofp, "%%%%BeginDocument: %s%s\n", token->u.epsf.filename,[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2542:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2542 |       while ((i = fread (buf, 1, sizeof (buf), token->u.epsf.fp)) != 0)[0m
      | [0;1;32m                                                                       ^
[0m      | [0;32m                                                                        {
[0m 2543 |         fwrite (buf, 1, i, cofp);[0m
      | [0;1;32m                                 
[0m[1mpsgen.c:2547:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2547 |   OUTPUT ((cofp, "\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2547:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2547 |   OUTPUT ((cofp, "\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2550:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2550 |   OUTPUT ((cofp, "%%%%EndDocument\nEndEPSF\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2550:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2550 |   OUTPUT ((cofp, "%%%%EndDocument\nEndEPSF\n"));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2553:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2553 |   if (token->u.epsf.pipe)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 2554 |     pclose (token->u.epsf.fp);[0m
 2555 |   else[0m
      | [0;32m  } 
[0m[1mpsgen.c:2555:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2555 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 2556 |     fclose (token->u.epsf.fp);[0m
      | [0;1;32m                              
[0m[1mpsgen.c:2571:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2571 |        i++)[0m
      | [0;1;32m           ^
[0m      | [0;32m            {
[0m 2572 |     buf[i] = ch;[0m
      | [0;1;32m                
[0m[1mpsgen.c:2574:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2574 |   if (ch != EOF)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 2575 |     is_ungetc (ch, is);[0m
      | [0;1;32m                       
[0m[1mpsgen.c:2586:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2586 |           val *= 72 / 2.54;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2587 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:2590:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2590 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mpsgen.c:2593:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2593 |           val *= 72;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2594 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:2597:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2597 |           is_ungetc (ch, is);[0m
      | [0;1;32m          ^                 
[0m      | [0;32m          {                 ;} 
[0m[1mpsgen.c:2601:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2601 |           if (horizontal)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2602 |             val *= CHAR_WIDTH ('m');[0m
 2603 |           else[0m
 2604 |             val *= LINESKIP;[0m
 2605 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mpsgen.c:2601:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2601 |           if (horizontal)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 2602 |             val *= CHAR_WIDTH ('m');[0m
 2603 |           else[0m
      | [0;32m          } 
[0m[1mpsgen.c:2603:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2603 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2604 |             val *= LINESKIP;[0m
      | [0;1;32m                            
[0m[1mpsgen.c:2614:8: [0m[0;1;35mwarning: [0m[1mExcessive padding in 'struct (unnamed at psgen.c:2614:8)' (8 padding bytes, where 0 is optimal). Optimal fields order: magic, name, magiclen, revert_delta, consider reordering the fields or adding explicit padding members [clang-analyzer-optin.performance.Padding][0m
 2614 | static struct[0m
      | [0;1;32m       ^~~~~~
[0m 2615 | {[0m
      | [0;1;32m~
[0m 2616 |   char *magic;[0m
      | [0;1;32m  ~~~~~~~~~~~~
[0m 2617 |   unsigned int magiclen;[0m
      | [0;1;32m  ~~~~~~~~~~~~~~~~~~~~~~
[0m 2618 |   char *name;[0m
      | [0;1;32m  ~~~~~~~~~~~
[0m 2619 |   int revert_delta;[0m
      | [0;1;32m  ~~~~~~~~~~~~~~~~~
[0m 2620 | } pass_through_magics[] =[0m
      | [0;1;32m~
[0m[1mpsgen.c:2614:8: [0m[0;1;36mnote: [0mExcessive padding in 'struct (unnamed at psgen.c:2614:8)' (8 padding bytes, where 0 is optimal). Optimal fields order: magic, name, magiclen, revert_delta, consider reordering the fields or adding explicit padding members[0m
 2614 | static struct[0m
      | [0;1;32m       ^~~~~~
[0m 2615 | {[0m
      | [0;1;32m~
[0m 2616 |   char *magic;[0m
      | [0;1;32m  ~~~~~~~~~~~~
[0m 2617 |   unsigned int magiclen;[0m
      | [0;1;32m  ~~~~~~~~~~~~~~~~~~~~~~
[0m 2618 |   char *name;[0m
      | [0;1;32m  ~~~~~~~~~~~
[0m 2619 |   int revert_delta;[0m
      | [0;1;32m  ~~~~~~~~~~~~~~~~~
[0m 2620 | } pass_through_magics[] =[0m
      | [0;1;32m~
[0m[1mpsgen.c:2637:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2637 |   if (output_language_pass_through)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 2638 |     MESSAGE (1,[0m
 2639 |              (stderr,[0m
 2640 |               _("passing through all input files for output language `%s'\n"),[0m
 2641 |               output_language));[0m
 2642 |   else[0m
      | [0;32m  } 
[0m[1mpsgen.c:2638:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2638 |     MESSAGE (1,[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2638:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2638 |     MESSAGE (1,[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2654:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2654 |                   || ch != (unsigned char) pass_through_magics[i].magic[j])[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 2655 |                 break;[0m
      | [0;1;32m                      
[0m[1mpsgen.c:2658:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2658 |           if (j >= pass_through_magics[i].magiclen)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 2659 |             /* The <i>th one matched. */[0m
 2660 |             break;[0m
      | [0;1;32m                  
[0m[1mpsgen.c:2670:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2670 |       if (pass_through_magics[i].magic == NULL)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 2671 |         /* No we didn't. */[0m
 2672 |         return 0;[0m
      | [0;1;32m                 
[0m[1mpsgen.c:2687:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2687 |           OUTPUT ((cofp,[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2687:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2687 |           OUTPUT ((cofp,[0m
      | [0;1;32m          ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2692:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2692 |       MESSAGE (1, (stderr, _("passing through %s file \"%s\"\n"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2692:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2692 |       MESSAGE (1, (stderr, _("passing through %s file \"%s\"\n"),[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2711:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2711 |       if (ps_header_dumped)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2712 |         /*[0m
 2713 |          * XXX How to end a PCL file mixed between ASCII files?[0m
 2714 |          */[0m
 2715 |         OUTPUT ((cofp, "%%%%EndDocument\n_R\n"));[0m
      | [0;1;32m                                                 
[0m[1mpsgen.c:2715:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2715 |         OUTPUT ((cofp, "%%%%EndDocument\n_R\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2715:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2715 |         OUTPUT ((cofp, "%%%%EndDocument\n_R\n"));[0m
      | [0;1;32m        ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2737:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2737 |   if (linenum == print_line_number_last)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2738 |     return;[0m
      | [0;1;32m           
[0m[1mpsgen.c:2754:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2754 |       OUTPUT ((cofp, "/F-gs-font %g %g SF\n", Fpt.w, Fpt.h));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2754:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2754 |       OUTPUT ((cofp, "/F-gs-font %g %g SF\n", Fpt.w, Fpt.h));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2759:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2759 |   sprintf (buf, "%d", linenum);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mpsgen.c:2759:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 2759 |   sprintf (buf, "%d", linenum);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mpsgen.c:2760:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2760 |   for (i = 0; buf[i]; i++)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2761 |     len += CHAR_WIDTH (buf[i]);[0m
      | [0;1;32m                               
[0m[1mpsgen.c:2764:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2764 |   OUTPUT ((cofp, "%g %g M (%s:) s\n", x + space - len, y, buf));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2764:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2764 |   OUTPUT ((cofp, "%g %g M (%s:) s\n", x + space - len, y, buf));[0m
      | [0;1;32m  ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2774:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2774 |       OUTPUT ((cofp, "/%s %g %g SUF\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2774:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2774 |       OUTPUT ((cofp, "/%s %g %g SUF\n", Fname, Fpt.w, Fpt.h));[0m
      | [0;1;32m      ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2794:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2794 |   if (divertfp == NULL)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 2795 |     FATAL ((stderr, _("couldn't create temporary divert file: %s"),[0m
 2796 |             strerror (errno)));[0m
      | [0;1;32m                               
[0m[1mpsgen.c:2795:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2795 |     FATAL ((stderr, _("couldn't create temporary divert file: %s"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2795:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2795 |     FATAL ((stderr, _("couldn't create temporary divert file: %s"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2795:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2795 |     FATAL ((stderr, _("couldn't create temporary divert file: %s"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2795:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2795 |     FATAL ((stderr, _("couldn't create temporary divert file: %s"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2811:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2811 |   if (fseek (divertfp, 0, SEEK_SET) != 0)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2812 |     FATAL ((stderr, _("couldn't rewind divert file: %s"), strerror (errno)));[0m
      | [0;1;32m                                                                             
[0m[1mpsgen.c:2812:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2812 |     FATAL ((stderr, _("couldn't rewind divert file: %s"), strerror (errno)));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2812:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2812 |     FATAL ((stderr, _("couldn't rewind divert file: %s"), strerror (errno)));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2812:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2812 |     FATAL ((stderr, _("couldn't rewind divert file: %s"), strerror (errno)));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2812:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2812 |     FATAL ((stderr, _("couldn't rewind divert file: %s"), strerror (errno)));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mpsgen.c:2816:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2816 |       if (strncmp (buf, "%%BeginDocument", 15) == 0)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2817 |         doc_level++;[0m
 2818 |       else if (strncmp (buf, "%%EndDocument", 13) == 0)[0m
      | [0;32m      } 
[0m[1mpsgen.c:2818:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2818 |       else if (strncmp (buf, "%%EndDocument", 13) == 0)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2819 |         doc_level--;[0m
      | [0;1;32m                    
[0m[1mpsgen.c:2828:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2828 |                   if (strncmp (buf, "%%EndPageSetup", 14) == 0)[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 2829 |                     break;[0m
      | [0;1;32m                          
[0m[1mpsgen.c:2837:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2837 |                       fprintf (ofp, "%d", total_pages_in_file);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpsgen.c:2837:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2837 |                       fprintf (ofp, "%d", total_pages_in_file);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mpsgen.c:2840:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2840 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2841 |                     fputs (buf, ofp);[0m
      | [0;1;32m                                     
[0m[1mpsgen.c:2859:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2859 |   if (rotate_even_pages)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2860 |     /* Rotate page 180 degrees. */[0m
 2861 |     OUTPUT ((cofp, "180 rotate\n%d %d translate\n",[0m
 2862 |              -media->w, -media->h));[0m
      | [0;1;32m                                    
[0m[1mpsgen.c:2861:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2861 |     OUTPUT ((cofp, "180 rotate\n%d %d translate\n",[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2861:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2861 |     OUTPUT ((cofp, "180 rotate\n%d %d translate\n",[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2864:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2864 |   if (swap_even_page_margins)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 2865 |     OUTPUT ((cofp, "%d 0 translate\n",[0m
 2866 |              -(media->llx - (media->w - media->urx))));[0m
      | [0;1;32m                                                       
[0m[1mpsgen.c:2865:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2865 |     OUTPUT ((cofp, "%d 0 translate\n",[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mpsgen.c:2865:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 2865 |     OUTPUT ((cofp, "%d 0 translate\n",[0m
      | [0;1;32m    ^
[0m[1mpsgen.c:204:7: [0m[0;1;36mnote: [0mexpanded from macro 'OUTPUT'[0m
  204 |       fprintf body;     \[0m
      | [0;1;32m      ^~~~~~~
[0m474 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[31/33][216.8s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpptq1l_5g.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/states/prims.c
[1mprims.c:92:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
   92 | match_arg (prim_name, type, argp, env, filename, linenum)[0m
      | [0;1;32m^
[0m[1mprims.c:103:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  103 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:103:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  103 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:107:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  107 |       fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:107:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  107 |       fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:118:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  118 | DEFUN (prim_call)[0m
      | [0;1;32m       ^
[0m[1mprims.c:127:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  127 |       fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:127:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  127 |       fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:134:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  134 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:134:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  134 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:139:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  139 | DEFUN (prim_calln)[0m
      | [0;1;32m       ^
[0m[1mprims.c:146:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  146 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:146:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  146 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:149:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  149 |   memcpy (cp, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:149:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  149 |   memcpy (cp, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:160:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  160 | DEFUN (prim_check_namerules)[0m
      | [0;1;32m       ^
[0m[1mprims.c:167:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  167 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:167:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  167 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:169:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  169 |   if (start_state)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  170 |     goto return_false;[0m
      | [0;1;32m                      
[0m[1mprims.c:200:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  200 | DEFUN (prim_check_startrules)[0m
      | [0;1;32m       ^
[0m[1mprims.c:207:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  207 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:207:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  207 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:209:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  209 |   if (start_state)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  210 |     goto return_false;[0m
      | [0;1;32m                      
[0m[1mprims.c:240:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  240 | DEFUN (prim_concat)[0m
      | [0;1;32m       ^
[0m[1mprims.c:247:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  247 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:247:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  247 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:253:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  253 |           fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:253:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  253 |           fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:261:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  261 |           memcpy (data + len, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m          ^~~~~~
[0m[1mprims.c:261:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  261 |           memcpy (data + len, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m          ^~~~~~
[0m[1mprims.c:275:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  275 | DEFUN (prim_float)[0m
      | [0;1;32m       ^
[0m[1mprims.c:282:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  282 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:282:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  282 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:292:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  292 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mprims.c:295:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  295 |       r->u.real = (double) n->u.array.len;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  296 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:299:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  299 |       if (n->u.str.len > sizeof (buf) - 1)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  300 |         r->u.real = 0.0;[0m
  301 |       else[0m
  302 |         {[0m
  303 |           memcpy (buf, n->u.str.data, n->u.str.len);[0m
  304 |           buf[n->u.str.len] = '\0';[0m
  305 |           r->u.real = atof (buf);[0m
  306 |         }[0m
  307 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:299:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  299 |       if (n->u.str.len > sizeof (buf) - 1)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  300 |         r->u.real = 0.0;[0m
  301 |       else[0m
      | [0;32m      } 
[0m[1mprims.c:303:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  303 |           memcpy (buf, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m          ^~~~~~
[0m[1mprims.c:303:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  303 |           memcpy (buf, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m          ^~~~~~
[0m[1mprims.c:310:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  310 |       r->u.real = (double) n->u.integer;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  311 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:314:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  314 |       r->u.real = n->u.real;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  315 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:323:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  323 | DEFUN (prim_getenv)[0m
      | [0;1;32m       ^
[0m[1mprims.c:331:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  331 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:331:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  331 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:334:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  334 |   memcpy (key, var->u.str.data, var->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:334:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  334 |   memcpy (key, var->u.str.data, var->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:357:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  357 | DEFUN (prim_int)[0m
      | [0;1;32m       ^
[0m[1mprims.c:364:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  364 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:364:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  364 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:374:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  374 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mprims.c:377:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  377 |       r->u.integer = n->u.array.len;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  378 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:381:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  381 |       if (n->u.str.len > sizeof (buf) - 1)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  382 |         r->u.integer = 0;[0m
  383 |       else[0m
  384 |         {[0m
  385 |           memcpy (buf, n->u.str.data, n->u.str.len);[0m
  386 |           buf[n->u.str.len] = '\0';[0m
  387 |           r->u.integer = atoi (buf);[0m
  388 |         }[0m
  389 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:381:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  381 |       if (n->u.str.len > sizeof (buf) - 1)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  382 |         r->u.integer = 0;[0m
  383 |       else[0m
      | [0;32m      } 
[0m[1mprims.c:385:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  385 |           memcpy (buf, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m          ^~~~~~
[0m[1mprims.c:385:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  385 |           memcpy (buf, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m          ^~~~~~
[0m[1mprims.c:392:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  392 |       r->u.integer = n->u.integer;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  393 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:396:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  396 |       r->u.integer = (int) n->u.real;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  397 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:405:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  405 | DEFUN (prim_length)[0m
      | [0;1;32m       ^
[0m[1mprims.c:411:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  411 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:411:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  411 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:418:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  418 |           result += n->u.str.len;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  419 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mprims.c:422:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  422 |           result += n->u.array.len;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  423 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mprims.c:426:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  426 |           fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:426:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  426 |           fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:426:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  426 |           fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m  427 |                    filename, linenum, prim_name);[0m
  428 |           exit (1);[0m
  429 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mprims.c:441:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  441 | DEFUN (prim_list)[0m
      | [0;1;32m       ^
[0m[1mprims.c:448:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  448 |   for (len = 0; arg; len++, arg = arg->next)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  449 |     ;[0m
      | [0;1;32m     
[0m[1mprims.c:459:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  459 |   for (len = 0; arg; len++, arg = arg->next)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  460 |     n->u.array.array[len] = eval_expr ((Expr *) arg->data, env);[0m
      | [0;1;32m                                                                
[0m[1mprims.c:466:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  466 | DEFUN (prim_panic)[0m
      | [0;1;32m       ^
[0m[1mprims.c:468:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  468 |   fprintf (stderr, _("%s: panic: "), program);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mprims.c:468:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  468 |   fprintf (stderr, _("%s: panic: "), program);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mprims.c:471:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  471 |   fprintf (stderr, "\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mprims.c:471:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  471 |   fprintf (stderr, "\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mprims.c:479:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  479 | DEFUN (prim_prereq)[0m
      | [0;1;32m       ^
[0m[1mprims.c:489:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  489 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:489:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  489 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:492:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  492 |   sscanf (VERSION, "%d.%d.%d", &over[0], &over[1], &over[2]);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:492:3: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
  492 |   sscanf (VERSION, "%d.%d.%d", &over[0], &over[1], &over[2]);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:497:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  497 |   memcpy (cp, s->u.str.data, s->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:497:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  497 |   memcpy (cp, s->u.str.data, s->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:499:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  499 |   if (sscanf (cp, "%d.%d.%d", &rver[0], &rver[1], &rver[2]) != 3)[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:499:7: [0m[0;1;36mnote: [0mCall to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11[0m
  499 |   if (sscanf (cp, "%d.%d.%d", &rver[0], &rver[1], &rver[2]) != 3)[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:501:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  501 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:501:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  501 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:510:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  510 |       if (over[i] > rver[i])[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  511 |         /* Ok, our version is bigger. */[0m
  512 |         break;[0m
      | [0;1;32m              
[0m[1mprims.c:516:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  516 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:516:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  516 |           fprintf (stderr,[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:531:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  531 | print_node (n)[0m
      | [0;1;32m^
[0m[1mprims.c:539:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  539 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mprims.c:542:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  542 |       fwrite (n->u.str.data, n->u.str.len, 1, ofp);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  543 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:546:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  546 |       fputc ('/', ofp);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  547 |       fwrite (n->u.re.data, n->u.re.len, 1, ofp);[0m
  548 |       fputc ('/', ofp);[0m
  549 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:552:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  552 |       fprintf (ofp, "%d", n->u.integer);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:552:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  552 |       fprintf (ofp, "%d", n->u.integer);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:552:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  552 |       fprintf (ofp, "%d", n->u.integer);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  553 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:556:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  556 |       fprintf (ofp, "%f", n->u.real);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:556:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  556 |       fprintf (ofp, "%f", n->u.real);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:556:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  556 |       fprintf (ofp, "%f", n->u.real);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  557 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:560:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  560 |       fprintf (ofp, "%s", n->u.sym);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:560:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  560 |       fprintf (ofp, "%s", n->u.sym);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:560:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  560 |       fprintf (ofp, "%s", n->u.sym);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  561 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:564:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  564 |       for (i = 0; i < n->u.array.len; i++)[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  565 |         {[0m
  566 |           print_node (n->u.array.array[i]);[0m
  567 |           if (i + 1 < n->u.array.len)[0m
  568 |             fprintf (ofp, " ");[0m
  569 |         }[0m
      | [0;1;32m         
[0m      | [0;32m         ;} 
[0m[1mprims.c:567:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  567 |           if (i + 1 < n->u.array.len)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  568 |             fprintf (ofp, " ");[0m
      | [0;1;32m                               
[0m[1mprims.c:568:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  568 |             fprintf (ofp, " ");[0m
      | [0;1;32m            ^~~~~~~
[0m[1mprims.c:568:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  568 |             fprintf (ofp, " ");[0m
      | [0;1;32m            ^~~~~~~
[0m[1mprims.c:574:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  574 | DEFUN (prim_print)[0m
      | [0;1;32m       ^
[0m[1mprims.c:579:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  579 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:579:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  579 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:591:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  591 | DEFUN (prim_range)[0m
      | [0;1;32m       ^
[0m[1mprims.c:597:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  597 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:597:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  597 |   NEED_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:44:7: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_ARG'[0m
   44 |       fprintf (stderr, _("%s:%d: %s: too few arguments\n"),     \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:603:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  603 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:603:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  603 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:607:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  607 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:607:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  607 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:617:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  617 |           fprintf (stderr, _("%s:%d: %s: offset out of range\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:617:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  617 |           fprintf (stderr, _("%s:%d: %s: offset out of range\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:626:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  626 |       memcpy (n->u.str.data, from->u.str.data + start->u.integer,[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:626:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  626 |       memcpy (n->u.str.data, from->u.str.data + start->u.integer,[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:633:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  633 |           fprintf (stderr, _("%s:%d: %s: offset out of range\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:633:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  633 |           fprintf (stderr, _("%s:%d: %s: offset out of range\n"),[0m
      | [0;1;32m          ^~~~~~~
[0m[1mprims.c:645:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  645 |       for (i = 0; i < n->u.array.len; i++)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  646 |         n->u.array.array[i][0m
  647 |           = node_copy (from->u.array.array[i + start->u.integer]);[0m
      | [0;1;32m                                                                  
[0m[1mprims.c:651:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  651 |       fprintf (stderr, _("%s:%d: %s: illegal argument\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:651:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  651 |       fprintf (stderr, _("%s:%d: %s: illegal argument\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:664:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  664 | DEFUN (prim_regexp)[0m
      | [0;1;32m       ^
[0m[1mprims.c:670:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  670 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:670:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  670 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:677:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  677 |   memcpy (n->u.re.data, str->u.str.data, str->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:677:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  677 |   memcpy (n->u.re.data, str->u.str.data, str->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:684:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  684 | DEFUN (prim_regexp_syntax)[0m
      | [0;1;32m       ^
[0m[1mprims.c:692:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  692 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:692:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  692 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:697:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  697 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:697:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  697 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:709:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  709 | DEFUN (prim_regmatch)[0m
      | [0;1;32m       ^
[0m[1mprims.c:719:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  719 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:719:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  719 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:752:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  752 | do_regsubsts (str, re, subst, allp)[0m
      | [0;1;32m^
[0m[1mprims.c:767:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  767 |   for (i = 0; i < subst->u.str.len; i++)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  768 |     if (subst->u.str.data[i] == '$')[0m
  769 |       {[0m
  770 |         do_expansions_in_substs = 1;[0m
  771 |         break;[0m
  772 |       }[0m
      | [0;1;32m       
[0m[1mprims.c:780:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  780 |       if (i < 0)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  781 |         goto out;[0m
      | [0;1;32m                 
[0m[1mprims.c:786:7: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
  786 |       APPEND (str->u.str.data + pos, matches.start[0] - pos);[0m
      | [0;1;32m      ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^
[0m[1mprims.c:885:3: [0m[0;1;36mnote: [0mAssuming 'arg' is equal to null[0m
  885 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:52:9: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   52 |     if (arg != NULL)                                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mprims.c:885:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  885 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:52:5: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   52 |     if (arg != NULL)                                            \[0m
      | [0;1;32m    ^
[0m[1mprims.c:885:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
  885 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:51:3: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   51 |   do {                                                          \[0m
      | [0;1;32m  ^
[0m[1mprims.c:887:10: [0m[0;1;36mnote: [0mCalling 'do_regsubsts'[0m
  887 |   return do_regsubsts (str, re, subst, 1);[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:760:3: [0m[0;1;36mnote: [0m'result' initialized to a null pointer value[0m
  760 |   static char *result = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:767:15: [0m[0;1;36mnote: [0mAssuming 'i' is >= field 'len'[0m
  767 |   for (i = 0; i < subst->u.str.len; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:767:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 774[0m
  767 |   for (i = 0; i < subst->u.str.len; i++)[0m
      | [0;1;32m  ^
[0m[1mprims.c:775:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  775 |   while (1)[0m
      | [0;1;32m  ^
[0m[1mprims.c:778:22: [0m[0;1;36mnote: [0mAssuming field 'fastmap_accurate' is not equal to 0[0m
  778 |       i = re_search (REGEXP (re), str->u.str.data, str->u.str.len,[0m
      | [0;1;32m                     ^
[0m[1m./defs.h:120:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEXP'[0m
  120 |   ((regexp)->u.re.compiled.fastmap_accurate                     \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:778:22: [0m[0;1;36mnote: [0m'?' condition is true[0m
  778 |       i = re_search (REGEXP (re), str->u.str.data, str->u.str.len,[0m
      | [0;1;32m                     ^
[0m[1m./defs.h:120:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEXP'[0m
  120 |   ((regexp)->u.re.compiled.fastmap_accurate                     \[0m
      | [0;1;32m   ^
[0m[1mprims.c:780:11: [0m[0;1;36mnote: [0mAssuming 'i' is >= 0[0m
  780 |       if (i < 0)[0m
      | [0;1;32m          ^~~~~
[0m[1mprims.c:780:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  780 |       if (i < 0)[0m
      | [0;1;32m      ^
[0m[1mprims.c:786:7: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  786 |       APPEND (str->u.str.data + pos, matches.start[0] - pos);[0m
      | [0;1;32m      ^
[0m[1mprims.c:65:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:786:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  786 |       APPEND (str->u.str.data + pos, matches.start[0] - pos);[0m
      | [0;1;32m      ^
[0m[1mprims.c:65:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m    ^
[0m[1mprims.c:786:7: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
  786 |       APPEND (str->u.str.data + pos, matches.start[0] - pos);[0m
      | [0;1;32m      ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:786:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  786 |       APPEND (str->u.str.data + pos, matches.start[0] - pos);[0m
      | [0;1;32m      ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:786:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  786 |       APPEND (str->u.str.data + pos, matches.start[0] - pos);[0m
      | [0;1;32m      ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:789:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  789 |       if (!do_expansions_in_substs)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m  790 |         APPEND (subst->u.str.data, subst->u.str.len);[0m
  791 |       else[0m
      | [0;32m      } 
[0m[1mprims.c:790:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  790 |         APPEND (subst->u.str.data, subst->u.str.len);[0m
      | [0;1;32m        ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:790:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  790 |         APPEND (subst->u.str.data, subst->u.str.len);[0m
      | [0;1;32m        ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:794:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  794 |           for (i = 0; i < subst->u.str.len; i++)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m[1mprims.c:801:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  801 |                     APPEND ("$", 1);[0m
      | [0;1;32m                    ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:801:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  801 |                     APPEND ("$", 1);[0m
      | [0;1;32m                    ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:801:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  801 |                     APPEND ("$", 1);[0m
      | [0;1;32m                    ^
[0m      | [0;32m                    {
[0m  802 |                     break;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mprims.c:64:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   64 |   do {                                                  \[0m
      | [0;1;32m  ^
[0m[1mprims.c:815:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  815 |                     if (matches.start[j] >= 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                    {
[0m  816 |                       APPEND (str->u.str.data + matches.start[j],[0m
  817 |                               matches.end[j] - matches.start[j]);[0m
  818 |                     break;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mprims.c:815:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  815 |                     if (matches.start[j] >= 0)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m  816 |                       APPEND (str->u.str.data + matches.start[j],[0m
  817 |                               matches.end[j] - matches.start[j]);[0m
      | [0;1;32m                                                                 
[0m[1mprims.c:816:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  816 |                       APPEND (str->u.str.data + matches.start[j],[0m
      | [0;1;32m                      ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:816:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  816 |                       APPEND (str->u.str.data + matches.start[j],[0m
      | [0;1;32m                      ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:822:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  822 |                     APPEND ("$", 1);[0m
      | [0;1;32m                    ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:822:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  822 |                     APPEND ("$", 1);[0m
      | [0;1;32m                    ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:822:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  822 |                     APPEND ("$", 1);[0m
      | [0;1;32m                    ^
[0m      | [0;32m                    {
[0m  823 |                     APPEND (subst->u.str.data + i, 1);[0m
  824 |                     break;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mprims.c:64:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   64 |   do {                                                  \[0m
      | [0;1;32m  ^
[0m[1mprims.c:823:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  823 |                     APPEND (subst->u.str.data + i, 1);[0m
      | [0;1;32m                    ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:823:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  823 |                     APPEND (subst->u.str.data + i, 1);[0m
      | [0;1;32m                    ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:827:10: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  827 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  828 |               APPEND (subst->u.str.data + i, 1);[0m
      | [0;1;32m                                                
[0m[1mprims.c:828:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  828 |               APPEND (subst->u.str.data + i, 1);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:828:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  828 |               APPEND (subst->u.str.data + i, 1);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:834:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  834 |       if (!allp)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  835 |         break;[0m
      | [0;1;32m              
[0m[1mprims.c:847:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  847 |   APPEND (str->u.str.data + pos, str->u.str.len - pos);[0m
      | [0;1;32m  ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:847:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  847 |   APPEND (str->u.str.data + pos, str->u.str.len - pos);[0m
      | [0;1;32m  ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:857:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  857 |   memcpy (str->u.str.data, result, result_pos);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:857:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  857 |   memcpy (str->u.str.data, result, result_pos);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:863:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  863 | DEFUN (prim_regsub)[0m
      | [0;1;32m       ^
[0m[1mprims.c:871:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  871 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:871:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  871 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:877:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  877 | DEFUN (prim_regsuball)[0m
      | [0;1;32m       ^
[0m[1mprims.c:885:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  885 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:885:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  885 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:891:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  891 | DEFUN (prim_require_state)[0m
      | [0;1;32m       ^
[0m[1mprims.c:901:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  901 |       fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:901:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  901 |       fprintf (stderr, _("%s:%d: %s: illegal argument type\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:908:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  908 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:908:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  908 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:913:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  913 |       fprintf (stderr, _("%s:%d: %s: couldn't define state `%s'\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:913:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  913 |       fprintf (stderr, _("%s:%d: %s: couldn't define state `%s'\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:922:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  922 | DEFUN (prim_split)[0m
      | [0;1;32m       ^
[0m[1mprims.c:930:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  930 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:930:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  930 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:941:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  941 |       if (i < 0)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m  942 |         /* No more matches. */[0m
  943 |         break;[0m
      | [0;1;32m              
[0m[1mprims.c:949:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  949 |       memcpy (n2->u.str.data, str->u.str.data + pos, n2->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:949:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  949 |       memcpy (n2->u.str.data, str->u.str.data + pos, n2->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:970:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  970 |   memcpy (n2->u.str.data, str->u.str.data + pos, n2->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:970:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  970 |   memcpy (n2->u.str.data, str->u.str.data + pos, n2->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:978:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  978 | DEFUN (prim_sprintf)[0m
      | [0;1;32m       ^
[0m[1mprims.c:1001:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1001 |           APPEND (cp + i, 1);[0m
      | [0;1;32m          ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1001:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1001 |           APPEND (cp + i, 1);[0m
      | [0;1;32m          ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1009:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1009 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1009:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1009 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1017:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 1018 |             ifmtopts[j] = cp[i];[0m
      | [0;1;32m                                
[0m[1mprims.c:1023:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1023 |               APPEND ("%", 1);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1023:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1023 |               APPEND ("%", 1);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1024:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1024 |               APPEND (ifmtopts, j);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1024:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1024 |               APPEND (ifmtopts, j);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1037:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1037 |                   fprintf (stderr,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mprims.c:1037:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1037 |                   fprintf (stderr,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mprims.c:1042:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1042 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1042:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1042 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1042:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1042 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1043 |               sprintf (buf, ifmt, n->u.integer);[0m
 1044 | [0m
 1045 |               APPEND (buf, strlen (buf));[0m
 1046 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mprims.c:1043:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1043 |               sprintf (buf, ifmt, n->u.integer);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1043:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1043 |               sprintf (buf, ifmt, n->u.integer);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1045:8: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1045 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:985:3: [0m[0;1;36mnote: [0m'result' initialized to a null pointer value[0m
  985 |   char *result = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~
[0m[1mprims.c:996:15: [0m[0;1;36mnote: [0mAssuming 'i' is < field 'len'[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~
[0m[1mprims.c:996:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m  ^
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m          ^~~~~~~~~~~~
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:998:28: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:998:28: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprims.c:998:55: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                                                      ^~~~~~~~~~~~~~~~
[0m[1mprims.c:998:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m      ^
[0m[1mprims.c:1003:12: [0m[0;1;36mnote: [0mTaking true branch[0m
 1003 |       else if (cp[i] == '%')[0m
      | [0;1;32m           ^
[0m[1mprims.c:1007:8: [0m[0;1;36mnote: [0mAssuming 'arg' is not equal to NULL[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~
[0m[1mprims.c:1007:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                           ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:23: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m                      ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1019[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1021:8: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1021:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1029:4: [0m[0;1;36mnote: [0mControl jumps to 'case 100:'  at line 1033[0m
 1029 |           switch (cp[i])[0m
      | [0;1;32m          ^
[0m[1mprims.c:1034:12: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to nINTEGER[0m
 1034 |               if (n->type != nINTEGER)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1034:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1034 |               if (n->type != nINTEGER)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1045:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1045 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1045:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1045 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m    ^
[0m[1mprims.c:1045:8: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1045 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1045:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1045 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1045:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1045 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1049:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1049 |               if (n->type != nINTEGER)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1050 |                 goto no_match;[0m
 1051 | [0m
 1052 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
 1053 |               sprintf (buf, ifmt, n->u.integer);[0m
 1054 | [0m
 1055 |               APPEND (buf, strlen (buf));[0m
 1056 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mprims.c:1049:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1049 |               if (n->type != nINTEGER)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1050 |                 goto no_match;[0m
      | [0;1;32m                              
[0m[1mprims.c:1052:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1052 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1052:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1052 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1053:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1053 |               sprintf (buf, ifmt, n->u.integer);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1053:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1053 |               sprintf (buf, ifmt, n->u.integer);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1055:8: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1055 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:985:3: [0m[0;1;36mnote: [0m'result' initialized to a null pointer value[0m
  985 |   char *result = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~
[0m[1mprims.c:996:15: [0m[0;1;36mnote: [0mAssuming 'i' is < field 'len'[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~
[0m[1mprims.c:996:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m  ^
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m          ^~~~~~~~~~~~
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:998:28: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:998:28: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprims.c:998:55: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                                                      ^~~~~~~~~~~~~~~~
[0m[1mprims.c:998:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m      ^
[0m[1mprims.c:1003:12: [0m[0;1;36mnote: [0mTaking true branch[0m
 1003 |       else if (cp[i] == '%')[0m
      | [0;1;32m           ^
[0m[1mprims.c:1007:8: [0m[0;1;36mnote: [0mAssuming 'arg' is not equal to NULL[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~
[0m[1mprims.c:1007:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                           ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:23: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m                      ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1019[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1021:8: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1021:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1029:4: [0m[0;1;36mnote: [0mControl jumps to 'case 99:'  at line 1048[0m
 1029 |           switch (cp[i])[0m
      | [0;1;32m          ^
[0m[1mprims.c:1049:12: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to nINTEGER[0m
 1049 |               if (n->type != nINTEGER)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1049:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1049 |               if (n->type != nINTEGER)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1055:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1055 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1055:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1055 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m    ^
[0m[1mprims.c:1055:8: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1055 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1055:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1055 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1055:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1055 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1062:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1062 |               if (n->type != nREAL)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 1063 |                 goto no_match;[0m
      | [0;1;32m                              
[0m[1mprims.c:1065:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1065 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1065:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1065 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1065:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1065 |               sprintf (ifmt, "%%%s%c", ifmtopts, cp[i]);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1066 |               sprintf (buf, ifmt, n->u.real);[0m
 1067 | [0m
 1068 |               APPEND (buf, strlen (buf));[0m
 1069 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mprims.c:1066:8: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1066 |               sprintf (buf, ifmt, n->u.real);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1066:8: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1066 |               sprintf (buf, ifmt, n->u.real);[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1068:8: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1068 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:985:3: [0m[0;1;36mnote: [0m'result' initialized to a null pointer value[0m
  985 |   char *result = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~
[0m[1mprims.c:996:15: [0m[0;1;36mnote: [0mAssuming 'i' is < field 'len'[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~
[0m[1mprims.c:996:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m  ^
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m          ^~~~~~~~~~~~
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:998:28: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:998:28: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprims.c:998:55: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                                                      ^~~~~~~~~~~~~~~~
[0m[1mprims.c:998:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m      ^
[0m[1mprims.c:1003:12: [0m[0;1;36mnote: [0mTaking true branch[0m
 1003 |       else if (cp[i] == '%')[0m
      | [0;1;32m           ^
[0m[1mprims.c:1007:8: [0m[0;1;36mnote: [0mAssuming 'arg' is not equal to NULL[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~
[0m[1mprims.c:1007:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                           ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:23: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m                      ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1019[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1021:8: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1021:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1029:4: [0m[0;1;36mnote: [0mControl jumps to 'case 69:'  at line 1061[0m
 1029 |           switch (cp[i])[0m
      | [0;1;32m          ^
[0m[1mprims.c:1062:12: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to nREAL[0m
 1062 |               if (n->type != nREAL)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~
[0m[1mprims.c:1062:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1062 |               if (n->type != nREAL)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1068:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1068 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1068:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m    ^
[0m[1mprims.c:1068:8: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1068 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1068:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1068 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1068:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1068 |               APPEND (buf, strlen (buf));[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1072:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1072 |               if (n->type != nSTRING)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1073 |                 goto no_match;[0m
 1074 | [0m
 1075 |               if (ifmtopts[0] != '\0')[0m
 1076 |                 {[0m
 1077 |                   fprintf (stderr,[0m
 1078 |                            _("%s:%d: %s: no extra options can be specified for %%s\n"),[0m
 1079 |                            filename, linenum, prim_name);[0m
 1080 |                   exit (1);[0m
 1081 |                 }[0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
 1083 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mprims.c:1072:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1072 |               if (n->type != nSTRING)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1073 |                 goto no_match;[0m
      | [0;1;32m                              
[0m[1mprims.c:1077:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1077 |                   fprintf (stderr,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mprims.c:1077:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1077 |                   fprintf (stderr,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mprims.c:1082:8: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:985:3: [0m[0;1;36mnote: [0m'result' initialized to a null pointer value[0m
  985 |   char *result = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~~~
[0m[1mprims.c:996:15: [0m[0;1;36mnote: [0mAssuming 'i' is < field 'len'[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~~
[0m[1mprims.c:996:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
  996 |   for (i = 0; i < fmt->u.str.len; i++)[0m
      | [0;1;32m  ^
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m          ^~~~~~~~~~~~
[0m[1mprims.c:998:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:998:28: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:998:28: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mprims.c:998:55: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m                                                      ^~~~~~~~~~~~~~~~
[0m[1mprims.c:998:7: [0m[0;1;36mnote: [0mTaking false branch[0m
  998 |       if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))[0m
      | [0;1;32m      ^
[0m[1mprims.c:1003:12: [0m[0;1;36mnote: [0mTaking true branch[0m
 1003 |       else if (cp[i] == '%')[0m
      | [0;1;32m           ^
[0m[1mprims.c:1007:8: [0m[0;1;36mnote: [0mAssuming 'arg' is not equal to NULL[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m              ^~~~~~~~~~~
[0m[1mprims.c:1007:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1007 |           if (arg == NULL)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                           ^
[0m[1mprims.c:1017:21: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:8: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m       ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:23: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m                      ^~~~~~~~~~~
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:43: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m                                                 ^
[0m[1mprims.c:75:7: [0m[0;1;36mnote: [0mexpanded from macro 'FMTSPECIAL'[0m
   75 |      (('0' <= (ch) && (ch) <= '9') || (ch) == '.' || (ch) == '-')[0m
      | [0;1;32m      ^
[0m[1mprims.c:1017:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1019[0m
 1017 |           for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1021:8: [0m[0;1;36mnote: [0m'i' is < field 'len'[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1021:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1021 |           if (i >= fmt->u.str.len)[0m
      | [0;1;32m          ^
[0m[1mprims.c:1029:4: [0m[0;1;36mnote: [0mControl jumps to 'case 115:'  at line 1071[0m
 1029 |           switch (cp[i])[0m
      | [0;1;32m          ^
[0m[1mprims.c:1072:12: [0m[0;1;36mnote: [0mAssuming field 'type' is equal to nSTRING[0m
 1072 |               if (n->type != nSTRING)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1072:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1072 |               if (n->type != nSTRING)[0m
      | [0;1;32m              ^
[0m[1mprims.c:1075:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1075 |               if (ifmtopts[0] != '\0')[0m
      | [0;1;32m              ^
[0m[1mprims.c:1082:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1082:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
      | [0;1;32m              ^
[0m[1mprims.c:65:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   65 |     if (result_len < result_pos + (len))                \[0m
      | [0;1;32m    ^
[0m[1mprims.c:1082:8: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~~~~~~
[0m[1mprims.c:1082:8: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1082:8: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1082 |               APPEND (n->u.str.data, n->u.str.len);[0m
      | [0;1;32m              ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1086:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1086 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1086:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1086 |               fprintf (stderr,[0m
      | [0;1;32m              ^~~~~~~
[0m[1mprims.c:1086:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1086 |               fprintf (stderr,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1087 |                        _("%s:%d: %s: illegal type specifier `%c'\n"),[0m
 1088 |                        filename, linenum, prim_name, cp[i]);[0m
 1089 |               exit (1);[0m
 1090 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mprims.c:1093:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1093 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1094 |         APPEND (cp + i, 1);[0m
      | [0;1;32m                           
[0m[1mprims.c:1094:2: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1094 |         APPEND (cp + i, 1);[0m
      | [0;1;32m        ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1094:2: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1094 |         APPEND (cp + i, 1);[0m
      | [0;1;32m        ^
[0m[1mprims.c:70:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND'[0m
   70 |     memcpy (result + result_pos, (data), (len));        \[0m
      | [0;1;32m    ^~~~~~
[0m[1mprims.c:1107:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1107 | DEFUN (prim_strcmp)[0m
      | [0;1;32m       ^
[0m[1mprims.c:1117:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1117 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1117:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1117 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1136:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1136 |   if (s1->u.str.len < s2->u.str.len)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1137 |     result = -1;[0m
 1138 |   else if (s1->u.str.len > s2->u.str.len)[0m
      | [0;32m  } 
[0m[1mprims.c:1138:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1138 |   else if (s1->u.str.len > s2->u.str.len)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1139 |     result = 1;[0m
 1140 |   else[0m
      | [0;32m  } 
[0m[1mprims.c:1140:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1140 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1141 |     result = 0;[0m
      | [0;1;32m               
[0m[1mprims.c:1153:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1153 | DEFUN (prim_string)[0m
      | [0;1;32m       ^
[0m[1mprims.c:1160:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1160 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1160:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1160 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1170:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1170 |       r->u.str.len = 0;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1171 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:1174:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1174 |       r->u.str.len = strlen (n->u.sym);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1175 |       r->u.str.data = (char *) xmalloc (r->u.str.len);[0m
 1176 |       memcpy (r->u.str.data, n->u.sym, r->u.str.len);[0m
 1177 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:1176:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1176 |       memcpy (r->u.str.data, n->u.sym, r->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1176:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1176 |       memcpy (r->u.str.data, n->u.sym, r->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1180:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1180 |       r->u.str.len = n->u.str.len;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1181 |       r->u.str.data = (char *) xmalloc (n->u.str.len);[0m
 1182 |       memcpy (r->u.str.data, n->u.str.data, n->u.str.len);[0m
 1183 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:1182:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1182 |       memcpy (r->u.str.data, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1182:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1182 |       memcpy (r->u.str.data, n->u.str.data, n->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1186:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1186 |       sprintf (buf, "%d", n->u.integer);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1186:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1186 |       sprintf (buf, "%d", n->u.integer);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1186:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1186 |       sprintf (buf, "%d", n->u.integer);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1187 |       r->u.str.len = strlen (buf);[0m
 1188 |       r->u.str.data = (char *) xmalloc (r->u.str.len);[0m
 1189 |       memcpy (r->u.str.data, buf, r->u.str.len);[0m
 1190 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:1189:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1189 |       memcpy (r->u.str.data, buf, r->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1189:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1189 |       memcpy (r->u.str.data, buf, r->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1193:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1193 |       sprintf (buf, "%f", n->u.real);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1193:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1193 |       sprintf (buf, "%f", n->u.real);[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1193:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1193 |       sprintf (buf, "%f", n->u.real);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 1194 |       r->u.str.len = strlen (buf);[0m
 1195 |       r->u.str.data = (char *) xmalloc (r->u.str.len);[0m
 1196 |       memcpy (r->u.str.data, buf, r->u.str.len);[0m
 1197 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mprims.c:1196:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1196 |       memcpy (r->u.str.data, buf, r->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1196:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1196 |       memcpy (r->u.str.data, buf, r->u.str.len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mprims.c:1205:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1205 | DEFUN (prim_strncmp)[0m
      | [0;1;32m       ^
[0m[1mprims.c:1216:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1216 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1216:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1216 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1243:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1243 |   if (s1->u.str.len < s2->u.str.len)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1244 |     result = -1;[0m
 1245 |   else if (s1->u.str.len > s2->u.str.len)[0m
      | [0;32m  } 
[0m[1mprims.c:1245:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1245 |   else if (s1->u.str.len > s2->u.str.len)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 1246 |     result = 1;[0m
 1247 |   else[0m
      | [0;32m  } 
[0m[1mprims.c:1247:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1247 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1248 |     result = 0;[0m
      | [0;1;32m               
[0m[1mprims.c:1261:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1261 | DEFUN (prim_substring)[0m
      | [0;1;32m       ^
[0m[1mprims.c:1269:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1269 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1269:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1269 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1273:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1273 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1273:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1273 |       fprintf (stderr,[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1280:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1280 |       fprintf (stderr, _("%s:%d: %s: offset out of range\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1280:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1280 |       fprintf (stderr, _("%s:%d: %s: offset out of range\n"),[0m
      | [0;1;32m      ^~~~~~~
[0m[1mprims.c:1290:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1290 |   memcpy (n->u.str.data, str->u.str.data + start->u.integer,[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:1290:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1290 |   memcpy (n->u.str.data, str->u.str.data + start->u.integer,[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:1301:8: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1301 | DEFUN (prim_system)[0m
      | [0;1;32m       ^
[0m[1mprims.c:1309:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1309 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1309:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1309 |   LAST_ARG ();[0m
      | [0;1;32m  ^
[0m[1mprims.c:54:2: [0m[0;1;36mnote: [0mexpanded from macro 'LAST_ARG'[0m
   54 |         fprintf (stderr, _("%s:%d: %s: too many arguments\n"),  \[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1312:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1312 |   memcpy (cmd, str->u.str.data, str->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:1312:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1312 |   memcpy (cmd, str->u.str.data, str->u.str.len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mprims.c:1371:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1371 |   for (i = 0; prims[i].name; i++)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1372 |     if (!strhash_put (ns_prims, prims[i].name, strlen (prims[i].name),[0m
 1373 |                       (void *) prims[i].prim, &old))[0m
 1374 |       {[0m
 1375 |         fprintf (stderr, _("%s: out of memory\n"), program);[0m
 1376 |         exit (1);[0m
 1377 |       }[0m
      | [0;1;32m       
[0m[1mprims.c:1375:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1375 |         fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mprims.c:1375:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1375 |         fprintf (stderr, _("%s: out of memory\n"), program);[0m
      | [0;1;32m        ^~~~~~~
[0m204 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[32/33][217.4s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpbxaso795.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/compat/regex.c
[1mregex.c:144:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  144 |    if (done)[0m
      | [0;1;32m            ^
[0m      | [0;32m             {
[0m  145 |      return;[0m
      | [0;1;32m            
[0m[1mregex.c:147:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  147 |    bzero (re_syntax_table, sizeof re_syntax_table);[0m
      | [0;1;32m   ^
[0m[1mregex.c:106:21: [0m[0;1;36mnote: [0mexpanded from macro 'bzero'[0m
  106 | #define bzero(s, n)     memset ((s), 0, (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:147:4: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
  147 |    bzero (re_syntax_table, sizeof re_syntax_table);[0m
      | [0;1;32m   ^
[0m[1mregex.c:106:21: [0m[0;1;36mnote: [0mexpanded from macro 'bzero'[0m
  106 | #define bzero(s, n)     memset ((s), 0, (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:149:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  149 |    for (c = 'a'; c <= 'z'; c++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  150 |      re_syntax_table[c] = Sword;[0m
      | [0;1;32m                                
[0m[1mregex.c:152:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  152 |    for (c = 'A'; c <= 'Z'; c++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  153 |      re_syntax_table[c] = Sword;[0m
      | [0;1;32m                                
[0m[1mregex.c:155:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  155 |    for (c = '0'; c <= '9'; c++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  156 |      re_syntax_table[c] = Sword;[0m
      | [0;1;32m                                
[0m[1mregex.c:339:12: [0m[0;1;35mwarning: [0m[1ma function declaration without a prototype is deprecated in all versions of C and is treated as a zero-parameter prototype in C23, conflicting with a subsequent definition [clang-diagnostic-deprecated-non-prototype][0m
  339 | static int re_match_2_internal ();[0m
      | [0;1;32m           ^
[0m[1mregex.c:946:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
  946 | re_set_syntax (syntax)[0m
      | [0;1;32m^
[0m[1mregex.c:975:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  975 |       SYNTAX (ch) = Sword;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  976 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mregex.c:165:19: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                  ^
[0m[1mregex.c:979:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  979 |       SYNTAX (ch) = 0;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m  980 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mregex.c:165:19: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                  ^
[0m[1mregex.c:984:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  984 |       break;[0m
      | [0;1;32m      ^    
[0m      | [0;32m      {    ;} 
[0m[1mregex.c:1802:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 1802 | regex_compile (pattern, size, syntax, bufp)[0m
      | [0;1;32m^
[0m[1mregex.c:1871:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1871 |   if (compile_stack.stack == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1872 |     return REG_ESPACE;[0m
      | [0;1;32m                      
[0m[1mregex.c:1907:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1907 |       if (!bufp->buffer) FREE_STACK_RETURN (REG_ESPACE);[0m
      | [0;1;32m                        ^                               
[0m      | [0;32m                         {
[0m[1mregex.c:1917:7: [0m[0;1;35mwarning: [0m[1mPotential leak of memory pointed to by 'compile_stack.stack' [clang-analyzer-unix.Malloc][0m
 1917 |       PATFETCH (c);[0m
      | [0;1;32m      ^
[0m[1mregex.c:1505:29: [0m[0;1;36mnote: [0mexpanded from macro 'PATFETCH'[0m
 1505 |   do {if (p == pend) return REG_EEND;                                   \[0m
      | [0;1;32m                            ^
[0m[1mregex.c:1870:25: [0m[0;1;36mnote: [0mMemory is allocated[0m
 1870 |   compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);[0m
      | [0;1;32m                        ^
[0m[1mregex.c:320:29: [0m[0;1;36mnote: [0mexpanded from macro 'TALLOC'[0m
  320 | #define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1871:7: [0m[0;1;36mnote: [0mAssuming field 'stack' is not equal to NULL[0m
 1871 |   if (compile_stack.stack == NULL)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1871:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1871 |   if (compile_stack.stack == NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:1895:7: [0m[0;1;36mnote: [0mAssuming field 'allocated' is not equal to 0[0m
 1895 |   if (bufp->allocated == 0)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1895:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1895 |   if (bufp->allocated == 0)[0m
      | [0;1;32m  ^
[0m[1mregex.c:1915:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1915 |   while (p != pend)[0m
      | [0;1;32m  ^
[0m[1mregex.c:1917:7: [0m[0;1;36mnote: [0mAssuming 'p' is equal to 'pend'[0m
 1917 |       PATFETCH (c);[0m
      | [0;1;32m      ^
[0m[1mregex.c:1505:11: [0m[0;1;36mnote: [0mexpanded from macro 'PATFETCH'[0m
 1505 |   do {if (p == pend) return REG_EEND;                                   \[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:1917:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1917 |       PATFETCH (c);[0m
      | [0;1;32m      ^
[0m[1mregex.c:1505:7: [0m[0;1;36mnote: [0mexpanded from macro 'PATFETCH'[0m
 1505 |   do {if (p == pend) return REG_EEND;                                   \[0m
      | [0;1;32m      ^
[0m[1mregex.c:1917:7: [0m[0;1;36mnote: [0mPotential leak of memory pointed to by 'compile_stack.stack'[0m
 1917 |       PATFETCH (c);[0m
      | [0;1;32m      ^
[0m[1mregex.c:1505:29: [0m[0;1;36mnote: [0mexpanded from macro 'PATFETCH'[0m
 1505 |   do {if (p == pend) return REG_EEND;                                   \[0m
      | [0;1;32m                            ^
[0m[1mregex.c:1922:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1922 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1923 |             if (   /* If at start of pattern, it's an operator.  */[0m
 1924 |                    p == pattern + 1[0m
 1925 |                    /* If context independent, it's an operator.  */[0m
 1926 |                 || syntax & RE_CONTEXT_INDEP_ANCHORS[0m
 1927 |                    /* Otherwise, depends on what's come before.  */[0m
 1928 |                 || at_begline_loc_p (pattern, p, syntax))[0m
 1929 |               BUF_PUSH (begline);[0m
 1930 |             else[0m
 1931 |               goto normal_char;[0m
 1932 |           }[0m
 1933 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:1928:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1928 |                 || at_begline_loc_p (pattern, p, syntax))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1929 |               BUF_PUSH (begline);[0m
 1930 |             else[0m
      | [0;32m            } 
[0m[1mregex.c:1930:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1930 |             else[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 1931 |               goto normal_char;[0m
      | [0;1;32m                               
[0m[1mregex.c:1937:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1937 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1938 |             if (   /* If at end of pattern, it's an operator.  */[0m
 1939 |                    p == pend[0m
 1940 |                    /* If context independent, it's an operator.  */[0m
 1941 |                 || syntax & RE_CONTEXT_INDEP_ANCHORS[0m
 1942 |                    /* Otherwise, depends on what's next.  */[0m
 1943 |                 || at_endline_loc_p (p, pend, syntax))[0m
 1944 |                BUF_PUSH (endline);[0m
 1945 |              else[0m
 1946 |                goto normal_char;[0m
 1947 |            }[0m
 1948 |            break;[0m
      | [0;1;32m                
[0m      | [0;32m                ;} 
[0m[1mregex.c:1943:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1943 |                 || at_endline_loc_p (p, pend, syntax))[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 1944 |                BUF_PUSH (endline);[0m
 1945 |              else[0m
      | [0;32m             } 
[0m[1mregex.c:1945:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1945 |              else[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1946 |                goto normal_char;[0m
      | [0;1;32m                                
[0m[1mregex.c:1954:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1954 |               || (syntax & RE_LIMITED_OPS))[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 1955 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mregex.c:1956:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1956 |         handle_plus:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mregex.c:1961:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1961 |               if (syntax & RE_CONTEXT_INVALID_OPS)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 1962 |                 FREE_STACK_RETURN (REG_BADRPT);[0m
 1963 |               else if (!(syntax & RE_CONTEXT_INDEP_OPS))[0m
      | [0;32m              } 
[0m[1mregex.c:1963:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1963 |               else if (!(syntax & RE_CONTEXT_INDEP_OPS))[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 1964 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:1984:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1984 |                 if (p == pend)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1985 |                   break;[0m
      | [0;1;32m                        
[0m[1mregex.c:1990:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1990 |                     || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m 1991 |                   ;[0m
 1992 | [0m
 1993 |                 else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')[0m
      | [0;32m                } 
[0m[1mregex.c:1995:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1995 |                     if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);[0m
      | [0;1;32m                                  ^                                
[0m      | [0;32m                                   {
[0m[1mregex.c:2018:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2018 |             if (!laststart)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2019 |               break;[0m
      | [0;1;32m                    
[0m[1mregex.c:2052:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2052 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2053 |                   /* Anything else.  */[0m
 2054 |                   STORE_JUMP (maybe_pop_jump, b, laststart - 3);[0m
      | [0;1;32m                                                                
[0m[1mregex.c:2085:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2085 |           laststart = b;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2086 |           BUF_PUSH (anychar);[0m
 2087 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:2091:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2091 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:2094:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2094 |             if (p == pend) FREE_STACK_RETURN (REG_EBRACK);[0m
      | [0;1;32m                          ^                               
[0m      | [0;32m                           {
[0m[1mregex.c:2105:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2105 |             if (*p == '^')[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m 2106 |               p++;[0m
      | [0;1;32m                  
[0m[1mregex.c:2115:13: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2115 |             bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);[0m
      | [0;1;32m            ^
[0m[1mregex.c:106:21: [0m[0;1;36mnote: [0mexpanded from macro 'bzero'[0m
  106 | #define bzero(s, n)     memset ((s), 0, (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:2115:13: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 2115 |             bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);[0m
      | [0;1;32m            ^
[0m[1mregex.c:106:21: [0m[0;1;36mnote: [0mexpanded from macro 'bzero'[0m
  106 | #define bzero(s, n)     memset ((s), 0, (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:2119:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2119 |                 && (syntax & RE_HAT_LISTS_NOT_NEWLINE))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2120 |               SET_LIST_BIT ('\n');[0m
      | [0;1;32m                                  
[0m[1mregex.c:2125:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2125 |                 if (p == pend) FREE_STACK_RETURN (REG_EBRACK);[0m
      | [0;1;32m                              ^                               
[0m      | [0;32m                               {
[0m[1mregex.c:2132:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2132 |                     if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);[0m
      | [0;1;32m                                  ^                                
[0m      | [0;32m                                   {
[0m[1mregex.c:2142:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2142 |                 if (c == ']' && p != p1 + 1)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 2143 |                   break;[0m
      | [0;1;32m                        
[0m[1mregex.c:2147:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2147 |                 if (had_char_class && c == '-' && *p != ']')[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 2148 |                   FREE_STACK_RETURN (REG_ERANGE);[0m
      | [0;1;32m                                                 
[0m[1mregex.c:2161:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2161 |                     if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);[0m
      | [0;1;32m                                           ^                        
[0m      | [0;32m                                            {
[0m[1mregex.c:2172:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2172 |                     if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);[0m
      | [0;1;32m                                           ^                        
[0m      | [0;32m                                            {
[0m[1mregex.c:2186:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2186 |                     if (p == pend) FREE_STACK_RETURN (REG_EBRACK);[0m
      | [0;1;32m                                  ^                               
[0m      | [0;32m                                   {
[0m[1mregex.c:2192:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2192 |                             || c1 == CHAR_CLASS_MAX_LENGTH)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2193 |                           break;[0m
      | [0;1;32m                                
[0m[1mregex.c:2245:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2245 |                         if (!IS_CHAR_CLASS (str))[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2246 |                           FREE_STACK_RETURN (REG_ECTYPE);[0m
      | [0;1;32m                                                         
[0m[1mregex.c:2252:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2252 |                         if (p == pend) FREE_STACK_RETURN (REG_EBRACK);[0m
      | [0;1;32m                                      ^                               
[0m      | [0;32m                                       {
[0m[1mregex.c:2261:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2261 |                                 || (is_cntrl  && ISCNTRL (ch)))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 2262 |                               SET_LIST_BIT (ch);[0m
      | [0;1;32m                                                
[0m[1mregex.c:2266:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2266 |                                 || (is_print  && ISPRINT (ch)))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 2267 |                               SET_LIST_BIT (ch);[0m
      | [0;1;32m                                                
[0m[1mregex.c:2271:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2271 |                                 || (is_xdigit && ISXDIGIT (ch)))[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 2272 |                               SET_LIST_BIT (ch);[0m
      | [0;1;32m                                                
[0m[1mregex.c:2274:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2274 |                                 && (ISUPPER (ch) || ISLOWER (ch)))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 2275 |                               SET_LIST_BIT (ch);[0m
      | [0;1;32m                                                
[0m[1mregex.c:2283:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2283 |                         while (c1--)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 2284 |                           PATUNFETCH;[0m
      | [0;1;32m                                     
[0m[1mregex.c:2299:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2299 |             while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2300 |               b[-1]--;[0m
      | [0;1;32m                      
[0m[1mregex.c:2307:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2307 |           if (syntax & RE_NO_BK_PARENS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2308 |             goto handle_open;[0m
 2309 |           else[0m
 2310 |             goto normal_char;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mregex.c:2307:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2307 |           if (syntax & RE_NO_BK_PARENS)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2308 |             goto handle_open;[0m
 2309 |           else[0m
      | [0;32m          } 
[0m[1mregex.c:2309:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2309 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2310 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mregex.c:2314:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2314 |           if (syntax & RE_NO_BK_PARENS)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2315 |             goto handle_close;[0m
 2316 |           else[0m
 2317 |             goto normal_char;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mregex.c:2314:40: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2314 |           if (syntax & RE_NO_BK_PARENS)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 2315 |             goto handle_close;[0m
 2316 |           else[0m
      | [0;32m          } 
[0m[1mregex.c:2316:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2316 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2317 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mregex.c:2321:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2321 |           if (syntax & RE_NEWLINE_ALT)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2322 |             goto handle_alt;[0m
 2323 |           else[0m
 2324 |             goto normal_char;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mregex.c:2321:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2321 |           if (syntax & RE_NEWLINE_ALT)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2322 |             goto handle_alt;[0m
 2323 |           else[0m
      | [0;32m          } 
[0m[1mregex.c:2323:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2323 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2324 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mregex.c:2328:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2328 |           if (syntax & RE_NO_BK_VBAR)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 2329 |             goto handle_alt;[0m
 2330 |           else[0m
 2331 |             goto normal_char;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mregex.c:2328:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2328 |           if (syntax & RE_NO_BK_VBAR)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 2329 |             goto handle_alt;[0m
 2330 |           else[0m
      | [0;32m          } 
[0m[1mregex.c:2330:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2330 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 2331 |             goto normal_char;[0m
      | [0;1;32m                             
[0m[1mregex.c:2335:12: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2335 |            if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)[0m
      | [0;1;32m           ^
[0m      | [0;32m           {
[0m 2336 |              goto handle_interval;[0m
 2337 |            else[0m
 2338 |              goto normal_char;[0m
      | [0;1;32m                             
[0m      | [0;32m                             ;} 
[0m[1mregex.c:2335:66: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2335 |            if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 2336 |              goto handle_interval;[0m
 2337 |            else[0m
      | [0;32m           } 
[0m[1mregex.c:2337:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2337 |            else[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m 2338 |              goto normal_char;[0m
      | [0;1;32m                              
[0m[1mregex.c:2342:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2342 |           if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:2342:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2342 |           if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);[0m
      | [0;1;32m                        ^                                
[0m      | [0;32m                         {
[0m[1mregex.c:2352:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2352 |               if (syntax & RE_NO_BK_PARENS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mregex.c:2352:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2352 |               if (syntax & RE_NO_BK_PARENS)[0m
      | [0;1;32m                                           ^
[0m      | [0;32m                                            {
[0m 2353 |                 goto normal_backslash;[0m
      | [0;1;32m                                      
[0m[1mregex.c:2363:51: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2363 |                   if (compile_stack.stack == NULL) return REG_ESPACE;[0m
      | [0;1;32m                                                  ^                  
[0m      | [0;32m                                                   {
[0m[1mregex.c:2401:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2401 |               if (syntax & RE_NO_BK_PARENS) goto normal_backslash;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mregex.c:2401:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2401 |               if (syntax & RE_NO_BK_PARENS) goto normal_backslash;[0m
      | [0;1;32m                                           ^                      
[0m      | [0;32m                                            {
[0m[1mregex.c:2403:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2403 |               if (COMPILE_STACK_EMPTY)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2404 |                 if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)[0m
 2405 |                   goto normal_backslash;[0m
 2406 |                 else[0m
 2407 |                   FREE_STACK_RETURN (REG_ERPAREN);[0m
      | [0;1;32m                                                  
[0m[1mregex.c:2404:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2404 |                 if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2405 |                   goto normal_backslash;[0m
 2406 |                 else[0m
      | [0;32m                } 
[0m[1mregex.c:2406:17: [0m[0;1;35mwarning: [0m[1madd explicit braces to avoid dangling else [clang-diagnostic-dangling-else][0m
 2406 |                 else[0m
      | [0;1;32m                ^
[0m[1mregex.c:2406:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2406 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2407 |                   FREE_STACK_RETURN (REG_ERPAREN);[0m
      | [0;1;32m                                                  
[0m[1mregex.c:2423:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2423 |               if (COMPILE_STACK_EMPTY)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 2424 |                 if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)[0m
 2425 |                   goto normal_char;[0m
 2426 |                 else[0m
 2427 |                   FREE_STACK_RETURN (REG_ERPAREN);[0m
      | [0;1;32m                                                  
[0m[1mregex.c:2424:59: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2424 |                 if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 2425 |                   goto normal_char;[0m
 2426 |                 else[0m
      | [0;32m                } 
[0m[1mregex.c:2426:17: [0m[0;1;35mwarning: [0m[1madd explicit braces to avoid dangling else [clang-diagnostic-dangling-else][0m
 2426 |                 else[0m
      | [0;1;32m                ^
[0m[1mregex.c:2426:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2426 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2427 |                   FREE_STACK_RETURN (REG_ERPAREN);[0m
      | [0;1;32m                                                  
[0m[1mregex.c:2467:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2467 |               if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mregex.c:2467:69: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2467 |               if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 2468 |                 goto normal_backslash;[0m
      | [0;1;32m                                      
[0m[1mregex.c:2470:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2470 |               if (syntax & RE_LIMITED_OPS)[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m 2471 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2496:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2496 |               if (fixup_alt_jump)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 2497 |                 STORE_JUMP (jump_past_alt, fixup_alt_jump, b);[0m
      | [0;1;32m                                                              
[0m[1mregex.c:2513:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2513 |               if (!(syntax & RE_INTERVALS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mregex.c:2517:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2517 |                   || (p - 2 == pattern  &&  p == pend))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 2518 |                 goto normal_backslash;[0m
      | [0;1;32m                                      
[0m[1mregex.c:2531:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2531 |                     if (syntax & RE_NO_BK_BRACES)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2532 |                       goto unfetch_interval;[0m
 2533 |                     else[0m
      | [0;32m                    } 
[0m[1mregex.c:2533:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2533 |                     else[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2534 |                       FREE_STACK_RETURN (REG_EBRACE);[0m
      | [0;1;32m                                                     
[0m[1mregex.c:2542:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2542 |                     if (upper_bound < 0) upper_bound = RE_DUP_MAX;[0m
      | [0;1;32m                                        ^                         
[0m      | [0;32m                                         {
[0m[1mregex.c:2544:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2544 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 2545 |                   /* Interval such as `{1}' => match exactly once. */[0m
 2546 |                   upper_bound = lower_bound;[0m
      | [0;1;32m                                            
[0m[1mregex.c:2551:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2551 |                     if (syntax & RE_NO_BK_BRACES)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2552 |                       goto unfetch_interval;[0m
 2553 |                     else[0m
      | [0;32m                    } 
[0m[1mregex.c:2553:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2553 |                     else[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2554 |                       FREE_STACK_RETURN (REG_BADBR);[0m
      | [0;1;32m                                                    
[0m[1mregex.c:2559:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2559 |                     if (c != '\\') FREE_STACK_RETURN (REG_EBRACE);[0m
      | [0;1;32m                                  ^                               
[0m      | [0;32m                                   {
[0m[1mregex.c:2566:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2566 |                     if (syntax & RE_NO_BK_BRACES)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 2567 |                       goto unfetch_interval;[0m
 2568 |                     else[0m
      | [0;32m                    } 
[0m[1mregex.c:2568:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2568 |                     else[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2569 |                       FREE_STACK_RETURN (REG_BADBR);[0m
      | [0;1;32m                                                    
[0m[1mregex.c:2577:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2577 |                     if (syntax & RE_CONTEXT_INVALID_OPS)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 2578 |                       FREE_STACK_RETURN (REG_BADRPT);[0m
 2579 |                     else if (syntax & RE_CONTEXT_INDEP_OPS)[0m
      | [0;32m                    } 
[0m[1mregex.c:2579:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2579 |                     else if (syntax & RE_CONTEXT_INDEP_OPS)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 2580 |                       laststart = b;[0m
 2581 |                     else[0m
      | [0;32m                    } 
[0m[1mregex.c:2581:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2581 |                     else[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 2582 |                       goto unfetch_interval;[0m
      | [0;1;32m                                            
[0m[1mregex.c:2675:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2675 |                    if (p > pattern  &&  p[-1] == '\\')[0m
      | [0;1;32m                                                      ^
[0m      | [0;32m                                                       {
[0m 2676 |                      goto normal_backslash;[0m
      | [0;1;32m                                           
[0m[1mregex.c:2702:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2702 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2703 |                 goto normal_char;[0m
 2704 |               laststart = b;[0m
 2705 |               BUF_PUSH (wordchar);[0m
 2706 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2702:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2702 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2703 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2710:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2710 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2711 |                 goto normal_char;[0m
 2712 |               laststart = b;[0m
 2713 |               BUF_PUSH (notwordchar);[0m
 2714 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2710:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2710 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2711 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2718:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2718 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2719 |                 goto normal_char;[0m
 2720 |               BUF_PUSH (wordbeg);[0m
 2721 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2718:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2718 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2719 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2724:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2724 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2725 |                 goto normal_char;[0m
 2726 |               BUF_PUSH (wordend);[0m
 2727 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2724:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2724 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2725 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2730:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2730 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2731 |                 goto normal_char;[0m
 2732 |               BUF_PUSH (wordbound);[0m
 2733 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2730:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2730 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2731 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2736:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2736 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2737 |                 goto normal_char;[0m
 2738 |               BUF_PUSH (notwordbound);[0m
 2739 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2736:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2736 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2737 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2742:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2742 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2743 |                 goto normal_char;[0m
 2744 |               BUF_PUSH (begbuf);[0m
 2745 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2742:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2742 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2743 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2748:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2748 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2749 |                 goto normal_char;[0m
 2750 |               BUF_PUSH (endbuf);[0m
 2751 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2748:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2748 |               if (re_syntax_options & RE_NO_GNU_OPS)[0m
      | [0;1;32m                                                    ^
[0m      | [0;32m                                                     {
[0m 2749 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2755:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2755 |               if (syntax & RE_NO_BK_REFS)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2756 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2758:15: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2758 |               c1 = c - '0';[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 2759 | [0m
 2760 |               if (c1 > regnum)[0m
 2761 |                 FREE_STACK_RETURN (REG_ESUBREG);[0m
 2762 | [0m
 2763 |               /* Can't back reference to a subexpression if inside of it.  */[0m
 2764 |               if (group_in_compile_stack (compile_stack, (regnum_t) c1))[0m
 2765 |                 goto normal_char;[0m
 2766 | [0m
 2767 |               laststart = b;[0m
 2768 |               BUF_PUSH_2 (duplicate, c1);[0m
 2769 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:2760:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2760 |               if (c1 > regnum)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 2761 |                 FREE_STACK_RETURN (REG_ESUBREG);[0m
      | [0;1;32m                                                
[0m[1mregex.c:2764:73: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2764 |               if (group_in_compile_stack (compile_stack, (regnum_t) c1))[0m
      | [0;1;32m                                                                        ^
[0m      | [0;32m                                                                         {
[0m 2765 |                 goto normal_char;[0m
      | [0;1;32m                                 
[0m[1mregex.c:2774:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2774 |               if (syntax & RE_BK_PLUS_QM)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 2775 |                 goto handle_plus;[0m
 2776 |               else[0m
      | [0;32m              } 
[0m[1mregex.c:2776:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2776 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 2777 |                 goto normal_backslash;[0m
      | [0;1;32m                                      
[0m[1mregex.c:2780:13: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2780 |             normal_backslash:[0m
      | [0;1;32m            ^
[0m      | [0;32m            {
[0m 2781 |               /* You might think it would be useful for \ to mean[0m
 2782 |                  not to translate; but if we don't translate it[0m
 2783 |                  it will never match anything.  */[0m
 2784 |               c = TRANSLATE (c);[0m
 2785 |               goto normal_char;[0m
      | [0;1;32m                              
[0m      | [0;32m                              ;} 
[0m[1mregex.c:2792:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2792 |         normal_char:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mregex.c:2829:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2829 |   if (fixup_alt_jump)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 2830 |     STORE_JUMP (jump_past_alt, fixup_alt_jump, b);[0m
      | [0;1;32m                                                  
[0m[1mregex.c:2832:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2832 |   if (!COMPILE_STACK_EMPTY)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 2833 |     FREE_STACK_RETURN (REG_EPAREN);[0m
      | [0;1;32m                                   
[0m[1mregex.c:2837:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2837 |   if (syntax & RE_NO_POSIX_BACKTRACKING)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 2838 |     BUF_PUSH (succeed);[0m
      | [0;1;32m                       
[0m[1mregex.c:2902:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2902 | store_op1 (op, loc, arg)[0m
      | [0;1;32m^
[0m[1mregex.c:2915:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2915 | store_op2 (op, loc, arg1, arg2)[0m
      | [0;1;32m^
[0m[1mregex.c:2930:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2930 | insert_op1 (op, loc, arg, end)[0m
      | [0;1;32m^
[0m[1mregex.c:2939:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2939 |   while (pfrom != loc)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2940 |     *--pto = *--pfrom;[0m
      | [0;1;32m                      
[0m[1mregex.c:2949:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2949 | insert_op2 (op, loc, arg1, arg2, end)[0m
      | [0;1;32m^
[0m[1mregex.c:2958:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2958 |   while (pfrom != loc)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 2959 |     *--pto = *--pfrom;[0m
      | [0;1;32m                      
[0m[1mregex.c:2970:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2970 | at_begline_loc_p (pattern, p, syntax)[0m
      | [0;1;32m^
[0m[1mregex.c:2989:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 2989 | at_endline_loc_p (p, pend, syntax)[0m
      | [0;1;32m^
[0m[1mregex.c:3011:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3011 | group_in_compile_stack (compile_stack, regnum)[0m
      | [0;1;32m^
[0m[1mregex.c:3019:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3019 |        this_element--)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 3020 |     if (compile_stack.stack[this_element].regnum == regnum)[0m
 3021 |       return true;[0m
      | [0;1;32m                  
[0m[1mregex.c:3020:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3020 |     if (compile_stack.stack[this_element].regnum == regnum)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 3021 |       return true;[0m
      | [0;1;32m                  
[0m[1mregex.c:3039:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3039 | compile_range (p_ptr, pend, translate, syntax, b)[0m
      | [0;1;32m^
[0m[1mregex.c:3050:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3050 |   if (p == pend)[0m
      | [0;1;32m                ^
[0m      | [0;32m                 {
[0m 3051 |     return REG_ERANGE;[0m
      | [0;1;32m                      
[0m[1mregex.c:3069:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3069 |   if (range_start > range_end)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 3070 |     return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;[0m
      | [0;1;32m                                                                  
[0m[1mregex.c:3098:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3098 | re_compile_fastmap (bufp)[0m
      | [0;1;32m^
[0m[1mregex.c:3134:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3134 |   bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */[0m
      | [0;1;32m  ^
[0m[1mregex.c:106:21: [0m[0;1;36mnote: [0mexpanded from macro 'bzero'[0m
  106 | #define bzero(s, n)     memset ((s), 0, (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:3134:3: [0m[0;1;36mnote: [0mCall to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11[0m
 3134 |   bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */[0m
      | [0;1;32m  ^
[0m[1mregex.c:106:21: [0m[0;1;36mnote: [0mexpanded from macro 'bzero'[0m
  106 | #define bzero(s, n)     memset ((s), 0, (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:3154:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3154 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 3155 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:3170:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3170 |           bufp->can_be_null = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3171 |           goto done;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:3178:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3178 |           fastmap[p[1]] = 1;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3179 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:3183:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3183 |           for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3184 |             if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))[0m
 3185 |               fastmap[j] = 1;[0m
 3186 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:3183:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3183 |           for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 3184 |             if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))[0m
 3185 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3184:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3184 |             if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3185 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3191:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3191 |           for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3192 |             fastmap[j] = 1;[0m
 3193 | [0m
 3194 |           for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)[0m
 3195 |             if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))[0m
 3196 |               fastmap[j] = 1;[0m
 3197 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:3191:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3191 |           for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3192 |             fastmap[j] = 1;[0m
      | [0;1;32m                           
[0m[1mregex.c:3194:47: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3194 |           for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 3195 |             if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))[0m
 3196 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3195:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3195 |             if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 3196 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3201:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3201 |           for (j = 0; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3202 |             if (SYNTAX (j) == Sword)[0m
 3203 |               fastmap[j] = 1;[0m
 3204 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:3201:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3201 |           for (j = 0; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3202 |             if (SYNTAX (j) == Sword)[0m
 3203 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3202:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3202 |             if (SYNTAX (j) == Sword)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3203 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3208:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3208 |           for (j = 0; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3209 |             if (SYNTAX (j) != Sword)[0m
 3210 |               fastmap[j] = 1;[0m
 3211 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:3208:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3208 |           for (j = 0; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 3209 |             if (SYNTAX (j) != Sword)[0m
 3210 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3209:30: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3209 |             if (SYNTAX (j) != Sword)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 3210 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3219:44: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3219 |             for (j = 0; j < (1 << BYTEWIDTH); j++)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m 3220 |               fastmap[j] = 1;[0m
      | [0;1;32m                             
[0m[1mregex.c:3223:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3223 |             if (!(bufp->syntax & RE_DOT_NEWLINE))[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 3224 |               fastmap['\n'] = fastmap_newline;[0m
 3225 | [0m
 3226 |             /* Return if we have already set `can_be_null'; if we have,[0m
 3227 |                then the fastmap is irrelevant.  Something's wrong here.  */[0m
 3228 |             else if (bufp->can_be_null)[0m
      | [0;32m            } 
[0m[1mregex.c:3228:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3228 |             else if (bufp->can_be_null)[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m 3229 |               goto done;[0m
      | [0;1;32m                        
[0m[1mregex.c:3283:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3283 |           p += j;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:3284:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3284 |           if (j > 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3285 |             continue;[0m
      | [0;1;32m                     
[0m[1mregex.c:3293:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3293 |               && (re_opcode_t) *p != succeed_n)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 3294 |             continue;[0m
      | [0;1;32m                     
[0m[1mregex.c:3302:63: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3302 |               && fail_stack.stack[fail_stack.avail - 1].pointer == p)[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 3303 |             fail_stack.avail--;[0m
      | [0;1;32m                               
[0m[1mregex.c:3320:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3320 |           if (p + j < pend)[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:3322:20: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 3322 |               if (!PUSH_PATTERN_OP (p + j, fail_stack))[0m
      | [0;1;32m                   ^
[0m[1mregex.c:1180:9: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_PATTERN_OP'[0m
 1180 |     && !DOUBLE_FAIL_STACK (FAIL_STACK))                                 \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:3322:20: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 3322 |               if (!PUSH_PATTERN_OP (p + j, fail_stack))[0m
      | [0;1;32m                   ^
[0m[1mregex.c:1180:9: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_PATTERN_OP'[0m
 1180 |     && !DOUBLE_FAIL_STACK (FAIL_STACK))                                 \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:3328:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3328 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 3329 |             bufp->can_be_null = 1;[0m
      | [0;1;32m                                  
[0m[1mregex.c:3342:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3342 |           p += 2;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3343 | [0m
 3344 |           /* Increment p past the n for when k != 0.  */[0m
 3345 |           EXTRACT_NUMBER_AND_INCR (k, p);[0m
 3346 |           if (k == 0)[0m
 3347 |             {[0m
 3348 |               p -= 4;[0m
 3349 |               succeed_n_p = true;  /* Spaghetti code alert.  */[0m
 3350 |               goto handle_on_failure_jump;[0m
 3351 |             }[0m
 3352 |           continue;[0m
      | [0;1;32m                  
[0m      | [0;32m                  ;} 
[0m[1mregex.c:3356:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3356 |           p += 4;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 3357 |           continue;[0m
      | [0;1;32m                  
[0m      | [0;32m                  ;} 
[0m[1mregex.c:3363:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3363 |           continue;[0m
      | [0;1;32m          ^       
[0m      | [0;32m          {       ;} 
[0m[1mregex.c:3367:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 3367 |           abort (); /* We have listed all the cases.  */[0m
      | [0;1;32m          ^       
[0m      | [0;32m          {       ;} 
[0m[1mregex.c:3403:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3403 | re_set_registers (bufp, regs, num_regs, starts, ends)[0m
      | [0;1;32m^
[0m[1mregex.c:3430:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3430 | re_search (bufp, string, size, startpos, range, regs)[0m
      | [0;1;32m^
[0m[1mregex.c:3463:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3463 | re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)[0m
      | [0;1;32m^
[0m[1mregex.c:3479:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 3480 |     return -1;[0m
      | [0;1;32m              
[0m[1mregex.c:3485:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 3486 |     range = 0 - startpos;[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;32m  } 
[0m[1mregex.c:3487:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 3488 |     range = total_size - startpos;[0m
      | [0;1;32m                                  
[0m[1mregex.c:3494:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3494 |       if (startpos > 0)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 3495 |         return -1;[0m
 3496 |       else[0m
      | [0;32m      } 
[0m[1mregex.c:3496:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3496 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 3497 |         range = 1;[0m
      | [0;1;32m                  
[0m[1mregex.c:3512:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 3513 |     if (re_compile_fastmap (bufp) == -2)[0m
 3514 |       return -2;[0m
      | [0;1;32m                
[0m[1mregex.c:3513:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3513 |     if (re_compile_fastmap (bufp) == -2)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 3514 |       return -2;[0m
      | [0;1;32m                
[0m[1mregex.c:3531:65: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 3532 |                 lim = range - (size1 - startpos);[0m
      | [0;1;32m                                                 
[0m[1mregex.c:3538:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3538 |               if (translate)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 3539 |                 while (range > lim[0m
 3540 |                        && !fastmap[(unsigned char)[0m
 3541 |                                    translate[(unsigned char) *d++]])[0m
 3542 |                   range--;[0m
 3543 |               else[0m
      | [0;32m              } 
[0m[1mregex.c:3541:34: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3541 |                                    translate[(unsigned char) *d++]])[0m
      | [0;1;32m                                                             ^
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mAssuming field 'no_sub' is not equal to 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mregex.c:5638:41: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                                        ^
[0m[1mregex.c:5642:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5642 |   private_preg.not_bol = !!(eflags & REG_NOTBOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5643:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5643 |   private_preg.not_eol = !!(eflags & REG_NOTEOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5650:7: [0m[0;1;36mnote: [0m'want_reg_info' is 0[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:5650:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5662:20: [0m[0;1;36mnote: [0m'want_reg_info' is 0[0m
 5662 |                    want_reg_info ? &regs : (struct re_registers *) 0);[0m
      | [0;1;32m                   ^~~~~~~~~~~~~
[0m[1mregex.c:5662:20: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mregex.c:5660:9: [0m[0;1;36mnote: [0mCalling 're_search'[0m
 5660 |   ret = re_search (&private_preg, string, len,[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 5661 |                    /* start: */ 0, /* range: */ len,[0m
      | [0;1;32m                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 5662 |                    want_reg_info ? &regs : (struct re_registers *) 0);[0m
      | [0;1;32m                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3436:10: [0m[0;1;36mnote: [0mCalling 're_search_2'[0m
 3436 |   return re_search_2 (bufp, NULL, 0, string, size, startpos, range,[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3437 |                       regs, size);[0m
      | [0;1;32m                      ~~~~~~~~~~~
[0m[1mregex.c:3479:7: [0m[0;1;36mnote: [0m'startpos' is >= 0[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m      ^~~~~~~~
[0m[1mregex.c:3479:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3479:23: [0m[0;1;36mnote: [0mAssuming 'startpos' is <= 'total_size'[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3479:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3485:7: [0m[0;1;36mnote: [0m'endpos' is >= 0[0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m      ^~~~~~
[0m[1mregex.c:3485:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3487:12: [0m[0;1;36mnote: [0mAssuming 'endpos' is <= 'total_size'[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m           ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3487:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m       ^
[0m[1mregex.c:3492:7: [0m[0;1;36mnote: [0mAssuming field 'used' is <= 0[0m
 3492 |   if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mregex.c:3492:22: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3492 |   if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3512:7: [0m[0;1;36mnote: [0mAssuming 'fastmap' is non-null[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3512:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3512:18: [0m[0;1;36mnote: [0mAssuming field 'fastmap_accurate' is not equal to 0[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3512:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3517:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3517 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0m'fastmap' is non-null[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m          ^~~~~~~
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3523:22: [0m[0;1;36mnote: [0mAssuming 'startpos' is < 'total_size'[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m          ^
[0m[1mregex.c:3523:47: [0m[0;1;36mnote: [0mAssuming field 'can_be_null' is 0[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m                                              ^~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3523:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m      ^
[0m[1mregex.c:3525:8: [0m[0;1;36mnote: [0mAssuming 'range' is > 0[0m
 3525 |           if (range > 0)        /* Searching forwards.  */[0m
      | [0;1;32m              ^~~~~~~~~
[0m[1mregex.c:3525:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 3525 |           if (range > 0)        /* Searching forwards.  */[0m
      | [0;1;32m          ^
[0m[1mregex.c:3531:19: [0m[0;1;36mnote: [0mAssuming 'startpos' is < 'size1'[0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~
[0m[1mregex.c:3531:19: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3531:39: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3531:15: [0m[0;1;36mnote: [0mTaking false branch[0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m              ^
[0m[1mregex.c:3534:13: [0m[0;1;36mnote: [0m'startpos' is < 'size1'[0m
 3534 |               d = (startpos >= size1 ? string2 - size1 : string1) + startpos;[0m
      | [0;1;32m                   ^~~~~~~~
[0m[1mregex.c:3534:13: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mregex.c:3538:12: [0m[0;1;36mnote: [0mAssuming 'translate' is non-null[0m
 3538 |               if (translate)[0m
      | [0;1;32m                  ^~~~~~~~~
[0m[1mregex.c:3538:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 3538 |               if (translate)[0m
      | [0;1;32m              ^
[0m[1mregex.c:3539:24: [0m[0;1;36mnote: [0m'range' is > 'lim'[0m
 3539 |                 while (range > lim[0m
      | [0;1;32m                       ^~~~~
[0m[1mregex.c:3539:24: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3541:35: [0m[0;1;36mnote: [0mNull pointer value stored to 'd'[0m
 3541 |                                    translate[(unsigned char) *d++]])[0m
      | [0;1;32m                                                              ^~~
[0m[1mregex.c:3541:34: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3541 |                                    translate[(unsigned char) *d++]])[0m
      | [0;1;32m                                                             ^~~~
[0m[1mregex.c:3541:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3541 |                                    translate[(unsigned char) *d++]])[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 3542 |                   range--;[0m
      | [0;1;32m                          
[0m[1mregex.c:3543:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3543 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 3544 |                 while (range > lim && !fastmap[(unsigned char) *d++])[0m
 3545 |                   range--;[0m
      | [0;1;32m                          
[0m[1mregex.c:3544:64: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 3544 |                 while (range > lim && !fastmap[(unsigned char) *d++])[0m
      | [0;1;32m                                                               ^
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mAssuming field 'no_sub' is not equal to 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mregex.c:5638:41: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                                        ^
[0m[1mregex.c:5642:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5642 |   private_preg.not_bol = !!(eflags & REG_NOTBOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5643:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5643 |   private_preg.not_eol = !!(eflags & REG_NOTEOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5650:7: [0m[0;1;36mnote: [0m'want_reg_info' is 0[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:5650:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5662:20: [0m[0;1;36mnote: [0m'want_reg_info' is 0[0m
 5662 |                    want_reg_info ? &regs : (struct re_registers *) 0);[0m
      | [0;1;32m                   ^~~~~~~~~~~~~
[0m[1mregex.c:5662:20: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mregex.c:5660:9: [0m[0;1;36mnote: [0mCalling 're_search'[0m
 5660 |   ret = re_search (&private_preg, string, len,[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 5661 |                    /* start: */ 0, /* range: */ len,[0m
      | [0;1;32m                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 5662 |                    want_reg_info ? &regs : (struct re_registers *) 0);[0m
      | [0;1;32m                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3436:10: [0m[0;1;36mnote: [0mCalling 're_search_2'[0m
 3436 |   return re_search_2 (bufp, NULL, 0, string, size, startpos, range,[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3437 |                       regs, size);[0m
      | [0;1;32m                      ~~~~~~~~~~~
[0m[1mregex.c:3479:7: [0m[0;1;36mnote: [0m'startpos' is >= 0[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m      ^~~~~~~~
[0m[1mregex.c:3479:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3479:23: [0m[0;1;36mnote: [0mAssuming 'startpos' is <= 'total_size'[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3479:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3485:7: [0m[0;1;36mnote: [0m'endpos' is >= 0[0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m      ^~~~~~
[0m[1mregex.c:3485:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3487:12: [0m[0;1;36mnote: [0mAssuming 'endpos' is <= 'total_size'[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m           ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3487:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m       ^
[0m[1mregex.c:3492:7: [0m[0;1;36mnote: [0mAssuming field 'used' is <= 0[0m
 3492 |   if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mregex.c:3492:22: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3492 |   if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3512:7: [0m[0;1;36mnote: [0mAssuming 'fastmap' is non-null[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3512:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3512:18: [0m[0;1;36mnote: [0mAssuming field 'fastmap_accurate' is not equal to 0[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3512:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3517:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3517 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0m'fastmap' is non-null[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m          ^~~~~~~
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3523:22: [0m[0;1;36mnote: [0mAssuming 'startpos' is < 'total_size'[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m          ^
[0m[1mregex.c:3523:47: [0m[0;1;36mnote: [0mAssuming field 'can_be_null' is 0[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m                                              ^~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3523:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m      ^
[0m[1mregex.c:3525:8: [0m[0;1;36mnote: [0mAssuming 'range' is > 0[0m
 3525 |           if (range > 0)        /* Searching forwards.  */[0m
      | [0;1;32m              ^~~~~~~~~
[0m[1mregex.c:3525:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 3525 |           if (range > 0)        /* Searching forwards.  */[0m
      | [0;1;32m          ^
[0m[1mregex.c:3531:19: [0m[0;1;36mnote: [0mAssuming 'startpos' is < 'size1'[0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~
[0m[1mregex.c:3531:19: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3531:39: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m                                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3531:15: [0m[0;1;36mnote: [0mTaking false branch[0m
 3531 |               if (startpos < size1 && startpos + range >= size1)[0m
      | [0;1;32m              ^
[0m[1mregex.c:3534:13: [0m[0;1;36mnote: [0m'startpos' is < 'size1'[0m
 3534 |               d = (startpos >= size1 ? string2 - size1 : string1) + startpos;[0m
      | [0;1;32m                   ^~~~~~~~
[0m[1mregex.c:3534:13: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mregex.c:3538:12: [0m[0;1;36mnote: [0mAssuming 'translate' is null[0m
 3538 |               if (translate)[0m
      | [0;1;32m                  ^~~~~~~~~
[0m[1mregex.c:3538:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 3538 |               if (translate)[0m
      | [0;1;32m              ^
[0m[1mregex.c:3544:24: [0m[0;1;36mnote: [0m'range' is > 'lim'[0m
 3544 |                 while (range > lim && !fastmap[(unsigned char) *d++])[0m
      | [0;1;32m                       ^~~~~
[0m[1mregex.c:3544:24: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3544:65: [0m[0;1;36mnote: [0mNull pointer value stored to 'd'[0m
 3544 |                 while (range > lim && !fastmap[(unsigned char) *d++])[0m
      | [0;1;32m                                                                ^~~
[0m[1mregex.c:3544:64: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 3544 |                 while (range > lim && !fastmap[(unsigned char) *d++])[0m
      | [0;1;32m                                                               ^~~~
[0m[1mregex.c:3544:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3544 |                 while (range > lim && !fastmap[(unsigned char) *d++])[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 3545 |                   range--;[0m
      | [0;1;32m                          
[0m[1mregex.c:3553:36: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'string1') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 3553 |                                  : string1[startpos]);[0m
      | [0;1;32m                                   ^
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mAssuming field 'no_sub' is not equal to 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mregex.c:5638:41: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                                        ^
[0m[1mregex.c:5642:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5642 |   private_preg.not_bol = !!(eflags & REG_NOTBOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5643:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5643 |   private_preg.not_eol = !!(eflags & REG_NOTEOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5650:7: [0m[0;1;36mnote: [0m'want_reg_info' is 0[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:5650:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5662:20: [0m[0;1;36mnote: [0m'want_reg_info' is 0[0m
 5662 |                    want_reg_info ? &regs : (struct re_registers *) 0);[0m
      | [0;1;32m                   ^~~~~~~~~~~~~
[0m[1mregex.c:5662:20: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mregex.c:5660:9: [0m[0;1;36mnote: [0mCalling 're_search'[0m
 5660 |   ret = re_search (&private_preg, string, len,[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 5661 |                    /* start: */ 0, /* range: */ len,[0m
      | [0;1;32m                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 5662 |                    want_reg_info ? &regs : (struct re_registers *) 0);[0m
      | [0;1;32m                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3436:29: [0m[0;1;36mnote: [0mPassing null pointer value via 2nd parameter 'string1'[0m
 3436 |   return re_search_2 (bufp, NULL, 0, string, size, startpos, range,[0m
      | [0;1;32m                            ^
[0m[1m/home/C00536225/dev/tcc/build/lib/clang/21/include/__stddef_null.h:26:14: [0m[0;1;36mnote: [0mexpanded from macro 'NULL'[0m
   26 | #define NULL ((void*)0)[0m
      | [0;1;32m             ^~~~~~~~~~
[0m[1mregex.c:3436:10: [0m[0;1;36mnote: [0mCalling 're_search_2'[0m
 3436 |   return re_search_2 (bufp, NULL, 0, string, size, startpos, range,[0m
      | [0;1;32m         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3437 |                       regs, size);[0m
      | [0;1;32m                      ~~~~~~~~~~~
[0m[1mregex.c:3479:7: [0m[0;1;36mnote: [0m'startpos' is >= 0[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m      ^~~~~~~~
[0m[1mregex.c:3479:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3479:23: [0m[0;1;36mnote: [0mAssuming 'startpos' is <= 'total_size'[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3479:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3479 |   if (startpos < 0 || startpos > total_size)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3485:7: [0m[0;1;36mnote: [0m'endpos' is >= 0[0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m      ^~~~~~
[0m[1mregex.c:3485:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3485 |   if (endpos < 0)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3487:12: [0m[0;1;36mnote: [0mAssuming 'endpos' is <= 'total_size'[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m           ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3487:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 3487 |   else if (endpos > total_size)[0m
      | [0;1;32m       ^
[0m[1mregex.c:3492:7: [0m[0;1;36mnote: [0mAssuming field 'used' is <= 0[0m
 3492 |   if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~
[0m[1mregex.c:3492:22: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3492 |   if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3512:7: [0m[0;1;36mnote: [0mAssuming 'fastmap' is non-null[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3512:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3512:18: [0m[0;1;36mnote: [0mAssuming field 'fastmap_accurate' is not equal to 0[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3512:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3512 |   if (fastmap && !bufp->fastmap_accurate)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3517:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3517 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0m'fastmap' is non-null[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m          ^~~~~~~
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3523:22: [0m[0;1;36mnote: [0mAssuming 'startpos' is < 'total_size'[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3523:11: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m          ^
[0m[1mregex.c:3523:47: [0m[0;1;36mnote: [0mAssuming field 'can_be_null' is 0[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m                                              ^~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3523:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 3523 |       if (fastmap && startpos < total_size && !bufp->can_be_null)[0m
      | [0;1;32m      ^
[0m[1mregex.c:3525:8: [0m[0;1;36mnote: [0mAssuming 'range' is <= 0[0m
 3525 |           if (range > 0)        /* Searching forwards.  */[0m
      | [0;1;32m              ^~~~~~~~~
[0m[1mregex.c:3525:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 3525 |           if (range > 0)        /* Searching forwards.  */[0m
      | [0;1;32m          ^
[0m[1mregex.c:3551:27: [0m[0;1;36mnote: [0m'size1' is not equal to 0[0m
 3551 |               register char c = (size1 == 0 || startpos >= size1[0m
      | [0;1;32m                                 ^~~~~
[0m[1mregex.c:3551:27: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3551:41: [0m[0;1;36mnote: [0m'startpos' is < 'size1'[0m
 3551 |               register char c = (size1 == 0 || startpos >= size1[0m
      | [0;1;32m                                               ^~~~~~~~
[0m[1mregex.c:3551:27: [0m[0;1;36mnote: [0m'?' condition is false[0m
 3551 |               register char c = (size1 == 0 || startpos >= size1[0m
      | [0;1;32m                                 ^
[0m[1mregex.c:3553:36: [0m[0;1;36mnote: [0mArray access (from variable 'string1') results in a null pointer dereference[0m
 3553 |                                  : string1[startpos]);[0m
      | [0;1;32m                                   ^~~~~~~
[0m[1mregex.c:3555:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3555 |               if (!fastmap[(unsigned char) TRANSLATE (c)])[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                           {
[0m 3556 |                 goto advance;[0m
      | [0;1;32m                             
[0m[1mregex.c:3562:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3562 |           && !bufp->can_be_null)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m 3563 |         return -1;[0m
      | [0;1;32m                  
[0m[1mregex.c:3565:33: [0m[0;1;35mwarning: [0m[1mpassing arguments to 're_match_2_internal' without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3565 |       val = re_match_2_internal (bufp, string1, size1, string2, size2,[0m
      | [0;1;32m                                ^
[0m[1mregex.c:3573:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3573 |       if (val >= 0)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 3574 |         return startpos;[0m
      | [0;1;32m                        
[0m[1mregex.c:3576:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3576 |       if (val == -2)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 3577 |         return -2;[0m
      | [0;1;32m                  
[0m[1mregex.c:3580:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 3580 |       if (!range)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 3581 |         break;[0m
 3582 |       else if (range > 0)[0m
      | [0;32m      } 
[0m[1mregex.c:3681:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3681 | re_match (bufp, string, size, pos, regs)[0m
      | [0;1;32m^
[0m[1mregex.c:3687:36: [0m[0;1;35mwarning: [0m[1mpassing arguments to 're_match_2_internal' without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3687 |   int result = re_match_2_internal (bufp, NULL, 0, string, size,[0m
      | [0;1;32m                                   ^
[0m[1mregex.c:3724:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3724 | re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)[0m
      | [0;1;32m^
[0m[1mregex.c:3732:36: [0m[0;1;35mwarning: [0m[1mpassing arguments to 're_match_2_internal' without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3732 |   int result = re_match_2_internal (bufp, string1, size1, string2, size2,[0m
      | [0;1;32m                                   ^
[0m[1mregex.c:3745:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 3745 | re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)[0m
      | [0;1;32m^
[0m[1mregex.c:4008:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4008 |               if (same_str_p)[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 4009 |                 best_match_p = d > match_end;[0m
 4010 |               else[0m
      | [0;32m              } 
[0m[1mregex.c:4010:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4010 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 4011 |                 best_match_p = !MATCHING_IN_FIRST_STRING;[0m
      | [0;1;32m                                                         
[0m[1mregex.c:4120:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4120 |                   if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m 4121 |                     regs->start[mcnt] = regs->end[mcnt] = -1;[0m
 4122 |                   else[0m
      | [0;32m                  } 
[0m[1mregex.c:4136:78: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4136 |               for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)[0m
      | [0;1;32m                                                                             ^
[0m      | [0;32m                                                                              {
[0m 4137 |                 regs->start[mcnt] = regs->end[mcnt] = -1;[0m
      | [0;1;32m                                                         
[0m[1mregex.c:4161:46: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4161 |           DEBUG_PRINT1 ("EXECUTING no_op.\n");[0m
      | [0;1;32m                                             ^
[0m      | [0;32m                                             {
[0m 4162 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:4165:48: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4165 |           DEBUG_PRINT1 ("EXECUTING succeed.\n");[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                               {
[0m 4166 |           goto succeed_label;[0m
      | [0;1;32m                            
[0m      | [0;32m                            ;} 
[0m[1mregex.c:4172:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4172 |           mcnt = *p++;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:4183:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4183 |                       != (unsigned char) *p++)[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 4184 |                     goto fail;[0m
      | [0;1;32m                              
[0m[1mregex.c:4193:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4193 |                   if (*d++ != (char) *p++) goto fail;[0m
      | [0;1;32m                                          ^          
[0m      | [0;32m                                           {
[0m[1mregex.c:4203:48: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4203 |           DEBUG_PRINT1 ("EXECUTING anychar.\n");[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                               {
[0m 4204 | [0m
 4205 |           PREFETCH ();[0m
 4206 | [0m
 4207 |           if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')[0m
 4208 |               || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))[0m
 4209 |             goto fail;[0m
 4210 | [0m
 4211 |           SET_REGS_MATCHED ();[0m
 4212 |           DEBUG_PRINT2 ("  Matched `%d'.\n", *d);[0m
 4213 |           d++;[0m
 4214 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:4208:79: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4208 |               || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m 4209 |             goto fail;[0m
      | [0;1;32m                      
[0m[1mregex.c:4231:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4231 |                 && p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))[0m
      | [0;1;32m                                                                 ^
[0m      | [0;32m                                                                  {
[0m 4232 |               not = !not;[0m
      | [0;1;32m                         
[0m[1mregex.c:4236:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4236 |             if (!not) goto fail;[0m
      | [0;1;32m                     ^          
[0m      | [0;32m                      {
[0m[1mregex.c:4250:64: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4250 |           DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                      {
[0m[1mregex.c:4255:15: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m              ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3908:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'reg_info'[0m
 3908 |       reg_info = reg_info_dummy = (register_info_type *) NULL;[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case start_memory:'  at line 4249[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4255:15: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m              ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4255:54: [0m[0;1;35mwarning: [0m[1mThe left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult][0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m                                                     ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is not equal to 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3891:18: [0m[0;1;36mnote: [0mUninitialized value stored to field 'match_null_string_p'[0m
 3891 |       reg_info = REGEX_TALLOC (num_regs, register_info_type);[0m
      | [0;1;32m                 ^
[0m[1mregex.c:324:35: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_TALLOC'[0m
  324 | #define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))[0m
      | [0;1;32m                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:268:24: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_ALLOCATE'[0m
  268 | #define REGEX_ALLOCATE alloca[0m
      | [0;1;32m                       ^
[0m[1m/usr/include/alloca.h:35:23: [0m[0;1;36mnote: [0mexpanded from macro 'alloca'[0m
   35 | # define alloca(size)   __builtin_alloca (size)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0m'regstart' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3895:25: [0m[0;1;36mnote: [0m'regend' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:35: [0m[0;1;36mnote: [0m'old_regstart' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                                  ^~~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:51: [0m[0;1;36mnote: [0m'old_regend' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                                                  ^~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:65: [0m[0;1;36mnote: [0m'reg_info' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                                                                ^~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3896:16: [0m[0;1;36mnote: [0m'best_regstart' is non-null[0m
 3896 |             && best_regstart && best_regend && reg_dummy && reg_info_dummy))[0m
      | [0;1;32m               ^~~~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3896:33: [0m[0;1;36mnote: [0m'best_regend' is non-null[0m
 3896 |             && best_regstart && best_regend && reg_dummy && reg_info_dummy))[0m
      | [0;1;32m                                ^~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3896:48: [0m[0;1;36mnote: [0m'reg_dummy' is non-null[0m
 3896 |             && best_regstart && best_regend && reg_dummy && reg_info_dummy))[0m
      | [0;1;32m                                               ^~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m      ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:18: [0m[0;1;36mnote: [0mAssuming 'mcnt' is < 'num_regs'[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:18: [0m[0;1;36mnote: [0mAssuming 'mcnt' is >= 'num_regs'[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case start_memory:'  at line 4249[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4255:54: [0m[0;1;36mnote: [0mThe left operand of '==' is a garbage value[0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m                                                     ^
[0m[1mregex.c:4255:80: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 4256 |             REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
 4257 |               = group_match_null_string_p (&p1, pend, reg_info);[0m
      | [0;1;32m                                                                
[0m[1mregex.c:4257:15: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4257 |               = group_match_null_string_p (&p1, pend, reg_info);[0m
      | [0;1;32m              ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3908:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'reg_info'[0m
 3908 |       reg_info = reg_info_dummy = (register_info_type *) NULL;[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is > 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case set_number_at:'  at line 4920[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4932:6: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4932 |             STORE_NUMBER (p1, mcnt);[0m
      | [0;1;32m            ^
[0m[1mregex.c:485:3: [0m[0;1;36mnote: [0mexpanded from macro 'STORE_NUMBER'[0m
  485 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4933:13: [0m[0;1;36mnote: [0m Execution continues on line 5074[0m
 4933 |             break;[0m
      | [0;1;32m            ^
[0m[1mregex.c:5074:7: [0m[0;1;36mnote: [0m Execution continues on line 3983[0m
 5074 |       continue;  /* Successfully executed one pattern command; keep going.  */[0m
      | [0;1;32m      ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case start_memory:'  at line 4249[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4255:15: [0m[0;1;36mnote: [0mAssuming field 'match_null_string_p' is equal to MATCH_NULL_UNSET_VALUE[0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m              ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:4255:11: [0m[0;1;36mnote: [0mTaking true branch[0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m          ^
[0m[1mregex.c:4257:15: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4257 |               = group_match_null_string_p (&p1, pend, reg_info);[0m
      | [0;1;32m              ^
[0m[1mregex.c:4284:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4284 |           if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m 4285 |             lowest_active_reg = *p;[0m
      | [0;1;32m                                   
[0m[1mregex.c:4298:63: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4298 |           DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                     {
[0m[1mregex.c:4305:28: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3908:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'reg_info'[0m
 3908 |       reg_info = reg_info_dummy = (register_info_type *) NULL;[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case stop_memory:'  at line 4297[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4305:28: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4305:28: [0m[0;1;35mwarning: [0m[1mBranch condition evaluates to a garbage value [clang-analyzer-core.uninitialized.Branch][0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is not equal to 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3891:18: [0m[0;1;36mnote: [0mUninitialized value stored to field 'match_null_string_p'[0m
 3891 |       reg_info = REGEX_TALLOC (num_regs, register_info_type);[0m
      | [0;1;32m                 ^
[0m[1mregex.c:324:35: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_TALLOC'[0m
  324 | #define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))[0m
      | [0;1;32m                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:268:24: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_ALLOCATE'[0m
  268 | #define REGEX_ALLOCATE alloca[0m
      | [0;1;32m                       ^
[0m[1m/usr/include/alloca.h:35:23: [0m[0;1;36mnote: [0mexpanded from macro 'alloca'[0m
   35 | # define alloca(size)   __builtin_alloca (size)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0m'regstart' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3895:25: [0m[0;1;36mnote: [0m'regend' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:35: [0m[0;1;36mnote: [0m'old_regstart' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                                  ^~~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:51: [0m[0;1;36mnote: [0m'old_regend' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                                                  ^~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:65: [0m[0;1;36mnote: [0m'reg_info' is non-null[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m                                                                ^~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3896:16: [0m[0;1;36mnote: [0m'best_regstart' is non-null[0m
 3896 |             && best_regstart && best_regend && reg_dummy && reg_info_dummy))[0m
      | [0;1;32m               ^~~~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3896:33: [0m[0;1;36mnote: [0m'best_regend' is non-null[0m
 3896 |             && best_regstart && best_regend && reg_dummy && reg_info_dummy))[0m
      | [0;1;32m                                ^~~~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3896:48: [0m[0;1;36mnote: [0m'reg_dummy' is non-null[0m
 3896 |             && best_regstart && best_regend && reg_dummy && reg_info_dummy))[0m
      | [0;1;32m                                               ^~~~~~~~~
[0m[1mregex.c:3895:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m            ^
[0m[1mregex.c:3895:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3895 |       if (!(regstart && regend && old_regstart && old_regend && reg_info[0m
      | [0;1;32m      ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:18: [0m[0;1;36mnote: [0mAssuming 'mcnt' is < 'num_regs'[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:18: [0m[0;1;36mnote: [0mAssuming 'mcnt' is >= 'num_regs'[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case stop_memory:'  at line 4297[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4305:28: [0m[0;1;36mnote: [0mBranch condition evaluates to a garbage value[0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4333:32: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4333 |               while (r > 0 && !IS_ACTIVE (reg_info[r]))[0m
      | [0;1;32m                               ^
[0m[1mregex.c:1447:23: [0m[0;1;36mnote: [0mexpanded from macro 'IS_ACTIVE'[0m
 1447 | #define IS_ACTIVE(R)  ((R).bits.is_active)[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3908:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'reg_info'[0m
 3908 |       reg_info = reg_info_dummy = (register_info_type *) NULL;[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is > 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case set_number_at:'  at line 4920[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4932:6: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4932 |             STORE_NUMBER (p1, mcnt);[0m
      | [0;1;32m            ^
[0m[1mregex.c:485:3: [0m[0;1;36mnote: [0mexpanded from macro 'STORE_NUMBER'[0m
  485 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4933:13: [0m[0;1;36mnote: [0m Execution continues on line 5074[0m
 4933 |             break;[0m
      | [0;1;32m            ^
[0m[1mregex.c:5074:7: [0m[0;1;36mnote: [0m Execution continues on line 3983[0m
 5074 |       continue;  /* Successfully executed one pattern command; keep going.  */[0m
      | [0;1;32m      ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case stop_memory:'  at line 4297[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4305:28: [0m[0;1;36mnote: [0mAssuming field 'match_null_string_p' is 0[0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4305:28: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:4322:15: [0m[0;1;36mnote: [0m'lowest_active_reg' is not equal to 'highest_active_reg'[0m
 4322 |           if (lowest_active_reg == highest_active_reg)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~
[0m[1mregex.c:4322:11: [0m[0;1;36mnote: [0mTaking false branch[0m
 4322 |           if (lowest_active_reg == highest_active_reg)[0m
      | [0;1;32m          ^
[0m[1mregex.c:4333:22: [0m[0;1;36mnote: [0mAssuming 'r' is > 0[0m
 4333 |               while (r > 0 && !IS_ACTIVE (reg_info[r]))[0m
      | [0;1;32m                     ^~~~~
[0m[1mregex.c:4333:22: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:4333:32: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4333 |               while (r > 0 && !IS_ACTIVE (reg_info[r]))[0m
      | [0;1;32m                               ^
[0m[1mregex.c:1447:23: [0m[0;1;36mnote: [0mexpanded from macro 'IS_ACTIVE'[0m
 1447 | #define IS_ACTIVE(R)  ((R).bits.is_active)[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4333:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4333 |               while (r > 0 && !IS_ACTIVE (reg_info[r]))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 4334 |                 r--;[0m
      | [0;1;32m                    
[0m[1mregex.c:4348:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4348 |               else[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 4349 |                 highest_active_reg = r;[0m
      | [0;1;32m                                       
[0m[1mregex.c:4368:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4368 |                     is_a_jump_n = true;[0m
      | [0;1;32m                    ^                 
[0m      | [0;32m                    {                 ;} 
[0m[1mregex.c:4374:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4374 |                     if (is_a_jump_n)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                    {
[0m 4375 |                       p1 += 2;[0m
 4376 |                     break;[0m
      | [0;1;32m                         
[0m      | [0;32m                         ;} 
[0m[1mregex.c:4374:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4374 |                     if (is_a_jump_n)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 4375 |                       p1 += 2;[0m
      | [0;1;32m                              
[0m[1mregex.c:4379:38: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4379 |                     /* do nothing */ ;[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                     {;} 
[0m[1mregex.c:4411:41: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'old_regstart') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 4411 |                           regstart[r] = old_regstart[r];[0m
      | [0;1;32m                                        ^~~~~~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3906:27: [0m[0;1;36mnote: [0mNull pointer value stored to 'old_regstart'[0m
 3906 |       regstart = regend = old_regstart = old_regend = best_regstart[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3907 |         = best_regend = reg_dummy = NULL;[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is > 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case set_number_at:'  at line 4920[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4932:6: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4932 |             STORE_NUMBER (p1, mcnt);[0m
      | [0;1;32m            ^
[0m[1mregex.c:485:3: [0m[0;1;36mnote: [0mexpanded from macro 'STORE_NUMBER'[0m
  485 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4933:13: [0m[0;1;36mnote: [0m Execution continues on line 5074[0m
 4933 |             break;[0m
      | [0;1;32m            ^
[0m[1mregex.c:5074:7: [0m[0;1;36mnote: [0m Execution continues on line 3983[0m
 5074 |       continue;  /* Successfully executed one pattern command; keep going.  */[0m
      | [0;1;32m      ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case stop_memory:'  at line 4297[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4305:28: [0m[0;1;36mnote: [0mAssuming field 'match_null_string_p' is 0[0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4305:28: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4305 |           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])[0m
      | [0;1;32m                           ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:4322:15: [0m[0;1;36mnote: [0m'lowest_active_reg' is not equal to 'highest_active_reg'[0m
 4322 |           if (lowest_active_reg == highest_active_reg)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~~~~
[0m[1mregex.c:4322:11: [0m[0;1;36mnote: [0mTaking false branch[0m
 4322 |           if (lowest_active_reg == highest_active_reg)[0m
      | [0;1;32m          ^
[0m[1mregex.c:4333:22: [0m[0;1;36mnote: [0mAssuming 'r' is <= 0[0m
 4333 |               while (r > 0 && !IS_ACTIVE (reg_info[r]))[0m
      | [0;1;32m                     ^~~~~
[0m[1mregex.c:4333:28: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 4333 |               while (r > 0 && !IS_ACTIVE (reg_info[r]))[0m
      | [0;1;32m                           ^
[0m[1mregex.c:4343:12: [0m[0;1;36mnote: [0m'r' is equal to 0[0m
 4343 |               if (r == 0)[0m
      | [0;1;32m                  ^
[0m[1mregex.c:4343:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 4343 |               if (r == 0)[0m
      | [0;1;32m              ^
[0m[1mregex.c:4357:16: [0m[0;1;36mnote: [0mAssuming field 'matched_something' is 0[0m
 4357 |           if ((!MATCHED_SOMETHING (reg_info[*p])[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4358:16: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 4358 |                || just_past_start_mem == p - 1)[0m
      | [0;1;32m               ^
[0m[1mregex.c:4359:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4359 |               && (p + 2) < pend)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~
[0m[1mregex.c:4357:11: [0m[0;1;36mnote: [0mTaking true branch[0m
 4357 |           if ((!MATCHED_SOMETHING (reg_info[*p])[0m
      | [0;1;32m          ^
[0m[1mregex.c:4365:15: [0m[0;1;36mnote: [0mControl jumps to 'case dummy_failure_jump:'  at line 4372[0m
 4365 |               switch ((re_opcode_t) *p1++)[0m
      | [0;1;32m              ^
[0m[1mregex.c:4373:21: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4373 |                     EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
      | [0;1;32m                    ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4373:21: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4373 |                     EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
      | [0;1;32m                    ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4374:11: [0m[0;1;36mnote: [0m'is_a_jump_n' is 0[0m
 4374 |                     if (is_a_jump_n)[0m
      | [0;1;32m                        ^~~~~~~~~~~
[0m[1mregex.c:4374:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 4374 |                     if (is_a_jump_n)[0m
      | [0;1;32m                    ^
[0m[1mregex.c:4376:21: [0m[0;1;36mnote: [0m Execution continues on line 4381[0m
 4376 |                     break;[0m
      | [0;1;32m                    ^
[0m[1mregex.c:4388:19: [0m[0;1;36mnote: [0mAssuming 'mcnt' is < 0[0m
 4388 |               if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump[0m
      | [0;1;32m                  ^~~~~~~~
[0m[1mregex.c:4388:19: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:4388:31: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4388 |               if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump[0m
      | [0;1;32m                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4388:19: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 4388 |               if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump[0m
      | [0;1;32m                  ^
[0m[1mregex.c:4389:22: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4389 |                   && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)[0m
      | [0;1;32m                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4388:19: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 4388 |               if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump[0m
      | [0;1;32m                  ^
[0m[1mregex.c:4389:61: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4389 |                   && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)[0m
      | [0;1;32m                                                            ^~~~~~~~~~~
[0m[1mregex.c:4388:15: [0m[0;1;36mnote: [0mTaking true branch[0m
 4388 |               if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump[0m
      | [0;1;32m              ^
[0m[1mregex.c:4401:23: [0m[0;1;36mnote: [0mAssuming field 'ever_matched_something' is not equal to 0[0m
 4401 |                   if (EVER_MATCHED_SOMETHING (reg_info[*p]))[0m
      | [0;1;32m                      ^
[0m[1mregex.c:1449:36: [0m[0;1;36mnote: [0mexpanded from macro 'EVER_MATCHED_SOMETHING'[0m
 1449 | #define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)[0m
      | [0;1;32m                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4401:19: [0m[0;1;36mnote: [0mTaking true branch[0m
 4401 |                   if (EVER_MATCHED_SOMETHING (reg_info[*p]))[0m
      | [0;1;32m                  ^
[0m[1mregex.c:4408:23: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 4408 |                       for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);[0m
      | [0;1;32m                      ^
[0m[1mregex.c:4411:41: [0m[0;1;36mnote: [0mArray access (from variable 'old_regstart') results in a null pointer dereference[0m
 4411 |                           regstart[r] = old_regstart[r];[0m
      | [0;1;32m                                        ^~~~~~~~~~~~
[0m[1mregex.c:4414:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4414 |                           if (old_regend[r] >= regstart[r])[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 4415 |                             regend[r] = old_regend[r];[0m
      | [0;1;32m                                                      
[0m[1mregex.c:4420:19: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4420 |                   PUSH_FAILURE_POINT (p1 + mcnt, d, -2);[0m
      | [0;1;32m                  ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4420:19: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4420 |                   PUSH_FAILURE_POINT (p1 + mcnt, d, -2);[0m
      | [0;1;32m                  ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4434:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4434 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:4440:17: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'regstart') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 4440 |             if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))[0m
      | [0;1;32m                ^
[0m[1mregex.c:1475:23: [0m[0;1;36mnote: [0mexpanded from macro 'REG_UNSET'[0m
 1475 | #define REG_UNSET(e) ((e) == REG_UNSET_VALUE)[0m
      | [0;1;32m                      ^~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3906:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'regstart'[0m
 3906 |       regstart = regend = old_regstart = old_regend = best_regstart[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3907 |         = best_regend = reg_dummy = NULL;[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case duplicate:'  at line 4433[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4440:17: [0m[0;1;36mnote: [0mArray access (from variable 'regstart') results in a null pointer dereference[0m
 4440 |             if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))[0m
      | [0;1;32m                ^
[0m[1mregex.c:1475:23: [0m[0;1;36mnote: [0mexpanded from macro 'REG_UNSET'[0m
 1475 | #define REG_UNSET(e) ((e) == REG_UNSET_VALUE)[0m
      | [0;1;32m                      ^~
[0m[1mregex.c:4440:74: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4440 |             if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))[0m
      | [0;1;32m                                                                         ^
[0m      | [0;32m                                                                          {
[0m 4441 |               goto fail;[0m
      | [0;1;32m                        
[0m[1mregex.c:4460:32: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4460 |                     if (dend2 == end_match_2) break;[0m
      | [0;1;32m                                             ^      
[0m      | [0;32m                                              {
[0m[1mregex.c:4461:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4461 |                     if (dend2 == regend[regno]) break;[0m
      | [0;1;32m                                               ^      
[0m      | [0;32m                                                {
[0m[1mregex.c:4468:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4468 |                 if (d2 == dend2) break;[0m
      | [0;1;32m                                ^      
[0m      | [0;32m                                 {
[0m[1mregex.c:4478:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4478 |                 if (mcnt > dend2 - d2)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 4479 |                   mcnt = dend2 - d2;[0m
      | [0;1;32m                                    
[0m[1mregex.c:4485:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4485 |                     : bcmp (d, d2, mcnt))[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 4486 |                   goto fail;[0m
      | [0;1;32m                            
[0m[1mregex.c:4500:48: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4500 |           DEBUG_PRINT1 ("EXECUTING begline.\n");[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                               {
[0m 4501 | [0m
 4502 |           if (AT_STRINGS_BEG (d))[0m
 4503 |             {[0m
 4504 |               if (!bufp->not_bol) break;[0m
 4505 |             }[0m
 4506 |           else if (d[-1] == '\n' && bufp->newline_anchor)[0m
 4507 |             {[0m
 4508 |               break;[0m
 4509 |             }[0m
 4510 |           /* In all other cases, we fail.  */[0m
 4511 |           goto fail;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:4504:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4504 |               if (!bufp->not_bol) break;[0m
      | [0;1;32m                                 ^      
[0m      | [0;32m                                  {
[0m[1mregex.c:4516:48: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4516 |           DEBUG_PRINT1 ("EXECUTING endline.\n");[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                               {
[0m 4517 | [0m
 4518 |           if (AT_STRINGS_END (d))[0m
 4519 |             {[0m
 4520 |               if (!bufp->not_eol) break;[0m
 4521 |             }[0m
 4522 | [0m
 4523 |           /* We have to ``prefetch'' the next character.  */[0m
 4524 |           else if ((d == end1 ? *string2 : *d) == '\n'[0m
 4525 |                    && bufp->newline_anchor)[0m
 4526 |             {[0m
 4527 |               break;[0m
 4528 |             }[0m
 4529 |           goto fail;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:4520:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4520 |               if (!bufp->not_eol) break;[0m
      | [0;1;32m                                 ^      
[0m      | [0;32m                                  {
[0m[1mregex.c:4524:33: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'string2') [clang-analyzer-core.NullDereference][0m
 4524 |           else if ((d == end1 ? *string2 : *d) == '\n'[0m
      | [0;1;32m                                ^~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case endline:'  at line 4515[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4518:15: [0m[0;1;36mnote: [0mAssuming 'd' is not equal to 'end2'[0m
 4518 |           if (AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3624:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_END'[0m
 3624 | #define AT_STRINGS_END(d) ((d) == end2)[0m
      | [0;1;32m                           ^~~~~~~~~~~
[0m[1mregex.c:4518:11: [0m[0;1;36mnote: [0mTaking false branch[0m
 4518 |           if (AT_STRINGS_END (d))[0m
      | [0;1;32m          ^
[0m[1mregex.c:4524:21: [0m[0;1;36mnote: [0mAssuming 'd' is equal to 'end1'[0m
 4524 |           else if ((d == end1 ? *string2 : *d) == '\n'[0m
      | [0;1;32m                    ^~~~~~~~~
[0m[1mregex.c:4524:21: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mregex.c:4524:33: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'string2')[0m
 4524 |           else if ((d == end1 ? *string2 : *d) == '\n'[0m
      | [0;1;32m                                ^~~~~~~~
[0m[1mregex.c:4534:47: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4534 |           DEBUG_PRINT1 ("EXECUTING begbuf.\n");[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                              {
[0m 4535 |           if (AT_STRINGS_BEG (d))[0m
 4536 |             break;[0m
 4537 |           goto fail;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:4535:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4535 |           if (AT_STRINGS_BEG (d))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4536 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:4542:47: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4542 |           DEBUG_PRINT1 ("EXECUTING endbuf.\n");[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                              {
[0m 4543 |           if (AT_STRINGS_END (d))[0m
 4544 |             break;[0m
 4545 |           goto fail;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:4543:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4543 |           if (AT_STRINGS_END (d))[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 4544 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:4565:65: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4565 |           DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                {
[0m 4566 | [0m
 4567 |           EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
 4568 | #ifdef _LIBC[0m
 4569 |           DEBUG_PRINT3 (" %d (to %p):\n", mcnt, p + mcnt);[0m
 4570 | #else[0m
 4571 |           DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);[0m
 4572 | #endif[0m
 4573 | [0m
 4574 |           PUSH_FAILURE_POINT (p + mcnt, NULL, -2);[0m
 4575 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:4574:11: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4574 |           PUSH_FAILURE_POINT (p + mcnt, NULL, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4574:11: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4574 |           PUSH_FAILURE_POINT (p + mcnt, NULL, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4591:9: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4591 |         on_failure:[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m[1mregex.c:4616:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4616 |           while (p1 < pend && (re_opcode_t) *p1 == no_op)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 4617 |             p1++;[0m
      | [0;1;32m                 
[0m[1mregex.c:4626:61: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4626 |               if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m 4627 |                 lowest_active_reg = *(p1 + 1);[0m
      | [0;1;32m                                              
[0m[1mregex.c:4631:11: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'regstart') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1269:4: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1269 |           PUSH_FAILURE_POINTER (regstart[this_reg]);                    \[0m
      | [0;1;32m          ^                     ~~~~~~~~
[0m[1mregex.c:1189:68: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINTER'[0m
 1189 |   fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)[0m
      | [0;1;32m                                                                   ^~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3906:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'regstart'[0m
 3906 |       regstart = regend = old_regstart = old_regend = best_regstart[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3907 |         = best_regend = reg_dummy = NULL;[0m
      | [0;1;32m        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is > 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case on_failure_jump:'  at line 4590[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4594:11: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4594 |           EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m          ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4594:11: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4594 |           EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m          ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4616:18: [0m[0;1;36mnote: [0mAssuming 'p1' is < 'pend'[0m
 4616 |           while (p1 < pend && (re_opcode_t) *p1 == no_op)[0m
      | [0;1;32m                 ^~~~~~~~~
[0m[1mregex.c:4616:18: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:4616:31: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 4616 |           while (p1 < pend && (re_opcode_t) *p1 == no_op)[0m
      | [0;1;32m                              ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4616:11: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 4619[0m
 4616 |           while (p1 < pend && (re_opcode_t) *p1 == no_op)[0m
      | [0;1;32m          ^
[0m[1mregex.c:4619:15: [0m[0;1;36mnote: [0m'p1' is < 'pend'[0m
 4619 |           if (p1 < pend && (re_opcode_t) *p1 == start_memory)[0m
      | [0;1;32m              ^~
[0m[1mregex.c:4619:15: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:4619:28: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4619 |           if (p1 < pend && (re_opcode_t) *p1 == start_memory)[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4619:11: [0m[0;1;36mnote: [0mTaking true branch[0m
 4619 |           if (p1 < pend && (re_opcode_t) *p1 == start_memory)[0m
      | [0;1;32m          ^
[0m[1mregex.c:4626:15: [0m[0;1;36mnote: [0mTaking true branch[0m
 4626 |               if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)[0m
      | [0;1;32m              ^
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1248:36: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1248 |     while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)                   \[0m
      | [0;1;32m                                   ^
[0m[1mregex.c:1325:6: [0m[0;1;36mnote: [0mexpanded from macro 'NUM_FAILURE_ITEMS'[0m
 1325 |   (((0                                                  \[0m
      | [0;1;32m     ^
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1248:12: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1248 |     while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)                   \[0m
      | [0;1;32m           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1331:31: [0m[0;1;36mnote: [0mexpanded from macro 'REMAINING_AVAIL_SLOTS'[0m
 1331 | #define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)[0m
      | [0;1;32m                              ^
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 4631[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1248:5: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1248 |     while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)                   \[0m
      | [0;1;32m    ^
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mTaking true branch[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1261:5: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1261 |     if (1)                                                              \[0m
      | [0;1;32m    ^
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mAssuming 'this_reg' is <= 'highest_active_reg'[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1262:42: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1262 |       for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; \[0m
      | [0;1;32m                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1262:7: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1262 |       for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; \[0m
      | [0;1;32m      ^
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mArray access (from variable 'regstart') results in a null pointer dereference[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1269:4: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1269 |           PUSH_FAILURE_POINTER (regstart[this_reg]);                    \[0m
      | [0;1;32m          ^                     ~~~~~~~~
[0m[1mregex.c:1189:68: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINTER'[0m
 1189 |   fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)[0m
      | [0;1;32m                                                                   ^~~~~
[0m[1mregex.c:4631:11: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4631:11: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4631 |           PUSH_FAILURE_POINT (p + mcnt, d, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4638:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4638 |           EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4664:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4664 |                         || (re_opcode_t) *p2 == start_memory))[0m
      | [0;1;32m                                                              ^
[0m      | [0;32m                                                               {
[0m 4665 |                   p2 += 3;[0m
 4666 |                 else if (p2 + 6 < pend[0m
      | [0;32m                } 
[0m[1mregex.c:4667:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4667 |                          && (re_opcode_t) *p2 == dummy_failure_jump)[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m 4668 |                   p2 += 6;[0m
 4669 |                 else[0m
      | [0;32m                } 
[0m[1mregex.c:4669:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4669 |                 else[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 4670 |                   break;[0m
      | [0;1;32m                        
[0m[1mregex.c:4708:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4708 |                         && p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 4709 |                       not = !not;[0m
      | [0;1;32m                                 
[0m[1mregex.c:4749:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4749 |                     for (idx = 0; idx < (int) p2[1]; idx++)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 4750 |                       if (! (p2[2 + idx] == 0[0m
 4751 |                              || (idx < (int) p1[4][0m
 4752 |                                  && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))[0m
 4753 |                         break;[0m
      | [0;1;32m                              
[0m[1mregex.c:4752:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4752 |                                  && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))[0m
      | [0;1;32m                                                                           ^
[0m      | [0;32m                                                                            {
[0m 4753 |                         break;[0m
      | [0;1;32m                              
[0m[1mregex.c:4768:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4768 |                          idx++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m 4769 |                       if ((p2[2 + idx] & p1[5 + idx]) != 0)[0m
 4770 |                         break;[0m
      | [0;1;32m                              
[0m[1mregex.c:4769:46: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4769 |                       if ((p2[2 + idx] & p1[5 + idx]) != 0)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 4770 |                         break;[0m
      | [0;1;32m                              
[0m[1mregex.c:4797:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4797 |           {[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:4808:13: [0m[0;1;35mwarning: [0m[1mOut of bound access to memory after the end of the memory returned by 'alloca' [clang-analyzer-security.ArrayBound][0m
 4808 |             POP_FAILURE_POINT (sdummy, pdummy,[0m
      | [0;1;32m            ^
[0m[1mregex.c:1367:17: [0m[0;1;36mnote: [0mexpanded from macro 'POP_FAILURE_POINT'[0m
 1367 |   string_temp = POP_FAILURE_POINTER ();                                 \[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1205:31: [0m[0;1;36mnote: [0mexpanded from macro 'POP_FAILURE_POINTER'[0m
 1205 | #define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer[0m
      | [0;1;32m                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case pop_failure_jump:'  at line 4796[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4808:13: [0m[0;1;36mnote: [0mAccess of the memory returned by 'alloca' at index 4294967295, while it holds only 5 'union fail_stack_elt' elements[0m
 4808 |             POP_FAILURE_POINT (sdummy, pdummy,[0m
      | [0;1;32m            ^
[0m[1mregex.c:1367:17: [0m[0;1;36mnote: [0mexpanded from macro 'POP_FAILURE_POINT'[0m
 1367 |   string_temp = POP_FAILURE_POINTER ();                                 \[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1205:31: [0m[0;1;36mnote: [0mexpanded from macro 'POP_FAILURE_POINTER'[0m
 1205 | #define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer[0m
      | [0;1;32m                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4824:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4824 |           EXTRACT_NUMBER_AND_INCR (mcnt, p);    /* Get the amount to jump.  */[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 4825 |           DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);[0m
 4826 |           p += mcnt;                            /* Do the jump.  */[0m
 4827 | #ifdef _LIBC[0m
 4828 |           DEBUG_PRINT2 ("(to %p).\n", p);[0m
 4829 | #else[0m
 4830 |           DEBUG_PRINT2 ("(to 0x%x).\n", p);[0m
 4831 | #endif[0m
 4832 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4838:54: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4838 |           DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                     {
[0m 4839 |           goto unconditional_jump;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mregex.c:4848:59: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4848 |           DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                          {
[0m 4849 |           /* It doesn't matter what we push for the string here.  What[0m
 4850 |              the code at `fail' tests is the value for the pattern.  */[0m
 4851 |           PUSH_FAILURE_POINT (0, 0, -2);[0m
 4852 |           goto unconditional_jump;[0m
      | [0;1;32m                                 
[0m      | [0;32m                                 ;} 
[0m[1mregex.c:4851:11: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4851 |           PUSH_FAILURE_POINT (0, 0, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4851:11: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4851 |           PUSH_FAILURE_POINT (0, 0, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4861:59: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4861 |           DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                          {
[0m 4862 |           /* See comments just above at `dummy_failure_jump' about the[0m
 4863 |              two zeroes.  */[0m
 4864 |           PUSH_FAILURE_POINT (0, 0, -2);[0m
 4865 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:4864:11: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 4864 |           PUSH_FAILURE_POINT (0, 0, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4864:11: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 4864 |           PUSH_FAILURE_POINT (0, 0, -2);[0m
      | [0;1;32m          ^
[0m[1mregex.c:1250:14: [0m[0;1;36mnote: [0mexpanded from macro 'PUSH_FAILURE_POINT'[0m
 1250 |         if (!DOUBLE_FAIL_STACK (fail_stack))                            \[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:1165:9: [0m[0;1;36mnote: [0mexpanded from macro 'DOUBLE_FAIL_STACK'[0m
 1165 |         REGEX_REALLOCATE_STACK ((fail_stack).stack,                     \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1166 |           (fail_stack).size * sizeof (fail_stack_elt_t),                \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 1167 |           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \[0m
      | [0;1;32m          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:305:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE_STACK'[0m
  305 |    REGEX_REALLOCATE (source, osize, nsize)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:273:4: [0m[0;1;36mnote: [0mexpanded from macro 'REGEX_REALLOCATE'[0m
  273 |    bcopy (source, destination, osize),                                  \[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:103:24: [0m[0;1;36mnote: [0mexpanded from macro 'bcopy'[0m
  103 | #define bcopy(s, d, n)  memcpy ((d), (s), (n))[0m
      | [0;1;32m                        ^~~~~~
[0m[1mregex.c:4870:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4870 |           EXTRACT_NUMBER (mcnt, p + 2);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4900:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4900 |           EXTRACT_NUMBER (mcnt, p + 2);[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4916:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4916 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 4917 |             p += 4;[0m
      | [0;1;32m                   
[0m[1mregex.c:4959:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 4960 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:4962:15: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4962 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is not equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3939:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'string1'[0m
 3939 |       string1 = 0;[0m
      | [0;1;32m      ^~~~~~~~~~~
[0m[1mregex.c:3942:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'end1'[0m
 3942 |   end1 = string1 + size1;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0m'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case wordbound:'  at line 4954[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4959:8: [0m[0;1;36mnote: [0m'size1' is 0[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:36: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                                   ^~~~~
[0m[1mregex.c:4959:8: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:36: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                                   ^
[0m[1mregex.c:4959:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4959:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                           ^
[0m[1mregex.c:4959:8: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:66: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                                                                 ^~~~~~
[0m[1mregex.c:4959:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:27: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                          ^
[0m[1mregex.c:4959:30: [0m[0;1;36mnote: [0mAssuming 'd' is not equal to 'end2'[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:3624:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_END'[0m
 3624 | #define AT_STRINGS_END(d) ((d) == end2)[0m
      | [0;1;32m                           ^~~~~~~~~~~
[0m[1mregex.c:4959:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 4959 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m          ^
[0m[1mregex.c:4962:15: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4962 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:4962:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4962 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4962:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
 4962 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m             ^
[0m[1mregex.c:4962:15: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4962 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4964:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4964 |           if (prevchar != thischar)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4965 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:4974:49: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m 4975 |             goto fail;[0m
      | [0;1;32m                      
[0m[1mregex.c:4977:15: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4977 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is not equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3939:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'string1'[0m
 3939 |       string1 = 0;[0m
      | [0;1;32m      ^~~~~~~~~~~
[0m[1mregex.c:3942:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'end1'[0m
 3942 |   end1 = string1 + size1;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0m'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case notwordbound:'  at line 4969[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4974:8: [0m[0;1;36mnote: [0m'size1' is 0[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:36: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                                   ^~~~~
[0m[1mregex.c:4974:8: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:36: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                                   ^
[0m[1mregex.c:4974:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:4974:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                           ^
[0m[1mregex.c:4974:8: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:66: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                                                                 ^~~~~~
[0m[1mregex.c:4974:8: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3623:27: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_BEG'[0m
 3623 | #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)[0m
      | [0;1;32m                          ^
[0m[1mregex.c:4974:30: [0m[0;1;36mnote: [0mAssuming 'd' is not equal to 'end2'[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:3624:28: [0m[0;1;36mnote: [0mexpanded from macro 'AT_STRINGS_END'[0m
 3624 | #define AT_STRINGS_END(d) ((d) == end2)[0m
      | [0;1;32m                           ^~~~~~~~~~~
[0m[1mregex.c:4974:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 4974 |           if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))[0m
      | [0;1;32m          ^
[0m[1mregex.c:4977:15: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4977 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:4977:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4977 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4977:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
 4977 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m             ^
[0m[1mregex.c:4977:15: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4977 |           prevchar = WORDCHAR_P (d - 1);[0m
      | [0;1;32m                     ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4979:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4979 |           if (prevchar != thischar)[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                    {
[0m 4980 |             goto fail;[0m
      | [0;1;32m                      
[0m[1mregex.c:4986:48: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4986 |           DEBUG_PRINT1 ("EXECUTING wordbeg.\n");[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                               {
[0m 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
 4988 |             break;[0m
 4989 |           goto fail;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:4987:8: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3942:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'end1'[0m
 3942 |   end1 = string1 + size1;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case wordbeg:'  at line 4985[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0mAssuming 'd' is not equal to 'end1'[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0m'?' condition is false[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0m'?' condition is true[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m             ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4987:8: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'string2') [clang-analyzer-core.NullDereference][0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:26: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case wordbeg:'  at line 4985[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0mAssuming 'd' is equal to 'end1'[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0m'?' condition is true[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:4987:8: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'string2')[0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:26: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:4987:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4987 |           if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))[0m
      | [0;1;32m                                                                            ^
[0m      | [0;32m                                                                             {
[0m 4988 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:4992:48: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 4992 |           DEBUG_PRINT1 ("EXECUTING wordend.\n");[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                               {
[0m 4993 |           if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)[0m
 4994 |               && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))[0m
 4995 |             break;[0m
 4996 |           goto fail;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mregex.c:4994:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 4994 |               && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 4995 |             break;[0m
      | [0;1;32m                  
[0m[1mregex.c:5053:59: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5053 |           DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");[0m
      | [0;1;32m                                                          ^
[0m      | [0;32m                                                          {
[0m 5054 |           PREFETCH ();[0m
 5055 |           if (!WORDCHAR_P (d))[0m
 5056 |             goto fail;[0m
 5057 |           SET_REGS_MATCHED ();[0m
 5058 |           d++;[0m
 5059 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:5055:16: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3942:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'end1'[0m
 3942 |   end1 = string1 + size1;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case wordchar:'  at line 5052[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:5054:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 5055[0m
 5054 |           PREFETCH ();[0m
      | [0;1;32m          ^
[0m[1mregex.c:3610:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREFETCH'[0m
 3610 |   while (d == dend)                                                     \[0m
      | [0;1;32m  ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0mAssuming 'd' is not equal to 'end1'[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0m'?' condition is false[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0m'?' condition is true[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m             ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5055:16: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'string2') [clang-analyzer-core.NullDereference][0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3632:26: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case wordchar:'  at line 5052[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:5054:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 5055[0m
 5054 |           PREFETCH ();[0m
      | [0;1;32m          ^
[0m[1mregex.c:3610:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREFETCH'[0m
 3610 |   while (d == dend)                                                     \[0m
      | [0;1;32m  ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0mAssuming 'd' is equal to 'end1'[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0m'?' condition is true[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:5055:16: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'string2')[0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m               ^
[0m[1mregex.c:3632:26: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5055:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5055 |           if (!WORDCHAR_P (d))[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5056 |             goto fail;[0m
      | [0;1;32m                      
[0m[1mregex.c:5062:62: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5062 |           DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                             {
[0m 5063 |           PREFETCH ();[0m
 5064 |           if (WORDCHAR_P (d))[0m
 5065 |             goto fail;[0m
 5066 |           SET_REGS_MATCHED ();[0m
 5067 |           d++;[0m
 5068 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:5064:8: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3942:3: [0m[0;1;36mnote: [0mNull pointer value stored to 'end1'[0m
 3942 |   end1 = string1 + size1;[0m
      | [0;1;32m  ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case notwordchar:'  at line 5061[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:5063:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 5064[0m
 5063 |           PREFETCH ();[0m
      | [0;1;32m          ^
[0m[1mregex.c:3610:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREFETCH'[0m
 3610 |   while (d == dend)                                                     \[0m
      | [0;1;32m  ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0mAssuming 'd' is not equal to 'end1'[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0m'?' condition is false[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0m'?' condition is true[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:14: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m             ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3633:35: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m                                  ^~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5064:8: [0m[0;1;35mwarning: [0m[1mDereference of null pointer (loaded from variable 'string2') [clang-analyzer-core.NullDereference][0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:26: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:3935:21: [0m[0;1;36mnote: [0mAssuming 'string1' is equal to NULL[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                    ^~~~~~~~~~~~~~~
[0m[1mregex.c:3935:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is <= 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case notwordchar:'  at line 5061[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:5063:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 5064[0m
 5063 |           PREFETCH ();[0m
      | [0;1;32m          ^
[0m[1mregex.c:3610:3: [0m[0;1;36mnote: [0mexpanded from macro 'PREFETCH'[0m
 3610 |   while (d == dend)                                                     \[0m
      | [0;1;32m  ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0mAssuming 'd' is equal to 'end1'[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m 3633 |            : (d) == string2 - 1 ? *(end1 - 1) : *(d))                   \[0m
      | [0;1;32m           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0m'?' condition is true[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:12: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m           ^
[0m[1mregex.c:5064:8: [0m[0;1;36mnote: [0mDereference of null pointer (loaded from variable 'string2')[0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m              ^
[0m[1mregex.c:3632:26: [0m[0;1;36mnote: [0mexpanded from macro 'WORDCHAR_P'[0m
 3632 |   (SYNTAX ((d) == end1 ? *string2                                       \[0m
      | [0;1;32m                         ^~~~~~~~
[0m[1mregex.c:165:35: [0m[0;1;36mnote: [0mexpanded from macro 'SYNTAX'[0m
  165 | #define SYNTAX(c) re_syntax_table[c][0m
      | [0;1;32m                                  ^
[0m[1mregex.c:5064:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5064 |           if (WORDCHAR_P (d))[0m
      | [0;1;32m                             ^
[0m      | [0;32m                              {
[0m 5065 |             goto fail;[0m
      | [0;1;32m                      
[0m[1mregex.c:5072:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5072 |           abort ();[0m
      | [0;1;32m          ^       
[0m      | [0;32m          {       ;} 
[0m[1mregex.c:5087:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5087 |           if (!p)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 5088 |             goto fail;[0m
      | [0;1;32m                      
[0m[1mregex.c:5101:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5101 |                   is_a_jump_n = true;[0m
      | [0;1;32m                  ^                 
[0m      | [0;32m                  {                 ;} 
[0m[1mregex.c:5106:19: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5106 |                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 5107 |                   p1 += mcnt;[0m
 5108 | [0m
 5109 |                   if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)[0m
 5110 |                       || (!is_a_jump_n[0m
 5111 |                           && (re_opcode_t) *p1 == on_failure_jump))[0m
 5112 |                     goto fail;[0m
 5113 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:5111:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5111 |                           && (re_opcode_t) *p1 == on_failure_jump))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 5112 |                     goto fail;[0m
      | [0;1;32m                              
[0m[1mregex.c:5115:36: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5115 |                   /* do nothing */ ;[0m
      | [0;1;32m                                   ^
[0m      | [0;32m                                   {;} 
[0m[1mregex.c:5119:41: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5119 |           if (d >= string1 && d <= end1)[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 5120 |             dend = end_match_1;[0m
      | [0;1;32m                               
[0m[1mregex.c:5122:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5122 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 5123 |         break;   /* Matching at this starting point really fails.  */[0m
      | [0;1;32m                                                                     
[0m[1mregex.c:5126:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5126 |   if (best_regs_set)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5127 |     goto restore_best_regs;[0m
      | [0;1;32m                           
[0m[1mregex.c:5148:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5148 | group_match_null_string_p (p, end, reg_info)[0m
      | [0;1;32m^
[0m[1mregex.c:5166:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5166 |           p1++;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m[1mregex.c:5199:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5199 |                                                       reg_info))[0m
      | [0;1;32m                                                                ^
[0m      | [0;32m                                                                 {
[0m 5200 |                     return false;[0m
      | [0;1;32m                                 
[0m[1mregex.c:5208:60: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5208 |                   if ((re_opcode_t) *p1 != on_failure_jump)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m 5209 |                     break;[0m
      | [0;1;32m                          
[0m[1mregex.c:5228:70: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5228 |               if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))[0m
      | [0;1;32m                                                                     ^
[0m      | [0;32m                                                                      {
[0m 5229 |                 return false;[0m
      | [0;1;32m                             
[0m[1mregex.c:5237:25: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5237 |           assert (p1[1] == **p);[0m
      | [0;1;32m                               ^
[0m      | [0;32m                               {
[0m 5238 |           *p = p1 + 2;[0m
 5239 |           return true;[0m
      | [0;1;32m                     
[0m      | [0;32m                     ;} 
[0m[1mregex.c:5243:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5243 |           if (!common_op_match_null_string_p (&p1, end, reg_info))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 5244 |             return false;[0m
      | [0;1;32m                        
[0m      | [0;32m                        ;} 
[0m[1mregex.c:5243:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5243 |           if (!common_op_match_null_string_p (&p1, end, reg_info))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 5244 |             return false;[0m
      | [0;1;32m                         
[0m[1mregex.c:5257:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5257 | alt_match_null_string_p (p, end, reg_info)[0m
      | [0;1;32m^
[0m[1mregex.c:5273:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5273 |           p1++;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 5274 |           EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
 5275 |           p1 += mcnt;[0m
 5276 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mregex.c:5279:11: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5279 |           if (!common_op_match_null_string_p (&p1, end, reg_info))[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 5280 |             return false;[0m
      | [0;1;32m                        
[0m      | [0;32m                        ;} 
[0m[1mregex.c:5279:67: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5279 |           if (!common_op_match_null_string_p (&p1, end, reg_info))[0m
      | [0;1;32m                                                                  ^
[0m      | [0;32m                                                                   {
[0m 5280 |             return false;[0m
      | [0;1;32m                         
[0m[1mregex.c:5294:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5294 | common_op_match_null_string_p (p, end, reg_info)[0m
      | [0;1;32m^
[0m[1mregex.c:5322:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5322 |       reg_no = *p1;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 5323 |       assert (reg_no > 0 && reg_no <= MAX_REGNUM);[0m
 5324 |       ret = group_match_null_string_p (&p1, end, reg_info);[0m
 5325 | [0m
 5326 |       /* Have to set this here in case we're checking a group which[0m
 5327 |          contains a group and a back reference to it.  */[0m
 5328 | [0m
 5329 |       if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)[0m
 5330 |         REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;[0m
 5331 | [0m
 5332 |       if (!ret)[0m
 5333 |         return false;[0m
 5334 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mregex.c:5329:11: [0m[0;1;35mwarning: [0m[1mDereference of null pointer [clang-analyzer-core.NullDereference][0m
 5329 |       if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m          ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mField 'stack' is not equal to null[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:20: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m                   ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1136:5: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1136 |     if (fail_stack.stack == NULL)                                       \[0m
      | [0;1;32m    ^
[0m[1mregex.c:3875:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 3875 |   INIT_FAIL_STACK ();[0m
      | [0;1;32m  ^
[0m[1mregex.c:1132:3: [0m[0;1;36mnote: [0mexpanded from macro 'INIT_FAIL_STACK'[0m
 1132 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:3883:7: [0m[0;1;36mnote: [0mAssuming field 're_nsub' is 0[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3883:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3883 |   if (bufp->re_nsub)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3908:7: [0m[0;1;36mnote: [0mNull pointer value stored to 'reg_info'[0m
 3908 |       reg_info = reg_info_dummy = (register_info_type *) NULL;[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mAssuming 'pos' is >= 0[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m      ^~~~~~~
[0m[1mregex.c:3913:7: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:3913:18: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m                 ^~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:3913:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3913 |   if (pos < 0 || pos > size1 + size2)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3922:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 3935[0m
 3922 |   for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3935:7: [0m[0;1;36mnote: [0mAssuming 'size2' is not equal to 0[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m      ^~~~~~~~~~
[0m[1mregex.c:3935:18: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3935 |   if (size2 == 0 && string1 != NULL)[0m
      | [0;1;32m                 ^
[0m[1mregex.c:3946:7: [0m[0;1;36mnote: [0mAssuming 'stop' is > 'size1'[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:3946:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 3946 |   if (stop <= size1)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3963:7: [0m[0;1;36mnote: [0mAssuming 'size1' is <= 0[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m      ^~~~~~~~~
[0m[1mregex.c:3963:17: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 3963 |   if (size1 > 0 && pos <= size1)[0m
      | [0;1;32m                ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case set_number_at:'  at line 4920[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4924:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4924 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:533:5: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  533 |     EXTRACT_NUMBER (destination, source);                               \[0m
      | [0;1;32m    ^
[0m[1mregex.c:504:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER'[0m
  504 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4926:13: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4926 |             EXTRACT_NUMBER_AND_INCR (mcnt, p);[0m
      | [0;1;32m            ^
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4932:6: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 4932 |             STORE_NUMBER (p1, mcnt);[0m
      | [0;1;32m            ^
[0m[1mregex.c:485:3: [0m[0;1;36mnote: [0mexpanded from macro 'STORE_NUMBER'[0m
  485 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:4933:13: [0m[0;1;36mnote: [0m Execution continues on line 5074[0m
 4933 |             break;[0m
      | [0;1;32m            ^
[0m[1mregex.c:5074:7: [0m[0;1;36mnote: [0m Execution continues on line 3983[0m
 5074 |       continue;  /* Successfully executed one pattern command; keep going.  */[0m
      | [0;1;32m      ^
[0m[1mregex.c:3983:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 3983 |   for (;;)[0m
      | [0;1;32m  ^
[0m[1mregex.c:3991:11: [0m[0;1;36mnote: [0mAssuming 'p' is not equal to 'pend'[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m          ^~~~~~~~~
[0m[1mregex.c:3991:7: [0m[0;1;36mnote: [0mTaking false branch[0m
 3991 |       if (p == pend)[0m
      | [0;1;32m      ^
[0m[1mregex.c:4156:7: [0m[0;1;36mnote: [0mControl jumps to 'case start_memory:'  at line 4249[0m
 4156 |       switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))[0m
      | [0;1;32m      ^
[0m[1mregex.c:4255:15: [0m[0;1;36mnote: [0mAssuming field 'match_null_string_p' is equal to MATCH_NULL_UNSET_VALUE[0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m              ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^
[0m[1mregex.c:4255:11: [0m[0;1;36mnote: [0mTaking true branch[0m
 4255 |           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m          ^
[0m[1mregex.c:4257:55: [0m[0;1;36mnote: [0mPassing null pointer value via 3rd parameter 'reg_info'[0m
 4257 |               = group_match_null_string_p (&p1, pend, reg_info);[0m
      | [0;1;32m                                                      ^~~~~~~~
[0m[1mregex.c:4257:17: [0m[0;1;36mnote: [0mCalling 'group_match_null_string_p'[0m
 4257 |               = group_match_null_string_p (&p1, pend, reg_info);[0m
      | [0;1;32m                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5156:10: [0m[0;1;36mnote: [0mAssuming 'p1' is < 'end'[0m
 5156 |   while (p1 < end)[0m
      | [0;1;32m         ^~~~~~~~
[0m[1mregex.c:5156:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 5156 |   while (p1 < end)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5162:7: [0m[0;1;36mnote: [0mControl jumps to the 'default' case at line 5242[0m
 5162 |       switch ((re_opcode_t) *p1)[0m
      | [0;1;32m      ^
[0m[1mregex.c:5243:57: [0m[0;1;36mnote: [0mPassing null pointer value via 3rd parameter 'reg_info'[0m
 5243 |           if (!common_op_match_null_string_p (&p1, end, reg_info))[0m
      | [0;1;32m                                                        ^~~~~~~~
[0m[1mregex.c:5243:16: [0m[0;1;36mnote: [0mCalling 'common_op_match_null_string_p'[0m
 5243 |           if (!common_op_match_null_string_p (&p1, end, reg_info))[0m
      | [0;1;32m               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5303:3: [0m[0;1;36mnote: [0mControl jumps to 'case start_memory:'  at line 5321[0m
 5303 |   switch ((re_opcode_t) *p1++)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5329:11: [0m[0;1;36mnote: [0mDereference of null pointer[0m
 5329 |       if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m          ^
[0m[1mregex.c:1446:37: [0m[0;1;36mnote: [0mexpanded from macro 'REG_MATCH_NULL_STRING_P'[0m
 1446 | #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)[0m
      | [0;1;32m                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5329:80: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5329 |       if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)[0m
      | [0;1;32m                                                                               ^
[0m      | [0;32m                                                                                {
[0m 5330 |         REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;[0m
      | [0;1;32m                                                         
[0m[1mregex.c:5332:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5332 |       if (!ret)[0m
      | [0;1;32m               ^
[0m      | [0;32m                {
[0m 5333 |         return false;[0m
      | [0;1;32m                     
[0m[1mregex.c:5338:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5338 |       EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 5339 |       if (mcnt >= 0)[0m
 5340 |         p1 += mcnt;[0m
 5341 |       else[0m
 5342 |         return false;[0m
 5343 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mregex.c:532:3: [0m[0;1;36mnote: [0mexpanded from macro 'EXTRACT_NUMBER_AND_INCR'[0m
  532 |   do {                                                                  \[0m
      | [0;1;32m  ^
[0m[1mregex.c:5339:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5339 |       if (mcnt >= 0)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 5340 |         p1 += mcnt;[0m
 5341 |       else[0m
      | [0;32m      } 
[0m[1mregex.c:5341:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5341 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 5342 |         return false;[0m
      | [0;1;32m                     
[0m[1mregex.c:5347:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5347 |       p1 += 2;[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 5348 |       EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
 5349 | [0m
 5350 |       if (mcnt == 0)[0m
 5351 |         {[0m
 5352 |           p1 -= 4;[0m
 5353 |           EXTRACT_NUMBER_AND_INCR (mcnt, p1);[0m
 5354 |           p1 += mcnt;[0m
 5355 |         }[0m
 5356 |       else[0m
 5357 |         return false;[0m
 5358 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mregex.c:5356:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5356 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 5357 |         return false;[0m
      | [0;1;32m                     
[0m[1mregex.c:5361:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5361 |       if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))[0m
      | [0;1;32m      ^
[0m      | [0;32m      {
[0m 5362 |         return false;[0m
 5363 |       break;[0m
      | [0;1;32m           
[0m      | [0;32m           ;} 
[0m[1mregex.c:5361:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5361 |       if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m 5362 |         return false;[0m
      | [0;1;32m                     
[0m[1mregex.c:5366:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5366 |       p1 += 4;[0m
      | [0;1;32m      ^      
[0m      | [0;32m      {      ;} 
[0m[1mregex.c:5370:7: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 5370 |       return false;[0m
      | [0;1;32m      ^           
[0m      | [0;32m      {           ;} 
[0m[1mregex.c:5382:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5382 | bcmp_translate (s1, s2, len, translate)[0m
      | [0;1;32m^
[0m[1mregex.c:5391:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5391 |       if (translate[*p1++] != translate[*p2++]) return 1;[0m
      | [0;1;32m                                               ^         
[0m      | [0;32m                                                {
[0m[1mregex.c:5409:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5409 | re_compile_pattern (pattern, length, bufp)[0m
      | [0;1;32m^
[0m[1mregex.c:5430:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5430 |   if (!ret)[0m
      | [0;1;32m           ^
[0m      | [0;32m            {
[0m 5431 |     return NULL;[0m
      | [0;1;32m                
[0m[1mregex.c:5546:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5546 | regcomp (preg, pattern, cflags)[0m
      | [0;1;32m^
[0m[1mregex.c:5574:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5574 |       if (preg->translate == NULL)[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 5575 |         return (int) REG_ESPACE;[0m
      | [0;1;32m                                
[0m[1mregex.c:5578:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5578 |       for (i = 0; i < CHAR_SET_SIZE; i++)[0m
      | [0;1;32m                                         ^
[0m      | [0;32m                                          {
[0m 5579 |         preg->translate[i] = ISUPPER (i) ? tolower (i) : i;[0m
      | [0;1;32m                                                           
[0m[1mregex.c:5581:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5581 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 5582 |     preg->translate = NULL;[0m
      | [0;1;32m                           
[0m[1mregex.c:5592:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5592 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 5593 |     preg->newline_anchor = 0;[0m
      | [0;1;32m                             
[0m[1mregex.c:5603:26: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5603 |   if (ret == REG_ERPAREN) ret = REG_EPAREN;[0m
      | [0;1;32m                         ^                 
[0m      | [0;32m                          {
[0m[1mregex.c:5627:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5627 | regexec (preg, string, nmatch, pmatch, eflags)[0m
      | [0;1;32m^
[0m[1mregex.c:5655:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5655 |       if (regs.start == NULL || regs.end == NULL)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m 5656 |         return (int) REG_NOMATCH;[0m
      | [0;1;32m                                 
[0m[1mregex.c:5656:22: [0m[0;1;35mwarning: [0m[1mPotential leak of memory pointed to by 'regs.end' [clang-analyzer-unix.Malloc][0m
 5656 |         return (int) REG_NOMATCH;[0m
      | [0;1;32m                     ^
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mAssuming field 'no_sub' is 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:5638:44: [0m[0;1;36mnote: [0mAssuming 'nmatch' is > 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                                           ^~~~~~~~~~
[0m[1mregex.c:5642:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5642 |   private_preg.not_bol = !!(eflags & REG_NOTBOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5643:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5643 |   private_preg.not_eol = !!(eflags & REG_NOTEOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5650:7: [0m[0;1;36mnote: [0m'want_reg_info' is 1[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:5650:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5654:18: [0m[0;1;36mnote: [0mMemory is allocated[0m
 5654 |       regs.end = TALLOC (nmatch, regoff_t);[0m
      | [0;1;32m                 ^
[0m[1mregex.c:320:29: [0m[0;1;36mnote: [0mexpanded from macro 'TALLOC'[0m
  320 | #define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5655:11: [0m[0;1;36mnote: [0mAssuming field 'start' is equal to NULL[0m
 5655 |       if (regs.start == NULL || regs.end == NULL)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5655:30: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 5655 |       if (regs.start == NULL || regs.end == NULL)[0m
      | [0;1;32m                             ^
[0m[1mregex.c:5656:22: [0m[0;1;36mnote: [0mPotential leak of memory pointed to by 'regs.end'[0m
 5656 |         return (int) REG_NOMATCH;[0m
      | [0;1;32m                     ^
[0m[1mregex.c:5656:22: [0m[0;1;35mwarning: [0m[1mPotential leak of memory pointed to by 'regs.start' [clang-analyzer-unix.Malloc][0m
 5656 |         return (int) REG_NOMATCH;[0m
      | [0;1;32m                     ^
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mAssuming field 'no_sub' is 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                          ^~~~~~~~~~~~~
[0m[1mregex.c:5638:27: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mregex.c:5638:44: [0m[0;1;36mnote: [0mAssuming 'nmatch' is > 0[0m
 5638 |   boolean want_reg_info = !preg->no_sub && nmatch > 0;[0m
      | [0;1;32m                                           ^~~~~~~~~~
[0m[1mregex.c:5642:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5642 |   private_preg.not_bol = !!(eflags & REG_NOTBOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5643:27: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 5643 |   private_preg.not_eol = !!(eflags & REG_NOTEOL);[0m
      | [0;1;32m                          ^~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5650:7: [0m[0;1;36mnote: [0m'want_reg_info' is 1[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m      ^~~~~~~~~~~~~
[0m[1mregex.c:5650:3: [0m[0;1;36mnote: [0mTaking true branch[0m
 5650 |   if (want_reg_info)[0m
      | [0;1;32m  ^
[0m[1mregex.c:5653:20: [0m[0;1;36mnote: [0mMemory is allocated[0m
 5653 |       regs.start = TALLOC (nmatch, regoff_t);[0m
      | [0;1;32m                   ^
[0m[1mregex.c:320:29: [0m[0;1;36mnote: [0mexpanded from macro 'TALLOC'[0m
  320 | #define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5655:11: [0m[0;1;36mnote: [0mAssuming field 'start' is not equal to NULL[0m
 5655 |       if (regs.start == NULL || regs.end == NULL)[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~
[0m[1mregex.c:5655:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mregex.c:5655:33: [0m[0;1;36mnote: [0mAssuming field 'end' is equal to NULL[0m
 5655 |       if (regs.start == NULL || regs.end == NULL)[0m
      | [0;1;32m                                ^~~~~~~~~~~~~~~~
[0m[1mregex.c:5655:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 5655 |       if (regs.start == NULL || regs.end == NULL)[0m
      | [0;1;32m      ^
[0m[1mregex.c:5656:22: [0m[0;1;36mnote: [0mPotential leak of memory pointed to by 'regs.start'[0m
 5656 |         return (int) REG_NOMATCH;[0m
      | [0;1;32m                     ^
[0m[1mregex.c:5692:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5692 | regerror (errcode, preg, errbuf, errbuf_size)[0m
      | [0;1;32m^
[0m[1mregex.c:5703:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5703 |                            / sizeof (re_error_msgid[0])))[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 5704 |     /* Only error codes returned by the rest of the code should be passed[0m
 5705 |        to this routine.  If we are given anything else, or if other regex[0m
 5706 |        code generates an invalid error code, then the program has a bug.[0m
 5707 |        Dump core so we can fix it.  */[0m
 5708 |     abort ();[0m
      | [0;1;32m             
[0m[1mregex.c:5718:11: [0m[0;1;35mwarning: [0m[1mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 5718 |           strncpy (errbuf, msg, errbuf_size - 1);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mregex.c:5718:11: [0m[0;1;36mnote: [0mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11[0m
 5718 |           strncpy (errbuf, msg, errbuf_size - 1);[0m
      | [0;1;32m          ^~~~~~~
[0m[1mregex.c:5721:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5721 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 5722 |         strcpy (errbuf, msg);[0m
      | [0;1;32m                             
[0m[1mregex.c:5722:9: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 5722 |         strcpy (errbuf, msg);[0m
      | [0;1;32m        ^~~~~~
[0m[1mregex.c:5722:9: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 5722 |         strcpy (errbuf, msg);[0m
      | [0;1;32m        ^~~~~~
[0m[1mregex.c:5735:1: [0m[0;1;35mwarning: [0m[1ma function definition without a prototype is deprecated in all versions of C and is not supported in C23 [clang-diagnostic-deprecated-non-prototype][0m
 5735 | regfree (preg)[0m
      | [0;1;32m^
[0m[1mregex.c:5738:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5738 |   if (preg->buffer != NULL)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 5739 |     free (preg->buffer);[0m
      | [0;1;32m                        
[0m[1mregex.c:5745:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5745 |   if (preg->fastmap != NULL)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 5746 |     free (preg->fastmap);[0m
      | [0;1;32m                         
[0m[1mregex.c:5750:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 5750 |   if (preg->translate != NULL)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 5751 |     free (preg->translate);[0m
      | [0;1;32m                           
[0m358 warnings generated.
Suppressed 2 warnings (2 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.

[33/33][247.2s] /home/C00536225/dev/tcc/build/bin/clang-tidy --use-color -checks=readability-braces-around-statements -export-fixes /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/tidy-fixes/tmpgocldl74.yaml -p=/itch/common/crepos/cu-to-rtu/c/enscript-1.6.6 /itch/common/crepos/cu-to-rtu/c/enscript-1.6.6/src/util.c
[1mutil.c:123:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  123 |       if (buf[0] == '#')[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  124 |         continue;[0m
      | [0;1;32m                 
[0m[1mutil.c:127:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  127 |       if (token == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  128 |         /* Empty line. */[0m
  129 |         continue;[0m
      | [0;1;32m                 
[0m[1mutil.c:134:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  134 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:134:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  134 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:134:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  134 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:134:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  134 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:140:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  140 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:140:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  140 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:140:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  140 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:140:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  140 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:147:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  147 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:147:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  147 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:147:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  147 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:147:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  147 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:153:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  153 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:153:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  153 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:153:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  153 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:153:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  153 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:159:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  159 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:159:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  159 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:159:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  159 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:159:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  159 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:166:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  166 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:166:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  166 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:166:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  166 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:166:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  166 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:173:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  173 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:173:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  173 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:173:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  173 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:173:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  173 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:180:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  180 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:180:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  180 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:180:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  180 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:180:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  180 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:181:34: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  181 |           if (MATCH (token2, "printer"))[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m  182 |             output_file = OUTPUT_FILE_NONE;[0m
  183 |           else if (MATCH (token2, "stdout"))[0m
      | [0;32m          } 
[0m[1mutil.c:183:38: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  183 |           else if (MATCH (token2, "stdout"))[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m  184 |             output_file = OUTPUT_FILE_STDOUT;[0m
  185 |           else[0m
      | [0;32m          } 
[0m[1mutil.c:185:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  185 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  186 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
  187 |                         token2, token));[0m
      | [0;1;32m                                        
[0m[1mutil.c:186:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  186 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:186:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  186 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:186:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  186 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:186:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  186 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:192:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  192 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:192:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  192 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:192:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  192 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:192:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  192 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:199:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  199 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:199:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  199 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:199:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  199 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:199:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  199 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:201:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  201 |           if (escape_char < 0 || escape_char > 255)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  202 |             CFG_FATAL ((stderr, _("invalid value \"%s\" for option %s"),[0m
  203 |                         token2, token));[0m
      | [0;1;32m                                        
[0m[1mutil.c:202:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  202 |             CFG_FATAL ((stderr, _("invalid value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:202:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  202 |             CFG_FATAL ((stderr, _("invalid value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:202:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  202 |             CFG_FATAL ((stderr, _("invalid value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:202:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  202 |             CFG_FATAL ((stderr, _("invalid value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:208:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  208 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:208:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  208 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:208:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  208 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:208:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  208 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:209:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  209 |           if (MATCH (token2, "column"))[0m
      | [0;1;32m                                       ^
[0m      | [0;32m                                        {
[0m  210 |             formfeed_type = FORMFEED_COLUMN;[0m
  211 |           else if (MATCH (token2, "page"))[0m
      | [0;32m          } 
[0m[1mutil.c:211:36: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  211 |           else if (MATCH (token2, "page"))[0m
      | [0;1;32m                                          ^
[0m      | [0;32m                                           {
[0m  212 |             formfeed_type = FORMFEED_PAGE;[0m
  213 |           else[0m
      | [0;32m          } 
[0m[1mutil.c:213:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  213 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  214 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
  215 |                         token2, token));[0m
      | [0;1;32m                                        
[0m[1mutil.c:214:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  214 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:214:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  214 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:214:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  214 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:214:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  214 |             CFG_FATAL ((stderr, _("illegal value \"%s\" for option %s"),[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:220:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  220 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:220:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  220 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:220:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  220 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:220:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  220 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:226:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  226 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:226:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  226 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:226:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  226 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:226:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  226 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:232:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  232 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:232:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  232 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:232:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  232 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:232:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  232 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:238:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  238 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:238:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  238 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:238:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  238 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:238:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  238 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:245:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  245 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:245:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  245 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:245:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  245 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:245:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  245 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:255:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  255 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:255:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  255 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:255:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  255 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:255:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  255 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:259:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  259 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:259:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  259 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:259:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  259 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:259:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  259 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:263:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  263 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:263:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  263 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:263:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  263 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:263:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  263 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:267:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  267 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:267:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  267 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:267:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  267 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:267:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  267 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:271:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  271 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:271:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  271 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:271:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  271 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:271:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  271 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:275:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  275 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:275:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  275 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:275:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  275 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:275:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  275 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:279:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  279 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:279:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  279 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:279:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  279 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:279:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  279 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:287:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  287 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:287:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  287 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:287:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  287 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:287:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  287 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:294:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  294 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:294:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  294 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:294:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  294 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:294:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  294 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:301:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  301 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:301:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  301 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:301:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  301 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:301:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  301 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:308:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  308 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:308:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  308 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:308:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  308 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:308:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  308 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:315:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  315 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:315:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  315 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:315:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  315 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:315:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  315 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:321:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  321 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:321:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  321 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:321:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  321 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:321:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  321 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:327:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  327 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:327:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  327 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:327:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  327 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:327:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  327 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:334:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  334 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:334:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  334 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:334:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  334 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:334:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  334 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:341:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  341 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:341:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  341 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:341:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  341 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:341:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  341 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:347:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  347 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:347:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  347 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:347:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  347 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:347:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  347 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:354:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  354 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:354:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  354 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:354:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  354 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:354:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  354 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:361:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  361 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:361:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  361 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:361:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  361 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:361:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  361 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:367:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  367 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:367:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  367 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:367:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  367 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:367:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  367 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:374:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  374 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:374:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  374 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:374:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  374 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:374:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  374 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:381:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  381 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:381:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  381 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:381:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  381 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:381:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  381 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:388:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  388 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:388:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  388 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:388:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  388 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:388:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  388 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:394:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  394 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:394:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  394 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:394:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  394 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:394:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  394 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:400:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  400 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:400:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  400 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:400:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  400 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:400:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  400 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:402:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  402 |           strcpy (underlay, token2);[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:402:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  402 |           strcpy (underlay, token2);[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:407:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  407 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:407:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  407 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:407:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  407 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:407:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  407 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:414:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  414 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:414:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  414 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:414:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  414 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:414:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  414 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:415:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  415 |           if (!parse_font_spec (token2, &ul_font, &ul_ptsize, NULL))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  416 |             CFG_FATAL ((stderr, _("malformed font spec: %s"), token2));[0m
      | [0;1;32m                                                                       
[0m[1mutil.c:416:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  416 |             CFG_FATAL ((stderr, _("malformed font spec: %s"), token2));[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:416:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  416 |             CFG_FATAL ((stderr, _("malformed font spec: %s"), token2));[0m
      | [0;1;32m            ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:416:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  416 |             CFG_FATAL ((stderr, _("malformed font spec: %s"), token2));[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:416:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  416 |             CFG_FATAL ((stderr, _("malformed font spec: %s"), token2));[0m
      | [0;1;32m            ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:421:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  421 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:421:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  421 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:421:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  421 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:421:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  421 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:427:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  427 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:427:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  427 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:427:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  427 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:427:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  427 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:435:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  435 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:435:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  435 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:435:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  435 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:435:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  435 |           CHECK_TOKEN ();[0m
      | [0;1;32m          ^
[0m[1mutil.c:93:5: [0m[0;1;36mnote: [0mexpanded from macro 'CHECK_TOKEN'[0m
   93 |     CFG_FATAL ((stderr, _("missing argument: %s"), token));[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:439:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  439 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  440 |         CFG_FATAL ((stderr, _("illegal option: %s"), token));[0m
      | [0;1;32m                                                             
[0m[1mutil.c:440:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  440 |         CFG_FATAL ((stderr, _("illegal option: %s"), token));[0m
      | [0;1;32m        ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:440:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  440 |         CFG_FATAL ((stderr, _("illegal option: %s"), token));[0m
      | [0;1;32m        ^
[0m[1mutil.c:33:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   33 |     fprintf (stderr, "%s:%s:%d: ", program, buffer_ptr(&fname), line); \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:440:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  440 |         CFG_FATAL ((stderr, _("illegal option: %s"), token));[0m
      | [0;1;32m        ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:440:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  440 |         CFG_FATAL ((stderr, _("illegal option: %s"), token));[0m
      | [0;1;32m        ^
[0m[1mutil.c:35:5: [0m[0;1;36mnote: [0mexpanded from macro 'CFG_FATAL'[0m
   35 |     fprintf (stderr, "\n");                                     \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:443:3: [0m[0;1;35mwarning: [0m[1mOpened stream never closed. Potential resource leak [clang-analyzer-unix.Stream][0m
  443 |   buffer_uninit (&fname);[0m
      | [0;1;32m  ^~~~~~~~~~~~~
[0m[1mutil.c:109:8: [0m[0;1;36mnote: [0mStream opened here[0m
  109 |   fp = fopen (buffer_ptr (&fname), "r");[0m
      | [0;1;32m       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:109:8: [0m[0;1;36mnote: [0mAssuming that 'fopen' is successful[0m
  109 |   fp = fopen (buffer_ptr (&fname), "r");[0m
      | [0;1;32m       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:113:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
  113 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:113:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  113 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:119:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution jumps to the end of the function[0m
  119 |   while (fgets (buf, sizeof (buf), fp))[0m
      | [0;1;32m  ^
[0m[1mutil.c:443:3: [0m[0;1;36mnote: [0mOpened stream never closed. Potential resource leak[0m
  443 |   buffer_uninit (&fname);[0m
      | [0;1;32m  ^~~~~~~~~~~~~
[0m[1mutil.c:453:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  453 |   MESSAGE (2,[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:453:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  453 |   MESSAGE (2,[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:461:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  461 |   strcpy (entry->name, name);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:461:3: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  461 |   strcpy (entry->name, name);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:480:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  480 |   for (i = 0; i < 256; i++)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m  481 |     if (array[i])[0m
  482 |       {[0m
  483 |         fprintf (stderr, "%3d ", i);[0m
  484 |         count++;[0m
  485 |         if (count % 15 == 0)[0m
  486 |           fprintf (stderr, "\n");[0m
  487 |       }[0m
      | [0;1;32m       
[0m[1mutil.c:483:2: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  483 |         fprintf (stderr, "%3d ", i);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mutil.c:483:2: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  483 |         fprintf (stderr, "%3d ", i);[0m
      | [0;1;32m        ^~~~~~~
[0m[1mutil.c:485:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  485 |         if (count % 15 == 0)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m  486 |           fprintf (stderr, "\n");[0m
      | [0;1;32m                                 
[0m[1mutil.c:486:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  486 |           fprintf (stderr, "\n");[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutil.c:486:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  486 |           fprintf (stderr, "\n");[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutil.c:489:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  489 |   if (count % 15 != 0)[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  490 |     fprintf (stderr, "\n");[0m
      | [0;1;32m                           
[0m[1mutil.c:490:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  490 |     fprintf (stderr, "\n");[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:490:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  490 |     fprintf (stderr, "\n");[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:543:57: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  543 |       if (strncmp (buf, HDR_TAG, strlen (HDR_TAG)) == 0)[0m
      | [0;1;32m                                                        ^
[0m      | [0;32m                                                         {
[0m  544 |         break;[0m
      | [0;1;32m              
[0m[1mutil.c:548:11: [0m[0;1;35mwarning: [0m[1mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior [clang-analyzer-unix.Stream][0m
  548 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:523:16: [0m[0;1;36mnote: [0mAssuming 'suffix' is null[0m
  523 |   ctx.suffix = suffix ? suffix : "";[0m
      | [0;1;32m               ^~~~~~
[0m[1mutil.c:523:16: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:526:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  526 |   if (!pathwalk (libpath, file_lookup, &ctx))[0m
      | [0;1;32m  ^
[0m[1mutil.c:532:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
  532 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:532:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  532 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:540:11: [0m[0;1;36mnote: [0mAssuming this stream operation fails[0m
  540 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:540:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 548[0m
  540 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m  ^
[0m[1mutil.c:548:11: [0m[0;1;36mnote: [0mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior[0m
  548 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:548:11: [0m[0;1;35mwarning: [0m[1mRead function called when stream is in EOF state. Function has no effect [clang-analyzer-unix.Stream][0m
  548 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:523:16: [0m[0;1;36mnote: [0mAssuming 'suffix' is null[0m
  523 |   ctx.suffix = suffix ? suffix : "";[0m
      | [0;1;32m               ^~~~~~
[0m[1mutil.c:523:16: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:526:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  526 |   if (!pathwalk (libpath, file_lookup, &ctx))[0m
      | [0;1;32m  ^
[0m[1mutil.c:532:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
  532 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:532:3: [0m[0;1;36mnote: [0mTaking false branch[0m
  532 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:540:11: [0m[0;1;36mnote: [0mAssuming stream reaches end-of-file here[0m
  540 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:540:3: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 548[0m
  540 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m  ^
[0m[1mutil.c:548:11: [0m[0;1;36mnote: [0mRead function called when stream is in EOF state. Function has no effect[0m
  548 |   while ((fgets (buf, sizeof (buf), fp)))[0m
      | [0;1;32m          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:561:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  561 |           strcpy (resources, buf + strlen (RESOURCE_DSC));[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:561:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  561 |           strcpy (resources, buf + strlen (RESOURCE_DSC));[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:567:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  567 |           if (cp == NULL)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m  568 |             /* Get the next line. */[0m
  569 |             continue;[0m
      | [0;1;32m                     
[0m[1mutil.c:573:62: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  573 |               for (cp = GET_TOKEN (NULL); cp; cp = GET_TOKEN (NULL))[0m
      | [0;1;32m                                                                    ^
[0m      | [0;32m                                                                     {
[0m  574 |                 /* Is this font already known? */[0m
  575 |                 if (!strhash_get (res_fonts, cp, strlen (cp) + 1,[0m
  576 |                                   (void **) &cp2))[0m
  577 |                   {[0m
  578 |                     /* Not it is not,  we must include this resource. */[0m
  579 |                     fprintf (ofp, "%%%%IncludeResource: font %s\n", cp);[0m
  580 | [0m
  581 |                     /*[0m
  582 |                      * And register that this resource is needed in[0m
  583 |                      * this document.[0m
  584 |                      */[0m
  585 |                     strhash_put (res_fonts, cp, strlen (cp) + 1, NULL, NULL);[0m
  586 |                   }[0m
      | [0;1;32m                   
[0m[1mutil.c:579:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  579 |                     fprintf (ofp, "%%%%IncludeResource: font %s\n", cp);[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mutil.c:579:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  579 |                     fprintf (ofp, "%%%%IncludeResource: font %s\n", cp);[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mutil.c:591:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  591 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m  592 |             /* Unknown resource, ignore. */[0m
  593 |             continue;[0m
      | [0;1;32m                     
[0m[1mutil.c:598:4: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
  598 |           strcpy (resources, buf + strlen (CONT_DSC));[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:598:4: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
  598 |           strcpy (resources, buf + strlen (CONT_DSC));[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:601:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  601 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m  602 |         pending_comment = 0;[0m
      | [0;1;32m                            
[0m[1mutil.c:616:72: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  616 |           for (i = strlen (DIRECTIVE_FORMAT); buf[i] && isspace (buf[i]); i++)[0m
      | [0;1;32m                                                                              ^
[0m      | [0;32m                                                                               {
[0m  617 |             ;[0m
      | [0;1;32m             
[0m[1mutil.c:618:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  618 |           if (!buf[i])[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  619 |             FATAL ((stderr, _("%s:%d: %%Format: no name"),[0m
  620 |                     buffer_ptr (ctx.fullname), line));[0m
      | [0;1;32m                                                      
[0m[1mutil.c:619:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  619 |             FATAL ((stderr, _("%s:%d: %%Format: no name"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:619:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  619 |             FATAL ((stderr, _("%s:%d: %%Format: no name"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:619:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  619 |             FATAL ((stderr, _("%s:%d: %%Format: no name"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:619:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  619 |             FATAL ((stderr, _("%s:%d: %%Format: no name"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:625:13: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  625 |                i++)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m  626 |             name[j++] = buf[i];[0m
      | [0;1;32m                               
[0m[1mutil.c:629:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  629 |           if (j >= sizeof (name) - 1)[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m  630 |             FATAL ((stderr, _("%s:%d: %%Format: too long name, maxlen=%d"),[0m
  631 |                     buffer_ptr (ctx.fullname), line, sizeof (name) - 1));[0m
      | [0;1;32m                                                                         
[0m[1mutil.c:630:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  630 |             FATAL ((stderr, _("%s:%d: %%Format: too long name, maxlen=%d"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:630:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  630 |             FATAL ((stderr, _("%s:%d: %%Format: too long name, maxlen=%d"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:630:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  630 |             FATAL ((stderr, _("%s:%d: %%Format: too long name, maxlen=%d"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:630:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  630 |             FATAL ((stderr, _("%s:%d: %%Format: too long name, maxlen=%d"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:631:40: [0m[0;1;35mwarning: [0m[1mformat specifies type 'int' but the argument has type 'unsigned long' [clang-diagnostic-format][0m
  630 |             FATAL ((stderr, _("%s:%d: %%Format: too long name, maxlen=%d"),[0m
      | [0;1;32m                                                                      ~~
[0m      | [0;32m                                                                      %lu
[0m  631 |                     buffer_ptr (ctx.fullname), line, sizeof (name) - 1));[0m
      | [0;1;32m                                                     ^
[0m[1m./gsint.h:517:13: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  517 |     fprintf body;                       \[0m
      | [0;1;32m            ^~~~
[0m[1mutil.c:634:43: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  634 |           for (; buf[i] && isspace (buf[i]); i++)[0m
      | [0;1;32m                                                 ^
[0m      | [0;32m                                                  {
[0m  635 |             ;[0m
      | [0;1;32m             
[0m[1mutil.c:639:45: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  639 |           for (j--; isspace (buf[j]) && j > i; j--)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  640 |             ;[0m
      | [0;1;32m             
[0m[1mutil.c:643:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  643 |           MESSAGE (2, (stderr, "%%Format: %s %.*s\n", name, j - i, buf + i));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:643:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  643 |           MESSAGE (2, (stderr, "%%Format: %s %.*s\n", name, j - i, buf + i));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:646:4: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  646 |           memcpy (cp, buf + i, j - i);[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:646:4: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
  646 |           memcpy (cp, buf + i, j - i);[0m
      | [0;1;32m          ^~~~~~
[0m[1mutil.c:651:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  651 |           if (cp2)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m  652 |             FATAL ((stderr,[0m
  653 |                     _("%s:%d: %%Format: name \"%s\" is already defined"),[0m
  654 |                     buffer_ptr (ctx.fullname), line, name));[0m
      | [0;1;32m                                                            
[0m[1mutil.c:652:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  652 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:652:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  652 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:652:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  652 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:652:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  652 |             FATAL ((stderr,[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:671:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  671 |                  buf[i] && !isspace (buf[i]); i++)[0m
      | [0;1;32m                                                  ^
[0m      | [0;32m                                                   {
[0m  672 |               ;[0m
      | [0;1;32m               
[0m[1mutil.c:673:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  673 |             if (!buf[i])[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  674 |               FATAL ((stderr, _("%s:%d: %%HeaderHeight: no argument"),[0m
  675 |                       buffer_ptr (ctx.fullname), line));[0m
      | [0;1;32m                                                        
[0m[1mutil.c:674:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  674 |               FATAL ((stderr, _("%s:%d: %%HeaderHeight: no argument"),[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:674:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  674 |               FATAL ((stderr, _("%s:%d: %%HeaderHeight: no argument"),[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:674:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  674 |               FATAL ((stderr, _("%s:%d: %%HeaderHeight: no argument"),[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:674:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  674 |               FATAL ((stderr, _("%s:%d: %%HeaderHeight: no argument"),[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:678:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  678 |             MESSAGE (2, (stderr, "%%HeaderHeight: %d\n", d_header_h));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:678:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  678 |             MESSAGE (2, (stderr, "%%HeaderHeight: %d\n", d_header_h));[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:693:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  693 |                buf[i] && !isspace (buf[i]); i++)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m  694 |             ;[0m
      | [0;1;32m             
[0m[1mutil.c:695:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  695 |           if (!buf[i])[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m  696 |             FATAL ((stderr, _("%s:%d: %%FooterHeight: no argument"),[0m
  697 |                     buffer_ptr (ctx.fullname), line));[0m
      | [0;1;32m                                                      
[0m[1mutil.c:696:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  696 |             FATAL ((stderr, _("%s:%d: %%FooterHeight: no argument"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:696:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  696 |             FATAL ((stderr, _("%s:%d: %%FooterHeight: no argument"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:696:6: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  696 |             FATAL ((stderr, _("%s:%d: %%FooterHeight: no argument"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:696:6: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  696 |             FATAL ((stderr, _("%s:%d: %%FooterHeight: no argument"),[0m
      | [0;1;32m            ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:700:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  700 |           MESSAGE (2, (stderr, "%%FooterHeight: %d\n", d_footer_h));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:700:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  700 |           MESSAGE (2, (stderr, "%%FooterHeight: %d\n", d_footer_h));[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:757:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  757 |       for (i--; i >= 0 && ISNUMBERDIGIT (spec[i]); i--)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  758 |         ;[0m
      | [0;1;32m         
[0m[1mutil.c:767:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  767 |           for (i--; i >= 0 && ISNUMBERDIGIT (spec[i]); i--)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  768 |             ;[0m
      | [0;1;32m             
[0m[1mutil.c:791:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  791 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m  792 |     size_return->w = size_return->h = atof (cp);[0m
      | [0;1;32m                                                
[0m[1mutil.c:796:3: [0m[0;1;35mwarning: [0m[1mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  796 |   strncpy (*name_return, spec, i);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:796:3: [0m[0;1;36mnote: [0mCall to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11[0m
  796 |   strncpy (*name_return, spec, i);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:810:56: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  810 |       for (i = 0; !found && encodings[i].names[0]; i++)[0m
      | [0;1;32m                                                       ^
[0m      | [0;32m                                                        {
[0m  811 |         for (j = 0; j < 3; j++)[0m
  812 |           if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],[0m
  813 |                                                       encp))[0m
  814 |             {[0m
  815 |               /* Found a match. */[0m
  816 |               *encoding_return = encodings[i].encoding;[0m
  817 |               encp = encodings[i].names[0];[0m
  818 |               found = 1;[0m
  819 |               break;[0m
  820 |             }[0m
      | [0;1;32m             
[0m[1mutil.c:811:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  811 |         for (j = 0; j < 3; j++)[0m
      | [0;1;32m                               ^
[0m      | [0;32m                                {
[0m  812 |           if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],[0m
  813 |                                                       encp))[0m
  814 |             {[0m
  815 |               /* Found a match. */[0m
  816 |               *encoding_return = encodings[i].encoding;[0m
  817 |               encp = encodings[i].names[0];[0m
  818 |               found = 1;[0m
  819 |               break;[0m
  820 |             }[0m
      | [0;1;32m             
[0m[1mutil.c:832:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  832 |       if (encoding_return)[0m
      | [0;1;32m                          ^
[0m      | [0;32m                           {
[0m  833 |         *encoding_return = encoding;[0m
      | [0;1;32m                                    
[0m[1mutil.c:837:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  837 |   MESSAGE (2, (stderr,[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:837:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  837 |   MESSAGE (2, (stderr,[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:842:52: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  842 |   if (size_return->w < 0.0 && size_return->h < 0.0)[0m
      | [0;1;32m                                                   ^
[0m      | [0;32m                                                    {
[0m  843 |     MESSAGE (0, (stderr, _("%s: warning: font size is negative\n"), program));[0m
  844 |   else if (size_return->w < 0.0)[0m
      | [0;32m  } 
[0m[1mutil.c:843:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  843 |     MESSAGE (0, (stderr, _("%s: warning: font size is negative\n"), program));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:843:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  843 |     MESSAGE (0, (stderr, _("%s: warning: font size is negative\n"), program));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:844:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  844 |   else if (size_return->w < 0.0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  845 |     MESSAGE (0, (stderr, _("%s: warning: font width is negative\n"), program));[0m
  846 |   else if (size_return->h < 0.0)[0m
      | [0;32m  } 
[0m[1mutil.c:845:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  845 |     MESSAGE (0, (stderr, _("%s: warning: font width is negative\n"), program));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:845:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  845 |     MESSAGE (0, (stderr, _("%s: warning: font width is negative\n"), program));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:846:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  846 |   else if (size_return->h < 0.0)[0m
      | [0;1;32m                                ^
[0m      | [0;32m                                 {
[0m  847 |     MESSAGE (0, (stderr, _("%s: warning: font height is negative\n"),[0m
  848 |                  program));[0m
      | [0;1;32m                           
[0m[1mutil.c:847:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  847 |     MESSAGE (0, (stderr, _("%s: warning: font height is negative\n"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:847:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  847 |     MESSAGE (0, (stderr, _("%s: warning: font height is negative\n"),[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:866:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  866 |   MESSAGE (2, (stderr, _("reading AFM info for font \"%s\"\n"), Fname));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:866:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  866 |   MESSAGE (2, (stderr, _("reading AFM info for font \"%s\"\n"), Fname));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:868:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  868 |   if (accept_composites)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m  869 |     enc_flags = AFM_ENCODE_ACCEPT_COMPOSITES;[0m
      | [0;1;32m                                             
[0m[1mutil.c:876:3: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  876 |   sprintf (buf, "@%f:%d", Fpt.w, encoding);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:876:3: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
  876 |   sprintf (buf, "@%f:%d", Fpt.w, encoding);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:896:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  896 |               if (strncmp (Fname, COUR, strlen (COUR)) != 0)[0m
      | [0;1;32m                                                            ^
[0m      | [0;32m                                                             {
[0m  897 |                 MESSAGE (0,[0m
  898 |                          (stderr,[0m
  899 |                           _("couldn't open AFM file for font \"%s\", using default\n"),[0m
  900 |                           Fname));[0m
      | [0;1;32m                                  
[0m[1mutil.c:897:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  897 |                 MESSAGE (0,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:897:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  897 |                 MESSAGE (0,[0m
      | [0;1;32m                ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:905:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  905 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:905:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  905 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:905:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
  905 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:905:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
  905 |                   FATAL ((stderr,[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:915:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  915 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_1,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  916 |                                         enc_flags);[0m
  917 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:920:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  920 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_2,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  921 |                                         enc_flags);[0m
  922 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:925:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  925 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_3,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  926 |                                         enc_flags);[0m
  927 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:930:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  930 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_4,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  931 |                                         enc_flags);[0m
  932 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:935:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  935 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_5,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  936 |                                         enc_flags);[0m
  937 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:940:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  940 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_7,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  941 |                                         enc_flags);[0m
  942 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:945:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  945 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_9,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  946 |                                         enc_flags);[0m
  947 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:950:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  950 |               (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_10,[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  951 |                                         enc_flags);[0m
  952 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:955:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  955 |               (void) afm_font_encoding (font, AFM_ENCODING_ASCII, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  956 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:960:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  960 |               (void) afm_font_encoding (font, AFM_ENCODING_ASCII, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  961 | [0m
  962 |               /* Then add those scand characters. */[0m
  963 |               for (i = 0; enc_7bit_ascii_fise[i].name; i++)[0m
  964 |                 (void) afm_font_encode (font, enc_7bit_ascii_fise[i].code,[0m
  965 |                                         enc_7bit_ascii_fise[i].name,[0m
  966 |                                         enc_flags);[0m
  967 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:963:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  963 |               for (i = 0; enc_7bit_ascii_fise[i].name; i++)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  964 |                 (void) afm_font_encode (font, enc_7bit_ascii_fise[i].code,[0m
  965 |                                         enc_7bit_ascii_fise[i].name,[0m
  966 |                                         enc_flags);[0m
      | [0;1;32m                                                   
[0m[1mutil.c:971:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  971 |               (void) afm_font_encoding (font, AFM_ENCODING_ASCII, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  972 | [0m
  973 |               /* Then add those scand characters. */[0m
  974 |               for (i = 0; enc_7bit_ascii_dkno[i].name; i++)[0m
  975 |                 (void) afm_font_encode (font, enc_7bit_ascii_dkno[i].code,[0m
  976 |                                         enc_7bit_ascii_dkno[i].name,[0m
  977 |                                         enc_flags);[0m
  978 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:974:53: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
  974 |               for (i = 0; enc_7bit_ascii_dkno[i].name; i++)[0m
      | [0;1;32m                                                           ^
[0m      | [0;32m                                                            {
[0m  975 |                 (void) afm_font_encode (font, enc_7bit_ascii_dkno[i].code,[0m
  976 |                                         enc_7bit_ascii_dkno[i].name,[0m
  977 |                                         enc_flags);[0m
      | [0;1;32m                                                   
[0m[1mutil.c:981:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  981 |               (void) afm_font_encoding (font, AFM_ENCODING_IBMPC, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  982 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:985:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  985 |               (void) afm_font_encoding (font, AFM_ENCODING_MAC, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  986 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:989:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  989 |               (void) afm_font_encoding (font, AFM_ENCODING_VMS, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  990 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:993:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  993 |               (void) afm_font_encoding (font, AFM_ENCODING_HP8, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  994 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:997:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
  997 |               (void) afm_font_encoding (font, AFM_ENCODING_KOI8, enc_flags);[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m  998 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:1002:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1002 |               break;[0m
      | [0;1;32m              ^    
[0m      | [0;32m              {    ;} 
[0m[1mutil.c:1006:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1006 |           if (!strhash_put (afm_cache, Fname, strlen (Fname), font, NULL))[0m
      | [0;1;32m                                                                          ^
[0m      | [0;32m                                                                           {
[0m 1007 |             font_cached = 0;[0m
      | [0;1;32m                            
[0m[1mutil.c:1019:42: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1019 |           if (font->encoding[i] == AFM_ENC_NONE)[0m
      | [0;1;32m                                                ^
[0m      | [0;32m                                                 {
[0m 1020 |             font_info->font_ctype[i] = ' ';[0m
 1021 |           else if (font->encoding[i] == AFM_ENC_NON_EXISTENT)[0m
      | [0;32m          } 
[0m[1mutil.c:1021:55: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1021 |           else if (font->encoding[i] == AFM_ENC_NON_EXISTENT)[0m
      | [0;1;32m                                                             ^
[0m      | [0;32m                                                              {
[0m 1022 |             font_info->font_ctype[i] = '.';[0m
 1023 |           else[0m
      | [0;32m          } 
[0m[1mutil.c:1023:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1023 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1024 |             font_info->font_ctype[i] = '*';[0m
      | [0;1;32m                                           
[0m[1mutil.c:1031:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1031 |       if (!font_cached)[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1032 |         (void) afm_close_font (font);[0m
      | [0;1;32m                                     
[0m[1mutil.c:1036:50: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1036 |                         strlen (buffer_ptr (&fkey)), font_info, NULL))[0m
      | [0;1;32m                                                                      ^
[0m      | [0;32m                                                                       {
[0m 1037 |         font_info_cached = 0;[0m
      | [0;1;32m                             
[0m[1mutil.c:1041:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1041 |   memcpy (font_widths, font_info->font_widths, 256 * sizeof (double));[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:1041:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1041 |   memcpy (font_widths, font_info->font_widths, 256 * sizeof (double));[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:1042:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1042 |   memcpy (font_ctype, font_info->font_ctype, 256);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:1042:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1042 |   memcpy (font_ctype, font_info->font_ctype, 256);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:1047:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1047 |   if (!font_info_cached)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1048 |     xfree (font_info);[0m
      | [0;1;32m                      
[0m[1mutil.c:1068:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1069 |     /* Font is unknown, nothing to download. */[0m
 1070 |     return;[0m
      | [0;1;32m           
[0m[1mutil.c:1095:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1099:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1099 |       MESSAGE (0, (stderr,[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1099:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1099 |       MESSAGE (0, (stderr,[0m
      | [0;1;32m      ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1108:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1108 |   fprintf (ofp, "%%%%BeginResource: font %s\n", name);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:1108:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1108 |   fprintf (ofp, "%%%%BeginResource: font %s\n", name);[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:1133:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1133 |           if (i != 6)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1134 |             break;[0m
      | [0;1;32m                  
[0m[1mutil.c:1142:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1142 |               last_was_cr = 0;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mutil.c:1146:9: [0m[0;1;35mwarning: [0m[1mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior [clang-analyzer-unix.Stream][0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1129:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1129 |       while (!done)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1133:8: [0m[0;1;36mnote: [0m'i' is equal to 6[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1133:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m          ^
[0m[1mutil.c:1139:4: [0m[0;1;36mnote: [0mControl jumps to 'case 1:'  at line 1141[0m
 1139 |           switch (buf[1])[0m
      | [0;1;32m          ^
[0m[1mutil.c:1143:15: [0m[0;1;36mnote: [0mAssuming 'chunk' is > 0[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~~~~~
[0m[1mutil.c:1143:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1145 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1146:9: [0m[0;1;36mnote: [0mAssuming this stream operation fails[0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1147:9: [0m[0;1;36mnote: [0mAssuming 'i' is not equal to 0[0m
 1147 |                   if (i == 0)[0m
      | [0;1;32m                      ^~~~~~
[0m[1mutil.c:1147:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1147 |                   if (i == 0)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1154:17: [0m[0;1;36mnote: [0m'j' is < 'i'[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^
[0m[1mutil.c:1154:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1156:13: [0m[0;1;36mnote: [0m'j' is equal to 0[0m
 1156 |                       if (j == 0 && last_was_cr && buf[0] != '\n')[0m
      | [0;1;32m                          ^
[0m[1mutil.c:1156:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mutil.c:1156:23: [0m[0;1;36mnote: [0m'last_was_cr' is 0[0m
 1156 |                       if (j == 0 && last_was_cr && buf[0] != '\n')[0m
      | [0;1;32m                                    ^~~~~~~~~~~
[0m[1mutil.c:1156:35: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1156 |                       if (j == 0 && last_was_cr && buf[0] != '\n')[0m
      | [0;1;32m                                                ^
[0m[1mutil.c:1161:18: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1161 |                       else if (buf[j] == '\r' && j + 1 < i[0m
      | [0;1;32m                               ^~~~~~~~~~~~~~
[0m[1mutil.c:1161:18: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mutil.c:1161:36: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1161 |                       else if (buf[j] == '\r' && j + 1 < i[0m
      | [0;1;32m                                                 ^~~~~~~~~
[0m[1mutil.c:1162:11: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1162 |                                && buf[j + 1] != '\n')[0m
      | [0;1;32m                               ^
[0m[1mutil.c:1166:14: [0m[0;1;36mnote: [0mTaking false branch[0m
 1166 |                       else if (buf[j] != '\r')[0m
      | [0;1;32m                           ^
[0m[1mutil.c:1154:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1170[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1143:15: [0m[0;1;36mnote: [0m'chunk' is > 0[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~
[0m[1mutil.c:1143:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1145 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1146:9: [0m[0;1;36mnote: [0mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior[0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1146:9: [0m[0;1;35mwarning: [0m[1mRead function called when stream is in EOF state. Function has no effect [clang-analyzer-unix.Stream][0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1129:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1129 |       while (!done)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1133:8: [0m[0;1;36mnote: [0m'i' is equal to 6[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1133:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m          ^
[0m[1mutil.c:1139:4: [0m[0;1;36mnote: [0mControl jumps to 'case 1:'  at line 1141[0m
 1139 |           switch (buf[1])[0m
      | [0;1;32m          ^
[0m[1mutil.c:1143:15: [0m[0;1;36mnote: [0mAssuming 'chunk' is > 0[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~~~~~
[0m[1mutil.c:1143:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1145 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1146:9: [0m[0;1;36mnote: [0mAssuming stream reaches end-of-file here[0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1147:9: [0m[0;1;36mnote: [0mAssuming 'i' is not equal to 0[0m
 1147 |                   if (i == 0)[0m
      | [0;1;32m                      ^~~~~~
[0m[1mutil.c:1147:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1147 |                   if (i == 0)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1154:17: [0m[0;1;36mnote: [0m'j' is < 'i'[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^
[0m[1mutil.c:1154:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1156:13: [0m[0;1;36mnote: [0m'j' is equal to 0[0m
 1156 |                       if (j == 0 && last_was_cr && buf[0] != '\n')[0m
      | [0;1;32m                          ^
[0m[1mutil.c:1156:13: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mutil.c:1156:23: [0m[0;1;36mnote: [0m'last_was_cr' is 0[0m
 1156 |                       if (j == 0 && last_was_cr && buf[0] != '\n')[0m
      | [0;1;32m                                    ^~~~~~~~~~~
[0m[1mutil.c:1156:35: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1156 |                       if (j == 0 && last_was_cr && buf[0] != '\n')[0m
      | [0;1;32m                                                ^
[0m[1mutil.c:1161:18: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1161 |                       else if (buf[j] == '\r' && j + 1 < i[0m
      | [0;1;32m                               ^~~~~~~~~~~~~~
[0m[1mutil.c:1161:18: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mutil.c:1161:36: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1161 |                       else if (buf[j] == '\r' && j + 1 < i[0m
      | [0;1;32m                                                 ^~~~~~~~~
[0m[1mutil.c:1162:11: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1162 |                                && buf[j + 1] != '\n')[0m
      | [0;1;32m                               ^
[0m[1mutil.c:1166:14: [0m[0;1;36mnote: [0mTaking false branch[0m
 1166 |                       else if (buf[j] != '\r')[0m
      | [0;1;32m                           ^
[0m[1mutil.c:1154:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1170[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1143:15: [0m[0;1;36mnote: [0m'chunk' is > 0[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~
[0m[1mutil.c:1143:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1145 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1146:9: [0m[0;1;36mnote: [0mRead function called when stream is in EOF state. Function has no effect[0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1166:33: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1166 |                       else if (buf[j] != '\r')[0m
      | [0;1;32m                                              ^
[0m      | [0;32m                                               {
[0m 1167 |                         fputc (buf[j], ofp);[0m
      | [0;1;32m                                            
[0m[1mutil.c:1171:20: [0m[0;1;35mwarning: [0m[1mOut of bound access to memory preceding 'buf' [clang-analyzer-security.ArrayBound][0m
 1171 |                   last_was_cr = (buf[i - 1] == '\r');[0m
      | [0;1;32m                                 ^~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1129:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1129 |       while (!done)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1133:8: [0m[0;1;36mnote: [0m'i' is equal to 6[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1133:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m          ^
[0m[1mutil.c:1139:4: [0m[0;1;36mnote: [0mControl jumps to 'case 1:'  at line 1141[0m
 1139 |           switch (buf[1])[0m
      | [0;1;32m          ^
[0m[1mutil.c:1143:15: [0m[0;1;36mnote: [0mAssuming 'chunk' is > 0[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~~~~~
[0m[1mutil.c:1143:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1143 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1145 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1145:15: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:1146:9: [0m[0;1;36mnote: [0mAssuming that 'fread' is successful[0m
 1146 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1147:9: [0m[0;1;36mnote: [0m'i' is not equal to 0[0m
 1147 |                   if (i == 0)[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1147:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1147 |                   if (i == 0)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1154:17: [0m[0;1;36mnote: [0mAssuming 'j' is >= 'i'[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^~~~~
[0m[1mutil.c:1154:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1170[0m
 1154 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1171:20: [0m[0;1;36mnote: [0mAccess of 'buf' at negative byte offset[0m
 1171 |                   last_was_cr = (buf[i - 1] == '\r');[0m
      | [0;1;32m                                 ^~~~~~~~~~
[0m[1mutil.c:1176:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m[1mutil.c:1179:9: [0m[0;1;35mwarning: [0m[1mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior [clang-analyzer-unix.Stream][0m
 1179 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1129:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1129 |       while (!done)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1133:8: [0m[0;1;36mnote: [0m'i' is equal to 6[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1133:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m          ^
[0m[1mutil.c:1139:4: [0m[0;1;36mnote: [0mControl jumps to 'case 2:'  at line 1175[0m
 1139 |           switch (buf[1])[0m
      | [0;1;32m          ^
[0m[1mutil.c:1176:15: [0m[0;1;36mnote: [0mAssuming 'chunk' is > 0[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~~~~~
[0m[1mutil.c:1176:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1178 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1179:9: [0m[0;1;36mnote: [0mAssuming this stream operation fails[0m
 1179 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1180:9: [0m[0;1;36mnote: [0mAssuming 'i' is not equal to 0[0m
 1180 |                   if (i == 0)[0m
      | [0;1;32m                      ^~~~~~
[0m[1mutil.c:1180:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1180 |                   if (i == 0)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1186:17: [0m[0;1;36mnote: [0m'j' is < 'i'[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^
[0m[1mutil.c:1186:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1189:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1189 |                       if ((j + 1) % 32 == 0)[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1186:17: [0m[0;1;36mnote: [0mAssuming 'j' is >= 'i'[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^~~~~
[0m[1mutil.c:1186:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1192[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1176:15: [0m[0;1;36mnote: [0m'chunk' is > 0[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~
[0m[1mutil.c:1176:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1178 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1179:9: [0m[0;1;36mnote: [0mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior[0m
 1179 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1179:9: [0m[0;1;35mwarning: [0m[1mRead function called when stream is in EOF state. Function has no effect [clang-analyzer-unix.Stream][0m
 1179 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking true branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1129:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1129 |       while (!done)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1133:8: [0m[0;1;36mnote: [0m'i' is equal to 6[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1133:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1133 |           if (i != 6)[0m
      | [0;1;32m          ^
[0m[1mutil.c:1139:4: [0m[0;1;36mnote: [0mControl jumps to 'case 2:'  at line 1175[0m
 1139 |           switch (buf[1])[0m
      | [0;1;32m          ^
[0m[1mutil.c:1176:15: [0m[0;1;36mnote: [0mAssuming 'chunk' is > 0[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~~~~~
[0m[1mutil.c:1176:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1178 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1179:9: [0m[0;1;36mnote: [0mAssuming stream reaches end-of-file here[0m
 1179 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1180:9: [0m[0;1;36mnote: [0mAssuming 'i' is not equal to 0[0m
 1180 |                   if (i == 0)[0m
      | [0;1;32m                      ^~~~~~
[0m[1mutil.c:1180:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1180 |                   if (i == 0)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1186:17: [0m[0;1;36mnote: [0m'j' is < 'i'[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^
[0m[1mutil.c:1186:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1189:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1189 |                       if ((j + 1) % 32 == 0)[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1186:17: [0m[0;1;36mnote: [0mAssuming 'j' is >= 'i'[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                              ^~~~~
[0m[1mutil.c:1186:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1192[0m
 1186 |                   for (j = 0; j < i; j++)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1176:15: [0m[0;1;36mnote: [0m'chunk' is > 0[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m                     ^~~~~
[0m[1mutil.c:1176:8: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1176 |               while (chunk > 0)[0m
      | [0;1;32m              ^
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1178 |                   to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;[0m
      | [0;1;32m                            ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1178:15: [0m[0;1;36mnote: [0m'?' condition is true[0m
[1mutil.c:1179:9: [0m[0;1;36mnote: [0mRead function called when stream is in EOF state. Function has no effect[0m
 1179 |                   i = fread (buf, 1, to_read, fp);[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1188:9: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1188 |                       fprintf (ofp, "%02X", buf[j]);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1188:9: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1188 |                       fprintf (ofp, "%02X", buf[j]);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1189:31: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1189 |                       if ((j + 1) % 32 == 0)[0m
      | [0;1;32m                                            ^
[0m      | [0;32m                                             {
[0m 1190 |                         fprintf (ofp, "\n");[0m
      | [0;1;32m                                            
[0m[1mutil.c:1190:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1190 |                         fprintf (ofp, "\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mutil.c:1190:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1190 |                         fprintf (ofp, "\n");[0m
      | [0;1;32m                        ^~~~~~~
[0m[1mutil.c:1197:8: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1197 |               done = 1;[0m
      | [0;1;32m              ^
[0m      | [0;32m              {
[0m 1198 |               break;[0m
      | [0;1;32m                   
[0m      | [0;32m                   ;} 
[0m[1mutil.c:1202:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1202 |           fprintf (ofp, "\n");[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutil.c:1202:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1202 |           fprintf (ofp, "\n");[0m
      | [0;1;32m          ^~~~~~~
[0m[1mutil.c:1209:19: [0m[0;1;35mwarning: [0m[1mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior [clang-analyzer-unix.Stream][0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is not equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1209:19: [0m[0;1;36mnote: [0mAssuming this stream operation fails[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1209:14: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1209:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1209:19: [0m[0;1;36mnote: [0mFile position of the stream might be 'indeterminate' after a failed operation. Can cause undefined behavior[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1209:19: [0m[0;1;35mwarning: [0m[1mRead function called when stream is in EOF state. Function has no effect [clang-analyzer-unix.Stream][0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:7: [0m[0;1;36mnote: [0mAssuming 'error' is equal to AFM_SUCCESS[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m      ^~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1068:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1068 |   if (error != AFM_SUCCESS)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1079:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1079 |   if (stat (buffer_ptr (&fname), &stat_st) != 0)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mAssuming 'quiet' is not equal to 0[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:9: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m        ^~~~~~
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:500:16: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  500 |     if (!quiet && verbose >= (verbose_level))   \[0m
      | [0;1;32m               ^
[0m[1mutil.c:1095:3: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1095 |   MESSAGE (1, (stderr, _("downloading font \"%s\"\n"), name));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:499:3: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  499 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1097:7: [0m[0;1;36mnote: [0m'fp' is not equal to NULL[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m      ^~
[0m[1mutil.c:1097:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1097 |   if (fp == NULL)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1112:3: [0m[0;1;36mnote: [0mTaking false branch[0m
 1112 |   if (i == EOF)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1117:12: [0m[0;1;36mnote: [0mAssuming 'i' is not equal to 128[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m           ^~~~~~~~
[0m[1mutil.c:1117:8: [0m[0;1;36mnote: [0mTaking false branch[0m
 1117 |   else if (i == 128)[0m
      | [0;1;32m       ^
[0m[1mutil.c:1209:19: [0m[0;1;36mnote: [0mAssuming stream reaches end-of-file here[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1209:14: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1209:7: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m      ^
[0m[1mutil.c:1209:19: [0m[0;1;36mnote: [0mRead function called when stream is in EOF state. Function has no effect[0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1209:58: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1209 |       while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)[0m
      | [0;1;32m                                                         ^
[0m      | [0;32m                                                          {
[0m 1210 |         fwrite (buf, 1, i, ofp);[0m
      | [0;1;32m                                
[0m[1mutil.c:1213:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1213 |   fprintf (ofp, "%%%%EndResource\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:1213:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1213 |   fprintf (ofp, "%%%%EndResource\n");[0m
      | [0;1;32m  ^~~~~~~
[0m[1mutil.c:1230:39: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1230 |   for (len = 0, i = 0; string[i]; i++)[0m
      | [0;1;32m                                      ^
[0m      | [0;32m                                       {
[0m 1231 |     switch (string[i])[0m
 1232 |       {[0m
 1233 |       case '(':[0m
 1234 |       case ')':[0m
 1235 |       case '\\':[0m
 1236 |         len += 2;[0m
 1237 |         break;[0m
 1238 | [0m
 1239 |       default:[0m
 1240 |         len++;[0m
 1241 |       }[0m
      | [0;1;32m       
[0m[1mutil.c:1237:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1237 |         break;[0m
      | [0;1;32m        ^    
[0m      | [0;32m        {    ;} 
[0m[1mutil.c:1240:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1240 |         len++;[0m
      | [0;1;32m        ^    
[0m      | [0;32m        {    ;} 
[0m[1mutil.c:1245:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1245 |   if (cp == NULL)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1246 |       return NULL;[0m
      | [0;1;32m                  
[0m[1mutil.c:1247:37: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1247 |   for (i = 0, j = 0; string[i]; i++)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1248 |     switch (string[i])[0m
 1249 |       {[0m
 1250 |       case '(':[0m
 1251 |       case ')':[0m
 1252 |       case '\\':[0m
 1253 |         cp[j++] = '\\';[0m
 1254 |         /* FALLTHROUGH */[0m
 1255 | [0m
 1256 |       default:[0m
 1257 |         cp[j++] = string[i];[0m
 1258 |         break;[0m
 1259 |       }[0m
      | [0;1;32m       
[0m[1mutil.c:1257:2: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1257 |         cp[j++] = string[i];[0m
      | [0;1;32m        ^
[0m      | [0;32m        {
[0m 1258 |         break;[0m
      | [0;1;32m             
[0m      | [0;32m             ;} 
[0m[1mutil.c:1348:28: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1349 |             width = width * 10 + str[i++] - '0';[0m
      | [0;1;32m                                                
[0m[1mutil.c:1358:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1285:23: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1285 |       rbuf[rbufpos++] = (ch);                   \[0m
      | [0;1;32m      ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 37:'  at line 1357[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0m'width' is not equal to 0[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0m'justification' is < 0[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1358:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1285:23: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1285 |       rbuf[rbufpos++] = (ch);                   \[0m
      | [0;1;32m      ~~~~            ^
[0m[1mutil.c:1358:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1358 |                   APPEND_CH ('%');[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1359 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1281:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1281 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1362:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1362 |                   getcwd (buf, sizeof (buf));[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1363 |                   cp = strrchr (buf, '/');[0m
 1364 |                   if (cp)[0m
 1365 |                     cp++;[0m
 1366 |                   else[0m
 1367 |                     cp = buf;[0m
 1368 |                   APPEND_STR (cp);[0m
 1369 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1364:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1364 |                   if (cp)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1365 |                     cp++;[0m
 1366 |                   else[0m
      | [0;32m                  } 
[0m[1mutil.c:1366:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1366 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1367 |                     cp = buf;[0m
      | [0;1;32m                             
[0m[1mutil.c:1368:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 99:'  at line 1361[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1364:9: [0m[0;1;36mnote: [0mAssuming 'cp' is non-null[0m
 1364 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1364:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1364 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1368[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 99:'  at line 1361[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1364:9: [0m[0;1;36mnote: [0mAssuming 'cp' is non-null[0m
 1364 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1364:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1364 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1368:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1368:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1368 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1372:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1372 |                   sprintf (buf, "%02d:%02d:%02d", run_tm.tm_hour,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1372:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1372 |                   sprintf (buf, "%02d:%02d:%02d", run_tm.tm_hour,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1372:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1372 |                   sprintf (buf, "%02d:%02d:%02d", run_tm.tm_hour,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1373 |                            run_tm.tm_min, run_tm.tm_sec);[0m
 1374 |                   APPEND_STR (buf);[0m
 1375 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1374:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 67:'  at line 1371[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1374[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 67:'  at line 1371[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1374:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1374:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1374 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1378:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1378 |                   getcwd (buf, sizeof (buf));[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1379 |                   APPEND_STR (buf);[0m
 1380 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1379:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 100:'  at line 1377[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1379[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 100:'  at line 1377[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1379:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1379:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1379 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1383:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1383 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mutil.c:1388:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1388 |                            i++, j++)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1389 |                         buf2[j] = str[i];[0m
      | [0;1;32m                                         
[0m[1mutil.c:1390:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1390 |                       if (str[i] != '}')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1391 |                         FATAL ((stderr,[0m
 1392 |                                 _("%s: too long format for %%D{} escape"),[0m
 1393 |                                 context_name));[0m
      | [0;1;32m                                               
[0m[1mutil.c:1391:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1391 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1391:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1391 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1391:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1391 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1391:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1391 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1401:9: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1401 |                       sprintf (buf, "%02d-%02d-%02d", run_tm.tm_year % 100,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1401:9: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1401 |                       sprintf (buf, "%02d-%02d-%02d", run_tm.tm_year % 100,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 68:'  at line 1382[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1383:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~
[0m[1mutil.c:1383:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1404[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 68:'  at line 1382[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1383:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1383 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~
[0m[1mutil.c:1383:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1383 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1404:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1404:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1404 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1408:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1408 |                   sprintf (buf, "%02d/%02d/%02d", run_tm.tm_year % 100,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1408:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1408 |                   sprintf (buf, "%02d/%02d/%02d", run_tm.tm_year % 100,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1408:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1408 |                   sprintf (buf, "%02d/%02d/%02d", run_tm.tm_year % 100,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1409 |                            run_tm.tm_mon + 1, run_tm.tm_mday);[0m
 1410 |                   APPEND_STR (buf);[0m
 1411 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1410:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 69:'  at line 1407[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1410[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 69:'  at line 1407[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1410:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1410:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1410 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1414:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1414 |                   sprintf (buf, "%d.%d.%d",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1414:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1414 |                   sprintf (buf, "%d.%d.%d",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1414:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1414 |                   sprintf (buf, "%d.%d.%d",[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1415 |                            run_tm.tm_mday,[0m
 1416 |                            run_tm.tm_mon + 1,[0m
 1417 |                            run_tm.tm_year + 1900);[0m
 1418 |                   APPEND_STR (buf);[0m
 1419 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1418:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 70:'  at line 1413[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1418[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 70:'  at line 1413[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1418:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1418:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1418 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 72:'  at line 1421[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1422[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 72:'  at line 1421[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1422:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1422:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1422 |                   APPEND_STR (title);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1423 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1293:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1293 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1426:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1426 |                   (void) gethostname (buf, sizeof (buf));[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1427 |                   cp = strchr (buf, '.');[0m
 1428 |                   if (cp)[0m
 1429 |                     *cp = '\0';[0m
 1430 |                   APPEND_STR (buf);[0m
 1431 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1428:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1428 |                   if (cp)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1429 |                     *cp = '\0';[0m
      | [0;1;32m                               
[0m[1mutil.c:1430:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 109:'  at line 1425[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1428:9: [0m[0;1;36mnote: [0mAssuming 'cp' is null[0m
 1428 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1428:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1428 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1430[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 109:'  at line 1425[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1428:9: [0m[0;1;36mnote: [0mAssuming 'cp' is null[0m
 1428 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1428:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1428 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1430:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1430:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1430 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1434:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1434 |                   (void) gethostname (buf, sizeof (buf));[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1435 |                   APPEND_STR (buf);[0m
 1436 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1435:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 77:'  at line 1433[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1435[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 77:'  at line 1433[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1435:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1435:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1435 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 110:'  at line 1438[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1439[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 110:'  at line 1438[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1439:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1439:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1439 |                   APPEND_STR (passwd->pw_name);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1440 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1293:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1293 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1443:5: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1443 |                   strcpy (buf, passwd->pw_gecos);[0m
      | [0;1;32m                  ^~~~~~
[0m[1mutil.c:1443:5: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 1443 |                   strcpy (buf, passwd->pw_gecos);[0m
      | [0;1;32m                  ^~~~~~
[0m[1mutil.c:1443:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1443 |                   strcpy (buf, passwd->pw_gecos);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1444 |                   cp = strchr (buf, ',');[0m
 1445 |                   if (cp)[0m
 1446 |                     *cp = '\0';[0m
 1447 |                   APPEND_STR (buf);[0m
 1448 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1445:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1445 |                   if (cp)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1446 |                     *cp = '\0';[0m
      | [0;1;32m                               
[0m[1mutil.c:1447:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 78:'  at line 1442[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1445:9: [0m[0;1;36mnote: [0mAssuming 'cp' is null[0m
 1445 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1445:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1445 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1447[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 78:'  at line 1442[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1445:9: [0m[0;1;36mnote: [0mAssuming 'cp' is null[0m
 1445 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1445:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1445 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1447:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1447:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1447 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1451:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1451 |                   sprintf (buf, "%d:%d%s",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1451:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1451 |                   sprintf (buf, "%d:%d%s",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1451:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1451 |                   sprintf (buf, "%d:%d%s",[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1452 |                            run_tm.tm_hour > 12[0m
 1453 |                            ? run_tm.tm_hour - 12 : run_tm.tm_hour,[0m
 1454 |                            run_tm.tm_min,[0m
 1455 |                            run_tm.tm_hour > 12 ? "pm" : "am");[0m
 1456 |                   APPEND_STR (buf);[0m
 1457 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1456:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 116:'  at line 1450[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1452:7: [0m[0;1;36mnote: [0mAssuming field 'tm_hour' is <= 12[0m
 1452 |                            run_tm.tm_hour > 12[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1452:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:1455:14: [0m[0;1;36mnote: [0mField 'tm_hour' is <= 12[0m
 1455 |                            run_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                                  ^
[0m[1mutil.c:1455:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1455 |                            run_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                           ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1456[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 116:'  at line 1450[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1452:7: [0m[0;1;36mnote: [0mAssuming field 'tm_hour' is <= 12[0m
 1452 |                            run_tm.tm_hour > 12[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1452:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:1455:14: [0m[0;1;36mnote: [0mField 'tm_hour' is <= 12[0m
 1455 |                            run_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                                  ^
[0m[1mutil.c:1455:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1455 |                            run_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                           ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1456:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1456:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1456 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1460:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1460 |                   sprintf (buf, "%d:%d", run_tm.tm_hour, run_tm.tm_min);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1460:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1460 |                   sprintf (buf, "%d:%d", run_tm.tm_hour, run_tm.tm_min);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1460:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1460 |                   sprintf (buf, "%d:%d", run_tm.tm_hour, run_tm.tm_min);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1461 |                   APPEND_STR (buf);[0m
 1462 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1461:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 84:'  at line 1459[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1461[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 84:'  at line 1459[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1461:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1461:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1461 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1465:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1465 |                   sprintf (buf, "%d:%d:%d", run_tm.tm_hour, run_tm.tm_min,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1465:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1465 |                   sprintf (buf, "%d:%d:%d", run_tm.tm_hour, run_tm.tm_min,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1465:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1465 |                   sprintf (buf, "%d:%d:%d", run_tm.tm_hour, run_tm.tm_min,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1466 |                            run_tm.tm_sec);[0m
 1467 |                   APPEND_STR (buf);[0m
 1468 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1467:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 42:'  at line 1464[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1467[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 42:'  at line 1464[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1467:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1467:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1467 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1471:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1471 |                   sprintf (buf, "%02d/%02d/%02d", run_tm.tm_mon + 1,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1471:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1471 |                   sprintf (buf, "%02d/%02d/%02d", run_tm.tm_mon + 1,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1471:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1471 |                   sprintf (buf, "%02d/%02d/%02d", run_tm.tm_mon + 1,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1472 |                            run_tm.tm_mday, run_tm.tm_year % 100);[0m
 1473 |                   APPEND_STR (buf);[0m
 1474 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1473:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 87:'  at line 1470[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1473[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:23: [0m[0;1;36mnote: [0mLeft side of '||' is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1355:8: [0m[0;1;36mnote: [0mControl jumps to 'case 87:'  at line 1470[0m
 1355 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1473:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1473:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1473 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1477:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1477 |                   FATAL ((stderr, _("%s: unknown `%%' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1477:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1477 |                   FATAL ((stderr, _("%s: unknown `%%' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1477:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1477 |                   FATAL ((stderr, _("%s: unknown `%%' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1477:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1477 |                   FATAL ((stderr, _("%s: unknown `%%' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1477:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1477 |                   FATAL ((stderr, _("%s: unknown `%%' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1478 |                           context_name, str[i], str[i]));[0m
 1479 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1m./gsint.h:515:3: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  515 |   do {                                  \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1488:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1285:23: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1285 |       rbuf[rbufpos++] = (ch);                   \[0m
      | [0;1;32m      ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 36:'  at line 1487[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0m'width' is not equal to 0[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0m'justification' is < 0[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1488:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1285:23: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1285 |       rbuf[rbufpos++] = (ch);                   \[0m
      | [0;1;32m      ~~~~            ^
[0m[1mutil.c:1488:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1488 |                   APPEND_CH ('$');[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1489 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1281:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1281 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1492:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1492 |                   if (slicing)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1493 |                     sprintf (buf, "%d%c", current_pagenum, slice - 1 + 'A');[0m
 1494 |                   else[0m
 1495 |                     sprintf (buf, "%d", current_pagenum);[0m
 1496 |                   APPEND_STR (buf);[0m
 1497 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1492:17: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1492 |                   if (slicing)[0m
      | [0;1;32m                              ^
[0m      | [0;32m                               {
[0m 1493 |                     sprintf (buf, "%d%c", current_pagenum, slice - 1 + 'A');[0m
 1494 |                   else[0m
      | [0;32m                  } 
[0m[1mutil.c:1493:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1493 |                     sprintf (buf, "%d%c", current_pagenum, slice - 1 + 'A');[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mutil.c:1493:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1493 |                     sprintf (buf, "%d%c", current_pagenum, slice - 1 + 'A');[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mutil.c:1494:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1494 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1495 |                     sprintf (buf, "%d", current_pagenum);[0m
      | [0;1;32m                                                         
[0m[1mutil.c:1495:7: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1495 |                     sprintf (buf, "%d", current_pagenum);[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mutil.c:1495:7: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1495 |                     sprintf (buf, "%d", current_pagenum);[0m
      | [0;1;32m                    ^~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 37:'  at line 1491[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1492:9: [0m[0;1;36mnote: [0mAssuming 'slicing' is 0[0m
 1492 |                   if (slicing)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1492:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1492 |                   if (slicing)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1496[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 37:'  at line 1491[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1492:9: [0m[0;1;36mnote: [0mAssuming 'slicing' is 0[0m
 1492 |                   if (slicing)[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1492:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1492 |                   if (slicing)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1496:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1496:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1496 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1500:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1285:23: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1285 |       rbuf[rbufpos++] = (ch);                   \[0m
      | [0;1;32m      ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking true branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 61:'  at line 1499[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1283:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1283 |     NEED_NBYTES (width);                        \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0m'width' is not equal to 0[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0m'justification' is < 0[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1284:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1284 |     if (width && justification < 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1500:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1285:23: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1285 |       rbuf[rbufpos++] = (ch);                   \[0m
      | [0;1;32m      ~~~~            ^
[0m[1mutil.c:1500:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1500 |                   APPEND_CH ('\001');[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1501 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1281:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_CH'[0m
 1281 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1504:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1504 |                   sprintf (buf, "%d", total_pages);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1504:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1504 |                   sprintf (buf, "%d", total_pages);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1504:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1504 |                   sprintf (buf, "%d", total_pages);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1505 |                   APPEND_STR (buf);[0m
 1506 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1505:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 112:'  at line 1503[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1505[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 112:'  at line 1503[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1505:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1505:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1505 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1509:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1509 |                   for (j = 0, i++;[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mutil.c:1511:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1511 |                        i++)[0m
      | [0;1;32m                           ^
[0m      | [0;32m                            {
[0m 1512 |                     buf[j++] = str[i];[0m
      | [0;1;32m                                      
[0m[1mutil.c:1514:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1514 |                   if (str[i] == '\0')[0m
      | [0;1;32m                                     ^
[0m      | [0;32m                                      {
[0m 1515 |                     FATAL ((stderr, _("%s: no closing ')' for $() escape"),[0m
 1516 |                             context_name));[0m
      | [0;1;32m                                           
[0m[1mutil.c:1515:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1515 |                     FATAL ((stderr, _("%s: no closing ')' for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1515:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1515 |                     FATAL ((stderr, _("%s: no closing ')' for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1515:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1515 |                     FATAL ((stderr, _("%s: no closing ')' for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1515:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1515 |                     FATAL ((stderr, _("%s: no closing ')' for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1517:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1517 |                   if (str[i] != ')')[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1518 |                     FATAL ((stderr, _("%s: too long variable name for $() escape"),[0m
 1519 |                             context_name));[0m
      | [0;1;32m                                           
[0m[1mutil.c:1518:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1518 |                     FATAL ((stderr, _("%s: too long variable name for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1518:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1518 |                     FATAL ((stderr, _("%s: too long variable name for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1518:7: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1518 |                     FATAL ((stderr, _("%s: too long variable name for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1518:7: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1518 |                     FATAL ((stderr, _("%s: too long variable name for $() escape"),[0m
      | [0;1;32m                    ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1524:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1524 |                   if (cp == NULL)[0m
      | [0;1;32m                                 ^
[0m      | [0;32m                                  {
[0m 1525 |                     cp = "";[0m
      | [0;1;32m                            
[0m[1mutil.c:1526:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 40:'  at line 1508[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1510:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1510 |                        str[i] && str[i] != ')' && j < sizeof (buf) - 1;[0m
      | [0;1;32m                       ^~~~~~
[0m[1mutil.c:1510:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mutil.c:1510:20: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1510 |                        str[i] && str[i] != ')' && j < sizeof (buf) - 1;[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~
[0m[1mutil.c:1510:34: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1510 |                        str[i] && str[i] != ')' && j < sizeof (buf) - 1;[0m
      | [0;1;32m                                               ^
[0m[1mutil.c:1514:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1514 |                   if (str[i] == '\0')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1517:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1517 |                   if (str[i] != ')')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1524:9: [0m[0;1;36mnote: [0m'cp' is not equal to NULL[0m
 1524 |                   if (cp == NULL)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1524:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1524 |                   if (cp == NULL)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1526[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 40:'  at line 1508[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1510:10: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1510 |                        str[i] && str[i] != ')' && j < sizeof (buf) - 1;[0m
      | [0;1;32m                       ^~~~~~
[0m[1mutil.c:1510:10: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
[1mutil.c:1510:20: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1510 |                        str[i] && str[i] != ')' && j < sizeof (buf) - 1;[0m
      | [0;1;32m                                 ^~~~~~~~~~~~~
[0m[1mutil.c:1510:34: [0m[0;1;36mnote: [0mLeft side of '&&' is false[0m
 1510 |                        str[i] && str[i] != ')' && j < sizeof (buf) - 1;[0m
      | [0;1;32m                                               ^
[0m[1mutil.c:1514:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1514 |                   if (str[i] == '\0')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1517:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1517 |                   if (str[i] != ')')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1524:9: [0m[0;1;36mnote: [0m'cp' is not equal to NULL[0m
 1524 |                   if (cp == NULL)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1524:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1524 |                   if (cp == NULL)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1526:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1526:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1526 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1530:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1530 |                   sprintf (buf, "%02d:%02d:%02d", mod_tm.tm_hour,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1530:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1530 |                   sprintf (buf, "%02d:%02d:%02d", mod_tm.tm_hour,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1530:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1530 |                   sprintf (buf, "%02d:%02d:%02d", mod_tm.tm_hour,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1531 |                            mod_tm.tm_min, mod_tm.tm_sec);[0m
 1532 |                   APPEND_STR (buf);[0m
 1533 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1532:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 67:'  at line 1529[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1532[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 67:'  at line 1529[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1532:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1532:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1532 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1536:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1536 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m[1mutil.c:1541:16: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1541 |                            i++, j++)[0m
      | [0;1;32m                                    ^
[0m      | [0;32m                                     {
[0m 1542 |                         buf2[j] = str[i];[0m
      | [0;1;32m                                         
[0m[1mutil.c:1543:27: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1543 |                       if (str[i] != '}')[0m
      | [0;1;32m                                        ^
[0m      | [0;32m                                         {
[0m 1544 |                         FATAL ((stderr,[0m
 1545 |                                 _("%s: too long format for $D{} escape"),[0m
 1546 |                                 context_name));[0m
      | [0;1;32m                                               
[0m[1mutil.c:1544:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1544 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1544:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1544 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1544:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1544 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1544:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1544 |                         FATAL ((stderr,[0m
      | [0;1;32m                        ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1554:9: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1554 |                       sprintf (buf, "%02d-%02d-%02d", mod_tm.tm_year % 100,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1554:9: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1554 |                       sprintf (buf, "%02d-%02d-%02d", mod_tm.tm_year % 100,[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 68:'  at line 1535[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1536:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1536 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~
[0m[1mutil.c:1536:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1536 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1557[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 68:'  at line 1535[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1536:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1536 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                      ^~~~~~~~~~~~~~~~~
[0m[1mutil.c:1536:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1536 |                   if (str[i + 1] == '{')[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1557:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1557:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1557 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1561:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1561 |                   sprintf (buf, "%02d/%02d/%02d", mod_tm.tm_year % 100,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1561:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1561 |                   sprintf (buf, "%02d/%02d/%02d", mod_tm.tm_year % 100,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1561:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1561 |                   sprintf (buf, "%02d/%02d/%02d", mod_tm.tm_year % 100,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1562 |                            mod_tm.tm_mon + 1, mod_tm.tm_mday);[0m
 1563 |                   APPEND_STR (buf);[0m
 1564 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1563:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 69:'  at line 1560[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1563[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 69:'  at line 1560[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1563:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1563:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1563 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1567:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1567 |                   sprintf (buf, "%d.%d.%d",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1567:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1567 |                   sprintf (buf, "%d.%d.%d",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1567:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1567 |                   sprintf (buf, "%d.%d.%d",[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1568 |                            mod_tm.tm_mday,[0m
 1569 |                            mod_tm.tm_mon + 1,[0m
 1570 |                            mod_tm.tm_year + 1900);[0m
 1571 |                   APPEND_STR (buf);[0m
 1572 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1571:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 70:'  at line 1566[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1571[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 70:'  at line 1566[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1571:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1571:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1571 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1575:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1575 |                   sprintf (buf, "%d:%d%s",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1575:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1575 |                   sprintf (buf, "%d:%d%s",[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1575:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1575 |                   sprintf (buf, "%d:%d%s",[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1576 |                            mod_tm.tm_hour > 12[0m
 1577 |                            ? mod_tm.tm_hour - 12 : mod_tm.tm_hour,[0m
 1578 |                            mod_tm.tm_min,[0m
 1579 |                            mod_tm.tm_hour > 12 ? "pm" : "am");[0m
 1580 |                   APPEND_STR (buf);[0m
 1581 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1580:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 116:'  at line 1574[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1576:7: [0m[0;1;36mnote: [0mAssuming field 'tm_hour' is <= 12[0m
 1576 |                            mod_tm.tm_hour > 12[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1576:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:1579:14: [0m[0;1;36mnote: [0mField 'tm_hour' is <= 12[0m
 1579 |                            mod_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                                  ^
[0m[1mutil.c:1579:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1579 |                            mod_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                           ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1580[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 116:'  at line 1574[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1576:7: [0m[0;1;36mnote: [0mAssuming field 'tm_hour' is <= 12[0m
 1576 |                            mod_tm.tm_hour > 12[0m
      | [0;1;32m                           ^~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1576:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
[1mutil.c:1579:14: [0m[0;1;36mnote: [0mField 'tm_hour' is <= 12[0m
 1579 |                            mod_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                                  ^
[0m[1mutil.c:1579:7: [0m[0;1;36mnote: [0m'?' condition is false[0m
 1579 |                            mod_tm.tm_hour > 12 ? "pm" : "am");[0m
      | [0;1;32m                           ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1580:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1580:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1580 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1584:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1584 |                   sprintf (buf, "%d:%d", mod_tm.tm_hour, mod_tm.tm_min);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1584:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1584 |                   sprintf (buf, "%d:%d", mod_tm.tm_hour, mod_tm.tm_min);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1584:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1584 |                   sprintf (buf, "%d:%d", mod_tm.tm_hour, mod_tm.tm_min);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1585 |                   APPEND_STR (buf);[0m
 1586 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1585:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 84:'  at line 1583[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1585[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 84:'  at line 1583[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1585:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1585:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1585 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1589:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1589 |                   sprintf (buf, "%d:%d:%d", mod_tm.tm_hour, mod_tm.tm_min,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1589:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1589 |                   sprintf (buf, "%d:%d:%d", mod_tm.tm_hour, mod_tm.tm_min,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1589:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1589 |                   sprintf (buf, "%d:%d:%d", mod_tm.tm_hour, mod_tm.tm_min,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1590 |                            mod_tm.tm_sec);[0m
 1591 |                   APPEND_STR (buf);[0m
 1592 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1591:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 42:'  at line 1588[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1591[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 42:'  at line 1588[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1591:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1591:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1591 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1595:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1595 |                   sprintf (buf, "%d", input_filenum);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1595:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1595 |                   sprintf (buf, "%d", input_filenum);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1595:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1595 |                   sprintf (buf, "%d", input_filenum);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1596 |                   APPEND_STR (buf);[0m
 1597 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1596:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 118:'  at line 1594[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1596[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 118:'  at line 1594[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1596:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1596:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1596 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1600:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1600 |                   if (toc)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1601 |                     {[0m
 1602 |                       sprintf (buf, "%d-", input_filenum);[0m
 1603 |                       APPEND_STR (buf);[0m
 1604 |                     }[0m
 1605 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1602:9: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1602 |                       sprintf (buf, "%d-", input_filenum);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1602:9: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1602 |                       sprintf (buf, "%d-", input_filenum);[0m
      | [0;1;32m                      ^~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 86:'  at line 1599[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1600:9: [0m[0;1;36mnote: [0mAssuming 'toc' is not equal to 0[0m
 1600 |                   if (toc)[0m
      | [0;1;32m                      ^~~
[0m[1mutil.c:1600:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1600 |                   if (toc)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mTaking true branch[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1603[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 86:'  at line 1599[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1600:9: [0m[0;1;36mnote: [0mAssuming 'toc' is not equal to 0[0m
 1600 |                   if (toc)[0m
      | [0;1;32m                      ^~~
[0m[1mutil.c:1600:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1600 |                   if (toc)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mTaking false branch[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mTaking true branch[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1603:9: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1603:9: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1603 |                       APPEND_STR (buf);[0m
      | [0;1;32m                      ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1608:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1608 |                   sprintf (buf, "%02d/%02d/%02d", mod_tm.tm_mon + 1,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1608:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1608 |                   sprintf (buf, "%02d/%02d/%02d", mod_tm.tm_mon + 1,[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1608:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1608 |                   sprintf (buf, "%02d/%02d/%02d", mod_tm.tm_mon + 1,[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1609 |                            mod_tm.tm_mday, mod_tm.tm_year % 100);[0m
 1610 |                   APPEND_STR (buf);[0m
 1611 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1610:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 87:'  at line 1607[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1610[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 87:'  at line 1607[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1610:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1610:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1610 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 78:'  at line 1613[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1614[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 78:'  at line 1613[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1614:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1614:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1614 |                   APPEND_STR (fname);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1615 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1293:3: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1293 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1618:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1618 |                   cp = strrchr (fname, '/');[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1619 |                   if (cp)[0m
 1620 |                     cp++;[0m
 1621 |                   else[0m
 1622 |                     cp = fname;[0m
 1623 |                   APPEND_STR (cp);[0m
 1624 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1619:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1619 |                   if (cp)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1620 |                     cp++;[0m
 1621 |                   else[0m
      | [0;32m                  } 
[0m[1mutil.c:1621:9: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1621 |                   else[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1622 |                     cp = fname;[0m
      | [0;1;32m                               
[0m[1mutil.c:1623:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 110:'  at line 1617[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1619:9: [0m[0;1;36mnote: [0mAssuming 'cp' is non-null[0m
 1619 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1619:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1619 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1623[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 110:'  at line 1617[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1619:9: [0m[0;1;36mnote: [0mAssuming 'cp' is non-null[0m
 1619 |                   if (cp)[0m
      | [0;1;32m                      ^~
[0m[1mutil.c:1619:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1619 |                   if (cp)[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1623:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1623:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1623 |                   APPEND_STR (cp);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1628:5: [0m[0;1;35mwarning: [0m[1mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1628 |                   sprintf (buf, "%d", current_file_linenum - 1);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1628:5: [0m[0;1;36mnote: [0mCall to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11[0m
 1628 |                   sprintf (buf, "%d", current_file_linenum - 1);[0m
      | [0;1;32m                  ^~~~~~~
[0m[1mutil.c:1628:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1628 |                   sprintf (buf, "%d", current_file_linenum - 1);[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1629 |                   APPEND_STR (buf);[0m
 1630 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1629:5: [0m[0;1;35mwarning: [0m[1mNull pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker][0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 76:'  at line 1626[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1629[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mNull pointer passed to 1st parameter expecting 'nonnull'[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^       ~~~~~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;35mwarning: [0m[1mArray access (from variable 'rbuf') results in a null pointer dereference [clang-analyzer-core.NullDereference][0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1319:3: [0m[0;1;36mnote: [0m'rbuf' initialized to a null pointer value[0m
 1319 |   char *rbuf = NULL;[0m
      | [0;1;32m  ^~~~~~~~~~
[0m[1mutil.c:1330:15: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m              ^~~~~~~~~~~~~~
[0m[1mutil.c:1330:3: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1330 |   for (i = 0; str[i] != '\0'; i++)[0m
      | [0;1;32m  ^
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m          ^~~~~~~~~~~
[0m[1mutil.c:1336:11: [0m[0;1;36mnote: [0mLeft side of '||' is false[0m
[1mutil.c:1336:26: [0m[0;1;36mnote: [0mAssuming the condition is true[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m                         ^~~~~~~~~~~
[0m[1mutil.c:1336:7: [0m[0;1;36mnote: [0mTaking true branch[0m
 1336 |       if (type == '%' || type == '$')[0m
      | [0;1;32m      ^
[0m[1mutil.c:1343:8: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m              ^~~~~~~~~~~~~
[0m[1mutil.c:1343:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1343 |           if (str[i] == '-')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1348:11: [0m[0;1;36mnote: [0mAssuming index is less than the number of 'const unsigned short' elements in the region[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m                 ^
[0m[1m/usr/include/ctype.h:192:21: [0m[0;1;36mnote: [0mexpanded from macro 'isdigit'[0m
  192 | # define isdigit(c)     __isctype((c), _ISdigit)[0m
      | [0;1;32m                        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1m/usr/include/ctype.h:89:4: [0m[0;1;36mnote: [0mexpanded from macro '__isctype'[0m
   89 |   ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)[0m
      | [0;1;32m   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1348:4: [0m[0;1;36mnote: [0mLoop condition is false. Execution continues on line 1352[0m
 1348 |           while (isdigit (str[i]))[0m
      | [0;1;32m          ^
[0m[1mutil.c:1352:4: [0m[0;1;36mnote: [0mTaking false branch[0m
 1352 |           if (type == '%')[0m
      | [0;1;32m          ^
[0m[1mutil.c:1485:8: [0m[0;1;36mnote: [0mControl jumps to 'case 76:'  at line 1626[0m
 1485 |               switch (str[i])[0m
      | [0;1;32m              ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mAssuming 'len' is <= 'width'[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m        ^~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1297:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1297 |     if (len > width)                            \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mAssuming the condition is false[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1273:9: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m        ^~~~~~~~~~~~~~~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mTaking false branch[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1273:5: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1273 |     if (rbufpos + (n) >= rbuflen)               \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mLoop condition is false.  Exiting loop[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1302:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1302 |     NEED_NBYTES (nspace + len);                 \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1272:3: [0m[0;1;36mnote: [0mexpanded from macro 'NEED_NBYTES'[0m
 1272 |   do {                                          \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mAssuming 'width' is not equal to 0[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mLeft side of '&&' is true[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:9: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m        ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0m'justification' is > 0[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m                 ^~~~~~~~~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mTaking true branch[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1303:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1303 |     if (width && justification > 0)             \[0m
      | [0;1;32m    ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mLoop condition is true.  Entering loop body[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1304:7: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1304 |       for (; nspace; nspace--)                  \[0m
      | [0;1;32m      ^
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mArray access (from variable 'rbuf') results in a null pointer dereference[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1305:18: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1305 |         rbuf[rbufpos++] = ' ';                  \[0m
      | [0;1;32m        ~~~~            ^
[0m[1mutil.c:1629:5: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1629:5: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1629 |                   APPEND_STR (buf);[0m
      | [0;1;32m                  ^
[0m[1mutil.c:1307:5: [0m[0;1;36mnote: [0mexpanded from macro 'APPEND_STR'[0m
 1307 |     memcpy (rbuf + rbufpos, str, len);          \[0m
      | [0;1;32m    ^~~~~~
[0m[1mutil.c:1633:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1633 |                   FATAL ((stderr, _("%s: unknown `$' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1633:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1633 |                   FATAL ((stderr, _("%s: unknown `$' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:516:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  516 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1633:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1633 |                   FATAL ((stderr, _("%s: unknown `$' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1633:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1633 |                   FATAL ((stderr, _("%s: unknown `$' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m[1m./gsint.h:518:5: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  518 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1633:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1633 |                   FATAL ((stderr, _("%s: unknown `$' escape `%c' (%d)"),[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1634 |                           context_name, str[i], str[i]));[0m
 1635 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1m./gsint.h:515:3: [0m[0;1;36mnote: [0mexpanded from macro 'FATAL'[0m
  515 |   do {                                  \[0m
      | [0;1;32m  ^
[0m[1mutil.c:1642:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1642 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1643 |         APPEND_CH (str[i]);[0m
      | [0;1;32m                           
[0m[1mutil.c:1664:68: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1664 |       if (strhash_delete (set, kv, strlen (kv) + 1, (void **) &cp))[0m
      | [0;1;32m                                                                   ^
[0m      | [0;32m                                                                    {
[0m 1665 |         xfree (cp);[0m
      | [0;1;32m                   
[0m[1mutil.c:1674:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1674 |       if (cp)[0m
      | [0;1;32m             ^
[0m      | [0;32m              {
[0m 1675 |         xfree (cp);[0m
      | [0;1;32m                   
[0m[1mutil.c:1690:54: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1690 |        got = strhash_get_next (set, &cp, &j, &value))[0m
      | [0;1;32m                                                     ^
[0m      | [0;32m                                                      {
[0m 1691 |     i++;[0m
      | [0;1;32m        
[0m[1mutil.c:1707:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1707 |       if (cp != path)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1708 |         cp++;[0m
      | [0;1;32m             
[0m[1mutil.c:1711:15: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1711 |       if (cp2)[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1712 |         len = cp2 - cp;[0m
 1713 |       else[0m
      | [0;32m      } 
[0m[1mutil.c:1713:11: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1713 |       else[0m
      | [0;1;32m          ^
[0m      | [0;32m           {
[0m 1714 |         len = strlen (cp);[0m
      | [0;1;32m                          
[0m[1mutil.c:1716:7: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1716 |       memcpy (buf, cp, len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mutil.c:1716:7: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 1716 |       memcpy (buf, cp, len);[0m
      | [0;1;32m      ^~~~~~
[0m[1mutil.c:1720:18: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1720 |       if (i != 0)[0m
      | [0;1;32m                 ^
[0m      | [0;32m                  {
[0m 1721 |         return i;[0m
      | [0;1;32m                 
[0m[1mutil.c:1736:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1736 |   MESSAGE (2, (stderr, "file_lookup(): %s/%s%s\t", path, ctx->name,[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1736:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1736 |   MESSAGE (2, (stderr, "file_lookup(): %s/%s%s\t", path, ctx->name,[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1740:35: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1740 |   if (len && path[len - 1] == '/')[0m
      | [0;1;32m                                  ^
[0m      | [0;32m                                   {
[0m 1741 |     len--;[0m
      | [0;1;32m          
[0m[1mutil.c:1751:3: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1751 |   MESSAGE (2, (stderr, "#%c\n", i ? 't' : 'f'));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1751:3: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1751 |   MESSAGE (2, (stderr, "#%c\n", i ? 't' : 'f'));[0m
      | [0;1;32m  ^
[0m[1m./gsint.h:501:7: [0m[0;1;36mnote: [0mexpanded from macro 'MESSAGE'[0m
  501 |       fprintf body;                             \[0m
      | [0;1;32m      ^~~~~~~
[0m[1mutil.c:1766:23: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1766 |   if (fname[0] != '~')[0m
      | [0;1;32m                      ^
[0m      | [0;32m                       {
[0m 1767 |     return xstrdup (fname);[0m
      | [0;1;32m                           
[0m[1mutil.c:1774:22: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1774 |       if (cp == NULL)[0m
      | [0;1;32m                     ^
[0m      | [0;32m                      {
[0m 1775 |         return xstrdup (fname);[0m
      | [0;1;32m                               
[0m[1mutil.c:1788:48: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1788 |   for (i = 1; fname[i] && fname[i] != '/'; i++)[0m
      | [0;1;32m                                               ^
[0m      | [0;32m                                                {
[0m 1789 |     ;[0m
      | [0;1;32m     
[0m[1mutil.c:1822:21: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1822 |   if (end == string)[0m
      | [0;1;32m                    ^
[0m      | [0;32m                     {
[0m 1823 |   malformed_float:[0m
 1824 |     ERROR ((stderr, _("malformed float dimension: \"%s\""), string));[0m
      | [0;1;32m                                                                     
[0m[1mutil.c:1824:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1824 |     ERROR ((stderr, _("malformed float dimension: \"%s\""), string));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1824:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1824 |     ERROR ((stderr, _("malformed float dimension: \"%s\""), string));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1824:5: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1824 |     ERROR ((stderr, _("malformed float dimension: \"%s\""), string));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1824:5: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1824 |     ERROR ((stderr, _("malformed float dimension: \"%s\""), string));[0m
      | [0;1;32m    ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1831:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1831 |           val *= 72 / 2.54;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1832 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutil.c:1835:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1835 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mutil.c:1838:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1838 |           val *= 72;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1839 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutil.c:1845:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1845 |           if (horizontal)[0m
      | [0;1;32m                         ^
[0m      | [0;32m                          {
[0m 1846 |             val *= CHAR_WIDTH ('m');[0m
 1847 |           else[0m
      | [0;32m          } 
[0m[1mutil.c:1847:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1847 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1848 |             val *= LINESKIP;[0m
      | [0;1;32m                            
[0m[1mutil.c:1849:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1849 |           break;[0m
      | [0;1;32m          ^    
[0m      | [0;32m          {    ;} 
[0m[1mutil.c:1852:4: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1852 |           goto malformed_float;[0m
      | [0;1;32m          ^
[0m      | [0;32m          {
[0m 1853 |           break;[0m
      | [0;1;32m               
[0m      | [0;32m               ;} 
[0m[1mutil.c:1858:24: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1858 |       if (*end != '\0')[0m
      | [0;1;32m                       ^
[0m      | [0;32m                        {
[0m 1859 |         goto malformed_float;[0m
      | [0;1;32m                             
[0m[1mutil.c:1891:25: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1891 |       if (fname == NULL)[0m
      | [0;1;32m                        ^
[0m      | [0;32m                         {
[0m 1892 |         fname = input_filter_stdin;[0m
      | [0;1;32m                                   
[0m[1mutil.c:1911:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1911 |                   if ((cp = shell_escape (fname)) != NULL)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1912 |                     {[0m
 1913 |                       cmdlen += strlen (cp);[0m
 1914 |                       cmd = xrealloc (cmd, cmdlen);[0m
 1915 | [0m
 1916 |                       /* Paste filename. */[0m
 1917 |                       strcpy (cmd + pos, cp);[0m
 1918 |                       pos += strlen (cp);[0m
 1919 |                       free (cp);[0m
 1920 |                     }[0m
 1921 | [0m
 1922 |                   i++;[0m
 1923 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1917:9: [0m[0;1;35mwarning: [0m[1mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy][0m
 1917 |                       strcpy (cmd + pos, cp);[0m
      | [0;1;32m                      ^~~~~~
[0m[1mutil.c:1917:9: [0m[0;1;36mnote: [0mCall to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119[0m
 1917 |                       strcpy (cmd + pos, cp);[0m
      | [0;1;32m                      ^~~~~~
[0m[1mutil.c:1926:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1926 |                   cmd[pos++] = '%';[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1927 |                   i++;[0m
 1928 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1931:5: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 1931 |                   cmd[pos++] = input_filter[i];[0m
      | [0;1;32m                  ^
[0m      | [0;32m                  {
[0m 1932 |                   break;[0m
      | [0;1;32m                       
[0m      | [0;32m                       ;} 
[0m[1mutil.c:1935:8: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1935 |           else[0m
      | [0;1;32m              ^
[0m      | [0;32m               {
[0m 1936 |             cmd[pos++] = input_filter[i];[0m
      | [0;1;32m                                         
[0m[1mutil.c:1945:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1945 |           ERROR ((stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1945:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1945 |           ERROR ((stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1945:4: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1945 |           ERROR ((stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1945:4: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1945 |           ERROR ((stderr,[0m
      | [0;1;32m          ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1956:14: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1956 |       if (fp)[0m
      | [0;1;32m             ^
[0m      | [0;32m              {
[0m 1957 |         is->fp = fp;[0m
 1958 |       else[0m
      | [0;32m      } 
[0m[1mutil.c:1963:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1963 |               ERROR ((stderr, _("couldn't open input file \"%s\": %s"), fname,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1963:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1963 |               ERROR ((stderr, _("couldn't open input file \"%s\": %s"), fname,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:507:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  507 |     fprintf (stderr, "%s: ", program);  \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1963:8: [0m[0;1;35mwarning: [0m[1mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 1963 |               ERROR ((stderr, _("couldn't open input file \"%s\": %s"), fname,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1963:8: [0m[0;1;36mnote: [0mCall to function 'fprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fprintf_s' in case of C11[0m
 1963 |               ERROR ((stderr, _("couldn't open input file \"%s\": %s"), fname,[0m
      | [0;1;32m              ^
[0m[1m./gsint.h:509:5: [0m[0;1;36mnote: [0mexpanded from macro 'ERROR'[0m
  509 |     fprintf (stderr, "\n");             \[0m
      | [0;1;32m    ^~~~~~~
[0m[1mutil.c:1977:19: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1977 |   if (is->is_pipe)[0m
      | [0;1;32m                  ^
[0m      | [0;32m                   {
[0m 1978 |     pclose (is->fp);[0m
 1979 |   else[0m
      | [0;32m  } 
[0m[1mutil.c:1979:7: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1979 |   else[0m
      | [0;1;32m      ^
[0m      | [0;32m       {
[0m 1980 |     fclose (is->fp);[0m
      | [0;1;32m                    
[0m[1mutil.c:1982:20: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 1982 |   if (is->unget_ch)[0m
      | [0;1;32m                   ^
[0m      | [0;32m                    {
[0m 1983 |     xfree (is->unget_ch);[0m
      | [0;1;32m                         
[0m[1mutil.c:2004:64: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2004 |       if (is->nreads > 0 && is->data_in_buf < sizeof (is->buf))[0m
      | [0;1;32m                                                               ^
[0m      | [0;32m                                                                {
[0m 2005 |         /* Yes. */[0m
 2006 |         return EOF;[0m
      | [0;1;32m                   
[0m[1mutil.c:2091:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2091 |   memcpy (buffer->data + buffer->len, data, len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:2091:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2091 |   memcpy (buffer->data + buffer->len, data, len);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:2103:3: [0m[0;1;35mwarning: [0m[1mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling][0m
 2103 |   memcpy (copy, buffer->data, buffer->len + 1);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:2103:3: [0m[0;1;36mnote: [0mCall to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11[0m
 2103 |   memcpy (copy, buffer->data, buffer->len + 1);[0m
      | [0;1;32m  ^~~~~~
[0m[1mutil.c:2142:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2142 |   for(inp = fn; *inp; ++inp)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2143 |     switch(*inp)[0m
 2144 |     {[0m
 2145 |       case '\'': len += 4; break;[0m
 2146 |       default:   len += 1; break;[0m
 2147 |     }[0m
      | [0;1;32m     
[0m[1mutil.c:2145:18: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2145 |       case '\'': len += 4; break;[0m
      | [0;1;32m                 ^              
[0m      | [0;32m                 {              ;} 
[0m[1mutil.c:2146:18: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2146 |       default:   len += 1; break;[0m
      | [0;1;32m                 ^              
[0m      | [0;32m                 {              ;} 
[0m[1mutil.c:2150:12: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2150 |   if(!outp)[0m
      | [0;1;32m           ^
[0m      | [0;32m            {
[0m 2151 |     return NULL; /* perhaps one should do better error handling here */[0m
      | [0;1;32m                                                                       
[0m[1mutil.c:2152:29: [0m[0;1;35mwarning: [0m[1mstatement should be inside braces [readability-braces-around-statements][0m
 2152 |   for(inp = fn; *inp; ++inp)[0m
      | [0;1;32m                            ^
[0m      | [0;32m                             {
[0m 2153 |     switch(*inp)[0m
 2154 |     {[0m
 2155 |       case '\'': *outp++ = '\''; *outp++ = '\\'; *outp++ = '\'', *outp++ = '\''; break;[0m
 2156 |       default:   *outp++ = *inp; break;[0m
 2157 |     }[0m
      | [0;1;32m     
[0m[1mutil.c:2155:18: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2155 |       case '\'': *outp++ = '\''; *outp++ = '\\'; *outp++ = '\'', *outp++ = '\''; break;[0m
      | [0;1;32m                 ^                                                                    
[0m      | [0;32m                 {                                                                    ;} 
[0m[1mutil.c:2156:18: [0m[0;1;35mwarning: [0m[1mcase statement body should be in braces [readability-braces-around-statements][0m
 2156 |       default:   *outp++ = *inp; break;[0m
      | [0;1;32m                 ^                    
[0m      | [0;32m                 {                    ;} 
[0m554 warnings generated.
Suppressed 12 warnings (12 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.



Process exited with return code 0
